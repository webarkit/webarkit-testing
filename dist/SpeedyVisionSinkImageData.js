(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SpeedyVisionSinkImageData"] = factory();
	else
		root["SpeedyVisionSinkImageData"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/speedy-vision/src/core/pipeline/pipeline-message.js":
/*!**************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/pipeline/pipeline-message.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyPipelineMessage: () => (/* binding */ SpeedyPipelineMessage),
/* harmony export */   SpeedyPipelineMessageType: () => (/* binding */ SpeedyPipelineMessageType),
/* harmony export */   SpeedyPipelineMessageWith2DVectors: () => (/* binding */ SpeedyPipelineMessageWith2DVectors),
/* harmony export */   SpeedyPipelineMessageWithImage: () => (/* binding */ SpeedyPipelineMessageWithImage),
/* harmony export */   SpeedyPipelineMessageWithKeypointMatches: () => (/* binding */ SpeedyPipelineMessageWithKeypointMatches),
/* harmony export */   SpeedyPipelineMessageWithKeypoints: () => (/* binding */ SpeedyPipelineMessageWithKeypoints),
/* harmony export */   SpeedyPipelineMessageWithLSHTables: () => (/* binding */ SpeedyPipelineMessageWithLSHTables),
/* harmony export */   SpeedyPipelineMessageWithNothing: () => (/* binding */ SpeedyPipelineMessageWithNothing)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/types */ "./node_modules/speedy-vision/src/utils/types.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/* harmony import */ var _gpu_speedy_texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../gpu/speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _gpu_speedy_lsh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../gpu/speedy-lsh */ "./node_modules/speedy-vision/src/gpu/speedy-lsh.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * pipeline-message.js
 * A message that is shared between nodes of a pipeline
 */







/**
 * Types of messages
 * @enum {Symbol}
 */
const SpeedyPipelineMessageType = Object.freeze({
    Nothing: Symbol('Nothing'),
    Image: Symbol('Image'),
    Keypoints: Symbol('Keypoints'),
    Vector2: Symbol('Vector2'),
    LSHTables: Symbol('LSHTables'),
    KeypointMatches: Symbol('KeypointMatches'),
});

/**
 * A message that is shared between nodes of a pipeline
 * @abstract
 */
class SpeedyPipelineMessage
{
    /**
     * Constructor
     * @param {SpeedyPipelineMessageType} type message type
     */
    constructor(type)
    {
        /** @type {SpeedyPipelineMessageType} message type */
        this._type = type;
    }

    /**
     * Message type
     * @returns {SpeedyPipelineMessageType}
     */
    get type()
    {
        return this._type;
    }

    /**
     * Checks if the type of this message is equal to parameter type
     * @param {SpeedyPipelineMessageType} type
     * @returns {boolean}
     */
    hasType(type)
    {
        return this._type === type;
    }

    /**
     * Is this an empty message?
     * @returns {boolean}
     */
    isEmpty()
    {
        return this.hasType(SpeedyPipelineMessageType.Nothing);
    }

    /**
     * Convert to string
     * @returns {string}
     */
    toString()
    {
        const type = Object.keys(SpeedyPipelineMessageType).find(
            type => SpeedyPipelineMessageType[type] === this.type
        );

        return `message of type ${type}`;
    }

    /**
     * Set parameters
     * @abstract
     * @param  {...any} args
     * @returns {SpeedyPipelineMessage} this message
     */
    set(...args)
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.AbstractMethodError();
    }

    /**
     * Create a message of the specified type
     * @param {SpeedyPipelineMessageType} type
     * @returns {SpeedyPipelineMessage}
     */
    static create(type)
    {
        return createMessage(type);
    }
}

/**
 * An empty message carrying nothing
 */
class SpeedyPipelineMessageWithNothing extends SpeedyPipelineMessage
{
    /**
     * Constructor
     */
    constructor()
    {
        super(SpeedyPipelineMessageType.Nothing);
    }

    /**
     * Set parameters
     * @returns {SpeedyPipelineMessage} this message
     */
    set()
    {
        return this;
    }
}

/**
 * A message transporting an image
 */
class SpeedyPipelineMessageWithImage extends SpeedyPipelineMessage
{
    /**
     * Constructor
     */
    constructor()
    {
        super(SpeedyPipelineMessageType.Image);

        /** @type {SpeedyDrawableTexture} the image we carry */
        this._image = null;

        /** @type {ImageFormat} image format */
        this._format = _utils_types__WEBPACK_IMPORTED_MODULE_1__.ImageFormat.RGBA;
    }

    /**
     * Set parameters
     * @param {SpeedyDrawableTexture} image the image we carry
     * @param {ImageFormat} [format] image format
     * @returns {SpeedyPipelineMessage} this message
     */
    set(image, format = _utils_types__WEBPACK_IMPORTED_MODULE_1__.ImageFormat.RGBA)
    {
        // set parameters
        this._image = image;
        this._format = format;

        // done!
        return this;
    }

    /**
     * The image we carry
     * @returns {SpeedyDrawableTexture}
     */
    get image()
    {
        return this._image;
    }

    /**
     * Image format
     * @returns {ImageFormat}
     */
    get format()
    {
        return this._format;
    }
}

/**
 * A message transporting keypoints
 */
class SpeedyPipelineMessageWithKeypoints extends SpeedyPipelineMessage
{
    /**
     * Constructor
     */
    constructor()
    {
        super(SpeedyPipelineMessageType.Keypoints);

        /** @type {SpeedyDrawableTexture} encoded keypoints */
        this._encodedKeypoints = null;

        /** @type {number} descriptor size in bytes */
        this._descriptorSize = 0;

        /** @type {number} extra size in bytes */
        this._extraSize = 0;

        /** @type {number} encoder length */
        this._encoderLength = 1;
    }

    /**
     * Set parameters
     * @param {SpeedyDrawableTexture} encodedKeypoints encoded keypoints
     * @param {number} descriptorSize in bytes
     * @param {number} extraSize in bytes
     * @param {number} encoderLength positive integer
     * @returns {SpeedyPipelineMessage} this message
     */
    set(encodedKeypoints, descriptorSize, extraSize, encoderLength)
    {
        // set parameters
        this._encodedKeypoints = encodedKeypoints;
        this._descriptorSize = descriptorSize | 0;
        this._extraSize = extraSize | 0;
        this._encoderLength = encoderLength | 0;

        // validate
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._descriptorSize >= 0 && this._extraSize >= 0);
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._encoderLength === this._encodedKeypoints.width, 'Invalid encoderLength');
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._encodedKeypoints.width === this._encodedKeypoints.height, 'Invalid encodedKeypoints texture');

        // done!
        return this;
    }

    /**
     * Encoded keypoints
     * @returns {SpeedyDrawableTexture}
     */
    get encodedKeypoints()
    {
        return this._encodedKeypoints;
    }

    /**
     * Descriptor size, in bytes
     * @returns {number}
     */
    get descriptorSize()
    {
        return this._descriptorSize;
    }

    /**
     * Extra size, in bytes
     * @returns {number}
     */
    get extraSize()
    {
        return this._extraSize;
    }

    /**
     * Encoder length
     * @returns {number}
     */
    get encoderLength()
    {
        return this._encoderLength;
    }
}

/*
 * A message transporting a set of 2D vectors
 */
class SpeedyPipelineMessageWith2DVectors extends SpeedyPipelineMessage
{
    /**
     * Constructor
     */
    constructor()
    {
        super(SpeedyPipelineMessageType.Vector2);

        /** @type {SpeedyDrawableTexture} the set of vectors */
        this._vectors = null;
    }

    /**
     * Set parameters
     * @param {SpeedyDrawableTexture} vectors the set of vectors
     * @returns {SpeedyPipelineMessage} this message
     */
    set(vectors)
    {
        // set parameters
        this._vectors = vectors;

        // done!
        return this;
    }

    /**
     * The set of vectors
     * @returns {SpeedyDrawableTexture}
     */
    get vectors()
    {
        return this._vectors;
    }
}

/**
 * A message transporting LSH tables
 */
class SpeedyPipelineMessageWithLSHTables extends SpeedyPipelineMessage
{
    /**
     * Constructor
     */
    constructor()
    {
        super(SpeedyPipelineMessageType.LSHTables);

        /** @type {SpeedyLSH} LSH data structure */
        this._lsh = null;
    }

    /**
     * Set parameters
     * @param {SpeedyLSH} lsh
     * @returns {SpeedyPipelineMessage} this message
     */
    set(lsh)
    {
        // set parameters
        this._lsh = lsh;

        // done!
        return this;
    }

    /**
     * LSH data structure
     * @returns {SpeedyLSH}
     */
    get lsh()
    {
        return this._lsh;
    }
}

/*
 * A message transporting a set of keypoint matches
 */
class SpeedyPipelineMessageWithKeypointMatches extends SpeedyPipelineMessage
{
    /**
     * Constructor
     */
    constructor()
    {
        super(SpeedyPipelineMessageType.KeypointMatches);

        /** @type {SpeedyDrawableTexture} keypoint matches (note: 1 pixel encodes 1 match) */
        this._encodedMatches = null;

        /** @type {number} number of matches per keypoint */
        this._matchesPerKeypoint = 1;
    }

    /**
     * Set parameters
     * @param {SpeedyDrawableTexture} encodedMatches
     * @param {number} matchesPerKeypoint
     * @returns {SpeedyPipelineMessage} this message
     */
    set(encodedMatches, matchesPerKeypoint)
    {
        // set parameters
        this._encodedMatches = encodedMatches;
        this._matchesPerKeypoint = matchesPerKeypoint | 0;

        // validate
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._matchesPerKeypoint > 0);

        // done!
        return this;
    }

    /**
     * The matches
     * @returns {SpeedyDrawableTexture}
     */
    get encodedMatches()
    {
        return this._encodedMatches;
    }

    /**
     * Number of matches per keypoint
     * @returns {number}
     */
    get matchesPerKeypoint()
    {
        return this._matchesPerKeypoint;
    }
}






//
// Utilities
//



/** Map message type to message class */
const MESSAGE_CLASS = Object.freeze({
    [SpeedyPipelineMessageType.Nothing]: SpeedyPipelineMessageWithNothing,
    [SpeedyPipelineMessageType.Image]: SpeedyPipelineMessageWithImage,
    [SpeedyPipelineMessageType.Keypoints]: SpeedyPipelineMessageWithKeypoints,
    [SpeedyPipelineMessageType.Vector2]: SpeedyPipelineMessageWith2DVectors,
    [SpeedyPipelineMessageType.LSHTables]: SpeedyPipelineMessageWithLSHTables,
    [SpeedyPipelineMessageType.KeypointMatches]: SpeedyPipelineMessageWithKeypointMatches,
});

/**
 * Create a message of the specified type
 * @param {SpeedyPipelineMessageType} type
 * @returns {SpeedyPipelineMessage}
 */
function createMessage(type)
{
    //return Reflect.construct(MESSAGE_CLASS[type], []);
    return new MESSAGE_CLASS[
        // error TS2538: Type 'Symbol' cannot be used as an index type.
        // heck, what the hack...
        /** @type {any} */ ( type )
    ];
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/pipeline/pipeline-node.js":
/*!***********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/pipeline/pipeline-node.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyPipelineNode: () => (/* binding */ SpeedyPipelineNode),
/* harmony export */   SpeedyPipelineSinkNode: () => (/* binding */ SpeedyPipelineSinkNode),
/* harmony export */   SpeedyPipelineSourceNode: () => (/* binding */ SpeedyPipelineSourceNode)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/globals */ "./node_modules/speedy-vision/src/utils/globals.js");
/* harmony import */ var _speedy_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/* harmony import */ var _pipeline_port__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pipeline-port */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-port.js");
/* harmony import */ var _pipeline_portbuilder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pipeline-portbuilder */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-portbuilder.js");
/* harmony import */ var _gpu_speedy_gpu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../gpu/speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _gpu_speedy_texture__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../gpu/speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _gpu_speedy_texture_reader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../gpu/speedy-texture-reader */ "./node_modules/speedy-vision/src/gpu/speedy-texture-reader.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * pipeline-node.js
 * Node of a pipeline
 */











/** @typedef {Object<string,SpeedyPipelineInputPort>} InputPortDictionary */
/** @typedef {Object<string,SpeedyPipelineOutputPort>} OutputPortDictionary */

/** Generate a random name for a node */
const generateRandomName = () => Math.random().toString(16).substr(2);

/** Create an empty input port dictionary */
const createInputPortDictionary = () => /** @type {InputPortDictionary} */ ( Object.create(null) );

/** Create an empty output port dictionary */
const createOutputPortDictionary = () => /** @type {OutputPortDictionary} */ ( Object.create(null) );

/**
 * Map an array of input ports to an InputPortDictionary whose keys are their names
 * @param {SpeedyPipelineInputPort[]} ports
 * @returns {InputPortDictionary}
 */
function InputPortDictionary(ports)
{
    return ports.reduce((dict, port) => ((dict[port.name] = port), dict), createInputPortDictionary());
}

/**
 * Map an array of output ports to an OutputPortDictionary whose keys are their names
 * @param {SpeedyPipelineOutputPort[]} ports
 * @returns {OutputPortDictionary}
 */
function OutputPortDictionary(ports)
{
    return ports.reduce((dict, port) => ((dict[port.name] = port), dict), createOutputPortDictionary());
}

/** A flag used for debugging purposes */
let _texView = false;



/**
 * Node of a pipeline
 * @abstract
 */
class SpeedyPipelineNode
{
    /**
     * Constructor
     * @param {string} [name] the name of this node
     * @param {number} [texCount] number of work textures
     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders
     */
    constructor(name = generateRandomName(), texCount = 0, portBuilders = [])
    {
        /** @type {string} the name of this node */
        this._name = String(name);

        /** @type {SpeedyDrawableTexture[]} work texture(s) */
        this._tex = (new Array(texCount)).fill(null);



        // build the ports
        const ports = portBuilders.map(builder => builder.build(this));
        const inputPorts = /** @type {SpeedyPipelineInputPort[]} */ ( ports.filter(port => port.isInputPort()) );
        const outputPorts = /** @type {SpeedyPipelineOutputPort[]} */ ( ports.filter(port => port.isOutputPort()) );

        /** @type {InputPortDictionary} input ports */
        this._inputPorts = InputPortDictionary(inputPorts);

        /** @type {OutputPortDictionary} output ports */
        this._outputPorts = OutputPortDictionary(outputPorts);



        // validate
        if(this._name.length == 0)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalArgumentError(`Invalid name "${this._name}" for node ${this.fullName}`);
        else if(portBuilders.length == 0)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalArgumentError(`No ports have been found in node ${this.fullName}`);
    }

    /**
     * The name of this node
     * @returns {string}
     */
    get name()
    {
        return this._name;
    }

    /**
     * Name and type of this node
     * @returns {string}
     */
    get fullName()
    {
        return `${this.constructor.name}[${this.name}]`;
    }

    /**
     * Find input port by name
     * @param {string} [portName]
     * @returns {SpeedyPipelineInputPort}
     */
    input(portName = _pipeline_port__WEBPACK_IMPORTED_MODULE_4__.SpeedyPipelineInputPort.DEFAULT_NAME)
    {
        if(portName in this._inputPorts)
            return this._inputPorts[portName];

        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalArgumentError(`Can't find input port ${portName} in node ${this.fullName}`);
    }

    /**
     * Find output port by name
     * @param {string} [portName]
     * @returns {SpeedyPipelineOutputPort}
     */
    output(portName = _pipeline_port__WEBPACK_IMPORTED_MODULE_4__.SpeedyPipelineOutputPort.DEFAULT_NAME)
    {
        if(portName in this._outputPorts)
            return this._outputPorts[portName];

        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalArgumentError(`Can't find output port ${portName} in node ${this.fullName}`);
    }

    /**
     * Get data from the input ports and execute
     * the task that this node is supposed to!
     * @param {SpeedyGPU} gpu
     * @returns {void|SpeedyPromise<void>}
     */
    execute(gpu)
    {
        let portName;

        // clear output ports
        for(portName in this._outputPorts)
            this._outputPorts[portName].clearMessage();

        // let the input ports receive what is due
        for(portName in this._inputPorts)
            this._inputPorts[portName].pullMessage(this.fullName);

        // run the task
        const runTask = this._run(gpu);
        if(typeof runTask === 'undefined') {
            for(portName in this._outputPorts) // ensure that no output ports are empty
                _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._outputPorts[portName].hasMessage(), `Did you forget to write data to the output port ${portName} of ${this.fullName}?`);

            return undefined;
        }
        else return runTask.then(() => {
            for(portName in this._outputPorts) // ensure that no output ports are empty
                _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._outputPorts[portName].hasMessage(), `Did you forget to write data to the output port ${portName} of ${this.fullName}?`);
        });
    }

    /**
     * Run the specific task of this node
     * @abstract
     * @param {SpeedyGPU} gpu
     * @returns {void|SpeedyPromise<void>}
     */
    _run(gpu)
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.AbstractMethodError();
    }

    /**
     * Initializes this node
     * @param {SpeedyGPU} gpu
     */
    init(gpu)
    {
        gpu.subscribe(this._allocateWorkTextures, this, gpu);
        this._allocateWorkTextures(gpu);
    }

    /**
     * Releases this node
     * @param {SpeedyGPU} gpu
     */
    release(gpu)
    {
        this._deallocateWorkTextures(gpu);
        gpu.unsubscribe(this._allocateWorkTextures, this);
    }

    /**
     * Clear all ports
     */
    clearPorts()
    {
        let portName;

        for(portName in this._inputPorts)
            this._inputPorts[portName].clearMessage();

        for(portName in this._outputPorts)
            this._outputPorts[portName].clearMessage();
    }

    /**
     * Find all nodes that feed input to this node
     * @returns {SpeedyPipelineNode[]}
     */
    inputNodes()
    {
        const nodes = [];

        for(const portName in this._inputPorts) {
            const port = this._inputPorts[portName];
            if(port.incomingLink != null)
                nodes.push(port.incomingLink.node);
        }

        return nodes;
    }

    /**
     * Is this a source of the pipeline?
     * @returns {boolean}
     */
    isSource()
    {
        return false;
    }

    /**
     * Is this a sink of the pipeline?
     * @returns {boolean}
     */
    isSink()
    {
        return false;

        // note: a portal sink has no output ports, but it isn't a sink of the pipeline!
        //return Object.keys(this._outputPorts).length == 0;
    }

    /**
     * Allocate work texture(s)
     * @param {SpeedyGPU} gpu
     */
    _allocateWorkTextures(gpu)
    {
        for(let j = 0; j < this._tex.length; j++)
            this._tex[j] = gpu.texturePool.allocate();
    }

    /**
     * Deallocate work texture(s)
     * @param {SpeedyGPU} gpu
     */
    _deallocateWorkTextures(gpu)
    {
        for(let j = this._tex.length - 1; j >= 0; j--)
            this._tex[j] = gpu.texturePool.free(this._tex[j]);
    }

    /**
     * Inspect the pixels of a texture for debugging purposes
     * @param {SpeedyGPU} gpu
     * @param {SpeedyDrawableTexture} texture
     * @returns {Uint8Array}
     */
    _inspect(gpu, texture)
    {
        const textureReader = new _gpu_speedy_texture_reader__WEBPACK_IMPORTED_MODULE_8__.SpeedyTextureReader();
        textureReader.init(gpu);
        const pixels = textureReader.readPixelsSync(texture);
        textureReader.release(gpu);

        return new Uint8Array(pixels); // copy the array
    }

    /**
     * Inspect the pixels of a texture as unsigned 32-bit integers
     * @param {SpeedyGPU} gpu
     * @param {SpeedyDrawableTexture} texture
     * @returns {Uint32Array}
     */
    _inspect32(gpu, texture)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(_utils_globals__WEBPACK_IMPORTED_MODULE_1__.LITTLE_ENDIAN); // make sure we use little-endian
        return new Uint32Array(this._inspect(gpu, texture).buffer);
    }

    /**
     * Visually inspect a texture for debugging purposes
     * @param {SpeedyGPU} gpu
     * @param {SpeedyDrawableTexture} texture
     */
    _visualize(gpu, texture)
    {
        const canvas = gpu.renderToCanvas(texture);
        if(!_texView) {
            document.body.appendChild(canvas);
            _texView = true;
        }
    }
}

/**
 * Source node (a node with no input ports)
 * @abstract
 */
class SpeedyPipelineSourceNode extends SpeedyPipelineNode
{
    /**
     * Constructor
     * @param {string} [name] the name of this node
     * @param {number} [texCount] number of work textures
     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders
     */
    constructor(name = undefined, texCount = undefined, portBuilders = undefined)
    {
        super(name, texCount, portBuilders);
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(Object.keys(this._inputPorts).length == 0);
    }

    /**
     * Is this a source of the pipeline?
     * @returns {boolean}
     */
    isSource()
    {
        return true;
    }
}

/**
 * Sink node (a node with no output ports)
 * @abstract
 */
class SpeedyPipelineSinkNode extends SpeedyPipelineNode
{
    /**
     * Constructor
     * @param {string} [name] the name of this node
     * @param {number} [texCount] number of work textures
     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders
     */
    constructor(name = undefined, texCount = undefined, portBuilders = undefined)
    {
        super(name, texCount, portBuilders);
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(Object.keys(this._outputPorts).length == 0);
    }

    /**
     * Export data from this node to the user
     * @abstract
     * @returns {SpeedyPromise<any>}
     */
    export()
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.AbstractMethodError();
    }

    /**
     * Is this a sink of the pipeline?
     * @returns {boolean}
     */
    isSink()
    {
        return true;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/pipeline/pipeline-port.js":
/*!***********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/pipeline/pipeline-port.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyPipelineInputPort: () => (/* binding */ SpeedyPipelineInputPort),
/* harmony export */   SpeedyPipelineOutputPort: () => (/* binding */ SpeedyPipelineOutputPort),
/* harmony export */   SpeedyPipelinePort: () => (/* binding */ SpeedyPipelinePort)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/* harmony import */ var _pipeline_portspec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pipeline-portspec */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-portspec.js");
/* harmony import */ var _pipeline_message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pipeline-message */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-message.js");
/* harmony import */ var _pipeline_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pipeline-node */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-node.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * pipeline-port.js
 * Port of a node of a pipeline
 */







// Constants
const DEFAULT_INPUT_PORT_NAME = 'in';
const DEFAULT_OUTPUT_PORT_NAME = 'out';
const ACCEPTABLE_PORT_NAME = /^[a-z][a-zA-Z0-9]*$/;
const EMPTY_MESSAGE = new _pipeline_message__WEBPACK_IMPORTED_MODULE_3__.SpeedyPipelineMessageWithNothing();

/**
 * Port of a node of a pipeline
 * @abstract
 */
class SpeedyPipelinePort
{
    /**
     * Constructor
     * @param {string} name the name of this port 
     * @param {SpeedyPipelinePortSpec} spec port specification
     * @param {SpeedyPipelineNode} node the node to which this port belongs
     */
    constructor(name, spec, node)
    {
        /** @type {string} the name of this port */
        this._name = String(name);

        /** @type {SpeedyPipelinePortSpec} the specification of this port */
        this._spec = spec;

        /** @type {SpeedyPipelineNode} the node to which this port belongs */
        this._node = node;

        /** @type {SpeedyPipelineMessage} the message located in this port */
        this._message = EMPTY_MESSAGE;


        // check if we've got an acceptable port name
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(ACCEPTABLE_PORT_NAME.test(this._name), `Port name "${this._name}" is not acceptable`);
    }

    /**
     * The name of this port
     * @returns {string}
     */
    get name()
    {
        return this._name;
    }

    /**
     * The node to which this port belongs
     * @returns {SpeedyPipelineNode}
     */
    get node()
    {
        return this._node;
    }

    /**
     * Connect this port to another
     * @abstract
     * @param {SpeedyPipelinePort} port
     */
    connectTo(port)
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.AbstractMethodError();
    }

    /**
     * Is this an input port?
     * @abstract
     * @returns {boolean}
     */
    isInputPort()
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.AbstractMethodError();
    }

    /**
     * Is this an output port?
     * @returns {boolean}
     */
    isOutputPort()
    {
        return !this.isInputPort();
    }

    /**
     * Clear the message stored in this port
     */
    clearMessage()
    {
        this._message = EMPTY_MESSAGE;
    }

    /**
     * Is there a valid message located in this port?
     * @returns {boolean}
     */
    hasMessage()
    {
        return !this._message.isEmpty();
    }

    /**
     * Read the message that is in this port
     * @returns {SpeedyPipelineMessage}
     */
    read()
    {
        if(this._message.isEmpty())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalOperationError(`Can't read from port ${this.name}: nothing to read`);

        return this._message;
    }

    /**
     * Write a message to this port
     * @param {SpeedyPipelineMessage} message
     */
    write(message)
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.NotSupportedError(`Can't write ${message} to port ${this.name}: unsupported operation`);
    }

    /**
     * Default port name
     * @abstract
     * @returns {string}
     */
    static get DEFAULT_NAME()
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.AbstractMethodError();
    }
}

/**
 * Output port
 */
class SpeedyPipelineOutputPort extends SpeedyPipelinePort
{
    /**
     * Constructor
     * @param {string} name the name of this port 
     * @param {SpeedyPipelinePortSpec} spec port specification
     * @param {SpeedyPipelineNode} node the node to which this port belongs
     */
    constructor(name, spec, node)
    {
        super(name, spec, node);

        /** @type {SpeedyPipelineMessage} cached message */
        this._cachedMessage = null;
    }

    /**
     * Connect this port to another
     * @param {SpeedyPipelineInputPort} port
     */
    connectTo(port)
    {
        if(!port.isInputPort())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Can't connect output port ${this.name} to port ${port.name}: expected an input port`);

        port.connectTo(this);
    }

    /**
     * Is this an input port?
     * @returns {boolean}
     */
    isInputPort()
    {
        return false;
    }

    /**
     * Write a message to this port
     * @param {SpeedyPipelineMessage} message
     */
    write(message)
    {
        if(!this._spec.accepts(message))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Can't write ${message} to port ${this.name}. ${this._spec}`);

        this._message = message;
    }

    /**
     * Write a message to this port using a cached message object
     * @param  {...any} args to be passed to SpeedyPipelineMessage.set()
     */
    swrite(...args)
    {
        if(this._cachedMessage == null)
            this._cachedMessage = _pipeline_message__WEBPACK_IMPORTED_MODULE_3__.SpeedyPipelineMessage.create(this._spec.expectedMessageType);

        this.write(this._cachedMessage.set(...args));
    }

    /**
     * Default port name
     * @returns {string}
     */
    static get DEFAULT_NAME()
    {
        return DEFAULT_OUTPUT_PORT_NAME;
    }
}

/**
 * Input port
 */
class SpeedyPipelineInputPort extends SpeedyPipelinePort
{
    /**
     * Constructor
     * @param {string} name the name of this port 
     * @param {SpeedyPipelinePortSpec} spec port specification
     * @param {SpeedyPipelineNode} node the node to which this port belongs
     */
    constructor(name, spec, node)
    {
        super(name, spec, node);

        /** @type {SpeedyPipelineOutputPort|null} incoming link */
        this._incomingLink = null;
    }

    /**
     * Incoming link
     * @returns {SpeedyPipelineOutputPort|null}
     */
    get incomingLink()
    {
        return this._incomingLink;
    }

    /**
     * Connect this port to another
     * @param {SpeedyPipelineOutputPort} port
     */
    connectTo(port)
    {
        if(!port.isOutputPort())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Can't connect input port ${this.name} of "${this.node.fullName}" to input port ${port.name} of "${port.node.fullName}": expected an output port`);
        else if(!this._spec.isCompatibleWith(port._spec))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Can't connect port ${this.name} of "${this.node.fullName}" to port ${port.name} of "${port.node.fullName}": incompatible types`);

        this._incomingLink = port;
    }

    /**
     * Unlink this port
     */
    disconnect()
    {
        this._incomingLink = null;
    }

    /**
     * Is this an input port?
     * @returns {boolean}
     */
    isInputPort()
    {
        return true;
    }

    /**
     * Receive a message using the incoming link
     * @param {string} [nodeName]
     * @returns {SpeedyPipelineMessage}
     */
    pullMessage(nodeName = '')
    {
        const name = nodeName.length > 0 ? `${this.name} of ${nodeName}` : this.name;

        if(this._incomingLink == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalOperationError(`No incoming link for input port ${name}`);

        const message = this._incomingLink.read();
        if(!this._spec.accepts(message))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Can't receive ${message} at port ${name}: ${this._spec}`);

        return (this._message = message);
    }

    /**
     * Default port name
     * @returns {string}
     */
    static get DEFAULT_NAME()
    {
        return DEFAULT_INPUT_PORT_NAME;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/pipeline/pipeline-portbuilder.js":
/*!******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/pipeline/pipeline-portbuilder.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputPort: () => (/* binding */ InputPort),
/* harmony export */   OutputPort: () => (/* binding */ OutputPort),
/* harmony export */   SpeedyPipelinePortBuilder: () => (/* binding */ SpeedyPipelinePortBuilder)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _pipeline_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pipeline-port */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-port.js");
/* harmony import */ var _pipeline_portspec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pipeline-portspec */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-portspec.js");
/* harmony import */ var _pipeline_message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pipeline-message */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-message.js");
/* harmony import */ var _pipeline_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pipeline-node */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-node.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * pipeline-portbuilder.js
 * Builder of a port of a node of a pipeline
 */







/**
 * @typedef {import('./pipeline-portspec').SpeedyPipelineMessageConstraint} SpeedyPipelineMessageConstraint
 */

/**
 * Builder of a port of a node of a pipeline
 */
class SpeedyPipelinePortBuilder
{
    /**
     * Constructor
     * @param {typeof SpeedyPipelinePort} portClass input or output?
     * @param {string} portName
     */
    constructor(portClass, portName)
    {
        /** @type {typeof SpeedyPipelinePort} input or output? */
        this._class = portClass;

        /** @type {string} port name */
        this._name = String(portName);

        /** @type {SpeedyPipelineMessageType} accepted message type */
        this._type = _pipeline_message__WEBPACK_IMPORTED_MODULE_3__.SpeedyPipelineMessageType.Nothing;

        /** @type {SpeedyPipelineMessageConstraint} message validation function */
        this._messageConstraint = undefined;
    }

    /**
     * Declare that the new port expects a certain type of message
     * @param {SpeedyPipelineMessageType} type expected type
     * @returns {SpeedyPipelinePortBuilder} this builder
     */
    expects(type)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._type == _pipeline_message__WEBPACK_IMPORTED_MODULE_3__.SpeedyPipelineMessageType.Nothing);
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(type != _pipeline_message__WEBPACK_IMPORTED_MODULE_3__.SpeedyPipelineMessageType.Nothing);

        this._type = type;

        return this;
    }

    /**
     * Declare that the new port expects messages satisfying a constraint
     * @param {SpeedyPipelineMessageConstraint} constraint
     * @returns {SpeedyPipelinePortBuilder} this builder
     */
    satisfying(constraint)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._type != _pipeline_message__WEBPACK_IMPORTED_MODULE_3__.SpeedyPipelineMessageType.Nothing, 'You must first declare what type of message this port expects');
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._messageConstraint === undefined);
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(typeof constraint === 'function');

        this._messageConstraint = constraint;

        return this;
    }

    /**
     * Build a port
     * @param {SpeedyPipelineNode} node the node to which the new port will belong
     * @returns {SpeedyPipelinePort}
     */
    build(node)
    {
        const spec = new _pipeline_portspec__WEBPACK_IMPORTED_MODULE_2__.SpeedyPipelinePortSpec(this._type, this._messageConstraint);
        return Reflect.construct(this._class, [this._name, spec, node]);
    }
}

/**
 * Creates a builder for an input port
 * @param {string} [portName]
 * @returns {SpeedyPipelinePortBuilder}
 */
function InputPort(portName = _pipeline_port__WEBPACK_IMPORTED_MODULE_1__.SpeedyPipelineInputPort.DEFAULT_NAME)
{
    return new SpeedyPipelinePortBuilder(_pipeline_port__WEBPACK_IMPORTED_MODULE_1__.SpeedyPipelineInputPort, portName);
}

/**
 * Creates a builder for an output port
 * @param {string} [portName]
 * @returns {SpeedyPipelinePortBuilder}
 */
function OutputPort(portName = _pipeline_port__WEBPACK_IMPORTED_MODULE_1__.SpeedyPipelineOutputPort.DEFAULT_NAME)
{
    return new SpeedyPipelinePortBuilder(_pipeline_port__WEBPACK_IMPORTED_MODULE_1__.SpeedyPipelineOutputPort, portName);
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/pipeline/pipeline-portspec.js":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/pipeline/pipeline-portspec.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyPipelinePortSpec: () => (/* binding */ SpeedyPipelinePortSpec)
/* harmony export */ });
/* harmony import */ var _pipeline_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipeline-message */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-message.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * pipeline-portspec.js
 * Specification (requirements) of a port of a node of a pipeline
 */




/**
 * A message constraint is a message validation predicate
 * @typedef {function(SpeedyPipelineMessage): boolean} SpeedyPipelineMessageConstraint
 */

/**
 * A validation predicate that validates all messages
 * @type {SpeedyPipelineMessageConstraint}
 */
const none = message => true;

/**
 * Specification (requirements) of a port of a node of a pipeline
 */
class SpeedyPipelinePortSpec
{
    /**
     * Constructor
     * @param {SpeedyPipelineMessageType} expectedMessageType expected message type
     * @param {SpeedyPipelineMessageConstraint} [messageConstraint] message validation function
     */
    constructor(expectedMessageType, messageConstraint = none)
    {
        /** @type {SpeedyPipelineMessageType} expected message type */
        this._expectedMessageType = expectedMessageType;

        /** @type {SpeedyPipelineMessageConstraint} message validation function */
        this._isValidMessage = (typeof messageConstraint === 'function') ? messageConstraint : none;


        // expect a valid type
        _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.assert(this._expectedMessageType != _pipeline_message__WEBPACK_IMPORTED_MODULE_0__.SpeedyPipelineMessageType.Nothing);
    }

    /**
     * Checks if two specs have the same expected type
     * @param {SpeedyPipelinePortSpec} spec
     * @returns {boolean}
     */
    isCompatibleWith(spec)
    {
        return this._expectedMessageType == spec._expectedMessageType;
    }

    /**
     * Is the given message accepted by a port that abides by this specification?
     * @param {SpeedyPipelineMessage} message
     * @returns {boolean}
     */
    accepts(message)
    {
        return message.hasType(this._expectedMessageType) && this._isValidMessage(message);
    }

    /**
     * Convert to string
     * @returns {string}
     */
    toString()
    {
        const type = Object.keys(_pipeline_message__WEBPACK_IMPORTED_MODULE_0__.SpeedyPipelineMessageType).find(
            type => _pipeline_message__WEBPACK_IMPORTED_MODULE_0__.SpeedyPipelineMessageType[type] === this._expectedMessageType
        );

        return `Port expects ${type} satisfying ${this._isValidMessage}`;
    }

    /**
     * Expected message type
     * @returns {SpeedyPipelineMessageType}
     */
    get expectedMessageType()
    {
        return this._expectedMessageType;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/settings.js":
/*!*********************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/settings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Settings: () => (/* binding */ Settings)
/* harmony export */ });
/* harmony import */ var _speedy_namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-namespace */ "./node_modules/speedy-vision/src/core/speedy-namespace.js");
/* harmony import */ var _gpu_speedy_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gpu/speedy-gl */ "./node_modules/speedy-vision/src/gpu/speedy-gl.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * settings.js
 * Global settings
 */





/** @typedef {import('../gpu/speedy-gl').PowerPreference} PowerPreference */
/** @typedef {"raf" | "asap"} GPUPollingMode */


/** @type {GPUPollingMode} Default GPU polling mode */
const DEFAULT_GPU_POLLING_MODE = 'raf';

/** @type {GPUPollingMode} GPU polling mode */
let gpuPollingMode = DEFAULT_GPU_POLLING_MODE;



/**
 * Global settings
 */
class Settings extends _speedy_namespace__WEBPACK_IMPORTED_MODULE_0__.SpeedyNamespace
{
    /**
     * Power preference of the WebGL context
     * @returns {PowerPreference}
     */
    static get powerPreference()
    {
        return _gpu_speedy_gl__WEBPACK_IMPORTED_MODULE_1__.SpeedyGL.powerPreference;
    }

    /**
     * Power preference of the WebGL context
     * @param {PowerPreference} value
     */
    static set powerPreference(value)
    {
        _gpu_speedy_gl__WEBPACK_IMPORTED_MODULE_1__.SpeedyGL.powerPreference = value;
    }

    /**
     * GPU polling mode
     * @returns {GPUPollingMode}
     */
    static get gpuPollingMode()
    {
        return gpuPollingMode;
    }

    /**
     * GPU polling mode
     * @param {GPUPollingMode} value
     */
    static set gpuPollingMode(value)
    {
        if(value !== 'raf' && value !== 'asap')
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalArgumentError(`Invalid GPU polling mode: "${value}"`);

        gpuPollingMode = value;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/speedy-media-source.js":
/*!********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/speedy-media-source.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyMediaSource: () => (/* binding */ SpeedyMediaSource)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _speedy_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/types */ "./node_modules/speedy-vision/src/utils/types.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-media-source.js
 * Wrappers around <img>, <video>, <canvas>, etc.
 */






/** @typedef {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} SpeedyMediaSourceNativeElement */

/** Internal token for protected constructors */
const PRIVATE_TOKEN = Symbol();

/**
 * An abstract media source: a wrapper around native
 * elements such as: HTMLImageElement, HTMLVideoElement,
 * and so on
 * @abstract
 */
class SpeedyMediaSource
{
    /**
     * @protected Constructor
     * @param {symbol} token
     */
    constructor(token)
    {
        // the constructor is not public
        if(token !== PRIVATE_TOKEN)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalOperationError();

        /** @type {SpeedyMediaSourceNativeElement} underlying media object */
        this._data = null;
    }

    /**
     * Load a media source
     * @param {SpeedyMediaSourceNativeElement} wrappedObject
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    static load(wrappedObject)
    {
        if(wrappedObject instanceof HTMLImageElement)
            return SpeedyImageMediaSource.load(wrappedObject);
        else if(wrappedObject instanceof HTMLVideoElement)
            return SpeedyVideoMediaSource.load(wrappedObject);
        else if(wrappedObject instanceof HTMLCanvasElement)
            return SpeedyCanvasMediaSource.load(wrappedObject);
        else if(wrappedObject instanceof ImageBitmap)
            return SpeedyBitmapMediaSource.load(wrappedObject);
        else
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalArgumentError(`Unsupported media type: ${wrappedObject}`);
    }

    /**
     * The underlying wrapped object
     * @returns {SpeedyMediaSourceNativeElement}
     */
    get data()
    {
        return this._data;
    }

    /**
     * Is the underlying media loaded?
     * @returns {boolean}
     */
    isLoaded()
    {
        return this._data !== null;
    }

    /**
     * The type of the underlying media source
     * @abstract
     * @returns {MediaType}
     */
    get type()
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.AbstractMethodError();
    }

    /**
     * Media width, in pixels
     * @abstract
     * @returns {number}
     */
    get width()
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.AbstractMethodError();
    }

    /**
     * Media height, in pixels
     * @abstract
     * @returns {number}
     */
    get height()
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.AbstractMethodError();
    }

    /**
     * Clone this media source
     * @abstract
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    clone()
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.AbstractMethodError();
    }

    /**
     * Release resources associated with this object
     * @returns {null}
     */
    release()
    {
        return (this._data = null);
    }

    /**
     * Load the underlying media
     * @abstract
     * @param {SpeedyMediaSourceNativeElement} element
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    _load(element)
    {
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.AbstractMethodError();
    }

    /**
     * Wait for an event to be triggered in an element
     * @param {Element} element
     * @param {string} eventName
     * @param {number} [timeout] in ms
     * @returns {SpeedyPromise<Element>}
     */
    static _waitUntil(element, eventName, timeout = 30000)
    {
        return new _speedy_promise__WEBPACK_IMPORTED_MODULE_1__.SpeedyPromise((resolve, reject) => {
            _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.log(`Waiting for ${eventName} to be triggered in ${element}...`);

            const timer = setTimeout(() => {
                reject(new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.TimeoutError(`${eventName} has not been triggered in ${element}: timeout (${timeout}ms)`));
            }, timeout);

            element.addEventListener(eventName, () => {
                clearTimeout(timer);
                resolve(element);
            }, false);
        });
    }
}

/**
 * Image media source:
 * a wrapper around HTMLImageElement
 */
class SpeedyImageMediaSource extends SpeedyMediaSource
{
    /**
     * @private Constructor
     * @param {symbol} token
     */
    constructor(token)
    {
        super(token);

        /** @type {HTMLImageElement} image element */
        this._data = null;
    }

    /**
     * The underlying wrapped object
     * @returns {HTMLImageElement}
     */
    get data()
    {
        return this._data;
    }

    /**
     * The type of the underlying media source
     * @returns {MediaType}
     */
    get type()
    {
        return _utils_types__WEBPACK_IMPORTED_MODULE_3__.MediaType.Image;
    }

    /**
     * Media width, in pixels
     * @returns {number}
     */
    get width()
    {
        return this._data ? this._data.naturalWidth : 0;
    }

    /**
     * Media height, in pixels
     * @returns {number}
     */
    get height()
    {
        return this._data ? this._data.naturalHeight : 0;
    }

    /**
     * Clone this media source
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    clone()
    {
        if(this._data == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalOperationError(`Media not loaded`);

        const newNode = /** @type {HTMLImageElement} */ ( this._data.cloneNode(true) );
        return SpeedyImageMediaSource.load(newNode);
    }

    /**
     * Load the underlying media
     * @param {HTMLImageElement} image
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    _load(image)
    {
        if(this.isLoaded())
            this.release();

        if(image.complete && image.naturalWidth !== 0) { // already loaded?
            return new _speedy_promise__WEBPACK_IMPORTED_MODULE_1__.SpeedyPromise(resolve => {
                this._data = image;
                resolve(this);
            });
        }
        else {
            return SpeedyMediaSource._waitUntil(image, 'load').then(() => {
                this._data = image;
                return this;
            });
        }
    }

    /**
     * Load the underlying media
     * @param {HTMLImageElement} image
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    static load(image)
    {
        return new SpeedyImageMediaSource(PRIVATE_TOKEN)._load(image);
    }
}

/**
 * Video media source:
 * a wrapper around HTMLVideoElement
 */
class SpeedyVideoMediaSource extends SpeedyMediaSource
{
    /**
     * @private Constructor
     * @param {symbol} token
     */
    constructor(token)
    {
        super(token);

        /** @type {HTMLVideoElement} video element */
        this._data = null;
    }

    /**
     * The underlying wrapped object
     * @returns {HTMLVideoElement}
     */
    get data()
    {
        return this._data;
    }

    /**
     * The type of the underlying media source
     * @returns {MediaType}
     */
    get type()
    {
        return _utils_types__WEBPACK_IMPORTED_MODULE_3__.MediaType.Video;
    }

    /**
     * Media width, in pixels
     * @returns {number}
     */
    get width()
    {
        // Warning: videoWidth & videoHeight may change at any time !!!
        // so you can't cache these dimensions
        return this._data ? this._data.videoWidth : 0;
    }

    /**
     * Media height, in pixels
     * @returns {number}
     */
    get height()
    {
        return this._data ? this._data.videoHeight : 0;
    }

    /**
     * Clone this media source
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    clone()
    {
        if(this._data == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalOperationError(`Media not loaded`);

        const newNode = /** @type {HTMLVideoElement} */ ( this._data.cloneNode(true) );
        return SpeedyVideoMediaSource.load(newNode);
    }

    /**
     * Load the underlying media
     * @param {HTMLVideoElement} video
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    _load(video)
    {
        if(this.isLoaded())
            this.release();

        if(video.readyState >= 4) { // already loaded?
            return new _speedy_promise__WEBPACK_IMPORTED_MODULE_1__.SpeedyPromise(resolve => {
                this._data = video;
                resolve(this);
            });
        }
        else {
            // waitUntil('canplay'); // use readyState >= 3
            return SpeedyMediaSource._waitUntil(video, 'canplaythrough').then(() => {
                this._data = video;
                return this;
            })
        }
    }

    /**
     * Load the underlying media
     * @param {HTMLVideoElement} video
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    static load(video)
    {
        return new SpeedyVideoMediaSource(PRIVATE_TOKEN)._load(video);
    }
}

/**
 * Canvas media source:
 * a wrapper around HTMLCanvasElement
 */
class SpeedyCanvasMediaSource extends SpeedyMediaSource
{
    /**
     * @private Constructor
     * @param {symbol} token
     */
    constructor(token)
    {
        super(token);

        /** @type {HTMLCanvasElement} canvas element */
        this._data = null;
    }

    /**
     * The underlying wrapped object
     * @returns {HTMLCanvasElement}
     */
    get data()
    {
        return this._data;
    }

    /**
     * The type of the underlying media source
     * @returns {MediaType}
     */
    get type()
    {
        return _utils_types__WEBPACK_IMPORTED_MODULE_3__.MediaType.Canvas;
    }

    /**
     * Media width, in pixels
     * @returns {number}
     */
    get width()
    {
        return this._data ? this._data.width : 0;
    }

    /**
     * Media height, in pixels
     * @returns {number}
     */
    get height()
    {
        return this._data ? this._data.height : 0;
    }

    /**
     * Clone this media source
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    clone()
    {
        if(this._data == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalOperationError(`Media not loaded`);

        const newCanvas = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.createCanvas(this.width, this.height);
        const newContext = newCanvas.getContext('2d');
        newContext.drawImage(this._data, 0, 0);

        return SpeedyCanvasMediaSource.load(newCanvas);
    }

    /**
     * Load the underlying media
     * @param {HTMLCanvasElement} canvas
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    _load(canvas)
    {
        if(this.isLoaded())
            this.release();

        return new _speedy_promise__WEBPACK_IMPORTED_MODULE_1__.SpeedyPromise(resolve => {
            this._data = canvas;
            resolve(this);
        });
    }

    /**
     * Load the underlying media
     * @param {HTMLCanvasElement} canvas
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    static load(canvas)
    {
        return new SpeedyCanvasMediaSource(PRIVATE_TOKEN)._load(canvas);
    }
}

/**
 * Bitmap media source:
 * a wrapper around ImageBitmap
 */
class SpeedyBitmapMediaSource extends SpeedyMediaSource
{
    /**
     * @private Constructor
     * @param {symbol} token
     */
    constructor(token)
    {
        super(token);

        /** @type {ImageBitmap} image bitmap */
        this._data = null;
    }

    /**
     * The underlying wrapped object
     * @returns {ImageBitmap}
     */
    get data()
    {
        return this._data;
    }

    /**
     * The type of the underlying media source
     * @returns {MediaType}
     */
    get type()
    {
        return _utils_types__WEBPACK_IMPORTED_MODULE_3__.MediaType.Bitmap;
    }

    /**
     * Media width, in pixels
     * @returns {number}
     */
    get width()
    {
        return this._data ? this._data.width : 0;
    }

    /**
     * Media height, in pixels
     * @returns {number}
     */
    get height()
    {
        return this._data ? this._data.height : 0;
    }

    /**
     * Clone this media source
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    clone()
    {
        if(this._data == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalOperationError(`Media not loaded`);

        return new _speedy_promise__WEBPACK_IMPORTED_MODULE_1__.SpeedyPromise((resolve, reject) => {
            createImageBitmap(this._data).then(
                newBitmap => {
                    const newSource = new SpeedyBitmapMediaSource(PRIVATE_TOKEN);
                    newSource._load(newBitmap).then(resolve, reject);
                },
                reject
            );
        });
    }

    /**
     * Release resources associated with this object
     * @returns {null}
     */
    release()
    {
        if(this._data != null)
            this._data.close();

        return super.release();
    }

    /**
     * Load the underlying media
     * @param {ImageBitmap} bitmap
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    _load(bitmap)
    {
        if(this.isLoaded())
            this.release();

        return new _speedy_promise__WEBPACK_IMPORTED_MODULE_1__.SpeedyPromise(resolve => {
            this._data = bitmap;
            resolve(this);
        });
    }

    /**
     * Load the underlying media
     * @param {ImageBitmap} bitmap
     * @returns {SpeedyPromise<SpeedyMediaSource>}
     */
    static load(bitmap)
    {
        return new SpeedyBitmapMediaSource(PRIVATE_TOKEN)._load(bitmap);
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/speedy-media.js":
/*!*************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/speedy-media.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyMedia: () => (/* binding */ SpeedyMedia)
/* harmony export */ });
/* harmony import */ var _gpu_speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gpu/speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _gpu_speedy_texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gpu/speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/types */ "./node_modules/speedy-vision/src/utils/types.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _speedy_media_source__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./speedy-media-source */ "./node_modules/speedy-vision/src/core/speedy-media-source.js");
/* harmony import */ var _speedy_promise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var _speedy_size__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./speedy-size */ "./node_modules/speedy-vision/src/core/speedy-size.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-media.js
 * SpeedyMedia implementation
 */










/** @typedef {import('./speedy-media-source').SpeedyMediaSourceNativeElement} SpeedyMediaSourceNativeElement */

/**
 * @typedef {object} SpeedyMediaOptions
 * @property {ImageFormat} [format] default is RGBA
 */

/** A helper used to keep the constructor of SpeedyMedia private */
const PRIVATE_TOKEN = Symbol();

/**
 * SpeedyMedia encapsulates a media element
 * (e.g., image, video, canvas)
 */
class SpeedyMedia
{
    /**
     * @private Constructor. It receives a VALID media source that is ALREADY LOADED.
     * @param {symbol} token
     * @param {SpeedyMediaSource} source
     * @param {SpeedyMediaOptions} [options] options object
     */
    constructor(token, source, options = {})
    {
        // private constructor
        if(token !== PRIVATE_TOKEN)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalOperationError();



        /** @type {SpeedyMediaSource} media source */
        this._source = source;

        /** @type {ImageFormat} format */
        this._format = options.format !== undefined ? options.format : _utils_types__WEBPACK_IMPORTED_MODULE_2__.ImageFormat.RGBA;

        /** @type {SpeedyMediaOptions} options */
        this._options = Object.freeze({ ...options, format: this._format });



        // validate
        if(!source.isLoaded())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalOperationError(`Source not loaded: ${source}`);
        else if(this._format !== _utils_types__WEBPACK_IMPORTED_MODULE_2__.ImageFormat.RGBA && this._format !== _utils_types__WEBPACK_IMPORTED_MODULE_2__.ImageFormat.GREY)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalArgumentError(`Invalid format: ${this._format}`);
    }

    /**
     * Load a media source
     * Will wait until the HTML media source is loaded
     * @param {SpeedyMediaSourceNativeElement} mediaSource An image, video or canvas
     * @param {SpeedyMediaOptions} [options] options object
     * @param {boolean} [log] show log message?
     * @returns {SpeedyPromise<SpeedyMedia>}
     */
    static load(mediaSource, options = {}, log = true)
    {
        return _speedy_media_source__WEBPACK_IMPORTED_MODULE_5__.SpeedyMediaSource.load(mediaSource).then(source => {
            _utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.assert(source.width !== 0 && source.height !== 0);

            // FIXME user could pass an invalid format in options if ImageFormat is made public
            const media = new SpeedyMedia(PRIVATE_TOKEN, source, options);

            // show log message
            if(log)
                _utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);

            // done!
            return media;
        });
    }

    /**
     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object
     * @returns {SpeedyMediaSourceNativeElement} the media element
     */
    get source()
    {
        return this._source ? this._source.data : null;
    }

    /**
     * The type of the media attached to this SpeedyMedia object
     * @returns {"image" | "video" | "canvas" | "bitmap" | "unknown"}
     */
    get type()
    {
        if(this.isReleased())
            return 'unknown';

        switch(this._source.type) {
            case _utils_types__WEBPACK_IMPORTED_MODULE_2__.MediaType.Image:
                return 'image';

            case _utils_types__WEBPACK_IMPORTED_MODULE_2__.MediaType.Video:
                return 'video';

            case _utils_types__WEBPACK_IMPORTED_MODULE_2__.MediaType.Canvas:
                return 'canvas';

            case _utils_types__WEBPACK_IMPORTED_MODULE_2__.MediaType.Bitmap:
                return 'bitmap';

            default: // this shouldn't happen
                return 'unknown';
        }
    }

    /**
     * Gets the width of the media
     * @returns {number} media width
     */
    get width()
    {
        return this._source ? this._source.width : 0;
    }

    /**
     * Gets the height of the media
     * @returns {number} media height
     */
    get height()
    {
        return this._source ? this._source.height : 0;
    }

    /**
     * The size of this media, in pixels
     * @returns {SpeedySize}
     */
    get size()
    {
        return this._source ? new _speedy_size__WEBPACK_IMPORTED_MODULE_7__.SpeedySize(this._source.width, this._source.height) : new _speedy_size__WEBPACK_IMPORTED_MODULE_7__.SpeedySize(0, 0);
    }

    /**
     * Returns a read-only object featuring advanced options
     * related to this SpeedyMedia object
     * @returns {SpeedyMediaOptions}
     */
    get options()
    {
        return this._options;
    }

    /**
     * Releases resources associated with this media
     * @returns {null}
     */
    release()
    {
        if(!this.isReleased()) {
            _utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.log('Releasing SpeedyMedia object...');
            this._source = this._source.release();
        }

        return null;
    }

    /**
     * Has this media been released?
     * @returns {boolean}
     */
    isReleased()
    {
        return this._source == null;
    }

    /**
     * Clones the SpeedyMedia object
     * @returns {SpeedyPromise<SpeedyMedia>} a clone object
     */
    clone()
    {
        // has the media been released?
        if(this.isReleased())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalOperationError(`Can't clone a SpeedyMedia that has been released`);

        // clone the object
        const clone = new SpeedyMedia(PRIVATE_TOKEN, this._source, this._options);

        // done!
        return _speedy_promise__WEBPACK_IMPORTED_MODULE_6__.SpeedyPromise.resolve(clone);
    }

    /**
     * Converts the media to an ImageBitmap
     * @returns {SpeedyPromise<ImageBitmap>}
     */
    toBitmap()
    {
        if(this.isReleased())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalOperationError('Can\'t convert SpeedyMedia to ImageBitmap: the media has been released');
        else if(!this._source.isLoaded())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalOperationError('Can\'t convert SpeedyMedia to bitmap: the media hasn\'t been loaded');
        else if(this._source.type == _utils_types__WEBPACK_IMPORTED_MODULE_2__.MediaType.Bitmap)
            return _speedy_promise__WEBPACK_IMPORTED_MODULE_6__.SpeedyPromise.resolve(this._source.data);
        else
            return new _speedy_promise__WEBPACK_IMPORTED_MODULE_6__.SpeedyPromise((resolve, reject) => createImageBitmap(this._source.data).then(resolve, reject));
    }
}


/***/ }),

/***/ "./node_modules/speedy-vision/src/core/speedy-namespace.js":
/*!*****************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/speedy-namespace.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyNamespace: () => (/* binding */ SpeedyNamespace)
/* harmony export */ });
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-namespace.js
 * Symbolizes a namespace
 */



/**
 * An abstract namespace
 * @abstract
 */
class SpeedyNamespace
{
    /**
     * Namespaces can't be instantiated.
     * Only static methods are allowed.
     * @abstract
     * @throws SpeedyError
     */
    constructor()
    {
        // only static methods are allowed
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_0__.AbstractMethodError(`Namespaces can't be instantiated`);
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/core/speedy-promise.js":
/*!***************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/speedy-promise.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyPromise: () => (/* binding */ SpeedyPromise)
/* harmony export */ });
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-promise.js
 * Speedy Promises: a fast implementation of Promises
 */

const PENDING = 0;
const FULFILLED = 1;
const REJECTED = 2;

const SUSPEND_ASYNC = 1;
const asap = (typeof queueMicrotask !== 'undefined' && queueMicrotask) || // browsers
             (typeof process !== 'undefined' && process.nextTick) || // node.js
             (f => Promise.resolve().then(() => f())); // most compatible

/**
 * SpeedyPromise: Super Fast Promises. SpeedyPromises can
 * interoperate with ES6 Promises. This implementation is
 * based on the Promises/A+ specification.
 * @template T
 */
class SpeedyPromise
{
    /**
     * Constructor
     * @param {function(function(T=): void, function(Error): void): void} callback
     */
    constructor(callback)
    {
        this._state = PENDING;
        this._value = undefined;

        this._onFulfillment = null;
        this._onRejection = null;
        this._children = 0;
        this[0] = this;
        this._parent = undefined;
        this._flags = 0;

        this._fulfill = this._fulfill.bind(this);
        this._reject = this._reject.bind(this);
        this._resolve = this._resolve.bind(this);
        this._broadcastIfAsync = this._broadcastIfAsync.bind(this);

        callback(this._fulfill, this._reject);
    }

    /**
     * Setup handlers
     * @template U, V=never
     * @param {null|undefined|(function(T): U|PromiseLike<U>|SpeedyPromise<U>)} onFulfillment called when the SpeedyPromise is fulfilled
     * @param {null|undefined|(function(Error): V|PromiseLike<V>|SpeedyPromise<V>)} [onRejection] called when the SpeedyPromise is rejected
     * @returns {SpeedyPromise<U>}
     */
    then(onFulfillment, onRejection = null)
    {
        const child = new SpeedyPromise(this._nop);
        child._onFulfillment = typeof onFulfillment === 'function' && onFulfillment;
        child._onRejection = typeof onRejection === 'function' && onRejection;
        child._parent = this;

        this[this._children++] = child; // attach child
        this._flags &= ~SUSPEND_ASYNC; // restore the async behavior
        this._notify();

        return child;
    }

    /**
     * Setup rejection handler
     * @template U, V=never
     * @param {null|undefined|(function(Error): V|PromiseLike<V>|SpeedyPromise<V>)} [onRejection] called when the SpeedyPromise is rejected
     * @returns {SpeedyPromise<V>}
     */
    catch(onRejection)
    {
        return this.then(null, onRejection);
    }

    /**
     * Execute a callback when the promise is settled
     * (i.e., fulfilled or rejected)
     * @param {function(): void} onFinally
     * @returns {SpeedyPromise<T>}
     */
    finally(onFinally)
    {
        const fn = val => { onFinally(); return val; };
        return this.then(fn, fn);
    }

    /**
     * Start the computation immediately, synchronously.
     * Can't afford to spend any time at all waiting for micro-tasks, etc.
     * @returns {SpeedyPromise<T>} this
     */
    turbocharge()
    {
        let my = this;

        // suspend the async behavior
        this._flags |= SUSPEND_ASYNC;
        while(my._parent !== undefined) {
            my = my._parent;
            my._flags |= SUSPEND_ASYNC;
        }

        // notify the children of the root
        my._notify(); // will be synchronous

        // return this SpeedyPromise
        return this;
    }

    /**
     * Convert to string
     * @returns {string}
     */
    toString()
    {
        switch(this._state) {
            case PENDING:
                return `SpeedyPromise { <pending> }`;
            case FULFILLED:
                return `SpeedyPromise { <fulfilled> ${this._value} }`;
            case REJECTED:
                return `SpeedyPromise { <rejected> ${this._value} }`;
            default:
                return '';
        }
    }

    /**
     * Symbol.toStringTag
     * @returns {string}
     */
    get [Symbol.toStringTag]()
    {
        return 'SpeedyPromise';
    }

    /**
     * Creates a resolved SpeedyPromise
     * @template U
     * @param {U} [value]
     * @returns {SpeedyPromise<U>}
     */
    static resolve(value)
    {
        const promise = new SpeedyPromise(this._snop);

        if((typeof value === 'object' && value !== null && 'then' in value) || (typeof value === 'function' && 'then' in value)) {
            // resolve asynchronously
            promise._resolve(value);
        }
        else {
            // fulfill synchronously
            promise._value = value;
            promise._state = FULFILLED;
        }

        return promise;
    }

    /**
     * Creates a rejected SpeedyPromise
     * @template U
     * @param {Error} reason
     * @returns {SpeedyPromise<U>}
     */
    static reject(reason)
    {
        const promise = new SpeedyPromise(this._snop);
        promise._value = reason;
        promise._state = REJECTED;
        return promise;
    }

    /**
     * Returns a SpeedyPromise that resolves to an array
     * containing the results of the input promises/values,
     * in their given order. The returned SpeedyPromise will
     * resolve if all input promises resolve, or reject if
     * any input promise rejects.
     * @template U
     * @param {Iterable<U>|Iterable<SpeedyPromise<U>>|Iterable<Promise<U>>} iterable e.g., a SpeedyPromise[], a thenable[]
     * @returns {SpeedyPromise<U[]>}
     *
     * FIXME iterables need not be all <U>
     */
    static all(iterable)
    {
        return new SpeedyPromise((resolve, reject) => {
            const input = [];

            // get elements
            for(const element of iterable)
                input.push(element);

            // resolve synchronously if there are no elements
            const length = input.length;
            if(length == 0) {
                resolve([]);
                return;
            }

            // resolve asynchronously
            let counter = length;
            const output = new Array(length);
            const partialResolve = i => (val => { output[i] = val; if(0 == --counter) resolve(output); });
            for(let i = 0; i < length; i++) {
                const element = input[i];
                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)
                    element.then(partialResolve(i), reject);
                else
                    SpeedyPromise.resolve(element).then(partialResolve(i), reject);
            }
        });
    }

    /**
     * Returns a promise that gets fulfilled or rejected as soon
     * as the first promise in the iterable gets fulfilled or
     * rejected (with its value/reason).
     * @template U
     * @param {Iterable<U>|Iterable<SpeedyPromise<U>>|Iterable<Promise<U>>} iterable e.g., a SpeedyPromise[], a thenable[]
     * @returns {SpeedyPromise<U>}
     */
    static race(iterable)
    {
        return new SpeedyPromise((resolve, reject) => {
            const input = [];

            // get elements
            for(const element of iterable)
                input.push(element);

            // if the iterable is empty, the promise
            // will be pending forever...

            // resolve asynchronously
            const length = input.length;
            for(let i = 0; i < length; i++) {
                const element = input[i];
                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)
                    element.then(resolve, reject);
                else
                    SpeedyPromise.resolve(element).then(resolve, reject);
            }
        });
    }

    /**
     * Fulfill this promise with a value
     * @param {T} value
     */
    _fulfill(value)
    {
        this._setState(FULFILLED, value);
    }

    /**
     * Reject this promise with a reason
     * @param {Error} reason
     */
    _reject(reason)
    {
        this._setState(REJECTED, reason);
    }

    /**
     * Set the state and the value of this promise
     * @param {number} state
     * @param {T|Error} value
     */
    _setState(state, value)
    {
        // the promise is already fulfilled or rejected
        if(this._state != PENDING)
            return;

        // set the new state
        this._state = state;
        this._value = value;
        this._notify();
    }

    /**
     * Notify my children that this promise is no
     * longer pending. This is an async operation:
     * my childen will be notified "as soon
     * as possible" (it will be scheduled).
     * We may force this to be synchronous, though
     */
    _notify()
    {
        // nothing to do
        if(this._state == PENDING)
            return;

        // have we turbocharged this promise?
        if(this._flags & SUSPEND_ASYNC) {
            this._broadcast(); // execute synchronously
            return;
        }

        // install a timer (default behavior)
        asap(this._broadcastIfAsync);
    }

    /**
     * Helper method
     */
    _broadcastIfAsync()
    {
        // we may have installed a timer at some
        // point, but turbocharged the promise later
        if(!(this._flags & SUSPEND_ASYNC))
            this._broadcast();
    }

    /**
     * Tell my children that this promise
     * is either fulfilled or rejected.
     * This is a synchronous operation
     */
    _broadcast()
    {
        const children = this._children;
        const state = this._state;

        if(state === FULFILLED) {
            for(let i = 0; i < children; i++) {
                const child = this[i];
                const callback = child._onFulfillment;

                try {
                    if(callback) {
                        if(callback !== child._nop) {
                            child._resolve(callback(this._value)); // promise resolution procedure
                            child._onFulfillment = child._nop; // will not be called again
                        }
                    }
                    else
                        child._fulfill(this._value);
                }
                catch(e) {
                    child._reject(e);
                }
            }
        }
        else if(state === REJECTED) {
            for(let i = 0; i < children; i++) {
                const child = this[i];
                const callback = child._onRejection;

                try {
                    if(callback) {
                        if(callback !== child._nop) {
                            child._resolve(callback(this._value)); // promise resolution procedure
                            child._onRejection = child._nop; // will not be called again
                        }
                    }
                    else
                        child._reject(this._value);
                }
                catch(e) {
                    child._reject(e);
                }
            }
        }
    }

    /**
     * Promise Resolution Procedure
     * based on the Promises/A+ spec
     * @param {T} x
     */
    _resolve(x)
    {
        if((typeof x !== 'object' && typeof x !== 'function') || (x === null)) { // if(x !== Object(x))
            this._fulfill(x);
            return;
        }

        if(x === this)
            throw new TypeError(); // Circular reference

        if(x.__proto__ === SpeedyPromise.prototype || x.__proto__ === Promise.prototype) {
            x.then(this._resolve, this._reject);
            return;
        }

        try {
            const then = x.then;
            if(typeof then === 'function') {
                let resolve = this._resolve, reject = this._reject;
                try {
                    then.call(x,
                        y => { resolve(y); resolve = reject = this._nop; },
                        r => { reject(r); resolve = reject = this._nop; }
                    );
                }
                catch(e) {
                    if(resolve !== this._nop && reject !== this._nop)
                        this._reject(e);
                }
            }
            else {
                this._fulfill(x);
            }
        }
        catch(e) {
            this._reject(e);
        }
    }

    /**
     * No-operation
     */
    _nop()
    {
    }

    /**
     * Static no-operation
     */
    static _snop()
    {
    }
}

//module.exports = { SpeedyPromise };

/*
// Uncomment to test performance with regular Promises
module.exports = { SpeedyPromise: Promise };
Promise.prototype.turbocharge = function() { return this };
*/


/***/ }),

/***/ "./node_modules/speedy-vision/src/core/speedy-size.js":
/*!************************************************************!*\
  !*** ./node_modules/speedy-vision/src/core/speedy-size.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedySize: () => (/* binding */ SpeedySize)
/* harmony export */ });
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-size.js
 * Size of a rectangle
 */

/**
 * Size of a rectangle
 */
class SpeedySize
{
    /**
     * Constructor
     * @param {number} width non-negative number
     * @param {number} height non-negative number
     */
    constructor(width, height)
    {
        /** @type {number} width */
        this._width = Math.max(0, +width);

        /** @type {number} height */
        this._height = Math.max(0, +height);
    }



    //
    // ===== METHODS =====
    //

    /**
     * Width
     * @returns {number}
     */
    get width()
    {
        return this._width;
    }

    /**
     * Width
     * @param {number} value
     */
    set width(value)
    {
        this._width = Math.max(0, +value);
    }

    /**
     * Height
     * @returns {number}
     */
    get height()
    {
        return this._height;
    }

    /**
     * Height
     * @param {number} value
     */
    set height(value)
    {
        this._height = Math.max(0, +value);
    }

    /**
     * Convert to string
     * @returns {string}
     */
    toString()
    {
        return `SpeedySize(${this.width}, ${this.height})`;
    }

    /**
     * Is this size equal to anotherSize?
     * @param {SpeedySize} anotherSize
     * @returns {boolean}
     */
    equals(anotherSize)
    {
        return this.width === anotherSize.width && this.height === anotherSize.height;
    }

    /**
     * The area of the rectangle
     * @returns {number}
     */
    area()
    {
        return this.width * this.height;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/programs/filters.js":
/*!****************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/programs/filters.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgramGroupFilters: () => (/* binding */ SpeedyProgramGroupFilters)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../speedy-program-group */ "./node_modules/speedy-vision/src/gpu/speedy-program-group.js");
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/* harmony import */ var _shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/filters/convolution */ "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * filters.js
 * Image filtering on the GPU
 */









//
// Shaders
//

// Convert to greyscale
const rgb2grey = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/rgb2grey.glsl')
                .withArguments('image');

// Convolution
const convolution = [3, 5, 7].reduce((obj, ksize) => ((obj[ksize] =
                        (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/convolution2d.glsl')
                       .withDefines({ 'KERNEL_SIZE_SQUARED': ksize * ksize })
                       .withArguments('image', 'kernel')
                    ), obj), {});

// Separable convolution
const convolutionX = [3, 5, 7, 9, 11, 13, 15].reduce((obj, ksize) => ((obj[ksize] =
                         (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/convolution1d.glsl')
                        .withDefines({ 'KERNEL_SIZE': ksize, 'AXIS': 0 })
                        .withArguments('image', 'kernel')
                     ), obj), {});

const convolutionY = [3, 5, 7, 9, 11, 13, 15].reduce((obj, ksize) => ((obj[ksize] =
                         (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/convolution1d.glsl')
                        .withDefines({ 'KERNEL_SIZE': ksize, 'AXIS': 1 })
                        .withArguments('image', 'kernel')
                     ), obj), {});
// Median filter
const median = [3, 5, 7].reduce((obj, ksize) => ((obj[ksize] =
                   (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/fast-median.glsl')
                  .withDefines({ 'KERNEL_SIZE': ksize })
                  .withArguments('image')
               ), obj), {});

// Normalize image
const normalizeGreyscale = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/normalize-image.glsl')
                          .withDefines({ 'GREYSCALE': 1 })
                          .withArguments('minmax2d', 'minValue', 'maxValue');

const normalizeColored = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/normalize-image.glsl')
                        .withDefines({ 'GREYSCALE': 0 })
                        .withArguments('minmax2dRGB', 'minValue', 'maxValue');

// Nightvision
const nightvision = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/nightvision.glsl')
                   .withDefines({ 'GREYSCALE': 0 })
                   .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay');

const nightvisionGreyscale = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('filters/nightvision.glsl')
                            .withDefines({ 'GREYSCALE': 1 })
                            .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay');



//
// Utilities
//

// Handy conversion for Gaussian filters
// (symmetric kernel, approx. zero after 3*sigma)
const ksize2sigma = ksize => Math.max(1.0, ksize / 6.0);

// Generate a 1D Gaussian kernel
const gaussian = ksize => _utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.gaussianKernel(ksize2sigma(ksize), ksize);

// Generate a 1D Box filter
const box = ksize => (new Array(ksize)).fill(1.0 / ksize);



/**
 * SpeedyProgramGroupFilters
 * Image filtering
 */
class SpeedyProgramGroupFilters extends _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__.SpeedyProgramGroup
{
    /**
     * Class constructor
     * @param {SpeedyGPU} gpu
     */
    constructor(gpu)
    {
        super(gpu);
        this
            // convert to greyscale
            .declare('rgb2grey', rgb2grey)

            // median filters
            .declare('median3', median[3]) // 3x3 window
            .declare('median5', median[5]) // 5x5 window
            .declare('median7', median[7]) // 7x7 window

            // 2D convolution
            .declare('convolution3', convolution[3]) // 3x3 kernel
            .declare('convolution5', convolution[5]) // 5x5 kernel
            .declare('convolution7', convolution[7]) // 7x7 kernel

            // 1D separable convolution
            .declare('convolution3x', convolutionX[3]) // 1x3 kernel
            .declare('convolution3y', convolutionY[3]) // 3x1 kernel
            .declare('convolution5x', convolutionX[5]) // 1x5 kernel
            .declare('convolution5y', convolutionY[5]) // 5x1 kernel
            .declare('convolution7x', convolutionX[7])
            .declare('convolution7y', convolutionY[7])
            .declare('convolution9x', convolutionX[9])
            .declare('convolution9y', convolutionY[9])
            .declare('convolution11x', convolutionX[11])
            .declare('convolution11y', convolutionY[11])
            .declare('convolution13x', convolutionX[13])
            .declare('convolution13y', convolutionY[13])
            .declare('convolution15x', convolutionX[15])
            .declare('convolution15y', convolutionY[15])

            // normalize image
            .declare('normalizeGreyscale', normalizeGreyscale)
            .declare('normalizeColored', normalizeColored)

            // nightvision
            .declare('nightvision', nightvision)
            .declare('nightvisionGreyscale', nightvisionGreyscale)
            .declare('illuminationMapLoX', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(_utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.gaussianKernel(80, 31)))
            .declare('illuminationMapLoY', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(_utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.gaussianKernel(80, 31)))
            .declare('illuminationMapX', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(_utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.gaussianKernel(80, 63)))
            .declare('illuminationMapY', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(_utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.gaussianKernel(80, 63)))
            .declare('illuminationMapHiX', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(_utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.gaussianKernel(80, 255)))
            .declare('illuminationMapHiY', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(_utils_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.gaussianKernel(80, 255)))

            // gaussian: separable kernels
            // see also: http://dev.theomader.com/gaussian-kernel-calculator/
            .declare('gaussian3x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)([ 0.25, 0.5, 0.25 ])) // sigma ~ 1.0
            .declare('gaussian3y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)([ 0.25, 0.5, 0.25 ]))
            .declare('gaussian5x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)([ 0.05, 0.25, 0.4, 0.25, 0.05 ])) // sigma ~ 1.0
            .declare('gaussian5y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)([ 0.05, 0.25, 0.4, 0.25, 0.05 ]))
            .declare('gaussian7x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(gaussian(7)))
            .declare('gaussian7y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(gaussian(7)))
            .declare('gaussian9x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(gaussian(9)))
            .declare('gaussian9y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(gaussian(9)))
            .declare('gaussian11x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(gaussian(11)))
            .declare('gaussian11y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(gaussian(11)))

            // box filter: separable kernels
            .declare('box3x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(box(3)))
            .declare('box3y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(box(3)))
            .declare('box5x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(box(5)))
            .declare('box5y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(box(5)))
            .declare('box7x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(box(7)))
            .declare('box7y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(box(7)))
            .declare('box9x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(box(9)))
            .declare('box9y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(box(9)))
            .declare('box11x', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convX)(box(11)))
            .declare('box11y', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_3__.convY)(box(11)))
        ;
    }
}


/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/programs/keypoints.js":
/*!******************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/programs/keypoints.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgramGroupKeypoints: () => (/* binding */ SpeedyProgramGroupKeypoints)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../speedy-program-group */ "./node_modules/speedy-vision/src/gpu/speedy-program-group.js");
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _speedy_lsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../speedy-lsh */ "./node_modules/speedy-vision/src/gpu/speedy-lsh.js");
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * keypoints.js
 * Facade for various keypoint detection algorithms
 */








// FAST corner detector
const fast9_16 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/fast.glsl', 'keypoints/fast.vs.glsl')
                .withDefines({ 'FAST_TYPE': 916 })
                .withArguments('corners', 'pyramid', 'lod', 'threshold');

// Harris corner detector
const harris = [1, 3, 5, 7].reduce((obj, win) => ((obj[win] =
                   (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/harris.glsl')
                  .withDefines({ 'WINDOW_SIZE': win })
                  .withArguments('corners', 'pyramid', 'derivatives', 'lod', 'lodStep', 'gaussian')
               ), obj), {});

const harrisScoreFindMax = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/score-findmax.glsl')
                          .withArguments('corners', 'iterationNumber');

const harrisScoreCutoff = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/harris-cutoff.glsl')
                         .withArguments('corners', 'maxScore', 'quality');

// Subpixel refinement
const subpixelQuadratic1d = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/subpixel-refinement.glsl')
                           .withDefines({ 'METHOD': 0 })
                           .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');

const subpixelTaylor2d = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/subpixel-refinement.glsl')
                        .withDefines({ 'METHOD': 1 })
                        .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');

const subpixelBilinear = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/subpixel-refinement.glsl')
                        .withDefines({ 'METHOD': 2 })
                        .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');

const subpixelBicubic = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/subpixel-refinement.glsl')
                       .withDefines({ 'METHOD': 3 })
                       .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');

// Scale refinement
const refineScaleLoG = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/refine-scale.glsl')
                      .withDefines({ 'METHOD': 0 })
                      .withArguments('pyramid', 'lodStep', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

const refineScaleFAST916 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/refine-scale.glsl')
                          .withDefines({ 'METHOD': 1 })
                          .withArguments('pyramid', 'lodStep', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');

// Pixel allocation
const allocateDescriptors = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/allocate-descriptors.glsl')
                            .withArguments('inputEncodedKeypoints', 'inputDescriptorSize', 'inputExtraSize', 'inputEncoderLength', 'outputDescriptorSize', 'outputExtraSize', 'outputEncoderLength');

const allocateExtra = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/allocate-extra.glsl')
                     .withArguments('inputEncodedKeypoints', 'inputDescriptorSize', 'inputExtraSize', 'inputEncoderLength', 'outputDescriptorSize', 'outputExtraSize', 'outputEncoderLength');

const transferToExtra = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/transfer-to-extra.glsl')
                        .withArguments('encodedData', 'strideOfEncodedData', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

// ORB descriptors
const orbDescriptor = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/orb-descriptor.glsl')
                     .withArguments('image', 'encodedCorners', 'extraSize', 'encoderLength');

const orbOrientation = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/orb-orientation.glsl')
                      .withArguments('image', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

// Non-maximum suppression
const nonMaxSuppression = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/nonmax-suppression.glsl')
                         .withDefines({ 'MULTISCALE': 0 })
                         .withArguments('image', 'lodStep');

const multiscaleNonMaxSuppression = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/nonmax-suppression.glsl')
                                   .withDefines({ 'MULTISCALE': 1 })
                                   .withArguments('image', 'lodStep');

const nonmaxSpace = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/nonmax-space.glsl')
                    .withArguments('corners');

const nonmaxScale = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/nonmax-scale.glsl')
                    .withDefines({ 'USE_LAPLACIAN': 1 })
                    .withArguments('corners', 'pyramid', 'pyrLaplacian', 'lodStep');

const nonmaxScaleSimple = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/nonmax-scale.glsl')
                         .withDefines({ 'USE_LAPLACIAN': 0 })
                         .withArguments('corners', 'pyramid', 'lodStep');

const laplacian = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/laplacian.glsl')
                 .withArguments('corners', 'pyramid', 'lodStep', 'lodOffset');

// Keypoint tracking & optical-flow
const lk = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21].reduce((obj, win) => ((obj[win] =
               (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/lk.glsl')
               .withDefines({ 'WINDOW_SIZE': win })
               .withArguments('encodedFlow', 'prevKeypoints', 'nextPyramid', 'prevPyramid', 'level', 'depth', 'numberOfIterations', 'discardThreshold', 'epsilon', 'descriptorSize', 'extraSize', 'encoderLength')
           ), obj), {});

const transferFlow = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/transfer-flow.glsl')
                     .withArguments('encodedFlow', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

// Brute-force matching
const bfMatcherInitCandidates = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/knn-init.glsl')
                               .withDefines({ 'ENCODE_FILTERS': 0 });

const bfMatcherInitFilters = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/knn-init.glsl')
                            .withDefines({ 'ENCODE_FILTERS': 1 });

const bfMatcherTransfer = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/knn-transfer.glsl')
                         .withArguments('encodedMatches', 'encodedKthMatches', 'numberOfMatchesPerKeypoint', 'kthMatch');

const bfMatcher32 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/bf-knn.glsl')
                    .withDefines({
                        'DESCRIPTOR_SIZE': 32,
                        'NUMBER_OF_KEYPOINTS_PER_PASS': 16,
                    })
                    .withArguments('encodedMatches', 'encodedFilters', 'matcherLength', 'dbEncodedKeypoints', 'dbDescriptorSize', 'dbExtraSize', 'dbEncoderLength', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'passId');

const bfMatcher64 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/bf-knn.glsl')
                    .withDefines({
                        'DESCRIPTOR_SIZE': 64,
                        'NUMBER_OF_KEYPOINTS_PER_PASS': 8,
                    })
                    .withArguments('encodedMatches', 'encodedFilters', 'matcherLength', 'dbEncodedKeypoints', 'dbDescriptorSize', 'dbExtraSize', 'dbEncoderLength', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'passId');

// LSH-based KNN matching
const lshKnnInitCandidates = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/knn-init.glsl')
                            .withDefines({ 'ENCODE_FILTERS': 0 });

const lshKnnInitFilters = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/knn-init.glsl')
                         .withDefines({ 'ENCODE_FILTERS': 1 });

const lshKnn = _speedy_lsh__WEBPACK_IMPORTED_MODULE_3__.LSH_ACCEPTABLE_DESCRIPTOR_SIZES.reduce((obj, descriptorSize) => ((obj[descriptorSize] = _speedy_lsh__WEBPACK_IMPORTED_MODULE_3__.LSH_ACCEPTABLE_HASH_SIZES.reduce((obj, hashSize) => ((obj[hashSize] = [0, 1, 2].reduce((obj, level) => ((obj[level] =
                  (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/lsh-knn.glsl')
                  .withDefines({
                      'DESCRIPTOR_SIZE': descriptorSize,
                      'HASH_SIZE': hashSize,
                      'LEVEL': level,
                      'SEQUENCE_MAXLEN': _speedy_lsh__WEBPACK_IMPORTED_MODULE_3__.LSH_SEQUENCE_MAXLEN,
                      'SEQUENCE_COUNT': _speedy_lsh__WEBPACK_IMPORTED_MODULE_3__.LSH_SEQUENCE_COUNT,
                  })
                  .withArguments('candidates', 'filters', 'matcherLength', 'tables', 'descriptorDB', 'tableIndex', 'bucketCapacity', 'bucketsPerTable', 'tablesStride', 'descriptorDBStride', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength')
              ), obj), {})), obj), {})), obj), {});

const lshKnnTransfer = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/knn-transfer.glsl')
                       .withArguments('encodedMatches', 'encodedKthMatches', 'numberOfMatchesPerKeypoint', 'kthMatch');

// Keypoint sorting
const sortCreatePermutation = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/sort-keypoints.glsl')
                             .withDefines({ 'STAGE': 1 })
                             .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

const sortMergePermutation = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/sort-keypoints.glsl')
                            .withDefines({ 'STAGE': 2 })
                            .withArguments('permutation', 'blockSize', 'dblLog2BlockSize');

const sortApplyPermutation = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/sort-keypoints.glsl')
                            .withDefines({ 'STAGE': 3 })
                            .withArguments('permutation', 'maxKeypoints', 'encodedKeypoints', 'descriptorSize', 'extraSize');

// Keypoint mixing
const mixKeypointsPreInit = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/mix-keypoints.glsl')
                           .withDefines({ 'STAGE': 1 })
                           .withArguments('encodedKeypointsA', 'encodedKeypointsB', 'encoderLengthA', 'encoderLengthB', 'encoderCapacityA', 'encoderCapacityB', 'descriptorSize', 'extraSize', 'encoderLength');

const mixKeypointsInit = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/mix-keypoints.glsl')
                        .withDefines({ 'STAGE': 2 })
                        .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxKeypoints');

const mixKeypointsSort = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/mix-keypoints.glsl')
                        .withDefines({ 'STAGE': 3 })
                        .withArguments('array', 'blockSize');

const mixKeypointsView = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/mix-keypoints.glsl')
                        .withDefines({ 'STAGE': 5 })
                        .withArguments('array');

const mixKeypointsApply = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/mix-keypoints.glsl')
                         .withDefines({ 'STAGE': 4 })
                         .withArguments('array', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

// Keypoint encoding
const initLookupTable = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/lookup-of-locations.glsl')
                       .withDefines({ 'FS_OUTPUT_TYPE': 2, 'STAGE': 1 })
                       .withArguments('corners');

const sortLookupTable = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/lookup-of-locations.glsl', 'keypoints/lookup-of-locations.vs.glsl')
                       .withDefines({ 'FS_OUTPUT_TYPE': 2, 'FS_USE_CUSTOM_PRECISION': 1, 'STAGE': 2 })
                       .withArguments('lookupTable', 'blockSize', 'width', 'height');

const viewLookupTable = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/lookup-of-locations.glsl')
                       .withDefines({ 'STAGE': -1 })
                       .withArguments('lookupTable');

const encodeKeypoints = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/encode-keypoints.glsl')
                       .withArguments('corners', 'lookupTable', 'stride', 'descriptorSize', 'extraSize', 'encoderLength', 'encoderCapacity');

const encodeKeypointSkipOffsets = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/encode-keypoint-offsets.glsl')
                                 .withArguments('corners', 'imageSize');

const encodeKeypointLongSkipOffsets = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/encode-keypoint-long-offsets.glsl')
                                     .withDefines({ 'MAX_ITERATIONS': 6 }) // dependent texture reads :(
                                     .withArguments('offsetsImage', 'imageSize');

const encodeKeypointPositions = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/encode-keypoint-positions.glsl')
                               .withArguments('offsetsImage', 'imageSize', 'passId', 'numPasses', 'keypointLimit', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

const encodeKeypointProperties = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/encode-keypoint-properties.glsl')
                                .withArguments('corners', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

const encodeNullKeypoints = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/encode-null-keypoints.glsl')
                           .withArguments();

const transferOrientation = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/transfer-orientation.glsl')
                           .withArguments('encodedOrientations', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

const uploadKeypoints = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/upload-keypoints.glsl')
                       .withDefines({
                            // UBOs can hold at least 16KB of data;
                            // gl.MAX_UNIFORM_BLOCK_SIZE >= 16384
                            // according to the GL ES 3 reference.
                            // Each keypoint uses 16 bytes (vec4)
                           'BUFFER_SIZE': 1024 //16384 / 16
                        })
                       .withArguments('encodedKeypoints', 'startIndex', 'endIndex', 'descriptorSize', 'extraSize', 'encoderLength');

// Geometric transformations
const applyHomography = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/apply-homography.glsl')
                        .withArguments('homography', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

// Keypoint filters
const clipBorder = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/clip-border.glsl')
                  .withArguments('imageWidth', 'imageHeight', 'borderTop', 'borderRight', 'borderBottom', 'borderLeft', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

const distanceFilter = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/distance-filter.glsl')
                      .withArguments('encodedKeypointsA', 'encoderLengthA', 'encodedKeypointsB', 'encoderLengthB', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');

const hammingDistanceFilter32 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/hamming-distance-filter.glsl')
                               .withDefines({ 'DESCRIPTOR_SIZE': 32 })
                               .withArguments('encodedKeypointsA', 'encoderLengthA', 'encodedKeypointsB', 'encoderLengthB', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');

const hammingDistanceFilter64 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/hamming-distance-filter.glsl')
                               .withDefines({ 'DESCRIPTOR_SIZE': 64 })
                               .withArguments('encodedKeypointsA', 'encoderLengthA', 'encodedKeypointsB', 'encoderLengthB', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');

// Other utilities
const shuffle = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/shuffle.glsl')
               .withDefines({ 'PERMUTATION_MAXLEN': 2048 })
               .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');

const clip = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_4__.importShader)('keypoints/clip.glsl')
            .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxKeypoints');

/**
 * SpeedyProgramGroupKeypoints
 * Keypoint detection
 */
class SpeedyProgramGroupKeypoints extends _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__.SpeedyProgramGroup
{
    /**
     * Class constructor
     * @param {SpeedyGPU} gpu
     */
    constructor(gpu)
    {
        super(gpu);
        this
            //
            // FAST corner detector
            //
            .declare('fast9_16', fast9_16, {
                ...this.program.usesPingpongRendering()
            })

            //
            // Harris corner detector
            //
            .declare('harris1', harris[1], {
                ...this.program.usesPingpongRendering()
            })
            .declare('harris3', harris[3], {
                ...this.program.usesPingpongRendering()
            })
            .declare('harris5', harris[5], {
                ...this.program.usesPingpongRendering()
            })
            .declare('harris7', harris[7], {
                ...this.program.usesPingpongRendering()
            })
            .declare('harrisScoreFindMax', harrisScoreFindMax, {
                ...this.program.usesPingpongRendering()
            })
            .declare('harrisScoreCutoff', harrisScoreCutoff)

            //
            // Subpixel refinement
            //
            .declare('subpixelQuadratic1d', subpixelQuadratic1d)
            .declare('subpixelTaylor2d', subpixelTaylor2d)
            .declare('subpixelBicubic', subpixelBicubic)
            .declare('subpixelBilinear', subpixelBilinear)

            //
            // Scale refinement
            //
            .declare('refineScaleLoG', refineScaleLoG)
            .declare('refineScaleFAST916', refineScaleFAST916)

            //
            // Pixel allocation
            //
            .declare('allocateDescriptors', allocateDescriptors)
            .declare('allocateExtra', allocateExtra)
            .declare('transferToExtra', transferToExtra)

            //
            // ORB descriptors
            //
            .declare('orbDescriptor', orbDescriptor)
            .declare('orbOrientation', orbOrientation)

            //
            // Non-maximum suppression
            //
            .declare('nonmax', nonMaxSuppression)
            .declare('pyrnonmax', multiscaleNonMaxSuppression)
            .declare('nonmaxSpace', nonmaxSpace)
            .declare('nonmaxScale', nonmaxScale)
            .declare('nonmaxScaleSimple', nonmaxScaleSimple)
            .declare('laplacian', laplacian)

            //
            // LK optical-flow
            //
            .declare('lk21', lk[21], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk19', lk[19], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk17', lk[17], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk15', lk[15], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk13', lk[13], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk11', lk[11], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk9', lk[9], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk7', lk[7], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk5', lk[5], {
                ...this.program.usesPingpongRendering()
            })
            .declare('lk3', lk[3], {
                ...this.program.usesPingpongRendering()
            })
            .declare('transferFlow', transferFlow)

            //
            // Brute-force KNN matching
            //
            .declare('bfMatcherInitCandidates', bfMatcherInitCandidates)
            .declare('bfMatcherInitFilters', bfMatcherInitFilters)
            .declare('bfMatcherTransfer', bfMatcherTransfer, {
                ...this.program.usesPingpongRendering()
            })
            .declare('bfMatcher32', bfMatcher32, {
                ...this.program.usesPingpongRendering()
            })
            .declare('bfMatcher64', bfMatcher64, {
                ...this.program.usesPingpongRendering()
            })

            //
            // LSH-based KNN matching
            //
            .declare('lshKnnInitCandidates', lshKnnInitCandidates)
            .declare('lshKnnInitFilters', lshKnnInitFilters)
            .declare('lshKnnTransfer', lshKnnTransfer, {
                ...this.program.usesPingpongRendering()
            })

            //
            // Keypoint sorting
            //
            .declare('sortCreatePermutation', sortCreatePermutation)
            .declare('sortMergePermutation', sortMergePermutation, {
                ...this.program.usesPingpongRendering()
            })
            .declare('sortApplyPermutation', sortApplyPermutation)

            //
            // Keypoint mixing
            //
            .declare('mixKeypointsPreInit', mixKeypointsPreInit)
            .declare('mixKeypointsInit', mixKeypointsInit)
            .declare('mixKeypointsSort', mixKeypointsSort, {
                ...this.program.usesPingpongRendering()
            })
            .declare('mixKeypointsView', mixKeypointsView)
            .declare('mixKeypointsApply', mixKeypointsApply)

            //
            // Keypoint encoders
            //
            .declare('encodeNullKeypoints', encodeNullKeypoints)
            .declare('encodeKeypoints', encodeKeypoints)
            .declare('initLookupTable', initLookupTable)
            .declare('sortLookupTable', sortLookupTable, {
                ...this.program.usesPingpongRendering()
            })
            .declare('viewLookupTable', viewLookupTable)


            .declare('encodeKeypointSkipOffsets', encodeKeypointSkipOffsets)
            .declare('encodeKeypointLongSkipOffsets', encodeKeypointLongSkipOffsets, {
                ...this.program.usesPingpongRendering()
            })
            .declare('encodeKeypointPositions', encodeKeypointPositions, {
                ...this.program.usesPingpongRendering()
            })
            .declare('encodeKeypointProperties', encodeKeypointProperties)



            .declare('transferOrientation', transferOrientation)
            .declare('uploadKeypoints', uploadKeypoints, {
                ...this.program.usesPingpongRendering()
            })

            //
            // Geometric transformations
            //
            .declare('applyHomography', applyHomography)

            //
            // Keypoint filters
            //
            .declare('clipBorder', clipBorder)
            .declare('distanceFilter', distanceFilter)
            .declare('hammingDistanceFilter32', hammingDistanceFilter32)
            .declare('hammingDistanceFilter64', hammingDistanceFilter64)

            //
            // Other utilities
            //
            .declare('shuffle', shuffle)
            .declare('clip', clip)
        ;

        //
        // LSH-based KNN matching
        //
        for(const descriptorSize of Object.keys(lshKnn)) {
            for(const hashSize of Object.keys(lshKnn[descriptorSize])) {
                for(const level of Object.keys(lshKnn[descriptorSize][hashSize])) {
                    const name = `lshKnn${descriptorSize}h${hashSize}lv${level}`;
                    this.declare(name, lshKnn[descriptorSize][hashSize][level], {
                        ...this.program.usesPingpongRendering()
                    });
                }
            }
        }
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/programs/pyramids.js":
/*!*****************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/programs/pyramids.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgramGroupPyramids: () => (/* binding */ SpeedyProgramGroupPyramids)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../speedy-program-group */ "./node_modules/speedy-vision/src/gpu/speedy-program-group.js");
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/* harmony import */ var _shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/filters/convolution */ "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * pyramids.js
 * Image pyramids
 */









//
// Shaders
//

const upsample2 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('pyramids/upsample2.glsl').withArguments('image');
const downsample2 = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('pyramids/downsample2.glsl').withArguments('image');


/**
 * SpeedyProgramGroupPyramids
 * Image pyramids
 */
class SpeedyProgramGroupPyramids extends _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__.SpeedyProgramGroup
{
    /**
     * Class constructor
     * @param {SpeedyGPU} gpu
     */
    constructor(gpu)
    {
        super(gpu);
        this
            // upsampling & downsampling
            .declare('upsample2', upsample2)
            .declare('downsample2', downsample2)

            // separable kernels for gaussian smoothing
            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1
            // pick a = 0.4 for gaussian approximation (sigma = 1)
            .declare('smoothX', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_4__.convX)([
                0.05, 0.25, 0.4, 0.25, 0.05
            ]))
            .declare('smoothY', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_4__.convY)([
                0.05, 0.25, 0.4, 0.25, 0.05
            ]))
            /*
            .declare('reduce', conv2D([
                0.00250, 0.01250, 0.02000, 0.01250, 0.00250,
                0.01250, 0.06250, 0.10000, 0.06250, 0.01250,
                0.02000, 0.10000, 0.16000, 0.10000, 0.02000,
                0.01250, 0.06250, 0.10000, 0.06250, 0.01250,
                0.00250, 0.01250, 0.02000, 0.01250, 0.00250
            ]))
            */

            // smoothing for 2x image
            // same rules as above with sum(k) = 2
            .declare('smoothX2', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_4__.convX)([
                0.1, 0.5, 0.8, 0.5, 0.1
                // NOTE: this would saturate the image, but we apply it
                // on a 2x upsampled version with lots of zero pixels
            ]))
            .declare('smoothY2', (0,_shaders_filters_convolution__WEBPACK_IMPORTED_MODULE_4__.convY)([
                0.1, 0.5, 0.8, 0.5, 0.1
            ], 1.0 / 2.0))
        ;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/programs/transforms.js":
/*!*******************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/programs/transforms.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgramGroupTransforms: () => (/* binding */ SpeedyProgramGroupTransforms)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../speedy-program-group */ "./node_modules/speedy-vision/src/gpu/speedy-program-group.js");
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * transforms.js
 * Geometric transformations
 */








//
// Shaders
//

// Perspective warp
const warpPerspective = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('transforms/warp-perspective.glsl')
                        .withArguments('image', 'inverseHomography');

// Resize image
const resizeNearest = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('transforms/resize.glsl')
                     .withDefines({
                         'INTERPOLATION_METHOD': 0 // Nearest neighbors
                     })
                     .withArguments('image');

const resizeBilinear = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('transforms/resize.glsl')
                      .withDefines({
                          'INTERPOLATION_METHOD': 1 // Bilinear interpolation
                      })
                      .withArguments('image');

// Additive mix (TODO create a new program group?)
const additiveMix = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_2__.importShader)('transforms/additive-mix.glsl')
                    .withArguments('image0', 'image1', 'alpha', 'beta', 'gamma');

/**
 * SpeedyProgramGroupTransforms
 * Geometric transformations
 */
class SpeedyProgramGroupTransforms extends _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__.SpeedyProgramGroup
{
    /**
     * Class constructor
     * @param {SpeedyGPU} gpu
     */
    constructor(gpu)
    {
        super(gpu);
        this
            .declare('warpPerspective', warpPerspective)
            .declare('resizeNearest', resizeNearest)
            .declare('resizeBilinear', resizeBilinear)
            .declare('additiveMix', additiveMix)
        ;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/programs/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/programs/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgramGroupUtils: () => (/* binding */ SpeedyProgramGroupUtils)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../speedy-program-group */ "./node_modules/speedy-vision/src/gpu/speedy-program-group.js");
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * utils.js
 * GPU utilities
 */









//
// Shaders
//

// Copy image
const copy = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/copy.glsl').withArguments('image');

// Copy keypoints
const copyKeypoints = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/copy-raster.glsl').withDefines({ 'TYPE': 1 }).withArguments('image');

// Copy 2D vectors
const copy2DVectors = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/copy-raster.glsl').withDefines({ 'TYPE': 2 }).withArguments('image');

// Flip y-axis for output
const flipY = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/copy.glsl', 'utils/flip-y.vs.glsl').withArguments('image');

// Fill image with a constant
const fill = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/fill.glsl').withArguments('value');

// Fill zero or more color components of the input image with a constant value
const fillComponents = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/fill-components.glsl').withArguments('image', 'pixelComponents', 'value');

// Copy the src component of src to zero or more color components of a copy of dest
const copyComponents = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/copy-components.glsl').withArguments('dest', 'src', 'destComponents', 'srcComponentId');

// Scan the entire image and find the minimum & maximum pixel intensity
const scanMinMax2D = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/scan-minmax2d.glsl').withArguments('image', 'iterationNumber');

// Compute the partial derivatives of an image
const sobelDerivatives = (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_3__.importShader)('utils/sobel-derivatives.glsl', 'utils/sobel-derivatives.vs.glsl').withArguments('pyramid', 'lod');




/**
 * SpeedyProgramGroupUtils
 * Utility operations
 */
class SpeedyProgramGroupUtils extends _speedy_program_group__WEBPACK_IMPORTED_MODULE_1__.SpeedyProgramGroup
{
    /**
     * Class constructor
     * @param {SpeedyGPU} gpu
     */
    constructor(gpu)
    {
        super(gpu);
        this
            // render to the canvas
            .declare('renderToCanvas', flipY, {
                ...this.program.rendersToCanvas()
            })

            // copy image
            .declare('copy', copy)

            // copy keypoints
            .declare('copyKeypoints', copyKeypoints)

            // copy 2D vectors
            .declare('copy2DVectors', copy2DVectors)

            // Fill image with a constant
            .declare('fill', fill)

            // Fill zero or more color components of the input image with a constant value
            .declare('fillComponents', fillComponents)

            // Copy the src component of src to zero or more color components of a copy of dest
            .declare('copyComponents', copyComponents)

            // find minimum & maximum pixel intensity
            .declare('scanMinMax2D', scanMinMax2D, {
                ...this.program.usesPingpongRendering()
            })

            // Compute the partial derivatives of an image
            .declare('sobelDerivatives', sobelDerivatives)
        ;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shader-declaration.js":
/*!******************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shader-declaration.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShaderDeclaration: () => (/* binding */ ShaderDeclaration),
/* harmony export */   createShader: () => (/* binding */ createShader),
/* harmony export */   importShader: () => (/* binding */ importShader)
/* harmony export */ });
/* harmony import */ var _shader_preprocessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader-preprocessor */ "./node_modules/speedy-vision/src/gpu/shader-preprocessor.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * shader-declaration.js
 * Encapsulates a shader declaration
 */




const DEFAULT_ATTRIBUTES = Object.freeze({
    position: 'a_position',
    texCoord: 'a_texCoord'
});

const DEFAULT_ATTRIBUTES_LOCATION = Object.freeze({
    position: 0, // use location 0; see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
    texCoord: 1,
});

const DEFAULT_VERTEX_SHADER_PREFIX = `#version 300 es
precision highp float;
precision highp int;

layout (location=${DEFAULT_ATTRIBUTES_LOCATION.position}) in vec2 ${DEFAULT_ATTRIBUTES.position};
layout (location=${DEFAULT_ATTRIBUTES_LOCATION.texCoord}) in vec2 ${DEFAULT_ATTRIBUTES.texCoord};
out highp vec2 texCoord;
uniform highp vec2 texSize;

#define vsinit() \
gl_Position = vec4(${DEFAULT_ATTRIBUTES.position}, 0.0f, 1.0f); \
texCoord = ${DEFAULT_ATTRIBUTES.texCoord};
\n\n`;

const DEFAULT_VERTEX_SHADER = `#define vsmain() ;`;

const DEFAULT_VERTEX_SHADER_SUFFIX = `\n\nvoid main() { vsinit(); vsmain(); }\n`;

const DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es

#if @FS_USE_CUSTOM_PRECISION@ == 0
precision mediump float; // ~float16
precision mediump sampler2D;
precision highp int; // int32
#endif

#if @FS_OUTPUT_TYPE@ == 0
#define OUT_TYPE mediump vec4
#elif @FS_OUTPUT_TYPE@ == 1
#define OUT_TYPE mediump ivec4
#elif @FS_OUTPUT_TYPE@ == 2
#define OUT_TYPE mediump uvec4
#else
#error Unknown FS_OUTPUT_TYPE
#endif

out OUT_TYPE color;
in highp vec2 texCoord;
uniform highp vec2 texSize;

@include "global.glsl"\n\n`;

const PRIVATE_TOKEN = Symbol();

/**
 * @typedef {object} ShaderDeclarationFilepathOptions
 * @property {"filepath"} type
 * @property {string} filepath
 * @property {string} [vsfilepath]
 *
 * @typedef {object} ShaderDeclarationSourceOptions
 * @property {"source"} type
 * @property {string} source
 * @property {string} [vssource]
 *
 * @typedef {ShaderDeclarationFilepathOptions | ShaderDeclarationSourceOptions} ShaderDeclarationOptions
 */

/** @typedef {import('./shader-preprocessor').ShaderDefines} ShaderDefines */

/**
 * Shader Declaration
 */
class ShaderDeclaration
{
    /**
     * @private Constructor
     * @param {ShaderDeclarationOptions} options
     * @param {Symbol} privateToken
     */
    constructor(options, privateToken)
    {
        if(privateToken !== PRIVATE_TOKEN)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalOperationError(); // private constructor!

        /** @type {string} original source code provided by the user (fragment shader) */
        this._source = (() => {
            switch(options.type) {
                case 'filepath': return __webpack_require__("./node_modules/speedy-vision/src/gpu/shaders sync recursive ^\\.\\/.*$")("./" + options.filepath);
                case 'source':   return options.source;
                default:         return /** @type {never} */ ( '' );
             }
        })();

        /** @type {string} vertex shader source code (without preprocessing) */
        this._vssource = (() => {
            switch(options.type) {
                case 'filepath': return options.vsfilepath ? __webpack_require__("./node_modules/speedy-vision/src/gpu/shaders sync recursive ^\\.\\/.*$")("./" + options.vsfilepath) : DEFAULT_VERTEX_SHADER;
                case 'source':   return options.vssource ? options.vssource : DEFAULT_VERTEX_SHADER;
                default:         return /** @type {never} */ ( '' );
             }
        })();

        /** @type {string} preprocessed source code of the fragment shader */
        this._fragmentSource = _shader_preprocessor__WEBPACK_IMPORTED_MODULE_0__.ShaderPreprocessor.run(DEFAULT_FRAGMENT_SHADER_PREFIX + this._source);

        /** @type {string} preprocessed source code of the vertex shader */
        this._vertexSource = _shader_preprocessor__WEBPACK_IMPORTED_MODULE_0__.ShaderPreprocessor.run(DEFAULT_VERTEX_SHADER_PREFIX + this._vssource + DEFAULT_VERTEX_SHADER_SUFFIX);

        /** @type {string} filepath of the fragment shader */
        this._filepath = options.type === 'filepath' ? options.filepath : '<in-memory>';

        /** @type {string} filepath of the vertex shader */
        this._vsfilepath = options.type === 'filepath' && options.vsfilepath ? options.vsfilepath : '<in-memory>';

        /** @type {string[]} an ordered list of uniform names */
        this._arguments = [];

        /** @type {Map<string,string>} it maps uniform names to their types */
        this._uniforms = this._autodetectUniforms(this._fragmentSource + '\n' + this._vertexSource);

        /** @type {ShaderDefines} it maps externally #defined constants to their values */
        this._defines = new Map();
    }

    /**
     * Creates a new Shader directly from a GLSL source
     * @param {string} source fragment shader
     * @param {string|null} [vssource] vertex shader
     * @returns {ShaderDeclaration}
     */
    static create(source, vssource = null)
    {
        return new ShaderDeclaration({ type: 'source', source, vssource }, PRIVATE_TOKEN);
    }

    /**
     * Import a Shader from a file containing a GLSL source
     * @param {string} filepath path to .glsl file relative to the shaders/ folder
     * @param {string} [vsfilepath] path to a .vs.glsl file relative to the shaders/ folder
     * @returns {ShaderDeclaration}
     */
    static import(filepath, vsfilepath = null)
    {
        if(!String(filepath).match(/^[a-zA-Z0-9_\-/]+\.glsl$/))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.FileNotFoundError(`Can't import fragment shader at "${filepath}"`);
        else if(vsfilepath != null && !String(vsfilepath).match(/^[a-zA-Z0-9_\-/]+\.vs\.glsl$/))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.FileNotFoundError(`Can't import vertex shader at "${vsfilepath}"`);

        return new ShaderDeclaration({ type: 'filepath', filepath, vsfilepath }, PRIVATE_TOKEN);
    }

    /**
     * Specify the list & order of arguments to be
     * passed to the shader
     * @param  {...string} args argument names
     * @returns {this}
     */
    withArguments(...args)
    {
        // the list of arguments may be declared only once
        if(this._arguments.length > 0)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalOperationError(`Redefinition of shader arguments`);

        // get arguments
        this._arguments = args.map(arg => String(arg));

        // validate
        for(const argname of this._arguments) {
            if(!this._uniforms.has(argname)) {
                if(!this._uniforms.has(argname + '[0]'))
                    throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Argument "${argname}" has not been declared in the shader`);
            }
        }

        // done!
        return this;
    }

    /**
     * Specify a set of #defines to be prepended to the fragment shader
     * @param {Object<string,number>} defines key-value pairs (define-name: define-value)
     * @returns {this}
     */
    withDefines(defines)
    {
        // the list of #defines may be defined only once
        if(this._defines.size > 0)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalOperationError(`Redefinition of externally defined constants of a shader`);

        // store and write the #defines
        const defs = [], keys = Object.keys(defines);
        for(const key of keys) {
            const value = Number(defines[key]); // force numeric values (just in case)
            this._defines.set(key, value);
            defs.push(`#define ${key} ${value}\n`);
        }

        // update the shaders & the uniforms
        const source = DEFAULT_FRAGMENT_SHADER_PREFIX + defs.join('') + this._source;
        const vssource = DEFAULT_VERTEX_SHADER_PREFIX + defs.join('') + this._vssource + DEFAULT_VERTEX_SHADER_SUFFIX;
        this._fragmentSource = _shader_preprocessor__WEBPACK_IMPORTED_MODULE_0__.ShaderPreprocessor.run(source, this._defines);
        this._vertexSource = _shader_preprocessor__WEBPACK_IMPORTED_MODULE_0__.ShaderPreprocessor.run(vssource, this._defines);
        this._uniforms = this._autodetectUniforms(this._fragmentSource + '\n' + this._vertexSource);

        // done!
        return this;
    }

    /**
     * Return the GLSL source of the fragment shader
     * @returns {string}
     */
    get fragmentSource()
    {
        return this._fragmentSource;
    }

    /**
     * Return the GLSL source of the vertex shader
     * @returns {string}
     */
    get vertexSource()
    {
        return this._vertexSource;
    }

    /**
     * Get the names of the vertex shader attributes
     * @returns {typeof DEFAULT_ATTRIBUTES}
     */
    get attributes()
    {
        return DEFAULT_ATTRIBUTES;
    }

    /**
     * Get the pre-defined locations of the vertex shader attributes
     * @returns {typeof DEFAULT_ATTRIBUTES_LOCATION}
     */
    get locationOfAttributes()
    {
        return DEFAULT_ATTRIBUTES_LOCATION;
    }

    /**
     * Names of the arguments that will be passed to the Shader,
     * corresponding to GLSL uniforms, in the order they will be passed
     * @returns {string[]}
     */
    get arguments()
    {
        return this._arguments;
    }

    /**
     * Names of the uniforms declared in the shader
     * @returns {string[]}
     */
    get uniforms()
    {
        return Array.from(this._uniforms.keys());
    }

    /**
     * The GLSL type of a uniform variable declared in the shader
     * @param {string} name
     * @returns {string}
     */
    uniformType(name)
    {
        if(!this._uniforms.has(name))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Unrecognized uniform variable: "${name}"`);

        return this._uniforms.get(name);
    }

    /**
     * The value of an externally defined constant, i.e., via withDefines()
     * @param {string} name 
     * @returns {number}
     */
    definedConstant(name)
    {
        if(!this._defines.has(name))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalArgumentError(`Unrecognized externally defined constant: "${name}"`);

        return this._defines.get(name);
    }

    /**
     * Parses a GLSL source and detects the uniform variables,
     * as well as their types
     * @param {string} preprocessedSource 
     * @returns {Map<string,string>} specifies the types of all uniforms
     */
    _autodetectUniforms(preprocessedSource)
    {
        const sourceWithoutComments = preprocessedSource; // assume we've preprocessed the source already
        const regex = /^\s*uniform\s+(highp\s+|mediump\s+|lowp\s+)?(\w+)\s+([^;]+)/gm;
        const uniforms = new Map();

        let match;
        while((match = regex.exec(sourceWithoutComments)) !== null) {
            const type = match[2];
            const names = match[3].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names

            for(const name of names) {
                if(name.endsWith(']')) {
                    // is it an array?
                    if(!(match = name.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))
                        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.ParseError(`Unspecified array length for uniform "${name}" in the shader`);

                    // read array name & size
                    const [ array, size ] = [ match[1], Number(match[2]) ];

                    // register uniforms
                    for(let i = 0; i < size; i++)
                        uniforms.set(`${array}[${i}]`, type);
                }
                else {
                    // register a regular uniform
                    if(!uniforms.has(name) || uniforms.get(name) === type)
                        uniforms.set(name, type);
                    else
                        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.IllegalOperationError(`Redefinition of uniform "${name}" in the shader`);
                }
            }
        }

        return uniforms;
    }
}

/**
 * Import a ShaderDeclaration from a GLSL file
 * @param {string} filepath relative to the shaders/ folder (a .glsl file)
 * @param {string|null} [vsfilepath] optional vertex shader (a .vs.glsl file)
 * @returns {ShaderDeclaration}
 */
function importShader(filepath, vsfilepath = null)
{
    return ShaderDeclaration.import(filepath, vsfilepath);
}

/**
 * Create a ShaderDeclaration from a GLSL source code
 * @param {string} source fragment shader
 * @param {string|null} [vssource] optional vertex shader
 * @returns {ShaderDeclaration}
 */
function createShader(source, vssource = null)
{
    return ShaderDeclaration.create(source, vssource);
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shader-preprocessor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shader-preprocessor.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShaderPreprocessor: () => (/* binding */ ShaderPreprocessor)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/types */ "./node_modules/speedy-vision/src/utils/types.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * shader-preprocessor.js
 * Custom preprocessor for shaders
 */





// Import numeric globals
const globals = __webpack_require__(/*! ../utils/globals */ "./node_modules/speedy-vision/src/utils/globals.js");
const numericGlobals = Object.keys(globals).filter(key => typeof globals[key] == 'number').reduce(
    (obj, key) => ((obj[key] = globals[key]), obj), {}
);

// Constants accessible by all shaders
const constants = Object.freeze({
    // numeric globals
    ...numericGlobals,

    // fragment shader
    'FS_USE_CUSTOM_PRECISION': 0, // use default precision settings
    'FS_OUTPUT_TYPE': 0, // normalized RGBA

    // colors
    'PIXELCOMPONENT_RED': _utils_types__WEBPACK_IMPORTED_MODULE_1__.PixelComponent.RED,
    'PIXELCOMPONENT_GREEN': _utils_types__WEBPACK_IMPORTED_MODULE_1__.PixelComponent.GREEN,
    'PIXELCOMPONENT_BLUE': _utils_types__WEBPACK_IMPORTED_MODULE_1__.PixelComponent.BLUE,
    'PIXELCOMPONENT_ALPHA': _utils_types__WEBPACK_IMPORTED_MODULE_1__.PixelComponent.ALPHA,
});

// Regular Expressions
const commentsRegex = [ /\/\*(.|\s)*?\*\//g , /\/\/.*$/gm ];
const includeRegex = /^\s*@\s*include\s+"(.*?)"/gm;
const constantRegex = /@(\w+)@/g;
const unrollRegex = [
    /@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+\+()\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,
    /@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+=\s*(-?\d+)\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,
];

/** @typedef {Map<string,number>} ShaderDefines */

/**
 * Custom preprocessor for the shaders
 */
class ShaderPreprocessor
{
    /**
     * Runs the preprocessor
     * @param {string} code 
     * @param {ShaderDefines} [defines]
     * @returns {string} preprocessed code
     */
    static run(code, defines = new Map())
    {
        const errors = []; // compile-time errors

        //
        // The preprocessor will remove comments from GLSL code,
        // include requested GLSL files and import global constants
        // defined for all shaders (see above)
        //
        return unrollLoops(
            String(code)
                .replace(commentsRegex[0], '')
                .replace(commentsRegex[1], '')
                .replace(includeRegex, (_, filename) =>
                    // FIXME: no cycle detection for @include
                    ShaderPreprocessor.run(readfileSync(filename), defines)
                )
                .replace(constantRegex, (_, name) => String(
                    // Find a defined constant. If not possible, find a global constant
                    defines.has(name) ? Number(defines.get(name)) : (
                        constants[name] !== undefined ? Number(constants[name]) : (
                            errors.push(`Undefined constant: ${name}`), 0
                        )
                    )
                )),
            defines
        ) + (errors.length > 0 ? errors.map(msg => `\n#error ${msg}\n`).join('') : '');
    }
}

 /**
 * Reads a shader from the shaders/include/ folder
 * @param {string} filename
 * @returns {string}
 */
function readfileSync(filename)
{
    if(String(filename).match(/^[a-zA-Z0-9_-]+\.glsl$/))
        return __webpack_require__("./node_modules/speedy-vision/src/gpu/shaders/include sync recursive ^\\.\\/.*$")("./" + filename);

    throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.FileNotFoundError(`Shader preprocessor: can't read file "${filename}"`);
}

/**
 * Unroll for loops in our own preprocessor
 * @param {string} code
 * @param {ShaderDefines} defines
 * @returns {string}
 */
function unrollLoops(code, defines)
{
    //
    // Currently, only integer for loops with positive step values
    // can be unrolled. (TODO: negative step values?)
    //
    // The current implementation does not support curly braces
    // inside unrolled loops. You may define macros to get around
    // this, but do you actually need to unroll such loops?
    //
    // Loops that don't fit the supported pattern will crash
    // the preprocessor if you try to unroll them.
    //
    const fn = unroll.bind(defines); // CRAZY!
    const n = unrollRegex.length;

    for(let i = 0; i < n; i++)
        code = code.replace(unrollRegex[i], fn);

    return code;
}

/**
 * Unroll a loop pattern (regexp)
 * @param {string} match the matched for loop
 * @param {string} type
 * @param {string} counter
 * @param {string} start
 * @param {string} cmp
 * @param {string} end
 * @param {string} step
 * @param {string} loopcode
 * @returns {string} unrolled loop
 */
function unroll(match, type, counter, start, cmp, end, step, loopcode)
{
    const defines = /** @type {ShaderDefines} */ ( this );

    // check if the loop limits are numeric constants or #defined numbers from the outside
    const hasStart = Number.isFinite(+start) || defines.has(start);
    const hasEnd = Number.isFinite(+end) || defines.has(end);
    if(!hasStart || !hasEnd) {
        if(defines.size > 0)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.ParseError(`Can't unroll loop: unknown limits (start=${start}, end=${end}). Code:\n\n${match}`);
        else
            return match; // don't unroll now, because defines is empty - maybe we'll succeed in the next pass
    }

    // parse and validate limits & step
    let istart = defines.has(start) ? defines.get(start) : parseInt(start);
    let iend = defines.has(end) ? defines.get(end) : parseInt(end);
    let istep = (step.length == 0) ? 1 : parseInt(step);
    _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(istart <= iend && istep > 0);

    /*
    // debug
    console.log(`Encontrei "${match}"`);
    console.log(`type="${type}"`);
    console.log(`counter="${counter}"`);
    console.log(`start="${start}"`);
    console.log(`cmp="${cmp}"`);
    console.log(`end="${end}"`);
    console.log(`step="${step}"`);
    console.log(`loopcode="${loopcode}"`)
    console.log('Defines:', defines);
    */

    // continue statements are not supported inside unrolled loops
    // and will generate a compiler error. Using break is ok.
    const hasBreak = (loopcode.match(/\bbreak\s*;/) !== null);

    // create a new scope
    let unrolledCode = hasBreak ? 'switch(1) { default:\n' : '{\n';

    // declare counter
    unrolledCode += `${type} ${counter};\n`;

    // unroll loop
    iend += (cmp == '<=') ? 1 : 0;
    for(let i = istart; i < iend; i += istep)
        unrolledCode += `{\n${counter} = ${i};\n${loopcode}\n}\n`;

    // close scope
    unrolledCode += '}\n';
    //console.log('Unrolled code:\n\n' + unrolledCode);

    // done!
    return unrolledCode;
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution.js":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/filters/convolution.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   conv2D: () => (/* binding */ conv2D),
/* harmony export */   convX: () => (/* binding */ convX),
/* harmony export */   convY: () => (/* binding */ convY)
/* harmony export */ });
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * convolution.js
 * Convolution shader generators
 */







/**
 * Generate a 2D convolution with a square kernel
 * @param {number[]} kernel convolution kernel
 * @param {number} [normalizationConstant] will be multiplied by all kernel entries
 */
function conv2D(kernel, normalizationConstant = 1.0)
{
    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));
    const kSize = Math.sqrt(kernel32.length) | 0;
    const N = kSize >> 1; // idiv 2

    // validate input
    if(kSize < 1 || kSize % 2 == 0)
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalArgumentError(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);
    else if(kSize * kSize != kernel32.length)
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalArgumentError(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);

    // select the appropriate pixel function
    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';

    // code generator
    const foreachKernelElement = fn => _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cartesian(_utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.symmetricRange(N), _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.symmetricRange(N)).map(
        cur => fn(
            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],
            cur[0], cur[1]
        )
    ).join('\n');

    const generateCode = (k, dy, dx) => `
        result += ${pixelAtOffset}(image, ivec2(${(-dx) | 0}, ${(-dy) | 0})) * float(${+k});
    `;

    // shader
    const source = `
    uniform sampler2D image;

    void main()
    {
        float alpha = threadPixel(image).a;
        vec4 result = vec4(0.0f);

        ${foreachKernelElement(generateCode)}

        color = vec4(result.rgb, alpha);
    }
    `;

    // done!
    return (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_0__.createShader)(source).withArguments('image');
}




/**
 * Generate a 1D convolution function on the x-axis
 * @param {number[]} kernel convolution kernel
 * @param {number} [normalizationConstant] will be multiplied by all kernel entries
 */
function convX(kernel, normalizationConstant = 1.0)
{
    return conv1D('x', kernel, normalizationConstant);
}




/**
 * Generate a 1D convolution function on the y-axis
 * @param {number[]} kernel convolution kernel
 * @param {number} [normalizationConstant] will be multiplied by all kernel entries
 */
function convY(kernel, normalizationConstant = 1.0)
{
    return conv1D('y', kernel, normalizationConstant);
}




/**
 * 1D convolution function generator
 * @param {string} axis either "x" or "y"
 * @param {number[]} kernel convolution kernel
 * @param {number} [normalizationConstant] will be multiplied by all kernel entries
 */
function conv1D(axis, kernel, normalizationConstant = 1.0)
{
    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));
    const kSize = kernel32.length;
    const N = kSize >> 1; // idiv 2

    // validate input
    if(kSize < 1 || kSize % 2 == 0)
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalArgumentError(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);
    else if(axis != 'x' && axis != 'y')
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalArgumentError(`Can't perform 1D convolution: invalid axis "${axis}"`); // this should never happen

    // select the appropriate pixel function
    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';

    // code generator
    const foreachKernelElement = fn => _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.symmetricRange(N).reduce(
        (acc, cur) => acc + fn(kernel32[cur + N], cur),
    '');
    const generateCode = (k, i) => ((axis == 'x') ? `
        pixel += ${pixelAtOffset}(image, ivec2(${(-i) | 0}, 0)) * float(${+k});
    ` : `
        pixel += ${pixelAtOffset}(image, ivec2(0, ${(-i) | 0})) * float(${+k});
    `);

    // shader
    const source = `
    uniform sampler2D image;

    void main()
    {
        float alpha = threadPixel(image).a;
        vec4 pixel = vec4(0.0f);

        ${foreachKernelElement(generateCode)}

        color = vec4(pixel.rgb, alpha);
    }
    `;

    // done!
    return (0,_shader_declaration__WEBPACK_IMPORTED_MODULE_0__.createShader)(source).withArguments('image');
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include sync recursive ^\\.\\/.*$":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/ sync ^\.\/.*$ ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./colors.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/colors.glsl",
	"./filters.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/filters.glsl",
	"./fixed-point.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/fixed-point.glsl",
	"./float16.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/float16.glsl",
	"./global.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/global.glsl",
	"./int32.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/int32.glsl",
	"./keypoint-descriptors.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-descriptors.glsl",
	"./keypoint-matches.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-matches.glsl",
	"./keypoints.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/keypoints.glsl",
	"./math.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/math.glsl",
	"./pyramids.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/pyramids.glsl",
	"./quickselect.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/quickselect.ignore.glsl",
	"./subpixel.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/subpixel.glsl"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/speedy-vision/src/gpu/shaders/include sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders sync recursive ^\\.\\/.*$":
/*!*******************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/ sync ^\.\/.*$ ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./filters/convolution": "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution.js",
	"./filters/convolution.js": "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution.js",
	"./filters/convolution1d.glsl": "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution1d.glsl",
	"./filters/convolution2d.glsl": "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution2d.glsl",
	"./filters/fast-median.glsl": "./node_modules/speedy-vision/src/gpu/shaders/filters/fast-median.glsl",
	"./filters/nightvision.glsl": "./node_modules/speedy-vision/src/gpu/shaders/filters/nightvision.glsl",
	"./filters/normalize-image.glsl": "./node_modules/speedy-vision/src/gpu/shaders/filters/normalize-image.glsl",
	"./filters/rgb2grey.glsl": "./node_modules/speedy-vision/src/gpu/shaders/filters/rgb2grey.glsl",
	"./include/colors.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/colors.glsl",
	"./include/filters.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/filters.glsl",
	"./include/fixed-point.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/fixed-point.glsl",
	"./include/float16.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/float16.glsl",
	"./include/global.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/global.glsl",
	"./include/int32.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/int32.glsl",
	"./include/keypoint-descriptors.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-descriptors.glsl",
	"./include/keypoint-matches.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-matches.glsl",
	"./include/keypoints.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/keypoints.glsl",
	"./include/math.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/math.glsl",
	"./include/pyramids.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/pyramids.glsl",
	"./include/quickselect.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/quickselect.ignore.glsl",
	"./include/subpixel.glsl": "./node_modules/speedy-vision/src/gpu/shaders/include/subpixel.glsl",
	"./keypoints/allocate-descriptors.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/allocate-descriptors.glsl",
	"./keypoints/allocate-extra.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/allocate-extra.glsl",
	"./keypoints/apply-homography.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/apply-homography.glsl",
	"./keypoints/bf-knn.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/bf-knn.glsl",
	"./keypoints/brisk.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/brisk.ignore.glsl",
	"./keypoints/clip-border.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/clip-border.glsl",
	"./keypoints/clip.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/clip.glsl",
	"./keypoints/discard-descriptors.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/discard-descriptors.ignore.glsl",
	"./keypoints/distance-filter.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/distance-filter.glsl",
	"./keypoints/encode-keypoint-long-offsets.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-long-offsets.glsl",
	"./keypoints/encode-keypoint-offsets.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-offsets.glsl",
	"./keypoints/encode-keypoint-positions.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-positions.glsl",
	"./keypoints/encode-keypoint-properties.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-properties.glsl",
	"./keypoints/encode-keypoints.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoints.glsl",
	"./keypoints/encode-null-keypoints.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-null-keypoints.glsl",
	"./keypoints/fast.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/fast.glsl",
	"./keypoints/fast.vs.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/fast.vs.glsl",
	"./keypoints/hamming-distance-filter.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/hamming-distance-filter.glsl",
	"./keypoints/harris-cutoff.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/harris-cutoff.glsl",
	"./keypoints/harris.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/harris.glsl",
	"./keypoints/knn-init.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/knn-init.glsl",
	"./keypoints/knn-transfer.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/knn-transfer.glsl",
	"./keypoints/laplacian.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/laplacian.glsl",
	"./keypoints/lk.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lk.glsl",
	"./keypoints/lookup-of-locations.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lookup-of-locations.glsl",
	"./keypoints/lookup-of-locations.vs.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lookup-of-locations.vs.glsl",
	"./keypoints/lsh-knn.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lsh-knn.glsl",
	"./keypoints/mix-keypoints.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/mix-keypoints.glsl",
	"./keypoints/ncc.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/ncc.ignore.glsl",
	"./keypoints/nonmax-scale.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-scale.glsl",
	"./keypoints/nonmax-space.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-space.glsl",
	"./keypoints/nonmax-suppression.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-suppression.glsl",
	"./keypoints/orb-descriptor.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/orb-descriptor.glsl",
	"./keypoints/orb-orientation.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/orb-orientation.glsl",
	"./keypoints/refine-scale.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/refine-scale.glsl",
	"./keypoints/score-findmax.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/score-findmax.glsl",
	"./keypoints/shuffle.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/shuffle.glsl",
	"./keypoints/sort-keypoints.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/sort-keypoints.glsl",
	"./keypoints/subpixel-refinement.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/subpixel-refinement.glsl",
	"./keypoints/transfer-flow.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-flow.glsl",
	"./keypoints/transfer-orientation.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-orientation.glsl",
	"./keypoints/transfer-to-extra.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-to-extra.glsl",
	"./keypoints/upload-keypoints.glsl": "./node_modules/speedy-vision/src/gpu/shaders/keypoints/upload-keypoints.glsl",
	"./pyramids/downsample2.glsl": "./node_modules/speedy-vision/src/gpu/shaders/pyramids/downsample2.glsl",
	"./pyramids/downsample3.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/pyramids/downsample3.ignore.glsl",
	"./pyramids/upsample2.glsl": "./node_modules/speedy-vision/src/gpu/shaders/pyramids/upsample2.glsl",
	"./pyramids/upsample3.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/pyramids/upsample3.ignore.glsl",
	"./transforms/additive-mix.glsl": "./node_modules/speedy-vision/src/gpu/shaders/transforms/additive-mix.glsl",
	"./transforms/resize.glsl": "./node_modules/speedy-vision/src/gpu/shaders/transforms/resize.glsl",
	"./transforms/warp-perspective.glsl": "./node_modules/speedy-vision/src/gpu/shaders/transforms/warp-perspective.glsl",
	"./utils/copy-components.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/copy-components.glsl",
	"./utils/copy-raster.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/copy-raster.glsl",
	"./utils/copy.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/copy.glsl",
	"./utils/crop.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/crop.ignore.glsl",
	"./utils/fill-components.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/fill-components.glsl",
	"./utils/fill.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/fill.glsl",
	"./utils/flip-y.vs.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/flip-y.vs.glsl",
	"./utils/scan-minmax1d.ignore.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/scan-minmax1d.ignore.glsl",
	"./utils/scan-minmax2d.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/scan-minmax2d.glsl",
	"./utils/sobel-derivatives.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/sobel-derivatives.glsl",
	"./utils/sobel-derivatives.vs.glsl": "./node_modules/speedy-vision/src/gpu/shaders/utils/sobel-derivatives.vs.glsl"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/speedy-vision/src/gpu/shaders sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-descriptordb.js":
/*!*******************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-descriptordb.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyDescriptorDB: () => (/* binding */ SpeedyDescriptorDB)
/* harmony export */ });
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _core_speedy_namespace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/speedy-namespace */ "./node_modules/speedy-vision/src/core/speedy-namespace.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-descriptordb.js
 * A database of binary descriptors in video memory
 */






//
// A database of binary descriptors is a texture that stores
// a set of (descriptor: uint8_t[]) entries.
//

/** @type {number} we use RGBA8 textures to store the descriptors */
const DESCRIPTORDB_BYTESPERPIXEL = 4;

/** @type {number} texture size goes up to 16 MB */
const DESCRIPTORDB_MAXLOG2STRIDE = 11; // 2048x2048 RGBA8 textures are guaranteed to be available in WebGL2 (where is the source of this?)

/**
 * Utility for generating a database of binary descriptors in video memory
 */
class SpeedyDescriptorDB extends _core_speedy_namespace__WEBPACK_IMPORTED_MODULE_1__.SpeedyNamespace
{
    /**
     * Create a database of binary descriptors
     * @param {SpeedyTexture} texture output texture
     * @param {Uint8Array[]} descriptors binary descriptors
     * @param {number} descriptorSize in bytes, a multiple of 4
     * @returns {SpeedyTexture} texture
     */
    static create(texture, descriptors, descriptorSize)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(descriptorSize % DESCRIPTORDB_BYTESPERPIXEL == 0, `Invalid descriptorSize: ${descriptorSize}`);

        const numberOfDescriptors = descriptors.length;
        const pixelsPerDescriptor = descriptorSize / DESCRIPTORDB_BYTESPERPIXEL;

        // find an appropriate texture size
        const n = Math.log2(pixelsPerDescriptor * Math.max(numberOfDescriptors, 1)) / 2;
        const log2stride = Math.min(DESCRIPTORDB_MAXLOG2STRIDE, Math.ceil(n));

        // setup texture parameters
        const stride = 1 << log2stride;
        const width = stride, height = stride; // we use powers-of-two

        // are we within storage capacity?
        const capacity = (width * height) / pixelsPerDescriptor;
        if(numberOfDescriptors > capacity)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.NotSupportedError(`The capacity of the descriptorDB (${capacity} for ${descriptorSize * 8}-bit descriptors) has been exceeded`);

        // create texture data
        const data = new Uint8Array(width * height * DESCRIPTORDB_BYTESPERPIXEL);
        for(let i = 0; i < numberOfDescriptors; i++) {
            const byteOffset = i * descriptorSize;
            const descriptor = descriptors[i];

            // validate input
            _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(descriptor.byteLength === descriptorSize);
            _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(byteOffset + descriptorSize <= data.byteLength);

            // write data
            data.set(descriptor, byteOffset);
        }

        // log data for further study
        const MEGABYTE = 1048576;
        const totalSize = numberOfDescriptors * descriptorSize;
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.log(
            `Creating a ${width}x${height} database of ${numberOfDescriptors} ` +
            `${descriptorSize * 8}-bit descriptors ` +
            `(total size: ${(totalSize / MEGABYTE).toFixed(2)} MB)`
        );

        // upload to the texture
        texture.resize(width, height);
        texture.upload(data);
        return texture;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-gl.js":
/*!*********************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-gl.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyGL: () => (/* binding */ SpeedyGL)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/observable */ "./node_modules/speedy-vision/src/utils/observable.js");
/* harmony import */ var _core_speedy_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-gl.js
 * A wrapper around the WebGL Rendering Context
 */






/** @typedef {'default' | 'low-power' | 'high-performance'} PowerPreference */

// Constants
const SINGLETON_KEY = Symbol();
const DEFAULT_POWER_PREFERENCE = 'default';

//
// We use a small canvas to improve the performance
// of createImageBitmap() on Firefox.
//
// A large canvas (2048x2048) causes a FPS drop, even
// if we only extract a small region of it (this is
// unlike Chrome, which is fast).
//
// Note: we automatically increase the size of the
// canvas (as needed) when rendering to it.
//
const CANVAS_WIDTH = 16, CANVAS_HEIGHT = 16;

/** @type {SpeedyGL} Singleton */
let instance = null;

/** @type {PowerPreference} power preference */
let powerPreference = DEFAULT_POWER_PREFERENCE;



/**
 * A wrapper around the WebGL Rendering Context
 */
class SpeedyGL extends _utils_observable__WEBPACK_IMPORTED_MODULE_1__.Observable
{
    /**
     * Constructor
     * @param {Symbol} key
     * @private
     */
    constructor(key)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(key === SINGLETON_KEY);
        super();



        /** @type {boolean} internal flag */
        this._reinitializeOnContextLoss = true;

        /** @type {HTMLCanvasElement} canvas */
        this._canvas = this._createCanvas(this._reinitialize.bind(this));

        /** @type {WebGL2RenderingContext} WebGL rendering context */
        this._gl = null;



        // create WebGL2 rendering context
        this._gl = this._createContext(this._canvas);
    }

    /**
     * Get Singleton
     * @returns {SpeedyGL}
     */
    static get instance()
    {
        return instance || (instance = new SpeedyGL(SINGLETON_KEY));
    }

    /**
     * The WebGL Rendering Context
     * Be careful not to cache this, as the WebGL Rendering Context may be lost!
     * @returns {WebGL2RenderingContext}
     */
    get gl()
    {
        return this._gl;
    }

    /**
     * The canvas
     * @returns {HTMLCanvasElement}
     */
    get canvas()
    {
        return this._canvas;
    }

    /**
     * Create a WebGL-capable canvas
     * @param {Function} reinitialize to be called if we get a WebGL context loss event
     * @returns {HTMLCanvasElement}
     */
    _createCanvas(reinitialize)
    {
        const canvas = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);

        canvas.addEventListener('webglcontextlost', ev => {
            _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.warning(`Lost WebGL2 context`);
            setTimeout(reinitialize, 0);
            ev.preventDefault();
        }, false);

        /*canvas.addEventListener('webglcontextrestored', ev => {
            Utils.warning(`Restored WebGL2 context`);
            ev.preventDefault();
        }, false);*/

        return canvas;
    }

    /**
     * Create a WebGL2 Rendering Context
     * @param {HTMLCanvasElement} canvas
     * @returns {WebGL2RenderingContext}
     */
    _createContext(canvas)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.log(`Creating a ${powerPreference} WebGL2 rendering context...`);

        // does the browser support WebGL2?
        if(typeof WebGL2RenderingContext === 'undefined')
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.NotSupportedError(`This application requires WebGL2. Please use a different browser.`);

         const gl = canvas.getContext('webgl2', {
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: powerPreference,
            alpha: true, // see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#avoid_alphafalse_which_can_be_expensive
            antialias: false,
            depth: false,
            stencil: false,
            desynchronized: true,
        });

        if(!gl)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.NotSupportedError(`Can't create a WebGL2 Rendering Context. Try a different browser!`);

        return gl;
    }

    /**
     * Reinitialize WebGL
     */
    _reinitialize()
    {
        // disable reinitialization?
        if(!this._reinitializeOnContextLoss)
            return;

        // warning
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.warning(`Reinitializing WebGL2...`);

        // create new canvas
        this._canvas.remove();
        this._canvas = this._createCanvas(this._reinitialize.bind(this));

        // create new context
        this._gl = this._createContext(this._canvas);

        // notify observers: we have a new context!
        // we need to recreate all textures...
        this._notify();
    }

    /**
     * Lose the WebGL context. This is used to manually
     * free resources, and also for purposes of testing
     * @returns {WEBGL_lose_context}
     */
    loseContext()
    {
        const gl = this._gl;

        // nothing to do?
        if(gl.isContextLost())
            return;

        // find the appropriate extension
        const ext = gl.getExtension('WEBGL_lose_context');
        if(!ext)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.NotSupportedError('WEBGL_lose_context extension is unavailable');

        // disable reinitialization
        this._reinitializeOnContextLoss = false;

        // lose context
        ext.loseContext();

        // done!
        return ext;
    }

    /**
     * Lose & restore the WebGL context
     * @param {number} [secondsToRestore]
     * @return {SpeedyPromise<WEBGL_lose_context>} resolves as soon as the context is restored
     */
    loseAndRestoreContext(secondsToRestore = 1)
    {
        const ms = Math.max(secondsToRestore, 0) * 1000;
        const ext = this.loseContext();

        return new _core_speedy_promise__WEBPACK_IMPORTED_MODULE_2__.SpeedyPromise(resolve => {
            setTimeout(() => {
                //ext.restoreContext();
                this._reinitializeOnContextLoss = true;
                this._reinitialize();
                setTimeout(() => resolve(ext), 0); // next frame
            }, ms);
        });
    }

    /**
     * Power preference for the WebGL context
     * @returns {PowerPreference}
     */
    static get powerPreference()
    {
        return powerPreference;
    }

    /**
     * Power preference for the WebGL context
     * @param {PowerPreference} value
     */
    static set powerPreference(value)
    {
        // validate
        if(!(value === 'default' || value === 'low-power' || value === 'high-performance'))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.IllegalArgumentError(`Invalid powerPreference: "${value}"`);

        // the power preference should be set before we create the WebGL context
        if(instance == null || powerPreference !== value) {
            powerPreference = value;

            // recreate the context if it already exists. Experimental.
            if(instance != null)
                instance.loseAndRestoreContext();
        }
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js":
/*!**********************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-gpu.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyGPU: () => (/* binding */ SpeedyGPU)
/* harmony export */ });
/* harmony import */ var _speedy_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-gl */ "./node_modules/speedy-vision/src/gpu/speedy-gl.js");
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _speedy_program_center__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./speedy-program-center */ "./node_modules/speedy-vision/src/gpu/speedy-program-center.js");
/* harmony import */ var _speedy_texture_pool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./speedy-texture-pool */ "./node_modules/speedy-vision/src/gpu/speedy-texture-pool.js");
/* harmony import */ var _speedy_texture_uploader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./speedy-texture-uploader */ "./node_modules/speedy-vision/src/gpu/speedy-texture-uploader.js");
/* harmony import */ var _core_speedy_media_source__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/speedy-media-source */ "./node_modules/speedy-vision/src/core/speedy-media-source.js");
/* harmony import */ var _core_speedy_promise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_observable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/observable */ "./node_modules/speedy-vision/src/utils/observable.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-gpu.js
 * GPU-accelerated routines for Computer Vision
 */












/**
 * GPU-accelerated routines for Computer Vision
 */
class SpeedyGPU extends _utils_observable__WEBPACK_IMPORTED_MODULE_8__.Observable
{
    /**
     * Constructor
     */
    constructor()
    {
        super();

        /** @type {SpeedyGL} cached reference */
        this._speedyGL = _speedy_gl__WEBPACK_IMPORTED_MODULE_0__.SpeedyGL.instance;

        /** @type {SpeedyProgramCenter} GPU-based programs */
        this._programs = new _speedy_program_center__WEBPACK_IMPORTED_MODULE_2__.SpeedyProgramCenter(this);

        /** @type {SpeedyTexturePool} texture pool */
        this._texturePool = new _speedy_texture_pool__WEBPACK_IMPORTED_MODULE_3__.SpeedyTexturePool(this);

        /** @type {SpeedyTextureUploader} texture uploader */
        this._textureUploader = new _speedy_texture_uploader__WEBPACK_IMPORTED_MODULE_4__.SpeedyTextureUploader(this);



        // recreate the state if necessary
        this._speedyGL.subscribe(this._reset, this);
    }

    /**
     * Access point to all GPU programs
     * @returns {SpeedyProgramCenter}
     */
    get programs()
    {
        return this._programs;
    }

    /**
     * The WebGL Rendering Context
     * Be careful not to cache this, as the WebGL Rendering Context may be lost!
     * @returns {WebGL2RenderingContext}
     */
    get gl()
    {
        return this._speedyGL.gl;
    }

    /**
     * Internal canvas
     * @returns {HTMLCanvasElement}
     */
    get canvas()
    {
        return this._speedyGL.canvas;
    }

    /**
     * Texture pool
     * @returns {SpeedyTexturePool}
     */
    get texturePool()
    {
        return this._texturePool;
    }

    /**
     * Renders a texture to the canvas
     * @param {SpeedyTexture} texture
     * @returns {HTMLCanvasElement} returned for convenience
     */
    renderToCanvas(texture)
    {
        const width = texture.width;
        const height = texture.height;
        const canvas = this.canvas;

        // do we need to resize the canvas?
        if(width > canvas.width || height > canvas.height) {
            _utils_utils__WEBPACK_IMPORTED_MODULE_7__.Utils.warning(`Resizing the canvas to ${width} x ${height}`);
            canvas.width = width;
            canvas.height = height;
        }

        // render
        this.programs.utils.renderToCanvas.outputs(width, height, null);
        this.programs.utils.renderToCanvas(texture);

        // done!
        return canvas;
    }

    /**
     * Upload an image to the GPU
     * @param {SpeedyMediaSource} source
     * @param {SpeedyTexture} outputTexture
     * @returns {SpeedyTexture} outputTexture
     */
    upload(source, outputTexture)
    {
        return this._textureUploader.upload(source, outputTexture);
    }

    /**
     * Releases resources
     * @returns {null}
     */
    release()
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_7__.Utils.assert(!this.isReleased());

        // release internal components
        this._programs = this._programs.release();
        this._texturePool = this._texturePool.release();
        this._textureUploader = this._textureUploader.release();

        // unsubscribe
        this._speedyGL.unsubscribe(this._reset);
        return null;
    }

    /**
     * Has this SpeedyGPU been released?
     * @returns {boolean}
     */
    isReleased()
    {
        return this._programs == null;
    }

    /**
     * Lose & restore the WebGL context (useful for testing purposes)
     * @return {SpeedyPromise<void>} resolves as soon as the context is restored
     */
    loseAndRestoreWebGLContext()
    {
        return this._speedyGL.loseAndRestoreContext().then(() => void(0));
    }

    /**
     * Reset the internal state
     * (called on context reset)
     */
    _reset()
    {
        if(this.isReleased())
            return;

        this._programs = new _speedy_program_center__WEBPACK_IMPORTED_MODULE_2__.SpeedyProgramCenter(this);
        this._texturePool = new _speedy_texture_pool__WEBPACK_IMPORTED_MODULE_3__.SpeedyTexturePool(this);
        this._textureUploader = new _speedy_texture_uploader__WEBPACK_IMPORTED_MODULE_4__.SpeedyTextureUploader(this);

        this._notify();
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-lsh.js":
/*!**********************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-lsh.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LSH_ACCEPTABLE_DESCRIPTOR_SIZES: () => (/* binding */ LSH_ACCEPTABLE_DESCRIPTOR_SIZES),
/* harmony export */   LSH_ACCEPTABLE_HASH_SIZES: () => (/* binding */ LSH_ACCEPTABLE_HASH_SIZES),
/* harmony export */   LSH_ACCEPTABLE_NUMBER_OF_TABLES: () => (/* binding */ LSH_ACCEPTABLE_NUMBER_OF_TABLES),
/* harmony export */   LSH_DEFAULT_HASH_SIZE: () => (/* binding */ LSH_DEFAULT_HASH_SIZE),
/* harmony export */   LSH_DEFAULT_NUMBER_OF_TABLES: () => (/* binding */ LSH_DEFAULT_NUMBER_OF_TABLES),
/* harmony export */   LSH_SEQUENCE_COUNT: () => (/* binding */ LSH_SEQUENCE_COUNT),
/* harmony export */   LSH_SEQUENCE_MAXLEN: () => (/* binding */ LSH_SEQUENCE_MAXLEN),
/* harmony export */   SpeedyLSH: () => (/* binding */ SpeedyLSH)
/* harmony export */ });
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _speedy_descriptordb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./speedy-descriptordb */ "./node_modules/speedy-vision/src/gpu/speedy-descriptordb.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/globals */ "./node_modules/speedy-vision/src/utils/globals.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-lsh.js
 * GPU-based LSH tables for fast matching of binary descriptors
 */






/*
 *              ALE'S GPU-BASED LSH FOR APPROXIMATE KNN MATCHING
 *              ------------------------------------------------
 *
 * Here is my variant of Locality Sensitive Hashing for GPU-based KNN matching!
 * Indices of keypoint descriptors are stored in several tables, each with many
 * buckets of fixed capacity. In a nutshell, I create a data structure of fixed
 * size to match the keypoints.
 *
 * Buckets in video memory may get full. Wouldn't it be cool if we could use a
 * probabilistic approach to let us work within their storage capacity?
 *
 * Let there be n buckets in a table, each with storage capacity c (holding
 * up to c elements). Buckets are numbered from 0 to n-1.
 *
 * We pick uniformly a random bucket to store a new element in the table. Let
 * X be the chosen bucket. The probability that we'll store the new element in
 * any particular bucket k is:
 *
 * P(X = k) = 1/n   (k = 0, 1, 2, ... n-1)
 *
 * On average, each new element stored in the table inserts 1/n of an element
 * in each bucket. If we add m new elements to the table, each bucket receives
 * m/n elements, on average(*).
 *
 * (*) for all k, define the Ik random variable as 1 if X = k and 0 otherwise.
 *     It follows that the expected value of Ik, E(Ik), is 1/n for all k. In
 *     addition, the expected value of (m Ik) is m * E(ik) = m/n.
 *
 * Now let Yi be the number of elements inserted in bucket i in m additions to
 * the table. We model Yi as Poisson(m/n), since on average, m additions to
 * the table result in m/n new elements being inserted in bucket i. Buckets
 * are picked independently. Hence, for all i, the probability that we insert
 * q elements in bucket i in m additions to the table is:
 *
 * P(Yi = q) = (m/n)^q * exp(-m/n) / q!   (q = 0, 1, 2...)
 *
 * Given that each bucket has storage capacity c, we require Yi <= c with a
 * high probability p (say, p = 0.99). This means that, in m additions, we
 * don't want to exceed the capacity c with high probability. So, let us find
 * a (large) value of m such that:
 *
 * P(Yi <= c) >= p
 *
 * Sounds good! We can find the largest matching m using binary search.
 *
 * I don't think we need to enforce a high probability that ALL buckets stay
 * within their capacity - n is large, we need to use the available space, and
 * we have multiple tables anyway.
 *
 * In practice, the assumption that buckets are picked uniformly doesn't hold:
 * keypoints that are nearby tend to have similar descriptors and buckets are
 * picked according to those descriptors. Still, this model works well enough
 * in practice and it is simple! That's what I like about it!
 *
 * ... now, how I actually do the matching is the theme of the next episode!
 */

/** @type {number} Default number of tables in a LSH data structure */
const LSH_DEFAULT_NUMBER_OF_TABLES = 8;

/** @type {number} Default number of bits of a hash */
const LSH_DEFAULT_HASH_SIZE = 15;

/** @type {number[]} Acceptable number of tables for a LSH data structure */
const LSH_ACCEPTABLE_NUMBER_OF_TABLES = [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32];

/** @type {number[]} Acceptable values for hashSize, in bits */
const LSH_ACCEPTABLE_HASH_SIZES = [10,11,12,13,14,15,16,17,18,19,20];

/** @type {number[]} Acceptable sizes for keypoint descriptors, in bytes */
const LSH_ACCEPTABLE_DESCRIPTOR_SIZES = [32,64];

/**
 * @typedef {Object} LSHProfile LSH profile
 * @property {string} name name of the profile
 * @property {number} capacity maximum number of keypoints that can be stored in such a table
 * @property {number} hashSize number of bits in a keypoint descriptor hash (at most 16)
 * @property {number} tableCount number of tables, preferably a power of 2 (at most 16)
 * @property {number} bucketCapacity maximum number of entries of a bucket of a table
 */

/** @type {function(number,number,number):LSHProfile[]|null} generate LSH profiles sorted by increasing capacity */
const generateLSHProfiles = (t,h,p) => !LSH_ACCEPTABLE_HASH_SIZES.includes(h) || !LSH_ACCEPTABLE_NUMBER_OF_TABLES.includes(t) ? null : [
    {
        name: 'x-small',
        bucketCapacity: 1,
        tableCount: t,
        hashSize: h,
        capacity: findTableCapacity(h, 1, p),
    },
    {
        name: 'small',
        bucketCapacity: 2,
        tableCount: t,
        hashSize: h,
        capacity: findTableCapacity(h, 2, p),
    },
    {
        name: 'small-plus',
        bucketCapacity: 3,
        tableCount: t,
        hashSize: h,
        capacity: findTableCapacity(h, 3, p),
    },
    {
        name: 'medium',
        bucketCapacity: 4,
        tableCount: t,
        hashSize: h,
        capacity: findTableCapacity(h, 4, p),
    },
    {
        name: 'medium-plus',
        bucketCapacity: 5,
        tableCount: t,
        hashSize: h,
        capacity: findTableCapacity(h, 5, p),
    },
    {
        name: 'large',
        bucketCapacity: 6,
        tableCount: t,
        hashSize: h,
        capacity: findTableCapacity(h, 6, p),
    },
    {
        name: 'x-large',
        bucketCapacity: 8,
        tableCount: t,
        hashSize: h,
        capacity: findTableCapacity(h, 8, p),
    },
];

//
// LSH hash sequences: random bits in increasing order
// We generate a few sequences (one for each table) supporting up to 16 hash bits
// We pad each sequence with invalid values at the end - we want to pick any bit with equal probability
//

/** @typedef {Uint32Array} BitSequences flattened array of LSH_SEQUENCE_COUNT sequences of LSH_SEQUENCE_MAXLEN elements each - each entry represents a bit index */
/** @typedef {Object<number,BitSequences>} BitSequencesIndexedByDescriptorSize */
/** @typedef {Object<number,BitSequencesIndexedByDescriptorSize>} LSHSequences */

/** @type {number} maximum number of elements of a sequence */
const LSH_SEQUENCE_MAXLEN = Math.max(...LSH_ACCEPTABLE_HASH_SIZES);

/** @type {number} number of sequences in a BitSequences object */
const LSH_SEQUENCE_COUNT = Math.max(...LSH_ACCEPTABLE_NUMBER_OF_TABLES);

/** @type {function(BitSequences): BitSequences} Sort subsequences of random bits in ascending order */
const partitionedSort = seq => (_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(LSH_SEQUENCE_COUNT)
    .forEach(i => seq.subarray(i * LSH_SEQUENCE_MAXLEN, (i+1) * LSH_SEQUENCE_MAXLEN).sort()),
seq);

/** @type {function(number, BitSequences): BitSequences} Set the last p entries of the input subsequences to an invalid value */
const padSequences = (p, seq) => (_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(LSH_SEQUENCE_COUNT)
    .forEach(i => seq.subarray((i+1) * LSH_SEQUENCE_MAXLEN - p, (i+1) * LSH_SEQUENCE_MAXLEN).fill(0xBADCAFE)),
seq);

/** @type {LSHSequences} the bits we pick to form the hashes, laid out in ascending order and indexed by descriptorSize and hashSize */
const LSH_SEQUENCES = (f => LSH_ACCEPTABLE_HASH_SIZES.reduce((p,o) => ((p[o]=f(o)), p), {}))(h => ({
    // for 256-bit descriptors
    32: partitionedSort(padSequences(LSH_SEQUENCE_MAXLEN - h, new Uint32Array([
        ...(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.shuffle(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(256))),
        ...(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.shuffle(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(256))),
        ...(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.shuffle(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(256))),
    ].slice(0, LSH_SEQUENCE_COUNT * LSH_SEQUENCE_MAXLEN)))),

    // for 512-bit descriptors
    64: partitionedSort(padSequences(LSH_SEQUENCE_MAXLEN - h, new Uint32Array([
        ...(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.shuffle(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(512))),
        ...(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.shuffle(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(512))),
    ].slice(0, LSH_SEQUENCE_COUNT * LSH_SEQUENCE_MAXLEN)))),
}));

//
// Misc
//

/** @type {number} we use RGBA8 textures (32 bits per pixel) as storage */
const LSH_BYTESPERPIXEL = 4;

/** @type {function(number): number} next power of 2 */
const nextPot = x => x > 1 ? 1 << Math.ceil(Math.log2(x)) : 1;



/**
 * GPU-based LSH tables for fast matching of binary descriptors
 */
class SpeedyLSH
{
    /**
     * Constructor
     * @param {SpeedyTexture} lshTables texture to be used as the set of LSH tables
     * @param {SpeedyTexture} descriptorDB texture to be used as the descriptor database
     * @param {Uint8Array[]} descriptors the binary descriptors you'll store (make sure you don't repeat them, otherwise they will just waste space)
     * @param {number} [tableCount] number of LSH tables, preferably a power of two
     * @param {number} [hashSize] number of bits of a hash of a descriptor
     * @param {number} [probability] probability of no discard events happening in the theoretical model
     */
    constructor(lshTables, descriptorDB, descriptors, tableCount = LSH_DEFAULT_NUMBER_OF_TABLES, hashSize = LSH_DEFAULT_HASH_SIZE, probability = 0.95)
    {
        const descriptorCount = descriptors.length;
        const descriptorSize = descriptorCount > 0 ? descriptors[0].byteLength : 0;
        const lshProfiles = generateLSHProfiles(tableCount, hashSize, probability);

        // validate input
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(descriptorCount > 0, `Can't build LSH tables without descriptors!`);
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(LSH_ACCEPTABLE_DESCRIPTOR_SIZES.includes(descriptorSize), `Can't build LSH tables: unacceptable descriptor size of ${descriptorSize} bytes`);
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(descriptors.findIndex(d => d.byteLength !== descriptorSize) < 0, `Can't build LSH tables: incorrectly sized descriptors. Expected ${descriptorSize} bytes for each`);
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(descriptorCount < _utils_globals__WEBPACK_IMPORTED_MODULE_3__.MATCH_MAX_INDEX, `Can't build LSH tables: too many descriptors (${descriptors.length})`);
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(lshProfiles != null, `Can't build LSH tables: unacceptable number of tables (${tableCount}) x hash size (${hashSize})`);

        /** @type {LSHProfile} LSH profile */
        this._profile = lshProfiles.find(profile => descriptorCount <= profile.capacity) || lshProfiles[lshProfiles.length - 1];

        /** @type {number} descriptor size, in bytes */
        this._descriptorSize = descriptorSize;

        /** @type {number} number of descriptors */
        this._descriptorCount = descriptorCount;

        /** @type {BitSequences} bit sequences */
        this._sequences = this._pickSequences(this._descriptorSize);

        /** @type {SpeedyTexture} LSH tables storing indices of descriptors */
        this._tables = this._createStaticTables(lshTables, this._sequences, descriptors, descriptorSize);

        /** @type {SpeedyTexture} a storage of descriptors */
        this._descriptorDB = _speedy_descriptordb__WEBPACK_IMPORTED_MODULE_1__.SpeedyDescriptorDB.create(descriptorDB, descriptors, descriptorSize);
    }

    /**
     * Descriptor size, in bytes
     * @returns {number}
     */
    get descriptorSize()
    {
        return this._descriptorSize;
    }

    /**
     * Number of descriptors stored in this LSH data structure
     * @returns {number}
     */
    get descriptorCount()
    {
        return this._descriptorCount;
    }

    /**
     * LSH bit sequences
     * @returns {BitSequences}
     */
    get sequences()
    {
        return this._sequences;
    }

    /**
     * Number of bits that make a hash
     * @returns {number}
     */
    get hashSize()
    {
        return this._profile.hashSize;
    }

    /**
     * Maximum number of descriptors that can be stored in a bucket of a table
     * @returns {number}
     */
    get bucketCapacity()
    {
        return this._profile.bucketCapacity;
    }

    /**
     * How many buckets per table do we have?
     * @returns {number}
     */
    get bucketsPerTable()
    {
        return 1 << this._profile.hashSize;
    }

    /**
     * Number of LSH tables
     * @returns {number}
     */
    get tableCount()
    {
        return this._profile.tableCount;
    }

    /**
     * Size of one LSH table, in bytes
     * @returns {number}
     */
    get tableSize()
    {
        return this.bucketsPerTable * this.bucketCapacity * LSH_BYTESPERPIXEL;
    }

    /**
     * Size of all LSH tables combined, in bytes
     * @returns {number}
     */
    get totalSize()
    {
        // actually, the total memory in VRAM may be a bit larger than
        // this value, depending on the actual size of the texture
        return this.tableCount * this.tableSize;
    }

    /**
     * LSH tables texture
     * @returns {SpeedyDrawableTexture}
     */
    get tables()
    {
        return this._tables;
    }

    /**
     * A collection of descriptors
     * @returns {SpeedyDrawableTexture}
     */
    get descriptorDB()
    {
        return this._descriptorDB;
    }

    /**
     * Pick the appropriate LSH sequences for a particular descriptor size
     * @param {number} descriptorSize in bytes
     * @returns {BitSequences}
     */
    _pickSequences(descriptorSize)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(Object.prototype.hasOwnProperty.call(LSH_SEQUENCES, this.hashSize));
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(Object.prototype.hasOwnProperty.call(LSH_SEQUENCES[this.hashSize], descriptorSize));

        return LSH_SEQUENCES[this.hashSize][descriptorSize];
    }

    /**
     * Create LSH tables
     * @param {SpeedyTexture} texture output texture
     * @param {BitSequences} sequences bit sequences
     * @param {Uint8Array[]} descriptors non-empty array of binary descriptors, ALL HAVING THE SAME SIZE
     * @param {number} descriptorSize in bytes
     * @returns {SpeedyTexture} texture
     */
    _createStaticTables(texture, sequences, descriptors, descriptorSize)
    {
        const END_OF_LIST = 0xFFFFFFFF;
        const profileName = this._profile.name;
        const tableCapacity = this._profile.capacity;
        const tableCount = this.tableCount;
        const bucketsPerTable = this.bucketsPerTable;
        const bucketSize = this.bucketCapacity * LSH_BYTESPERPIXEL;
        const hashSize = this.hashSize;
        const numberOfPixels = this.tableCount * this.bucketsPerTable * this.bucketCapacity; // watch for overflow?
        const textureWidth = Math.min(nextPot(Math.sqrt(numberOfPixels)), 4096); // 4096 is compatible with most devices according to MDN
        const textureHeight = Math.ceil(numberOfPixels / textureWidth);
        const numberOfDescriptors = descriptors.length;

        // validate input
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(hashSize <= LSH_SEQUENCE_MAXLEN);
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(tableCount <= LSH_SEQUENCE_COUNT);
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(numberOfPixels <= textureWidth * textureHeight);

        // log
        const MEGABYTE = 1048576;
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.log(
            `Building ${tableCount} ${profileName} LSH tables with ${numberOfDescriptors} ` +
            `${descriptorSize * 8}-bit descriptors each and hashSize = ${hashSize} bits ` +
            `(${textureWidth}x${textureHeight}, with ${(this.tableSize / MEGABYTE).toFixed(2)} ` +
            `MB per table and total size = ${(this.totalSize / MEGABYTE).toFixed(2)} MB), `
        );

        // warn the user if there are too many descriptors
        if(numberOfDescriptors > tableCapacity) {
            const exceedingPercentage = 100 * numberOfDescriptors / tableCapacity;
            _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.warning(`There are too many descriptors (${numberOfDescriptors}) for a ${profileName} LSH table. That's ${exceedingPercentage.toFixed(2)}% of its theoretical capacity. Consider increasing the hashSize (currently set to ${hashSize}) or reducing the number of descriptors to avoid degradation.`);
        }

        // create empty LSH tables
        const buffer = new ArrayBuffer(textureWidth * textureHeight * LSH_BYTESPERPIXEL);
        const bytes = (new Uint8Array(buffer)).fill(0xFF);
        const data = new DataView(buffer);

        // shuffle the descriptors...
        // it seems like a good idea to handle collisions of similar descriptors,
        // which may be located next to each other in the array
        const permutation = _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.shuffle(_utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.range(numberOfDescriptors));

        // for each descriptor
        // do everything in little-endian format!
        const numberOfDiscardedDescriptorsPerTable = (new Array(tableCount)).fill(0);
        for(let i = 0; i < numberOfDescriptors; i++) {
            const descriptorIndex = permutation[i]; //i;
            const hashes = this._hashCodes(descriptors[descriptorIndex], sequences);

            // for each table
            for(let table = 0; table < tableCount; table++) {
                // compute hash & memory addresses
                const hash = hashes[table];
                const tableByteOffset = table * bucketsPerTable * bucketSize;
                const bucketByteOffset = tableByteOffset + hash * bucketSize;

                // find the end of the list
                let index = END_OF_LIST;
                for(let entryByteOffset = 0; entryByteOffset < bucketSize; entryByteOffset += LSH_BYTESPERPIXEL) {
                    const byteOffset = bucketByteOffset + entryByteOffset;
                    index = data.getUint32(byteOffset, true);

                    // add the keypoint
                    if(index == END_OF_LIST) {
                        data.setUint32(byteOffset, descriptorIndex, true);
                        break;
                    }
                }

                // note: if the bucket is full, we just discard the entry :\
                // we give this event a probabilistic treatment (see above),
                // so it happens with low probability
                if(index != END_OF_LIST)
                    numberOfDiscardedDescriptorsPerTable[table]++;
            }
        }

        // log data for further study
        const numberOfDiscardedDescriptors = numberOfDiscardedDescriptorsPerTable.reduce((sum, val) => sum + val, 0);
        const profile = numberOfDiscardedDescriptorsPerTable.map(d => 100 * d / numberOfDescriptors);
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.log(
            `When building ${tableCount} ${profileName} LSH tables with ${numberOfDescriptors} ` +
            `${descriptorSize * 8}-bit descriptors each and hashSize = ${hashSize} bits, ` +
            `I got the following discard profile: ` + profile.map(x => x.toFixed(2) + '%').join(', ') + `. ` +
            `Average: ${(100 * numberOfDiscardedDescriptors / (tableCount * numberOfDescriptors)).toFixed(2)}%. ` +
            `Minimum: ${Math.min(...profile).toFixed(2)}%. ` +
            `Table capacity: ${tableCapacity}.`
        );

        // upload the LSH tables to the GPU
        texture.resize(textureWidth, textureHeight);
        texture.upload(bytes);
        return texture;
    }

    /**
     * Pick bits from a binary descriptor
     * @param {Uint8Array} descriptor a single descriptor
     * @param {BitSequences} sequences flattened array of tableCount sequences of LSH_SEQUENCE_MAXLEN elements each
     * @returns {number[]} hash code for each table
     */
    _hashCodes(descriptor, sequences)
    {
        const tableCount = this.tableCount;
        const hashSize = this.hashSize;
        const bucketsPerTable = this.bucketsPerTable;
        const hashes = new Array(tableCount);
        //const descriptorSize = descriptor.length;

        // just to be sure...
        _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(
            hashSize <= LSH_SEQUENCE_MAXLEN &&
            sequences.length >= LSH_SEQUENCE_MAXLEN * tableCount
        );

        // for each table
        for(let table = 0; table < tableCount; table++) {
            const offset = LSH_SEQUENCE_MAXLEN * table;

            // pick bits [ sequences[offset] .. sequences[offset + hashSize-1] ]
            let hash = 0;
            for(let i = 0; i < hashSize; i++) {
                let bit = sequences[offset + i];
                let b = bit >>> 3;
                let m = 1 << (bit & 7);

                //Utils.assert(b < descriptorSize);
                hash = (hash << 1) | ((descriptor[b] & m) != 0);
            }

            // validate & store
            _utils_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.assert(hash >= 0 && hash < bucketsPerTable);
            hashes[table] = hash;
        }

        // done!
        return hashes;
    }
}

/**
 * Compute P(X <= k), where X ~ Poisson(lambda)
 * @param {number} lambda positive number
 * @param {number} k non-negative integer
 * @returns {number}
 */
function cumulativePoisson(lambda, k)
{
    const exp = Math.exp(-lambda);
    let sum = 1, fat = 1, pow = 1;

    // k should be small!!!
    for(let i = 1; i <= k; i++)
        sum += (pow *= lambda) / (fat *= i);

    return sum * exp;
}

/**
 * Find the maximum number of keypoint descriptors that a table can hold
 * @param {number} hashSize positive integer
 * @param {number} bucketCapacity positive integer
 * @param {number} [probability] probability of no discard events happening in the theoretical model
 * @return {number} optimal table capacity
 */
function findTableCapacity(hashSize, bucketCapacity, probability = 0.99)
{
    const n = 1 << hashSize // number of buckets
    const c = bucketCapacity;
    const p = probability;

    let l = 1, r = n * c; // watch for overflow!
    let m = 0, pm = 0;

    // binary search
    while(l < r) {
        m = Math.floor((l + r) / 2);
        pm = cumulativePoisson(m / n, c);

        if(pm > p) //if(1-pm < 1-p)
            l = m + 1;
        else
            r = m;
    }

    return m;
}


/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-program-center.js":
/*!*********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-program-center.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgramCenter: () => (/* binding */ SpeedyProgramCenter)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _programs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./programs/utils */ "./node_modules/speedy-vision/src/gpu/programs/utils.js");
/* harmony import */ var _programs_filters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./programs/filters */ "./node_modules/speedy-vision/src/gpu/programs/filters.js");
/* harmony import */ var _programs_keypoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./programs/keypoints */ "./node_modules/speedy-vision/src/gpu/programs/keypoints.js");
/* harmony import */ var _programs_pyramids__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./programs/pyramids */ "./node_modules/speedy-vision/src/gpu/programs/pyramids.js");
/* harmony import */ var _programs_transforms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./programs/transforms */ "./node_modules/speedy-vision/src/gpu/programs/transforms.js");
/* harmony import */ var _speedy_program_group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./speedy-program-group */ "./node_modules/speedy-vision/src/gpu/speedy-program-group.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-program-center.js
 * An access point to all programs that run on the GPU
 */









/**
 * An access point to all programs that run on the CPU
 * All program groups can be accessed via this class
 */
class SpeedyProgramCenter
{
    /**
     * Class constructor
     * @param {SpeedyGPU} gpu reference to SpeedyGPU
     */
    constructor(gpu)
    {
        // Note: we instantiate the program groups lazily

        /** @type {SpeedyGPU} reference to SpeedyGPU */
        this._gpu = gpu;

        /** @type {SpeedyProgramGroupFilters} image filters */
        this._filters = null;

        /** @type {SpeedyProgramGroupTransforms} geometric transformations */
        this._transforms = null;

        /** @type {SpeedyProgramGroupPyramids} pyramids & scale-space */
        this._pyramids = null;

        /** @type {SpeedyProgramGroupKeypoints} keypoint routines */
        this._keypoints = null;

        /** @type {SpeedyProgramGroupUtils} utility programs */
        this._utils = null;
    }

    /**
     * Image filters & convolutions
     * @returns {SpeedyProgramGroupFilters}
     */
    get filters()
    {
        return this._filters || (this._filters = new _programs_filters__WEBPACK_IMPORTED_MODULE_2__.SpeedyProgramGroupFilters(this._gpu));
    }

    /**
     * Geometric transformations
     * @returns {SpeedyProgramGroupTransforms}
     */
    get transforms()
    {
        return this._transforms || (this._transforms = new _programs_transforms__WEBPACK_IMPORTED_MODULE_5__.SpeedyProgramGroupTransforms(this._gpu));
    }

    /**
     * Image pyramids & scale-space
     * @returns {SpeedyProgramGroupPyramids}
     */
    get pyramids()
    {
        return this._pyramids || (this._pyramids = new _programs_pyramids__WEBPACK_IMPORTED_MODULE_4__.SpeedyProgramGroupPyramids(this._gpu));
    }

    /**
     * Keypoint detection & description
     * @returns {SpeedyProgramGroupKeypoints}
     */
    get keypoints()
    {
        return this._keypoints || (this._keypoints = new _programs_keypoints__WEBPACK_IMPORTED_MODULE_3__.SpeedyProgramGroupKeypoints(this._gpu));
    }

    /**
     * Utility programs
     * @returns {SpeedyProgramGroupUtils}
     */
    get utils()
    {
        return this._utils || (this._utils = new _programs_utils__WEBPACK_IMPORTED_MODULE_1__.SpeedyProgramGroupUtils(this._gpu));
    }

    /**
     * Release all programs from all groups. You'll
     * no longer be able to use any of them.
     * @returns {null}
     */
    release()
    {
        for(const key in this) {
            if(Object.prototype.hasOwnProperty.call(this, key) && this[key] != null) {
                const group = this[key];
                if(group instanceof _speedy_program_group__WEBPACK_IMPORTED_MODULE_6__.SpeedyProgramGroup)
                    group.release();
            }
        }

        return null;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-program-group.js":
/*!********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-program-group.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgramGroup: () => (/* binding */ SpeedyProgramGroup)
/* harmony export */ });
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/* harmony import */ var _speedy_program__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./speedy-program */ "./node_modules/speedy-vision/src/gpu/speedy-program.js");
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-program-group.js
 * An abstract group of programs that run on the GPU
 */





/** @typedef {import('./speedy-program').SpeedyProgramOptions} SpeedyProgramOptions */

/**
 * @typedef {object} SpeedyProgramHelpers
 * @property {function(): SpeedyProgramOptions} usesPingpongRendering
 * @property {function(): SpeedyProgramOptions} rendersToCanvas
*/

/** @const {SpeedyProgramHelpers} Program settings generator */
const PROGRAM_HELPERS = Object.freeze({

    /**
     * Pingpong Rendering: the output texture of a
     * program cannot be used as an input to itself.
     * This is a convenient helper in these situations
     * @returns {SpeedyProgramOptions}
     */
    usesPingpongRendering() {
        return {
            pingpong: true
        };
    },

    /**
     * Render to canvas
     * Use it when we're supposed to see the texture
     * @returns {SpeedyProgramOptions}
     */
    rendersToCanvas() {
        return {
            renderToTexture: false
        };
    },

});


/**
 * SpeedyProgramGroup
 * A semantically correlated group
 * of programs that run on the GPU
 * @abstract
 */
class SpeedyProgramGroup
{
    /**
     * Class constructor
     * @protected
     * @param {SpeedyGPU} gpu
     */
    constructor(gpu)
    {
        /** @type {SpeedyGPU} GPU-accelerated routines */
        this._gpu = gpu;

        /** @type {SpeedyProgram[]} the list of all programs that belong to this group */
        this._programs = [];
    }

    /**
     * Declare a program
     * @protected
     * @param {string} name Program name
     * @param {ShaderDeclaration} shaderdecl Shader declaration
     * @param {SpeedyProgramOptions} [options] Program settings
     * @returns {this}
     */
    declare(name, shaderdecl, options = {})
    {
        // lazy instantiation of kernels
        Object.defineProperty(this, name, {
            get: (() => {
                // Why cast a symbol to symbol?
                // Suppress error TS9005: Declaration emit for this file requires using private name 'key'.
                const key = /** @type {symbol} */ ( Symbol(name) );
                return () => this[key] || (this[key] = this._createProgram(shaderdecl, options));
            })()
        });

        return this;
    }

    /**
     * Neat helpers to be used when declaring programs
     * @returns {SpeedyProgramHelpers}
     */
    get program()
    {
        return PROGRAM_HELPERS;
    }

    /**
     * Releases all programs from this group
     * @returns {null}
     */
    release()
    {
        for(let i = 0; i < this._programs.length; i++)
            this._programs[i].release();

        return null;
    }

    /**
     * Spawn a SpeedyProgram
     * @param {ShaderDeclaration} shaderdecl Shader declaration
     * @param {SpeedyProgramOptions} [options] Program settings
     * @returns {SpeedyProgram}
     */
    _createProgram(shaderdecl, options = {})
    {
        const program = new _speedy_program__WEBPACK_IMPORTED_MODULE_1__.SpeedyProgram(this._gpu.gl, shaderdecl, options);
        this._programs.push(program);
        return program;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-program.js":
/*!**************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-program.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyProgram: () => (/* binding */ SpeedyProgram)
/* harmony export */ });
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _core_speedy_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var _shader_declaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader-declaration */ "./node_modules/speedy-vision/src/gpu/shader-declaration.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-program.js
 * SpeedyProgram class
 */







/** @const {Object<string,string>} Map uniform type to a gl function */
const UNIFORM_SETTERS = Object.freeze({
    'sampler2D': 'uniform1i',
    'isampler2D':'uniform1i',
    'usampler2D':'uniform1i',
    'float':     'uniform1f',
    'int':       'uniform1i',
    'uint':      'uniform1ui',
    'bool':      'uniform1i',
    'vec2':      'uniform2f',
    'vec3':      'uniform3f',
    'vec4':      'uniform4f',
    'ivec2':     'uniform2i',
    'ivec3':     'uniform3i',
    'ivec4':     'uniform4i',
    'uvec2':     'uniform2ui',
    'uvec3':     'uniform3ui',
    'uvec4':     'uniform4ui',
    'bvec2':     'uniform2i',
    'bvec3':     'uniform3i',
    'bvec4':     'uniform4i',
    'mat2':      'uniformMatrix2fv',
    'mat3':      'uniformMatrix3fv',
    'mat4':      'uniformMatrix4fv',
});

/**
 * @typedef {object} SpeedyProgramOptions
 * @property {boolean} [renderToTexture] render results to a texture?
 * @property {boolean} [pingpong] alternate output texture between calls
 */

/** @typedef {number|number[]|boolean|boolean[]|SpeedyTexture} SpeedyProgramUniformValue */

/**
 * A SpeedyProgram is a Function that
 * runs GPU-accelerated GLSL code
 */
class SpeedyProgram extends Function
{
    /**
     * Creates a new SpeedyProgram
     * @param {WebGL2RenderingContext} gl WebGL context
     * @param {ShaderDeclaration} shaderdecl Shader declaration
     * @param {SpeedyProgramOptions} [options] user options
     */
    constructor(gl, shaderdecl, options = { })
    {
        super('...args', 'return this._self._call(...args)');

        /** @type {SpeedyProgram} this function bound to this function! */
        this._self = this.bind(this);

        this._self._init(gl, shaderdecl, options);
        return this._self;
    }

    /**
     * Initialize the SpeedyProgram
     * @param {WebGL2RenderingContext} gl WebGL context
     * @param {ShaderDeclaration} shaderdecl Shader declaration
     * @param {SpeedyProgramOptions} options user options
     */
    _init(gl, shaderdecl, options)
    {
        // not a valid context?
        if(gl.isContextLost())
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalOperationError(`Can't initialize SpeedyProgram: lost context`);

        // options object
        options = Object.assign({
            // default options
            renderToTexture: true,
            pingpong: false,
        }, options);



        /** @type {WebGL2RenderingContext} */
        this._gl = gl;

        /** @type {WebGLProgram} vertex shader + fragment shader */
        this._program = SpeedyProgram._compile(gl, shaderdecl.vertexSource, shaderdecl.fragmentSource);

        /** @type {ProgramGeometry} this is a quad */
        this._geometry = new ProgramGeometry(gl, {
            position: shaderdecl.locationOfAttributes.position,
            texCoord: shaderdecl.locationOfAttributes.texCoord
        });

        /** @type {string[]} names of the arguments of the SpeedyProgram */
        this._argnames = shaderdecl.arguments;

        /** @type {boolean[]} tells whether the i-th argument of the SpeedyProgram is an array or not */
        this._argIsArray = (new Array(this._argnames.length)).fill(false);

        /** @type {UBOHelper} UBO helper (lazy instantiation) */
        this._ubo = null;

        /** @type {boolean} should we render to a texture? If false, we render to the canvas */
        this._renderToTexture = Boolean(options.renderToTexture);

        /** @type {number} width of the output */
        this._width = 1;

        /** @type {number} height of the output */
        this._height = 1;

        /** @type {SpeedyDrawableTexture[]} output texture(s) */
        this._texture = (new Array(options.pingpong ? 2 : 1)).fill(null);

        /** @type {number} used for pingpong rendering */
        this._textureIndex = 0;

        /** @type {Map<string,UniformVariable>} uniform variables */
        this._uniform = new Map();

        /** @type {ShaderDeclaration} shader declaration */
        this._shaderdecl = shaderdecl;


        // autodetect uniforms
        gl.useProgram(this._program);
        for(const name of shaderdecl.uniforms) {
            const type = shaderdecl.uniformType(name);
            const location = gl.getUniformLocation(this._program, name);
            this._uniform.set(name, new UniformVariable(type, location));
        }

        // match arguments & uniforms
        for(let j = 0; j < this._argnames.length; j++) {
            const argname = this._argnames[j];
            if(!this._uniform.has(argname)) {
                this._argIsArray[j] = this._uniform.has(argname + '[0]');
                if(!this._argIsArray[j])
                    throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalOperationError(`Expected uniform "${argname}", as declared in the argument list`);
            }
        }
    }

    /**
     * Run the SpeedyProgram
     * @param  {...SpeedyProgramUniformValue} args
     * @returns {SpeedyDrawableTexture}
     */
    _call(...args)
    {
        const gl = this._gl;
        const argnames = this._argnames;

        // matching arguments?
        if(args.length != argnames.length)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalArgumentError(`Can't run shader: incorrect number of arguments (expected ${argnames.length}, got ${args.length})`);

        // can't use the output texture as an input
        const flatArgs = _utils_utils__WEBPACK_IMPORTED_MODULE_3__.Utils.flatten(args);
        for(let j = flatArgs.length - 1; j >= 0; j--) {
            if(flatArgs[j] === this._texture[this._textureIndex])
                throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.NotSupportedError(`Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!`);
        }

        // context loss?
        if(gl.isContextLost())
            return this._texture[this._textureIndex];

        // use program
        gl.useProgram(this._program);

        // bind the VAO
        gl.bindVertexArray(this._geometry.vao);

        // select the render target
        const texture = this._texture[this._textureIndex];
        const fbo = this._renderToTexture ? texture.glFbo : null;

        // update texSize uniform (available in all fragment shaders)
        const width = this._width, height = this._height;
        const texSize = this._uniform.get('texSize');
        texSize.setValue(gl, [ width, height ]);
        //gl.uniform2f(texSize.location, width, height);

        // set uniforms[i] to args[i]
        for(let i = 0, texNo = 0; i < args.length; i++) {
            const argname = argnames[i];

            if(!this._argIsArray[i]) {
                // uniform variable matches argument name
                const uniform = this._uniform.get(argname);
                texNo = uniform.setValue(gl, args[i], texNo);
            }
            else {
                // uniform array matches argument name
                const array = args[i];
                if(Array.isArray(array)) {
                    if(this._uniform.has(`${argname}[${array.length}]`))
                        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalArgumentError(`Can't run shader: too few elements in the "${argname}" array`);
                    for(let j = 0, uniform = undefined; (uniform = this._uniform.get(`${argname}[${j}]`)) !== undefined; j++)
                        texNo = uniform.setValue(gl, array[j], texNo);
                }
                else
                    throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalArgumentError(`Can't run shader: expected an array for "${argname}"`);
            }
        }

        // set Uniform Buffer Objects (if any)
        if(this._ubo !== null)
            this._ubo.update();

        // bind the FBO
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

        // draw call
        gl.viewport(0, 0, width, height);
        gl.drawArrays(gl.TRIANGLES, 0, 6); // mode, offset, count

        // unbind the FBO
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // unbind the VAO
        gl.bindVertexArray(null);

        // we've just changed the texture! discard the pyramid, if any
        if(texture != null)
            texture.discardMipmaps();

        // ping-pong rendering
        this._pingpong();

        // done!
        return texture;
    }

    /**
     * Set the output texture(s) and its (their) shape(s)
     * @param {number} width new width, in pixels
     * @param {number} height new height, in pixels
     * @param  {...SpeedyDrawableTexture|null} texture output texture(s)
     * @returns {SpeedyProgram} this
     */
    outputs(width, height, ...texture)
    {
        this._setOutputTexture(...texture);
        this._setOutputSize(width, height);
        return this;
    }

    /**
     * Set the size of the output
     * @param {number} width new width, in pixels
     * @param {number} height new height, in pixels
     * @returns {SpeedyProgram} this
     */
    _setOutputSize(width, height)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_3__.Utils.assert(width > 0 && height > 0);

        // update output size
        this._width = width | 0;
        this._height = height | 0;

        // resize the output texture(s)
        for(let i = 0; i < this._texture.length; i++) {
            if(this._texture[i] != null)
                this._texture[i].resize(this._width, this._height);
        }

        // done!
        return this;
    }

    /**
     * Use the provided texture(s) as output
     * @param {...SpeedyDrawableTexture} texture set to null to use the internal texture(s)
     * @returns {SpeedyProgram} this
     */
    _setOutputTexture(...texture)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_3__.Utils.assert(texture.length === this._texture.length, `Incorrect number of textures (expected ${this._texture.length})`);

        // update output texture(s)
        for(let i = 0; i < this._texture.length; i++)
            this._texture[i] = texture[i];
        this._textureIndex = 0;

        // done!
        return this;
    }

    /**
     * Clear the internal textures
     * @returns {SpeedyDrawableTexture}
     */
    clear()
    {
        const texture = this._texture[this._textureIndex];

        // clear internal textures
        for(let i = 0; i < this._texture.length; i++)
            this._texture[i].clear();

        // ping-pong rendering
        this._pingpong();

        // done!
        return texture;
    }

    /**
     * Set data using a Uniform Buffer Object
     * @param {string} blockName uniform block name
     * @param {ArrayBufferView} data
     * @returns {SpeedyProgram} this
     */
    setUBO(blockName, data)
    {
        if(this._ubo === null)
            this._ubo = new UBOHelper(this._gl, this._program);

        this._ubo.set(blockName, data);
        return this;
    }

    /**
     * Release the resources associated with this SpeedyProgram
     * @returns {null}
     */
    release()
    {
        const gl = this._gl;

        // Release UBOs (if any)
        if(this._ubo != null)
            this._ubo = this._ubo.release();

        // Unlink textures
        this._texture.fill(null);

        // Release geometry
        this._geometry = this._geometry.release();

        // Release program
        gl.deleteProgram(this._program);
        this._program = null;

        // Need to delete the shaders as well? In sec 5.14.9 Programs and shaders
        // of the WebGL 1.0 spec, it is mentioned that the underlying GL object
        // will automatically be marked for deletion when the JS object is
        // destroyed (i.e., garbage collected)

        // done!
        return null;
    }

    /**
     * A constant #defined in the shader declaration
     * @param {string} name
     * @returns {number}
     */
    definedConstant(name)
    {
        return this._shaderdecl.definedConstant(name);
    }

    /**
     * Helper method for pingpong rendering: alternates
     * the texture index from 0 to 1 and vice-versa
     */
    _pingpong()
    {
        if(this._texture.length > 1)
            this._textureIndex = 1 - this._textureIndex;
    }

    /**
     * Compile and link GLSL shaders
     * @param {WebGL2RenderingContext} gl
     * @param {string} vertexShaderSource GLSL code of the vertex shader
     * @param {string} fragmentShaderSource GLSL code of the fragment shader
     * @returns {WebGLProgram}
     */
    static _compile(gl, vertexShaderSource, fragmentShaderSource)
    {
        const program = gl.createProgram();
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

        // compile vertex shader
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);
        gl.attachShader(program, vertexShader);

        // compile fragment shader
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, fragmentShader);

        // link program
        gl.linkProgram(program);
        gl.validateProgram(program);

        // return on success
        if(gl.getProgramParameter(program, gl.LINK_STATUS))
            return program;

        // display an error
        const errors = [
            gl.getShaderInfoLog(fragmentShader),
            gl.getShaderInfoLog(vertexShader),
            gl.getProgramInfoLog(program),
        ];

        gl.deleteProgram(program);
        gl.deleteShader(fragmentShader);
        gl.deleteShader(vertexShader);

        // display error
        const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));
        const col = k => new Array(spaces(k)).fill(' ').join('') + k + '. ';
        const source = errors[0] ? fragmentShaderSource : vertexShaderSource;
        const formattedSource = source.split('\n')
            .map((line, no) => col(1+no) + line)
            .join('\n');

        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.GLError(
            `\n\n---------- ERROR ----------\n\n` +
            errors.filter(err => err).join('\n') +
            `\n\n---------- SOURCE CODE ----------\n\n` +
            formattedSource + '\n'
        );
    }
}





// ============================================================================
//                                  HELPERS
// ============================================================================






/**
 * Configure and store the VAO and the VBOs
 * @param {WebGL2RenderingContext} gl
 * @param {LocationOfAttributes} location
 * @returns {ProgramGeometry}
 *
 * @typedef {Object} LocationOfAttributes
 * @property {number} position
 * @property {number} texCoord
 *
 * @typedef {Object} BufferOfAttributes
 * @property {WebGLBuffer} position
 * @property {WebGLBuffer} texCoord
 */
function ProgramGeometry(gl, location)
{
    /** @type {WebGLVertexArrayObject} Vertex Array Object */
    this.vao = gl.createVertexArray();

    /** @type {BufferOfAttributes} Vertex Buffer Objects */
    this.vbo = Object.freeze({
        position: gl.createBuffer(),
        texCoord: gl.createBuffer()
    });

    /** @type {WebGL2RenderingContext} */
    this._gl = gl;



    // bind the VAO
    gl.bindVertexArray(this.vao);

    // set the position attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.position);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // clip coordinates (CCW)
        -1, -1,
        1, -1,
        -1, 1,

        -1, 1,
        1, -1,
        1, 1,
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(location.position);
    gl.vertexAttribPointer(location.position, // attribute location
                            2,                // 2 components per vertex (x,y)
                            gl.FLOAT,         // type
                            false,            // don't normalize
                            0,                // default stride (tightly packed)
                            0);               // offset

    // set the texCoord attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.texCoord);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // texture coordinates (CCW)
        0, 0,
        1, 0,
        0, 1,

        0, 1,
        1, 0,
        1, 1,
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(location.texCoord);
    gl.vertexAttribPointer(location.texCoord, // attribute location
                            2,                // 2 components per vertex (x,y)
                            gl.FLOAT,         // type
                            false,            // don't normalize
                            0,                // default stride (tightly packed)
                            0);               // offset

    // unbind
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindVertexArray(null);

    // done!
    return Object.freeze(this);
}

/**
 * Releases the internal resources
 * @returns {null}
 */
ProgramGeometry.prototype.release = function()
{
    const gl = this._gl;

    gl.deleteVertexArray(this.vao);
    gl.deleteBuffer(this.vbo.position);
    gl.deleteBuffer(this.vbo.texCoord);

    return null;
}





/**
 * Helper class for storing data in GLSL uniform variables
 * @param {string} type
 * @param {WebGLUniformLocation} location
 */
function UniformVariable(type, location)
{
    /** @type {string} GLSL data type */
    this.type = String(type);
    if(!Object.prototype.hasOwnProperty.call(UNIFORM_SETTERS, this.type))
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.NotSupportedError(`Unsupported uniform type: ${this.type}`);

    /** @type {WebGLUniformLocation} uniform location in a WebGL program */
    this.location = location;

    /** @type {string} setter function */
    this.setter = UNIFORM_SETTERS[this.type];
    const n = Number((this.setter.match(/^uniform(Matrix)?(\d)/))[2]) | 0;

    /** @type {number} is the uniform a scalar (0), a vector (1) or a matrix (2)? */
    this.dim = this.type.startsWith('mat') ? 2 : ((this.type.indexOf('vec') >= 0) ? 1 : 0);

    /** @type {number} required number of scalars */
    this.length = (this.dim == 2) ? n * n : n;

    /** @type {SpeedyProgramUniformValue|null} cached value */
    this._value = null;
}

/**
 * Set the value of a uniform variable
 * @param {WebGL2RenderingContext} gl
 * @param {SpeedyProgramUniformValue} value use column-major format for matrices
 * @param {number} [texNo] current texture index
 * @returns {number} new texture index
 */
UniformVariable.prototype.setValue = function(gl, value, texNo = -1)
{
    const setValue = /** @type {Function} */ ( gl[this.setter] );

    // check uniform type
    if(typeof value === 'object' && this.type.endsWith('sampler2D')) {
        // set texture
        if(texNo >= gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.NotSupportedError(`Can't activate texture unit ${texNo}: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);
        else if(Array.isArray(value))
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.NotSupportedError(`Can't pass arrays of textures to shaders`);
        else if(value == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalArgumentError(`Can't run shader: cannot use ${value} as an input texture`);
        else if(texNo < 0)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalArgumentError(`Missing texNo`);

        const tex = value;
        gl.activeTexture(gl.TEXTURE0 + texNo);
        gl.bindTexture(gl.TEXTURE_2D, tex.glTexture);
        gl.uniform1i(this.location, texNo);

        texNo++;
    }
    else if(value === this._value) {
        // do not update the uniform if it hasn't changed
        void(0);
    }
    else if(typeof value === 'number' || typeof value === 'boolean') {
        // set scalar value
        setValue.call(gl, this.location, value);
    }
    else if(Array.isArray(value)) {
        // set vector or matrix
        if(value.length === this.length) {
            if(this.dim == 2)
                setValue.call(gl, this.location, false, value); // matrix
            else
                setValue.call(gl, this.location, ...value); // vector
        }
        else
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalArgumentError(`Can't run shader: incorrect number of values for ${this.type}: "${value}"`);
    }
    else
        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_4__.IllegalArgumentError(`Can't run shader: unrecognized argument "${value}"`);

    // cache the value
    this._value = value;

    // done
    return texNo;
}




/**
 * @typedef {object} UBOStuff
 * @property {WebGLBuffer} buffer
 * @property {number} blockBindingIndex "global" binding index
 * @property {number} blockIndex UBO "location" in the program
 * @property {ArrayBufferView|null} data user-data
 */

/**
 * A helper class for handling Uniform Buffer Objects (UBOs)
 * @param {WebGL2RenderingContext} gl
 * @param {WebGLProgram} program
 */
function UBOHelper(gl, program)
{
    /** @type {WebGL2RenderingContext} */
    this._gl = gl;

    /** @type {WebGLProgram} */
    this._program = program;

    /** @type {number} auto-increment counter */
    this._nextIndex = 0;

    /** @type {Object<string,UBOStuff>} UBO dictionary indexed by uniform block names */
    this._ubo = Object.create(null);
}

/**
 * Set Uniform Buffer Object data
 * (the buffer will be uploaded when the program is executed)
 * @param {string} name uniform block name
 * @param {ArrayBufferView} data
 */
UBOHelper.prototype.set = function(name, data)
{
    const gl = this._gl;

    // create UBO entry
    if(this._ubo[name] === undefined) {
        this._ubo[name] = {
            buffer: gl.createBuffer(),
            blockBindingIndex: this._nextIndex++,
            blockIndex: -1,
            data: null
        };
    }

    // get UBO entry for the given block name
    const ubo = this._ubo[name];

    // read block index & assign binding point
    if(ubo.blockIndex < 0) {
        const blockIndex = gl.getUniformBlockIndex(this._program, name); // GLuint
        gl.uniformBlockBinding(this._program, blockIndex, ubo.blockBindingIndex);
        ubo.blockIndex = blockIndex;
    }

    // store the data - we'll upload it later
    ubo.data = data;
}

/**
 * Update UBO data
 * Called when we're using the appropriate WebGLProgram
 */
UBOHelper.prototype.update = function()
{
    const gl = this._gl;

    for(const name in this._ubo) {
        const ubo = this._ubo[name];

        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo.buffer);
        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data, gl.DYNAMIC_DRAW);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, ubo.blockBindingIndex, ubo.buffer);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    }
}

/**
 * Release allocated buffers
 * @returns {null}
 */
UBOHelper.prototype.release = function()
{
    const gl = this._gl;

    for(const name in this._ubo) {
        const ubo = this._ubo[name];

        gl.deleteBuffer(ubo.buffer);
        ubo.data = null;
    }

    return null;
}


/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-texture-pool.js":
/*!*******************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-texture-pool.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyTexturePool: () => (/* binding */ SpeedyTexturePool)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-texture-pool.js
 * Texture pool
 */






// Constants
const DEFAULT_CAPACITY = 1024;
const BUCKET = Symbol('Bucket');


/*

=== Heuristics to figure out the capacity of a texture pool ===

1. Decide the maximum amount of VRAM you'd like to use in a pool (say, 64 MB).

2. Figure out the average texture size in your application (say, 640x360 pixels).

3. Figure out the average texture size in bytes (say, 921600 bytes). Each pixel
   uses 4 bytes (RGBA format).

4. Divide the maximum amount of VRAM by the average texture size in bytes
   (say, 72). That's the capacity of the pool.

Note that textures are allocated lazily, so VRAM usage is kept to a minimum.

Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices

*/



/**
 * @typedef {number} TextureBucketIndex index of a bucket in a pool
 */



/**
 * A bucket
 */
class TextureBucket
{
    /**
     * Constructor
     * @param {SpeedyDrawableTexture} texture managed texture
     * @param {TextureBucketIndex} index index of this bucket
     * @param {TextureBucketIndex} next index of the next bucket
     */
    constructor(texture, index, next)
    {
        /** @type {SpeedyDrawableTexture} managed texture */
        this.texture = texture;

        /** @type {TextureBucketIndex} index of this bucket */
        this.index = index;

        /** @type {TextureBucketIndex} index of the next bucket */
        this.next = next;

        /** @type {boolean} whether the texture is available or not */
        this.free = true;
    }
}



/**
 * Texture pool
 */
class SpeedyTexturePool
{
    /**
     * Constructor
     * @param {SpeedyGPU} gpu
     * @param {number} [capacity] number of textures in the pool
     */
    constructor(gpu, capacity = DEFAULT_CAPACITY)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(capacity > 0);

        /** @type {TextureBucket[]} buckets */
        this._bucket = Array.from({ length: capacity }, (_, i) => new TextureBucket(null, i, i - 1));

        /** @type {TextureBucketIndex} index of an available bucket */
        this._head = capacity - 1;

        /** @type {SpeedyGPU} GPU instance */
        this._gpu = gpu;
    }

    /**
     * Get a texture from the pool
     * @returns {SpeedyDrawableTexture}
     */
    allocate()
    {
        if(this._head < 0)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_3__.OutOfMemoryError(`Exhausted pool (capacity: ${this._bucket.length})`);

        const bucket = this._bucket[this._head];
        bucket.free = false;
        this._head = bucket.next;

        if(bucket.texture == null) // lazy instantiation
            bucket.texture = SpeedyTexturePool._createManagedTexture(this._gpu.gl, bucket);

        return bucket.texture;
    }

    /**
     * Put a texture back in the pool
     * @param {SpeedyDrawableTexture} texture
     * @returns {null}
     */
    free(texture)
    {
        const bucket = texture[BUCKET];
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(bucket !== undefined && !bucket.free, `Unmanaged texture or double free`);

        bucket.next = this._head;
        bucket.free = true;
        this._head = bucket.index;

        return null;
    }

    /**
     * Release the texture pool
     * @returns {null}
     */
    release()
    {
        for(let i = 0; i < this._bucket.length; i++) {
            if(this._bucket[i].texture != null)
                this._bucket[i].texture = this._bucket[i].texture.release();
        }

        return null;
    }

    /**
     * Create a texture with a reference to a bucket
     * @param {WebGL2RenderingContext} gl
     * @param {TextureBucket} bucket
     * @returns {SpeedyDrawableTexture}
     */
    static _createManagedTexture(gl, bucket)
    {
        const texture = new _speedy_texture__WEBPACK_IMPORTED_MODULE_2__.SpeedyDrawableTexture(gl, 1, 1);
        return Object.defineProperty(texture, BUCKET, {
            configurable: false,
            enumerable: false,
            writable: false,
            value: bucket
        });
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-texture-reader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-texture-reader.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyTextureReader: () => (/* binding */ SpeedyTextureReader)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _core_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/settings */ "./node_modules/speedy-vision/src/core/settings.js");
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _core_speedy_promise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _utils_asap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/asap */ "./node_modules/speedy-vision/src/utils/asap.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-texture-reader.js
 * Reads data from textures
 */









/** @type {number} number of PBOs; used to get a performance boost in gl.readPixels() */
const DEFAULT_NUMBER_OF_BUFFERS = 2;

/** @type {(fn: Function, ...args: any[]) => number} Run function fn on the "next frame" */
const runOnNextFrame = navigator.userAgent.includes('Firefox') ?
    ((fn, ...args) => setTimeout(fn, 10, ...args)) : // RAF produces a warning on Firefox
    ((fn, ...args) => requestAnimationFrame(() => fn.apply(undefined, args))); // reduce battery usage

/**
 * Reads data from textures
 */
class SpeedyTextureReader
{
    /**
     * Constructor
     * @param {number} [numberOfBuffers]
     */
    constructor(numberOfBuffers = DEFAULT_NUMBER_OF_BUFFERS)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(numberOfBuffers > 0);

        /** @type {boolean} is this object initialized? */
        this._initialized = false;

        /** @type {Uint8Array[]} pixel buffers for data transfers (each stores RGBA data) */
        this._pixelBuffer = (new Array(numberOfBuffers)).fill(null).map(() => new Uint8Array(0));

        /** @type {WebGLBuffer[]} Pixel Buffer Objects (PBOs) */
        this._pbo = (new Array(numberOfBuffers)).fill(null);

        /** @type {number} the index of the buffer that will be consumed in this frame */
        this._consumerIndex = 0;

        /** @type {number} the index of the buffer that will be produced next */
        this._producerIndex = numberOfBuffers - 1;

        /** @type {SpeedyPromise<void>[]} producer-consumer promises */
        this._promise = Array.from({ length: numberOfBuffers }, () => _core_speedy_promise__WEBPACK_IMPORTED_MODULE_3__.SpeedyPromise.resolve());

        /** @type {boolean[]} are the contents of the ith buffer being produced? */
        this._busy = (new Array(numberOfBuffers)).fill(false);

        /** @type {boolean[]} can the ith buffer be consumed? */
        this._ready = (new Array(numberOfBuffers)).fill(true);
    }

    /**
     * Initialize this object
     * @param {SpeedyGPU} gpu
     */
    init(gpu)
    {
        this._allocatePBOs(gpu);
        gpu.subscribe(this._allocatePBOs, this, gpu);

        this._initialized = true;
    }

    /**
     * Release resources
     * @param {SpeedyGPU} gpu
     * @returns {null}
     */
    release(gpu)
    {
        gpu.unsubscribe(this._allocatePBOs, this);
        this._deallocatePBOs(gpu);

        this._initialized = false;
        return null;
    }

    /**
     * Read pixels from a texture, synchronously.
     * You may optionally specify a (x,y,width,height) sub-rectangle.
     * @param {SpeedyDrawableTexture} texture a texture with a FBO
     * @param {number} [x]
     * @param {number} [y] 
     * @param {number} [width]
     * @param {number} [height]
     * @returns {Uint8Array} pixels in the RGBA format
     */
    readPixelsSync(texture, x = 0, y = 0, width = texture.width, height = texture.height)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._initialized);

        const gl = texture.gl;
        const fbo = texture.glFbo;

        // clamp values
        width = Math.max(0, Math.min(width, texture.width));
        height = Math.max(0, Math.min(height, texture.height));
        x = Math.max(0, Math.min(x, texture.width - width));
        y = Math.max(0, Math.min(y, texture.height - height));

        // buffer allocation
        const sizeofBuffer = width * height * 4; // 4 bytes per pixel (RGBA)
        this._reallocate(sizeofBuffer);

        // lost context?
        if(gl.isContextLost())
            return this._pixelBuffer[0].subarray(0, sizeofBuffer);

        // read pixels
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // done!
        return this._pixelBuffer[0].subarray(0, sizeofBuffer);
    }

    /**
     * Read pixels from a texture, asynchronously, with PBOs.
     * You may optionally specify a (x,y,width,height) sub-rectangle.
     * @param {SpeedyDrawableTexture} texture a texture with a FBO
     * @param {number} [x]
     * @param {number} [y] 
     * @param {number} [width]
     * @param {number} [height]
     * @param {boolean} [useBufferedDownloads] accelerate downloads by returning pixels from the texture of the previous call (useful for streaming)
     * @returns {SpeedyPromise<Uint8Array>} resolves to an array of pixels in the RGBA format
     */
    readPixelsAsync(texture, x = 0, y = 0, width = texture.width, height = texture.height, useBufferedDownloads = false)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(this._initialized);

        const gl = texture.gl;
        const fbo = texture.glFbo;

        // clamp values
        width = Math.max(0, Math.min(width, texture.width));
        height = Math.max(0, Math.min(height, texture.height));
        x = Math.max(0, Math.min(x, texture.width - width));
        y = Math.max(0, Math.min(y, texture.height - height));

        // buffer allocation
        const sizeofBuffer = width * height * 4; // 4 bytes per pixel (RGBA)
        this._reallocate(sizeofBuffer);

        // lost context?
        if(gl.isContextLost())
            return _core_speedy_promise__WEBPACK_IMPORTED_MODULE_3__.SpeedyPromise.resolve(this._pixelBuffer[0].subarray(0, sizeofBuffer));

        // do not optimize?
        if(!useBufferedDownloads) {
            const pixelBuffer = this._pixelBuffer[0].subarray(0, sizeofBuffer);
            return SpeedyTextureReader._readPixelsViaPBO(gl, this._pbo[0], pixelBuffer, fbo, x, y, width, height).then(() =>
                pixelBuffer
            );
        }

        // Hide latency with a Producer-Consumer mechanism
        const numberOfBuffers = this._pixelBuffer.length;

        // GPU needs to produce data
        const producerIndex = this._producerIndex;

        if(!this._busy[producerIndex]) {
            const pbo = this._pbo[producerIndex];
            const pixelBuffer = this._pixelBuffer[producerIndex].subarray(0, sizeofBuffer);

            this._producerIndex = (producerIndex + 1) % numberOfBuffers;

            this._ready[producerIndex] = false;
            this._busy[producerIndex] = true;
            //console.time("produce "+producerIndex);
            this._promise[producerIndex] = SpeedyTextureReader._readPixelsViaPBO(gl, pbo, pixelBuffer, fbo, x, y, width, height).then(() => {
                //console.timeEnd("produce "+producerIndex);
                this._busy[producerIndex] = false;
                this._ready[producerIndex] = true;
            });
        }
        //else console.log("skip",producerIndex);
        else /* skip frame */ ;

        // CPU needs to consume data
        const consumerIndex = this._consumerIndex;
        this._consumerIndex = (consumerIndex + 1) % numberOfBuffers;

        if(!this._ready[consumerIndex]) {
            //console.time("consume "+consumerIndex);
            return this._promise[consumerIndex].then(() => {
                //console.timeEnd("consume "+consumerIndex);
                this._ready[consumerIndex] = false;
                return this._pixelBuffer[consumerIndex];
            });
        }

        //console.log("NO WAIT "+consumerIndex);
        this._ready[consumerIndex] = false;
        return _core_speedy_promise__WEBPACK_IMPORTED_MODULE_3__.SpeedyPromise.resolve(this._pixelBuffer[consumerIndex]);
    }

    /**
     * Reallocate the pixel buffers, so that they can hold the required number of bytes
     * If the pixel buffers already have the required capacity, then nothing is done
     * @param {number} size in bytes
     */
    _reallocate(size)
    {
        // no need to reallocate
        if(size <= this._pixelBuffer[0].byteLength)
            return;

        // reallocate
        for(let i = 0; i < this._pixelBuffer.length; i++) {
            const newBuffer = new Uint8Array(size);
            //newBuffer.set(this._pixelBuffer[i]); // make this optional?
            this._pixelBuffer[i] = newBuffer;
        }
    }

    /**
     * Allocate PBOs
     * @param {SpeedyGPU} gpu
     */
    _allocatePBOs(gpu)
    {
        const gl = gpu.gl;

        for(let i = 0; i < this._pbo.length; i++)
            this._pbo[i] = gl.createBuffer();
    }

    /**
     * Deallocate PBOs
     * @param {SpeedyGPU} gpu
     */
    _deallocatePBOs(gpu)
    {
        const gl = gpu.gl;

        for(let i = this._pbo.length - 1; i >= 0; i--) {
            gl.deleteBuffer(this._pbo[i]);
            this._pbo[i] = null;
        }
    }

    /**
     * Read pixels to a Uint8Array, asynchronously, using a Pixel Buffer Object (PBO)
     * It's assumed that the target texture is in the RGBA8 format
     * @param {WebGL2RenderingContext} gl
     * @param {WebGLBuffer} pbo
     * @param {Uint8Array} outputBuffer with size >= width * height * 4
     * @param {WebGLFramebuffer} fbo
     * @param {GLint} x
     * @param {GLint} y
     * @param {GLsizei} width
     * @param {GLsizei} height
     * @returns {SpeedyPromise<void>}
     */
    static _readPixelsViaPBO(gl, pbo, outputBuffer, fbo, x, y, width, height)
    {
        /*

        When testing Speedy on Chrome (mobile) using about:tracing with the
        --enable-gpu-service-tracing flag, I found that A LOT of time is spent
        in TraceGLAPI::glMapBufferRange, which takes place just after
        GLES2DecoderImpl::HandleReadPixels and GLES2DecoderImpl::glReadPixels.

        Using multiple PBOs doesn't seem to impact Chrome too much. Performance
        is much better on Firefox. This suggests there is room for improvement.
        I do not yet understand clearly the cause for this lag on Chrome. It
        may be a CPU-GPU synchronization issue.

        EDIT: I have found that using gl.flush() aggressively greatly improves
              things. WebGL commands will be pushed frequently!

        See also:
        https://www.khronos.org/registry/webgl/specs/latest/2.0/#3.7.3 (Buffer objects)
        https://github.com/chromium/chromium/blob/master/docs/gpu/debugging_gpu_related_code.md

        */
        const size = width * height * 4;

        // validate outputBuffer
        _utils_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.assert(outputBuffer.byteLength >= size, `Invalid buffer size`);

        // read pixels into the PBO
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);
        gl.bufferData(gl.PIXEL_PACK_BUFFER, size, gl.DYNAMIC_READ);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);

        // create a fence
        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
        gl.flush(); // make sure the sync command is read

        // wait for the commands to be processed by the GPU
        return new _core_speedy_promise__WEBPACK_IMPORTED_MODULE_3__.SpeedyPromise((resolve, reject) => {

            // according to the WebGL2 spec sec 3.7.14 Sync objects,
            // "sync objects may only transition to the signaled state
            // when the user agent's event loop is not executing a task"
            // in other words, it won't be signaled in the same frame
            if(_core_settings__WEBPACK_IMPORTED_MODULE_1__.Settings.gpuPollingMode != 'asap')
                runOnNextFrame(SpeedyTextureReader._clientWaitAsync, gl, sync, 0, resolve, reject);
            else
                (0,_utils_asap__WEBPACK_IMPORTED_MODULE_5__.asap)(SpeedyTextureReader._clientWaitAsync, gl, sync, 0, resolve, reject);

        }).then(() => {
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);
            gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
        }).catch(err => {
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_6__.IllegalOperationError(`Can't getBufferSubDataAsync(): error in clientWaitAsync()`, err);
        }).finally(() => {
            gl.deleteSync(sync);
        });
    }

    /**
     * Waits for a sync object to become signaled
     * @param {WebGL2RenderingContext} gl
     * @param {WebGLSync} sync
     * @param {GLbitfield} flags may be gl.SYNC_FLUSH_COMMANDS_BIT or 0
     * @param {Function} resolve
     * @param {Function} reject
     * @param {number} [pollInterval] in milliseconds
     * @param {number} [remainingAttempts] for timeout
     */
    static _clientWaitAsync(gl, sync, flags, resolve, reject, pollInterval = 10, remainingAttempts = 1000)
    {
        (function poll() {
            const status = gl.clientWaitSync(sync, flags, 0);

            if(remainingAttempts-- <= 0) {
                reject(new _utils_errors__WEBPACK_IMPORTED_MODULE_6__.TimeoutError(`GPU polling timeout`, _utils_errors__WEBPACK_IMPORTED_MODULE_6__.GLError.from(gl)));
            }
            else if(status === gl.CONDITION_SATISFIED || status === gl.ALREADY_SIGNALED) {
                resolve();
            }
            else {
                //setTimeout(poll, pollInterval);
                if(_core_settings__WEBPACK_IMPORTED_MODULE_1__.Settings.gpuPollingMode != 'asap')
                    requestAnimationFrame(poll); // RAF is a rather unusual way to do polling at ~60 fps. Does it reduce CPU usage?
                else
                    (0,_utils_asap__WEBPACK_IMPORTED_MODULE_5__.asap)(poll);
            }
        })();
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-texture-uploader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-texture-uploader.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyTextureUploader: () => (/* binding */ SpeedyTextureUploader)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _speedy_texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var _core_speedy_media_source__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/speedy-media-source */ "./node_modules/speedy-vision/src/core/speedy-media-source.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-texture-uploader.js
 * A utility that helps uploading data to textures
 */





/**
 * A utility that helps uploading data to textures
 */
class SpeedyTextureUploader
{
    /**
     * Constructor
     * @param {SpeedyGPU} gpu
     */
    constructor(gpu)
    {
        /** @type {SpeedyGPU} GPU instance */
        this._gpu = gpu;
    }

    /**
     * Upload an image to the GPU
     * @param {SpeedyMediaSource} source
     * @param {SpeedyTexture} outputTexture
     * @returns {SpeedyTexture} output texture
     */
    upload(source, outputTexture)
    {
        const data = source.data;

        // bugfix: if the media is a video, we can't really
        // upload it to the GPU unless it's ready
        //if(data.constructor.name == 'HTMLVideoElement') {
        if(data instanceof HTMLVideoElement) {
            if(data.readyState < 2) {
                // this may happen when the video loops (Firefox)
                // return the previously uploaded texture
                //Utils.warning(`Trying to process a video that isn't ready yet`);
                return outputTexture;
            }
        }

        // upload to the output texture
        return outputTexture.upload(data, source.width, source.height);
    }

    /**
     * Release the texture uploader
     * @returns {null}
     */
    release()
    {
        return null;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/speedy-texture.js":
/*!**************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/speedy-texture.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedyDrawableTexture: () => (/* binding */ SpeedyDrawableTexture),
/* harmony export */   SpeedyTexture: () => (/* binding */ SpeedyTexture)
/* harmony export */ });
/* harmony import */ var _speedy_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/globals */ "./node_modules/speedy-vision/src/utils/globals.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * speedy-texture.js
 * A wrapper around WebGLTexture
 */






/**
 * Get a buffer filled with zeros
 * @param {number} size number of bytes
 * @returns {Uint8Array}
 */
/*
const zeros = (function() {
    let buffer = new Uint8Array(4);

    return function(size) {
        if(size > buffer.length)
            buffer = new Uint8Array(size);

        return buffer.subarray(0, size);
    }
})();
*/

/**
 * A wrapper around WebGLTexture
 */
class SpeedyTexture
{
    /**
     * Constructor
     * @param {WebGL2RenderingContext} gl
     * @param {number} width texture width in pixels
     * @param {number} height texture height in pixels
     * @param {number} [format]
     * @param {number} [internalFormat]
     * @param {number} [dataType]
     * @param {number} [filter]
     * @param {number} [wrap]
     */
    constructor(gl, width, height, format = gl.RGBA, internalFormat = gl.RGBA8, dataType = gl.UNSIGNED_BYTE, filter = gl.NEAREST, wrap = gl.MIRRORED_REPEAT)
    {
        /** @type {WebGL2RenderingContext} rendering context */
        this._gl = gl;

        /** @type {number} width of the texture */
        this._width = Math.max(1, width | 0);

        /** @type {number} height of the texture */
        this._height = Math.max(1, height | 0);

        /** @type {boolean} have we generated mipmaps for this texture? */
        this._hasMipmaps = false;

        /** @type {number} texture format */
        this._format = format;

        /** @type {number} internal format (usually a sized format) */
        this._internalFormat = internalFormat;

        /** @type {number} data type */
        this._dataType = dataType;

        /** @type {number} texture filtering (min & mag) */
        this._filter = filter;

        /** @type {number} texture wrapping */
        this._wrap = wrap;

        /** @type {WebGLTexture} internal texture object */
        this._glTexture = SpeedyTexture._createTexture(this._gl, this._width, this._height, this._format, this._internalFormat, this._dataType, this._filter, this._wrap);
    }

    /**
     * Releases the texture
     * @returns {null}
     */
    release()
    {
        const gl = this._gl;

        // already released?
        if(this._glTexture == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalOperationError(`The SpeedyTexture has already been released`);

        // release resources
        this.discardMipmaps();
        gl.deleteTexture(this._glTexture);
        this._glTexture = null;
        this._width = this._height = 0;

        // done!
        return null;
    }

    /**
     * Upload pixel data to the texture. The texture will be resized if needed.
     * @param {TexImageSource} pixels
     * @param {number} [width] in pixels
     * @param {number} [height] in pixels
     * @return {SpeedyTexture} this
     */
    upload(pixels, width = this._width, height = this._height)
    {
        const gl = this._gl;
        _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.assert(width > 0 && height > 0);

        this.discardMipmaps();
        this._width = width;
        this._height = height;
        this._internalFormat = gl.RGBA8;
        this._format = gl.RGBA;
        this._dataType = gl.UNSIGNED_BYTE;

        SpeedyTexture._upload(gl, this._glTexture, this._width, this._height, pixels, 0, this._format, this._internalFormat, this._dataType);
        return this;
    }

    /**
     * Clear the texture
     * @returns {this}
     */
    clear()
    {
        const gl = this._gl;

        // context loss?
        if(gl.isContextLost())
            return this;

        // clear texture data
        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this._width, this._height, 0, this._format, this._dataType, null);
        gl.bindTexture(gl.TEXTURE_2D, null);

        // no mipmaps
        this.discardMipmaps();

        // done!
        return this;
    }

    /**
     * Resize this texture. Its content will be lost!
     * @param {number} width new width, in pixels
     * @param {number} height new height, in pixels
     * @returns {this}
     */
    resize(width, height)
    {
        const gl = this._gl;

        // no need to resize?
        if(this._width === width && this._height === height)
            return this;

        // validate size
        width |= 0; height |= 0;
        if(width > _utils_globals__WEBPACK_IMPORTED_MODULE_3__.MAX_TEXTURE_LENGTH || height > _utils_globals__WEBPACK_IMPORTED_MODULE_3__.MAX_TEXTURE_LENGTH)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.NotSupportedError(`Maximum texture size exceeded. Using ${width} x ${height}, expected up to ${_utils_globals__WEBPACK_IMPORTED_MODULE_3__.MAX_TEXTURE_LENGTH} x ${_utils_globals__WEBPACK_IMPORTED_MODULE_3__.MAX_TEXTURE_LENGTH}.`);
        else if(width < 1 || height < 1)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalArgumentError(`Invalid texture size: ${width} x ${height}`);

        // context loss?
        if(gl.isContextLost())
            return this;

        // update dimensions
        this._width = width;
        this._height = height;

        // resize
        // Note: this is fast on Chrome, but seems slow on Firefox
        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this._width, this._height, 0, this._format, this._dataType, null);
        gl.bindTexture(gl.TEXTURE_2D, null);

        // no mipmaps
        this.discardMipmaps();

        // done!
        return this;
    }

    /**
     * Generate mipmap
     * @param {SpeedyDrawableTexture[]} [mipmap] custom texture for each mip level
     * @returns {SpeedyTexture} this
     */
    generateMipmaps(mipmap = [])
    {
        const gl = this._gl;

        // nothing to do
        if(this._hasMipmaps)
            return this;

        // let the hardware compute the all levels of the pyramid, up to 1x1
        // we also specify the TEXTURE_MIN_FILTER to be used from now on
        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);

        // accept custom textures
        if(mipmap.length > 0) {
            // expected number of mipmap levels according to the OpenGL ES 3.0 spec (sec 3.8.10.4)
            const width = this.width, height = this.height;
            const numMipmaps = 1 + Math.floor(Math.log2(Math.max(width, height)));
            _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.assert(mipmap.length <= numMipmaps);

            // verify the dimensions of each level
            for(let level = 1; level < mipmap.length; level++) {
                // use max(1, floor(size / 2^lod)), in accordance to
                // the OpenGL ES 3.0 spec sec 3.8.10.4 (Mipmapping)
                const w = Math.max(1, width >>> level);
                const h = Math.max(1, height >>> level);

                // verify the dimensions of this level
                _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.assert(mipmap[level].width === w && mipmap[level].height === h);

                // copy to mipmap
                mipmap[level].copyTo(this, level);
            }
        }

        // done!
        this._hasMipmaps = true;
        return this;
    }

    /**
     * Invalidates previously generated mipmap, if any
     */
    discardMipmaps()
    {
        const gl = this._gl;

        // nothing to do
        if(!this._hasMipmaps)
            return;

        // reset the min filter
        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._filter);
        gl.bindTexture(gl.TEXTURE_2D, null);

        // done!
        this._hasMipmaps = false;
    }

    /**
     * Does this texture have a mipmap?
     * @returns {boolean}
     */
    hasMipmaps()
    {
        return this._hasMipmaps;
    }

    /**
     * Has this texture been released?
     * @returns {boolean}
     */
    isReleased()
    {
        return this._glTexture == null;
    }

    /**
     * The internal WebGLTexture
     * @returns {WebGLTexture}
     */
    get glTexture()
    {
        return this._glTexture;
    }

    /**
     * The width of the texture, in pixels
     * @returns {number}
     */
    get width()
    {
        return this._width;
    }

    /**
     * The height of the texture, in pixels
     * @returns {number}
     */
    get height()
    {
        return this._height;
    }

    /**
     * The WebGL Context
     * @returns {WebGL2RenderingContext}
     */
    get gl()
    {
        return this._gl;
    }

    /**
     * Create a WebGL texture
     * @param {WebGL2RenderingContext} gl
     * @param {number} width in pixels
     * @param {number} height in pixels
     * @param {number} format usually gl.RGBA
     * @param {number} internalFormat usually gl.RGBA8
     * @param {number} dataType usually gl.UNSIGNED_BYTE
     * @param {number} filter usually gl.NEAREST or gl.LINEAR
     * @param {number} wrap gl.REPEAT, gl.MIRRORED_REPEAT or gl.CLAMP_TO_EDGE
     * @returns {WebGLTexture}
     */
    static _createTexture(gl, width, height, format, internalFormat, dataType, filter, wrap)
    {
        _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.assert(width > 0 && height > 0);

        // create & bind texture
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // setup
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
        //gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat, width, height);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, dataType, null);

        // unbind & return
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Upload pixel data to a WebGL texture
     * @param {WebGL2RenderingContext} gl
     * @param {WebGLTexture} texture
     * @param {GLsizei} width texture width
     * @param {GLsizei} height texture height
     * @param {TexImageSource} pixels
     * @param {GLint} lod mipmap level-of-detail
     * @param {number} format
     * @param {number} internalFormat
     * @param {number} dataType
     * @returns {WebGLTexture} texture
     */
    static _upload(gl, texture, width, height, pixels, lod, format, internalFormat, dataType)
    {
        // Prefer calling _upload() before gl.useProgram() to avoid the
        // needless switching of GL programs internally. See also:
        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
        gl.bindTexture(gl.TEXTURE_2D, texture);

        /*
        // slower than texImage2D, unlike the spec?
        gl.texSubImage2D(gl.TEXTURE_2D,     // target
                         lod,               // mip level
                         0,                 // x-offset
                         0,                 // y-offset
                         width,             // texture width
                         height,            // texture height
                         gl.RGBA,           // source format
                         gl.UNSIGNED_BYTE,  // source type
                         pixels);           // source data
        */

        gl.texImage2D(gl.TEXTURE_2D,        // target
                      lod,                  // mip level
                      internalFormat,       // internal format
                      width,                // texture width
                      height,               // texture height
                      0,                    // border
                      format,               // source format
                      dataType,             // source type
                      pixels);              // source data

        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
}

/**
 * A SpeedyTexture with a framebuffer
 */
class SpeedyDrawableTexture extends SpeedyTexture
{
    /**
     * Constructor
     * @param {WebGL2RenderingContext} gl
     * @param {number} width texture width in pixels
     * @param {number} height texture height in pixels
     * @param {number} [format]
     * @param {number} [internalFormat]
     * @param {number} [dataType]
     * @param {number} [filter]
     * @param {number} [wrap]
     */
    constructor(gl, width, height, format = undefined, internalFormat = undefined, dataType = undefined, filter = undefined, wrap = undefined)
    {
        super(gl, width, height, format, internalFormat, dataType, filter, wrap);

        /** @type {WebGLFramebuffer} framebuffer */
        this._glFbo = SpeedyDrawableTexture._createFramebuffer(gl, this._glTexture);
    }

    /**
     * Releases the texture
     * @returns {null}
     */
    release()
    {
        const gl = this._gl;

        // already released?
        if(this._glFbo == null)
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.IllegalOperationError(`The SpeedyDrawableTexture has already been released`);

        // release the framebuffer
        gl.deleteFramebuffer(this._glFbo);
        this._glFbo = null;

        // release the SpeedyTexture
        return super.release();
    }

    /**
     * The internal WebGLFramebuffer
     * @returns {WebGLFramebuffer}
     */
    get glFbo()
    {
        return this._glFbo;
    }

    /**
     * Copy this texture into another
     * (you may have to discard the mipmaps after calling this function)
     * @param {SpeedyTexture} texture target texture
     * @param {number} [lod] level-of-detail of the target texture
     */
    copyTo(texture, lod = 0)
    {
        const gl = this._gl;

        // context loss?
        if(gl.isContextLost())
            return;

        // compute texture size as max(1, floor(size / 2^lod)),
        // in accordance to the OpenGL ES 3.0 spec sec 3.8.10.4
        // (Mipmapping)
        const pot = 1 << (lod |= 0);
        const expectedWidth = Math.max(1, Math.floor(texture.width / pot));
        const expectedHeight = Math.max(1, Math.floor(texture.height / pot));

        // validate
        _utils_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.assert(this._width === expectedWidth && this._height === expectedHeight);

        // copy to texture
        SpeedyDrawableTexture._copyToTexture(gl, this._glFbo, texture.glTexture, 0, 0, this._width, this._height, lod);
    }

    /*
     * Resize this texture
     * @param {number} width new width, in pixels
     * @param {number} height new height, in pixels
     * @param {boolean} [preserveContent] should we preserve the content of the texture? EXPENSIVE!
     * @returns {this}
     */
    /*resize(width, height, preserveContent = false)
    {
        const gl = this._gl;

        // no need to preserve the content?
        if(!preserveContent)
            return super.resize(width, height);

        // no need to resize?
        if(this._width === width && this._height === height)
            return this;

        // validate size
        width |= 0; height |= 0;
        Utils.assert(width > 0 && height > 0);

        // context loss?
        if(gl.isContextLost())
            return this;

        // allocate new texture
        const newTexture = SpeedyTexture._createTexture(gl, width, height);

        // initialize the new texture with zeros to avoid a
        // warning when calling copyTexSubImage2D() on Firefox
        // this may not be very efficient?
        SpeedyTexture._upload(gl, newTexture, width, height, zeros(width * height * 4)); // RGBA: 4 bytes per pixel

        // copy the old texture to the new one
        const oldWidth = this._width, oldHeight = this._height;
        SpeedyDrawableTexture._copyToTexture(gl, this._glFbo, newTexture, 0, 0, Math.min(width, oldWidth), Math.min(height, oldHeight), 0);

        // bind FBO
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFbo);

        // invalidate old data (is this needed?)
        gl.invalidateFramebuffer(gl.FRAMEBUFFER, [gl.COLOR_ATTACHMENT0]);

        // attach the new texture to the existing framebuffer
        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target
                                gl.COLOR_ATTACHMENT0,   // color buffer
                                gl.TEXTURE_2D,          // tex target
                                newTexture,             // texture
                                0);                     // mipmap level

        // unbind FBO
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // release the old texture and replace it
        gl.deleteTexture(this._glTexture);
        this._glTexture = newTexture;

        // update dimensions & discard mipmaps
        this.discardMipmaps();
        this._width = width;
        this._height = height;

        // done!
        return this;
    }
    */

    /**
     * Clear the texture
     * @returns {this}
     */
    clear()
    {
        //
        // When we pass null to texImage2D(), it seems that Firefox
        // doesn't clear the texture. Instead, it displays this warning:
        //
        // "WebGL warning: drawArraysInstanced:
        //  Tex image TEXTURE_2D level 0 is incurring lazy initialization."
        //
        // Here is a workaround:
        //
        return this.clearToColor(0, 0, 0, 0);
    }

    /**
     * Clear the texture to a color
     * @param {number} r red component, a value in [0,1]
     * @param {number} g green component, a value in [0,1]
     * @param {number} b blue component, a value in [0,1]
     * @param {number} a alpha component, a value in [0,1]
     * @returns {this}
     */
    clearToColor(r, g, b, a)
    {
        const gl = this._gl;

        // context loss?
        if(gl.isContextLost())
            return this;

        // clamp parameters
        r = Math.max(0.0, Math.min(+r, 1.0));
        g = Math.max(0.0, Math.min(+g, 1.0));
        b = Math.max(0.0, Math.min(+b, 1.0));
        a = Math.max(0.0, Math.min(+a, 1.0));

        // discard mipmaps, if any
        this.discardMipmaps();

        // clear the texture
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFbo);
        gl.viewport(0, 0, this._width, this._height);
        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // done!
        return this;
    }

    /**
     * Create a FBO associated with an existing texture
     * @param {WebGL2RenderingContext} gl
     * @param {WebGLTexture} texture
     * @returns {WebGLFramebuffer}
     */
    static _createFramebuffer(gl, texture)
    {
        const fbo = gl.createFramebuffer();

        // setup framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target
                                gl.COLOR_ATTACHMENT0,   // color buffer
                                gl.TEXTURE_2D,          // tex target
                                texture,                // texture
                                0);                     // mipmap level

        // check for errors
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if(status != gl.FRAMEBUFFER_COMPLETE) {
            const error = (() => (([
                'FRAMEBUFFER_UNSUPPORTED',
                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',
                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',
                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',
                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'
            ].filter(err => gl[err] === status))[0] || 'unknown error'))();
            throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.GLError(`Can't create framebuffer: ${error} (${status})`);
        }

        // unbind & return
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return fbo;
    }

    /**
     * Copy data from a framebuffer to a texture
     * @param {WebGL2RenderingContext} gl
     * @param {WebGLFramebuffer} fbo we'll read the data from this
     * @param {WebGLTexture} texture destination texture
     * @param {GLint} x xpos (where to start copying)
     * @param {GLint} y ypos (where to start copying)
     * @param {GLsizei} width width of the texture
     * @param {GLsizei} height height of the texture
     * @param {GLint} [lod] mipmap level-of-detail
     * @returns {WebGLTexture} texture
     */
    static _copyToTexture(gl, fbo, texture, x, y, width, height, lod = 0)
    {
        //gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

        gl.copyTexSubImage2D(
            gl.TEXTURE_2D, // target
            lod, // mipmap level
            0, // xoffset
            0, // yoffset
            x, // xpos (where to start copying)
            y, // ypos (where to start copying)
            width, // width of the texture
            height // height of the texture
        );

        /*
        gl.copyTexImage2D(
            gl.TEXTURE_2D, // target
            lod, // mipmap level
            gl.RGBA, // internal format
            x, // xpos (where to start copying)
            y, // ypos (where to start copying)
            width, // width of the texture
            height, // height of the texture
            0 // border
        );
        */

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);

        return texture;
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/utils/asap.js":
/*!******************************************************!*\
  !*** ./node_modules/speedy-vision/src/utils/asap.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asap: () => (/* binding */ asap)
/* harmony export */ });
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * asap.js
 * Schedule a function to run "as soon as possible"
 */

/** callbacks */
const callbacks = /** @type {Function[]} */ ( [] );

/** arguments to be passed to the callbacks */
const args = /** @type {any[][]} */ ( [] );

/** asap key */
const ASAP_KEY = 'asap' + Math.random().toString(36).substr(1);

// Register an event listener
window.addEventListener('message', event => {
    if(event.source !== window || event.data !== ASAP_KEY)
        return;

    event.stopPropagation();
    if(callbacks.length == 0)
        return;

    const fn = callbacks.pop();
    const argArray = args.pop();
    fn.apply(undefined, argArray);
}, true);

/**
 * Schedule a function to run "as soon as possible"
 * @param {Function} fn callback
 * @param {any[]} params optional parameters
 */
function asap(fn, ...params)
{
    callbacks.unshift(fn);
    args.unshift(params);
    window.postMessage(ASAP_KEY, '*');
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/utils/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/speedy-vision/src/utils/errors.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractMethodError: () => (/* binding */ AbstractMethodError),
/* harmony export */   AccessDeniedError: () => (/* binding */ AccessDeniedError),
/* harmony export */   AssertionError: () => (/* binding */ AssertionError),
/* harmony export */   FileNotFoundError: () => (/* binding */ FileNotFoundError),
/* harmony export */   GLError: () => (/* binding */ GLError),
/* harmony export */   IllegalArgumentError: () => (/* binding */ IllegalArgumentError),
/* harmony export */   IllegalOperationError: () => (/* binding */ IllegalOperationError),
/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),
/* harmony export */   NotSupportedError: () => (/* binding */ NotSupportedError),
/* harmony export */   OutOfMemoryError: () => (/* binding */ OutOfMemoryError),
/* harmony export */   ParseError: () => (/* binding */ ParseError),
/* harmony export */   SpeedyError: () => (/* binding */ SpeedyError),
/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),
/* harmony export */   WebAssemblyError: () => (/* binding */ WebAssemblyError)
/* harmony export */ });
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * errors.js
 * Error classes
 */

/** @typedef {SpeedyError|Error|null} SpeedyErrorCause */

/**
 * Generic error class for Speedy
 */
class SpeedyError extends Error
{
    /**
     * Class constructor
     * @param {string} message message text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message, cause = null)
    {
        super([
            message,
            cause ? cause.toString() : '[speedy-vision.js]'
        ].join('\n-> '));

        /** @type {SpeedyErrorCause} cause of the error */
        this._cause = cause;
    }

    /**
     * Error name
     * @returns {string}
     */
    get name()
    {
        return this.constructor.name;
    }

    /**
     * Set error name (ignored)
     * @param {string} _ ignored
     */
    set name(_)
    {
        void(0);
    }

    /**
     * Get the cause of the error. Available if
     * it has been specified in the constructor
     * @returns {SpeedyErrorCause}
     */
    get cause()
    {
        return this._cause;
    }
}

/**
 * Unsupported operation error
 * The requested operation is not supported
 */
class NotSupportedError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Unsupported operation. ${message}`, cause);
    }
}

/**
 * Not implemented error
 * The called method is not implemented
 */
class NotImplementedError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Method not implemented. ${message}`, cause);
    }
}

/**
 * WebGL error
 */
class GLError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`WebGL error. ${message}`, cause);
    }

    /**
     * Get an error object describing the latest WebGL error
     * @param {WebGL2RenderingContext} gl
     * @returns {GLError}
     */
    static from(gl)
    {
        const recognizedErrors = [
            'NO_ERROR',
            'INVALID_ENUM',
            'INVALID_VALUE',
            'INVALID_OPERATION',
            'INVALID_FRAMEBUFFER_OPERATION',
            'OUT_OF_MEMORY',
            'CONTEXT_LOST_WEBGL',
        ];

        const glError = gl.getError();
        const message = recognizedErrors.find(error => gl[error] == glError) || 'Unknown';
        return new GLError(message);
    }
}

/**
 * AbstractMethodError
 * Thrown when one tries to call an abstract method
 */
class AbstractMethodError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Can't call abstract method. ${message}`, cause);
    }
}

/**
 * Illegal argument error
 * A method has received one or more illegal arguments
 */
class IllegalArgumentError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Illegal argument. ${message}`, cause);
    }
}

/**
 * Illegal operation error
 * The method arguments are valid, but the method can't
 * be called due to the current the state of the object
 */
class IllegalOperationError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Illegal operation. ${message}`, cause);
    }
}

/**
 * Out of memory
 */
class OutOfMemoryError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Out of memory. ${message}`, cause);
    }
}

/**
 * File not found error
 */
class FileNotFoundError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`File not found. ${message}`, cause);
    }
}

/**
 * Timeout error
 */
class TimeoutError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Timeout error. ${message}`, cause);
    }
}

/**
 * Parse error
 */
class ParseError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Parse error. ${message}`, cause);
    }
}

/**
 * Assertion error
 */
class AssertionError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Assertion failed. ${message}`, cause);
    }
}

/**
 * Access denied
 */
class AccessDeniedError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`Access denied. ${message}`, cause);
    }
}

/**
 * WebAssembly error
 */
class WebAssemblyError extends SpeedyError
{
    /**
     * Class constructor
     * @param {string} [message] additional text
     * @param {SpeedyErrorCause} [cause] cause of the error
     */
    constructor(message = '', cause = null)
    {
        super(`WebAssembly error. ${message}`, cause);
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/utils/globals.js":
/*!*********************************************************!*\
  !*** ./node_modules/speedy-vision/src/utils/globals.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_ENCODER_CAPACITY: () => (/* binding */ DEFAULT_ENCODER_CAPACITY),
/* harmony export */   FIX_BITS: () => (/* binding */ FIX_BITS),
/* harmony export */   FIX_RESOLUTION: () => (/* binding */ FIX_RESOLUTION),
/* harmony export */   LITTLE_ENDIAN: () => (/* binding */ LITTLE_ENDIAN),
/* harmony export */   LOG2_MAX_DESCRIPTOR_SIZE: () => (/* binding */ LOG2_MAX_DESCRIPTOR_SIZE),
/* harmony export */   LOG2_PYRAMID_MAX_SCALE: () => (/* binding */ LOG2_PYRAMID_MAX_SCALE),
/* harmony export */   MATCH_INDEX_BITS: () => (/* binding */ MATCH_INDEX_BITS),
/* harmony export */   MATCH_INDEX_MASK: () => (/* binding */ MATCH_INDEX_MASK),
/* harmony export */   MATCH_MAX_DISTANCE: () => (/* binding */ MATCH_MAX_DISTANCE),
/* harmony export */   MATCH_MAX_INDEX: () => (/* binding */ MATCH_MAX_INDEX),
/* harmony export */   MAX_DESCRIPTOR_SIZE: () => (/* binding */ MAX_DESCRIPTOR_SIZE),
/* harmony export */   MAX_ENCODER_CAPACITY: () => (/* binding */ MAX_ENCODER_CAPACITY),
/* harmony export */   MAX_TEXTURE_LENGTH: () => (/* binding */ MAX_TEXTURE_LENGTH),
/* harmony export */   MIN_ENCODER_LENGTH: () => (/* binding */ MIN_ENCODER_LENGTH),
/* harmony export */   MIN_KEYPOINT_SIZE: () => (/* binding */ MIN_KEYPOINT_SIZE),
/* harmony export */   PYRAMID_MAX_LEVELS: () => (/* binding */ PYRAMID_MAX_LEVELS),
/* harmony export */   PYRAMID_MAX_SCALE: () => (/* binding */ PYRAMID_MAX_SCALE)
/* harmony export */ });
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * globals.js
 * Global constants
 */

// -----------------------------------------------------------------
// IMAGE PYRAMIDS & SCALE-SPACE
// -----------------------------------------------------------------

/** @type {number} The maximum number of levels in a pyramid, considering a scale factor of 2x between levels */
const PYRAMID_MAX_LEVELS = 8;

/** @type {number} The base-2 logarithm of PYRAMID_MAX_SCALE */
const LOG2_PYRAMID_MAX_SCALE = 0;

/** @type {number} The maximum supported scale for a pyramid level */
const PYRAMID_MAX_SCALE = 1 << LOG2_PYRAMID_MAX_SCALE;



// -----------------------------------------------------------------
// FIXED-POINT MATH
// -----------------------------------------------------------------

/** @type {number} How many bits do we use to store fractional data? */
const FIX_BITS = 3; // step size: 0.125 = 1/2^FIX_BITS

/** @type {number} Fixed-point resolution */
const FIX_RESOLUTION = 1 << FIX_BITS; // float(2^(FIX_BITS))



// -----------------------------------------------------------------
// TEXTURE LIMITS
// -----------------------------------------------------------------

/** @type {number} Maximum texture length (width, height) */
const MAX_TEXTURE_LENGTH = (1 << (16 - FIX_BITS)) - 1; // must be 2^n - 1 due to keypoint encoding



// -----------------------------------------------------------------
// KEYPOINTS
// -----------------------------------------------------------------

/** @type {number} Size of a keypoint header, in bytes (must be divisible by 4) */
const MIN_KEYPOINT_SIZE = 8;

/** @type {number} Minimum length of a keypoint encoder, in pixels (encodes at least 1 keypoint) */
const MIN_ENCODER_LENGTH = 2; // capacity computations are based on this // Math.ceil(Math.sqrt(MIN_KEYPOINT_SIZE / 4));

/** @type {number} Maximum number of keypoints we can encode (the actual length of the encoder may vary) */
const MAX_ENCODER_CAPACITY = 8192;

/** @type {number} Default capacity of a keypoint encoder (64x64 texture with 2 pixels per keypoint) */
const DEFAULT_ENCODER_CAPACITY = 2048;

/** @type {number} log2 of MAX_DESCRIPTOR_SIZE */
const LOG2_MAX_DESCRIPTOR_SIZE = 6;

/** @type {number} maximum size of a keypoint descriptor, in bytes */
const MAX_DESCRIPTOR_SIZE = 1 << LOG2_MAX_DESCRIPTOR_SIZE;

/** @type {number} How many bits will we use when encoding the index of a keypoint match? */
const MATCH_INDEX_BITS = 32 - (LOG2_MAX_DESCRIPTOR_SIZE + 3); // 32 - log2(MAX_DESCRIPTOR_SIZE * 8)

/** @type {number} Bitwise mask to extract a keypoint index from an encoded match */
const MATCH_INDEX_MASK = (1 << MATCH_INDEX_BITS) - 1;

/** @type {number} Maximum size of the database of keypoints for matching */
const MATCH_MAX_INDEX = (1 << MATCH_INDEX_BITS) - 1;

/** @type {number} The maximum distance that can be stored in a match */
const MATCH_MAX_DISTANCE = (1 << (32 - MATCH_INDEX_BITS)) - 1;



// -----------------------------------------------------------------
// MISC
// -----------------------------------------------------------------

/** @type {boolean} Are we in a little-endian machine? */
const LITTLE_ENDIAN = (function() {
    return 0xCAFE === (new Uint16Array(new Uint8Array([0xFE, 0xCA]).buffer))[0];
})();

/***/ }),

/***/ "./node_modules/speedy-vision/src/utils/observable.js":
/*!************************************************************!*\
  !*** ./node_modules/speedy-vision/src/utils/observable.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Observable: () => (/* binding */ Observable)
/* harmony export */ });
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * observable.js
 * Observer design pattern
 */

/**
 * Implementation of the Observer design pattern
 * @abstract
 */
class Observable
{
    /**
     * Constructor
     */
    constructor()
    {
        /** @type {Function[]} subscribers / callbacks */
        this._subscribers = [];

        /** @type {object[]} "this" pointers */
        this._thisptr = [];

        /** @type {Array<any[]>} function arguments */
        this._args = [];
    }

    /**
     * Add subscriber
     * @param {Function} fn callback
     * @param {object} [thisptr] "this" pointer to be used when invoking the callback
     * @param {...any} args arguments to be passed to the callback
     */
    subscribe(fn, thisptr, ...args)
    {
        this._subscribers.push(fn);
        this._thisptr.push(thisptr);
        this._args.push(args);
    }

    /**
     * Remove subscriber
     * @param {Function} fn previously added callback
     * @param {object} [thisptr] "this" pointer
     */
    unsubscribe(fn, thisptr)
    {
        for(let j = this._subscribers.length - 1; j >= 0; j--) {
            if(this._subscribers[j] === fn && this._thisptr[j] === thisptr) {
                this._subscribers.splice(j, 1);
                this._thisptr.splice(j, 1);
                this._args.splice(j, 1);
                break;
            }
        }
    }

    /**
     * Notify all subscribers about a state change
     * @protected
     */
    _notify()
    {
        for(let i = 0; i < this._subscribers.length; i++)
            this._subscribers[i].call(this._thisptr[i], ...(this._args[i]));
    }
}

/***/ }),

/***/ "./node_modules/speedy-vision/src/utils/types.js":
/*!*******************************************************!*\
  !*** ./node_modules/speedy-vision/src/utils/types.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorComponentId: () => (/* binding */ ColorComponentId),
/* harmony export */   ImageFormat: () => (/* binding */ ImageFormat),
/* harmony export */   MediaType: () => (/* binding */ MediaType),
/* harmony export */   PixelComponent: () => (/* binding */ PixelComponent)
/* harmony export */ });
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * types.js
 * Types & formats
 */

/**
 * Media types
 * @enum {Symbol}
 */
const MediaType = Object.freeze({
    Image: Symbol('Image'),
    Video: Symbol('Video'),
    Canvas: Symbol('Canvas'),
    Bitmap: Symbol('Bitmap'),
});

/**
 * Image formats
 * @enum {Symbol}
 */
const ImageFormat = Object.freeze({
    RGBA: Symbol('RGBA'),
    GREY: Symbol('GREY'),
});

/**
 * Pixel component (bitwise flags)
 * @typedef {number} PixelComponent
 */
const PixelComponent = Object.freeze({
    RED:   1,
    GREEN: 2,
    BLUE:  4,
    ALPHA: 8,
    ALL:   15 // = RED | GREEN | BLUE | ALPHA
});

/**
 * Component ID utility
 */
const ColorComponentId = Object.freeze({
    [PixelComponent.RED]:   0,
    [PixelComponent.GREEN]: 1,
    [PixelComponent.BLUE]:  2,
    [PixelComponent.ALPHA]: 3
});

/***/ }),

/***/ "./node_modules/speedy-vision/src/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/speedy-vision/src/utils/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Utils: () => (/* binding */ Utils)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ "./node_modules/speedy-vision/src/utils/errors.js");
/* harmony import */ var _core_speedy_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/*
 * speedy-vision.js
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * utils.js
 * Generic utilities
 */




/**
 * Generic utilities
 */
class Utils
{
    /**
     * Generates a warning
     * @param {string} text message text
     * @param  {...string} args optional text
     */
    static warning(text, ...args)
    {
        console.warn('[speedy-vision]', text, ...args);
    }

    /**
     * Logs a message
     * @param {string} text message text
     * @param  {...string} args optional text
     */
    static log(text, ...args)
    {
        console.log('[speedy-vision]', text, ...args);
    }

    /**
     * Assertion
     * @param {boolean} expr expression
     * @param {string} [text] error message
     * @throws {AssertionError}
     */
    static assert(expr, text = '')
    {
        if(!expr)
            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.AssertionError(text);
    }

    /**
     * Gets the names of the arguments of the specified function
     * @param {Function} fun 
     * @returns {string[]}
     */
    static functionArguments(fun)
    {
        const code = fun.toString();
        const regex = code.startsWith('function') ? 'function\\s.*\\(([^)]*)\\)' :
                     (code.startsWith('(') ? '\\(([^)]*)\\).*=>' : '([^=]+).*=>');
        const match = new RegExp(regex).exec(code);

        if(match !== null) {
            const args = match[1].replace(/\/\*.*?\*\//g, ''); // remove comments
            return args.split(',').map(argname =>
                argname.replace(/=.*$/, '').trim() // remove default params & trim
            ).filter(argname =>
                argname // handle trailing commas
            );
        }
        else
            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(`Can't detect function arguments of ${code}`);
    }

    /**
     * Get all property descriptors from an object,
     * traversing its entire prototype chain
     * @param {object} obj 
     * @returns {object}
     */
    static getAllPropertyDescriptors(obj)
    {
        if(obj) {
            const proto = Object.getPrototypeOf(obj);

            return {
                ...(Utils.getAllPropertyDescriptors(proto)),
                ...Object.getOwnPropertyDescriptors(obj)
            };
        }
        else
            return Object.create(null);
    }

    /**
     * Creates a HTMLCanvasElement with the given dimensions
     * @param {number} width in pixels
     * @param {number} height in pixels
     * @returns {HTMLCanvasElement}
     */
    static createCanvas(width, height)
    {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        return canvas;
    }

    /**
     * Generates a random number with
     * Gaussian distribution (mu, sigma)
     * @param {number} mu mean
     * @param {number} sigma standard deviation
     * @returns {number} random number
     */
    static gaussianNoise(mu = 0, sigma = 1)
    {
        // Box-Muller transformation
        const TWO_PI = 2.0 * Math.PI;
        
        let a, b = Math.random();
        do { a = Math.random(); } while(a <= Number.EPSILON);
        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);

        return z * sigma + mu;
    }

    /**
     * Generate a 1D gaussian kernel with custom sigma
     * Tip: use kernelSize >= (5 * sigma), kernelSize odd
     * @param {number} sigma gaussian sigma
     * @param {number} [kernelSize] kernel size, odd number
     * @param {boolean} [normalized] normalize entries so that their sum is 1
     * @returns {number[]}
     */
    static gaussianKernel(sigma, kernelSize = 0, normalized = true)
    {
        /*
         * Let G(x) be a Gaussian function centered at 0 with fixed sigma:
         *
         * G(x) = (1 / (sigma * sqrt(2 * pi))) * exp(-(x / (sqrt(2) * sigma))^2)
         * 
         * In addition, let f(p) be a kernel value at pixel p, -k/2 <= p <= k/2:
         * 
         * f(p) = \int_{p - 0.5}^{p + 0.5} G(x) dx (integrate around p)
         *      = \int_{0}^{p + 0.5} G(x) dx - \int_{0}^{p - 0.5} G(x) dx
         * 
         * Setting a constant c := sqrt(2) * sigma, it follows that:
         * 
         * f(p) = (1 / 2c) * (erf((p + 0.5) / c) - erf((p - 0.5) / c))
         */

        // default kernel size
        if(kernelSize == 0) {
            kernelSize = Math.ceil(5.0 * sigma) | 0;
            kernelSize += 1 - (kernelSize % 2);
        }

        // validate input
        kernelSize |= 0;
        if(kernelSize < 1 || kernelSize % 2 == 0)
            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.IllegalArgumentError(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`);
        else if(sigma <= 0.0)
            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.IllegalArgumentError(`Invalid sigma given to gaussianKernel: ${sigma}`);

        // function erf(x) = -erf(-x) can be approximated numerically. See:
        // https://en.wikipedia.org/wiki/Error_function#Numerical_approximations
        const kernel = new Array(kernelSize);

        // set constants
        const N  =  kernelSize >> 1; // integer (floor, div 2)
        const c  =  (+sigma) * 1.4142135623730951; // sigma * sqrt(2)
        const m  =  0.3275911;
        const a1 =  0.254829592;
        const a2 = -0.284496736;
        const a3 =  1.421413741;
        const a4 = -1.453152027;
        const a5 =  1.061405429;

        // compute the kernel
        let sum = 0.0;
        for(let j = 0; j < kernelSize; j++) {
            let xa = (j - N + 0.5) / c;
            let xb = (j - N - 0.5) / c;
            let sa = 1.0, sb = 1.0;

            if(xa < 0.0) { sa = -1.0; xa = -xa; }
            if(xb < 0.0) { sb = -1.0; xb = -xb; }

            const ta = 1.0 / (1.0 + m * xa);
            const tb = 1.0 / (1.0 + m * xb);
            const pa = ((((a5 * ta + a4) * ta + a3) * ta + a2) * ta + a1) * ta;
            const pb = ((((a5 * tb + a4) * tb + a3) * tb + a2) * tb + a1) * tb;
            const ya = 1.0 - pa * Math.exp(-xa * xa);
            const yb = 1.0 - pb * Math.exp(-xb * xb);

            const erfa = sa * ya;
            const erfb = sb * yb;
            const fp = (erfa - erfb) / (2.0 * c);

            kernel[j] = fp;
            sum += fp;
        }

        // normalize the kernel
        if(normalized) {
            for(let j = 0; j < kernelSize; j++)
                kernel[j] /= sum;
        }

        // done!
        return kernel;
    }

    /**
     * Generate a 2D kernel in column-major format using two separable 1D kernels
     * @param {number[]} ka 1D kernel
     * @param {number[]} [kb]
     * @returns {number[]}
     */
    static kernel2d(ka, kb = ka)
    {
        const ksize = ka.length;
        Utils.assert(ka.length == ka.length);
        Utils.assert(ksize >= 1 && ksize % 2 == 1);

        // compute the outer product ka x kb
        let kernel2d = new Array(ksize * ksize), k = 0;
        for(let col = 0; col < ksize; col++) {
            for(let row = 0; row < ksize; row++)
                kernel2d[k++] = ka[row] * kb[col];
        }

        return kernel2d;
    }

    /**
     * Cartesian product a x b: [ [ai, bj] for all i, j ]
     * @param {number[]} a
     * @param {number[]} b
     * @returns {Array<[number,number]>}
     */
    static cartesian(a, b)
    {
        return [].concat(...a.map(a => b.map(b => [a, b])));
    }

    /**
     * Symmetric range
     * @param {number} n non-negative integer
     * @returns {number[]} [ -n, ..., n ]
     */
    static symmetricRange(n)
    {
        if((n |= 0) < 0)
            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.IllegalArgumentError(`Expected a non-negative integer as input`);

        return [...(Array(2*n + 1).keys())].map(x => x - n);
    }

    /**
     * Compute the [0, n) range of integers
     * @param {number} n positive integer
     * @returns {number[]} [ 0, 1, ..., n-1 ]
     */
    static range(n)
    {
        if((n |= 0) <= 0)
            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.IllegalArgumentError(`Expected a positive integer as input`);

        return [...(Array(n).keys())];
    }

    /**
     * Shuffle in-place
     * @template T
     * @param {T[]} arr
     * @returns {T[]} arr
     */
    static shuffle(arr)
    {
        const len = arr.length;
        const m = len - 1;

        // Fisher-Yattes
        for(let i = 0; i < m; i++) {
            const j = i + ((Math.random() * (len - i)) | 0); // i <= j < arr.length

            if(i !== j) {
                const t = arr[i];
                arr[i] = arr[j];
                arr[j] = t;
            }
        }

        return arr;
    }

    /**
     * Flatten an array (1 level only)
     * @template U
     * @param {U[]} array
     * @returns {U[]}
     */
    static flatten(array)
    {
        //return array.flat();
        //return array.reduce((arr, val) => arr.concat(val), []);

        const flat = [];

        for(let i = 0, n = array.length; i < n; i++) {
            const entry = array[i];

            if(Array.isArray(entry)) {
                for(let j = 0, m = entry.length; j < m; j++)
                    flat.push(entry[j]);
            }
            else
                flat.push(entry);
        }

        return flat;
    }

    /**
     * Decode a 16-bit float from a
     * unsigned 16-bit integer
     * @param {number} uint16
     * @returns {number}
     */
    static decodeFloat16(uint16)
    {
        // decode according to sec 2.1.2
        // 16-Bit Floating Point Numbers
        // of the OpenGL ES 3 spec
        const s = (uint16 & 0xFFFF) >> 15; // sign bit
        const e = (uint16 & 0x7FFF) >> 10; // exponent
        const m = (uint16 & 0x3FF); // mantissa
        const sign = 1 - 2 * s; // (-1)^s

        if(e == 0)
            return m == 0 ? sign * 0.0 : sign * m * 5.960464477539063e-8; // zero / subnormal
        else if(e == 31)
            return m == 0 ? sign * Number.POSITIVE_INFINITY : Number.NaN;

        const f = e >= 15 ? (1 << (e-15)) : 1.0 / (1 << (15-e)); // 2^(e-15)
        return sign * f * (1.0 + m * 0.0009765625); // normal
    }

    /**
     * Wrapper around getUserMedia()
     * @param {MediaStreamConstraints} [constraints] will be passed to getUserMedia()
     * @returns {SpeedyPromise<HTMLVideoElement>}
     */
    static requestCameraStream(constraints = { audio: false, video: true })
    {
        Utils.log('Accessing the webcam...');

        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NotSupportedError('Unsupported browser: no mediaDevices.getUserMedia()');

        return new _core_speedy_promise__WEBPACK_IMPORTED_MODULE_1__.SpeedyPromise((resolve, reject) => {
            navigator.mediaDevices.getUserMedia(constraints).then(stream => {
                const video = document.createElement('video');
                video.onloadedmetadata = () => {
                    video.play();
                    Utils.log(`The camera is on! Resolution: ${video.videoWidth} x ${video.videoHeight}`);
                    resolve(video);
                };
                video.srcObject = stream;
            })
            .catch(err => {
                reject(new _errors__WEBPACK_IMPORTED_MODULE_0__.AccessDeniedError(
                    `Please give access to the camera and reload the page`,
                    err
                ));
            });
        });
    }
}


/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution1d.glsl":
/*!*******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/filters/convolution1d.glsl ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = "#if !defined(KERNEL_SIZE) || !defined(AXIS) || (AXIS != 0 && AXIS != 1)\n#error Undefined KERNEL_SIZE / AXIS\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE@];\nconst ivec2 axis = ivec2(1-AXIS, AXIS);\n#define S(x,k) result += pixelAtShortOffset(image, ivec2((x),(x)) * axis) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if KERNEL_SIZE == 3\nS(-1, 2);\nS( 0, 1);\nS( 1, 0);\n#elif KERNEL_SIZE == 5\nS(-2, 4);\nS(-1, 3);\nS( 0, 2);\nS( 1, 1);\nS( 2, 0);\n#elif KERNEL_SIZE == 7\nS(-3, 6);\nS(-2, 5);\nS(-1, 4);\nS( 0, 3);\nS( 1, 2);\nS( 2, 1);\nS( 3, 0);\n#elif KERNEL_SIZE == 9\nS(-4, 8);\nS(-3, 7);\nS(-2, 6);\nS(-1, 5);\nS( 0, 4);\nS( 1, 3);\nS( 2, 2);\nS( 3, 1);\nS( 4, 0);\n#elif KERNEL_SIZE == 11\nS(-5, 10);\nS(-4, 9);\nS(-3, 8);\nS(-2, 7);\nS(-1, 6);\nS( 0, 5);\nS( 1, 4);\nS( 2, 3);\nS( 3, 2);\nS( 4, 1);\nS( 5, 0);\n#elif KERNEL_SIZE == 13\nS(-6, 12);\nS(-5, 11);\nS(-4, 10);\nS(-3, 9);\nS(-2, 8);\nS(-1, 7);\nS( 0, 6);\nS( 1, 5);\nS( 2, 4);\nS( 3, 3);\nS( 4, 2);\nS( 5, 1);\nS( 6, 0);\n#elif KERNEL_SIZE == 15\nS(-7, 14);\nS(-6, 13);\nS(-5, 12);\nS(-4, 11);\nS(-3, 10);\nS(-2, 9);\nS(-1, 8);\nS( 0, 7);\nS( 1, 6);\nS( 2, 5);\nS( 3, 4);\nS( 4, 3);\nS( 5, 2);\nS( 6, 1);\nS( 7, 0);\n#else\n#error Invalid parameters\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/filters/convolution2d.glsl":
/*!*******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/filters/convolution2d.glsl ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef KERNEL_SIZE_SQUARED\n#define Must define KERNEL_SIZE_SQUARED\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE_SQUARED@];\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if KERNEL_SIZE_SQUARED == 9\nS(-1,-1, 8);\nS(-1, 0, 7);\nS(-1, 1, 6);\nS( 0,-1, 5);\nS( 0, 0, 4);\nS( 0, 1, 3);\nS( 1,-1, 2);\nS( 1, 0, 1);\nS( 1, 1, 0);\n#elif KERNEL_SIZE_SQUARED == 25\nS(-2,-2, 24);\nS(-2,-1, 23);\nS(-2, 0, 22);\nS(-2, 1, 21);\nS(-2, 2, 20);\nS(-1,-2, 19);\nS(-1,-1, 18);\nS(-1, 0, 17);\nS(-1, 1, 16);\nS(-1, 2, 15);\nS( 0,-2, 14);\nS( 0,-1, 13);\nS( 0, 0, 12);\nS( 0, 1, 11);\nS( 0, 2, 10);\nS( 1,-2, 9);\nS( 1,-1, 8);\nS( 1, 0, 7);\nS( 1, 1, 6);\nS( 1, 2, 5);\nS( 2,-2, 4);\nS( 2,-1, 3);\nS( 2, 0, 2);\nS( 2, 1, 1);\nS( 2, 2, 0);\n#elif KERNEL_SIZE_SQUARED == 49\nS(-3,-3, 48);\nS(-3,-2, 47);\nS(-3,-1, 46);\nS(-3, 0, 45);\nS(-3, 1, 44);\nS(-3, 2, 43);\nS(-3, 3, 42);\nS(-2,-3, 41);\nS(-2,-2, 40);\nS(-2,-1, 39);\nS(-2, 0, 38);\nS(-2, 1, 37);\nS(-2, 2, 36);\nS(-2, 3, 35);\nS(-1,-3, 34);\nS(-1,-2, 33);\nS(-1,-1, 32);\nS(-1, 0, 31);\nS(-1, 1, 30);\nS(-1, 2, 29);\nS(-1, 3, 28);\nS( 0,-3, 27);\nS( 0,-2, 26);\nS( 0,-1, 25);\nS( 0, 0, 24);\nS( 0, 1, 23);\nS( 0, 2, 22);\nS( 0, 3, 21);\nS( 1,-3, 20);\nS( 1,-2, 19);\nS( 1,-1, 18);\nS( 1, 0, 17);\nS( 1, 1, 16);\nS( 1, 2, 15);\nS( 1, 3, 14);\nS( 2,-3, 13);\nS( 2,-2, 12);\nS( 2,-1, 11);\nS( 2, 0, 10);\nS( 2, 1, 9);\nS( 2, 2, 8);\nS( 2, 3, 7);\nS( 3,-3, 6);\nS( 3,-2, 5);\nS( 3,-1, 4);\nS( 3, 0, 3);\nS( 3, 1, 2);\nS( 3, 2, 1);\nS( 3, 3, 0);\n#else\n#error Invalid KERNEL_SIZE_SQUARED\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/filters/fast-median.glsl":
/*!*****************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/filters/fast-median.glsl ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\n#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;\n#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g\nvoid main()\n{\nfloat median;\nvec2 t;\n#if !defined(KERNEL_SIZE)\n#error Must define KERNEL_SIZE\n#elif KERNEL_SIZE == 3\nfloat p[9];\nS(0,-1,-1);\nS(1, 0,-1);\nS(2, 1,-1);\nS(3,-1, 0);\nS(4, 0, 0);\nS(5, 1, 0);\nS(6,-1, 1);\nS(7, 0, 1);\nS(8, 1, 1);\nX(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);\nmedian = p[4];\n#elif KERNEL_SIZE == 5\nfloat p[25];\nS( 0,-2,-2);\nS( 1,-1,-2);\nS( 2, 0,-2);\nS( 3, 1,-2);\nS( 4, 2,-2);\nS( 5,-2,-1);\nS( 6,-1,-1);\nS( 7, 0,-1);\nS( 8, 1,-1);\nS( 9, 2,-1);\nS(10,-2, 0);\nS(11,-1, 0);\nS(12, 0, 0);\nS(13, 1, 0);\nS(14, 2, 0);\nS(15,-2, 1);\nS(16,-1, 1);\nS(17, 0, 1);\nS(18, 1, 1);\nS(19, 2, 1);\nS(20,-2, 2);\nS(21,-1, 2);\nS(22, 0, 2);\nS(23, 1, 2);\nS(24, 2, 2);\nX(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);\nmedian = p[12];\n#elif KERNEL_SIZE == 7\nfloat p[49];\nS( 0,-3,-3);\nS( 1,-2,-3);\nS( 2,-1,-3);\nS( 3, 0,-3);\nS( 4, 1,-3);\nS( 5, 2,-3);\nS( 6, 3,-3);\nS( 7,-3,-2);\nS( 8,-2,-2);\nS( 9,-1,-2);\nS(10, 0,-2);\nS(11, 1,-2);\nS(12, 2,-2);\nS(13, 3,-2);\nS(14,-3,-1);\nS(15,-2,-1);\nS(16,-1,-1);\nS(17, 0,-1);\nS(18, 1,-1);\nS(19, 2,-1);\nS(20, 3,-1);\nS(21,-3, 0);\nS(22,-2, 0);\nS(23,-1, 0);\nS(24, 0, 0);\nS(25, 1, 0);\nS(26, 2, 0);\nS(27, 3, 0);\nS(28,-3, 1);\nS(29,-2, 1);\nS(30,-1, 1);\nS(31, 0, 1);\nS(32, 1, 1);\nS(33, 2, 1);\nS(34, 3, 1);\nS(35,-3, 2);\nS(36,-2, 2);\nS(37,-1, 2);\nS(38, 0, 2);\nS(39, 1, 2);\nS(40, 2, 2);\nS(41, 3, 2);\nS(42,-3, 3);\nS(43,-2, 3);\nS(44,-1, 3);\nS(45, 0, 3);\nS(46, 1, 3);\nS(47, 2, 3);\nS(48, 3, 3);\nX(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);\nmedian = p[24];\n#else\n#error Unsupported kernel size\n#endif\ncolor = vec4(median, median, median, 1.0f);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/filters/nightvision.glsl":
/*!*****************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/filters/nightvision.glsl ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nuniform sampler2D illuminationMap;\nuniform float gain;\nuniform float offset;\nuniform float decay;\n#ifndef GREYSCALE\n#error Must define GREYSCALE\n#endif\n#if GREYSCALE == 0\nconst mat3 rgb2yuv = mat3(\n0.299f, -0.14713f, 0.615f,\n0.587f, -0.28886f, -0.51499f,\n0.114f, 0.436f, -0.10001f\n);\nconst mat3 yuv2rgb = mat3(\n1.0f, 1.0f, 1.0f,\n0.0f, -0.39465f, 2.03211f,\n1.13983f, -0.58060f, 0.0f\n);\n#endif\nconst float eps = 0.0001f;\nconst float sqrt2 = 1.4142135623730951f;\nconst float magic = 20.0f;\nconst vec2 center = vec2(0.5f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nvec4 imapPixel = threadPixel(illuminationMap);\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\nfloat dist = length(texCoord - center);\nfloat vgain = gain * exp(-lambda * dist);\nfloat normalizedGain = 2.0f * vgain;\nfloat normalizedOffset = 2.0f * offset - 1.0f;\n#if GREYSCALE != 0\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\ncolor = vec4(luma, luma, luma, 1.0f);\n#else\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\nluma += normalizedOffset;\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\ncolor = vec4(rgbCorrectedPixel, 1.0f);\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/filters/normalize-image.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/filters/normalize-image.glsl ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef GREYSCALE\n#error Must define GREYSCALE\n#endif\n#if GREYSCALE != 0\nuniform sampler2D minmax2d;\n#else\nuniform sampler2D minmax2dRGB[3];\n#endif\nuniform float minValue;\nuniform float maxValue;\nconst float eps = 1.0f / 255.0f;\nvoid main()\n{\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\nvec4 newMin = vec4(minmax.x);\nvec4 newRange = vec4(minmax.y - minmax.x);\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\n#if GREYSCALE != 0\nvec4 pixel = threadPixel(minmax2d);\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\n#else\nmat4 channel = mat4(\nthreadPixel(minmax2dRGB[0]),\nthreadPixel(minmax2dRGB[1]),\nthreadPixel(minmax2dRGB[2]),\nalpha\n);\n#endif\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\ncolor = newIntensity;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/filters/rgb2grey.glsl":
/*!**************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/filters/rgb2grey.glsl ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = "const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat g = dot(pixel, grey);\ncolor = vec4(g, g, g, 1.0f);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/colors.glsl":
/*!************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/colors.glsl ***!
  \************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _COLORS_GLSL\n#define _COLORS_GLSL\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/filters.glsl":
/*!*************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/filters.glsl ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _FILTERS_GLSL\n#define _FILTERS_GLSL\nfloat laplacian(sampler2D pyramid, vec2 position, float lod)\n{\nfloat pot = exp2(lod);\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nconst vec3 ones = vec3(1.0f);\nconst mat3 kernel = mat3(\n0,-1, 0,\n-1, 4,-1,\n0,-1, 0\n);\n#define LPC(x,y) pyrSubpixelAtExOffset(pyramid, position, lod, pot, ivec2((x),(y)), pyrBaseSize).g\nmat3 neighborhood = mat3(\n0.0f, LPC(0,-1), 0.0f,\nLPC(-1,0), LPC(0,0), LPC(1,0),\n0.0f, LPC(0,1), 0.0f\n);\nmat3 m = matrixCompMult(neighborhood, kernel);\nreturn dot(ones, vec3(\ndot(m[0], ones),\ndot(m[1], ones),\ndot(m[2], ones)\n)) * (1.0f + lod);\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/fixed-point.glsl":
/*!*****************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/fixed-point.glsl ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _FIXEDPOINT_GLSL\n#define _FIXEDPOINT_GLSL\n#define fixed_t int\n#define fixed2_t ivec2\nconst int FIX_BITS = int(@FIX_BITS@);\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\n#define itofix(x) fixed_t((x) << FIX_BITS)\n#define fixtoi(f) int((x) >> FIX_BITS)\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/float16.glsl":
/*!*************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/float16.glsl ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _FLOAT16_GLSL\n#define _FLOAT16_GLSL\n#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)\n#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))\n#define encodePairOfFloat16(f) vec4(encodeFloat16((f).x), encodeFloat16((f).y))\n#define decodePairOfFloat16(v) vec2(decodeFloat16((v).rg), decodeFloat16((v).ba))\n#define encodeNullPairOfFloat16() vec4(1.0f)\n#define isNullPairOfFloat16(v) all(equal((v), encodeNullPairOfFloat16()))\n#define encodeDiscardedPairOfFloat16() vec4(0.0f, 1.0f, 0.0f, 1.0f)\n#define isDiscardedPairOfFloat16(v) all(equal((v), encodeDiscardedPairOfFloat16()))\n#define encodeFloat16NaN() vec2(0.5f, 1.0f)\n#define isEncodedFloat16NaN(v) all(equal((v), encodeFloat16NaN()))\nuvec2 packf16( float f)\n{\nuint y = packHalf2x16(vec2(f, 0.0f));\nreturn uvec2(y, y >> 8u) & 0xFFu;\n}\nfloat unpackf16(uvec2 v)\n{\nv &= 0xFFu;\nreturn unpackHalf2x16(v.x | (v.y << 8u)).x;\n}\nbool isEncodedFloat16Zero(vec2 v)\n{\nuvec2 w = uvec2(v * 255.0f);\nreturn 0u == w.x + w.y * (0x80u - w.y);\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/global.glsl":
/*!************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/global.glsl ***!
  \************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _GLOBAL_GLSL\n#define _GLOBAL_GLSL\n#define threadLocation() ivec2(texCoord * texSize)\n#define outputSize() ivec2(texSize)\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/int32.glsl":
/*!***********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/int32.glsl ***!
  \***********************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _INT32_GLSL\n#define _INT32_GLSL\nuint decodeUint32(vec4 rgba)\n{\nuvec4 v = uvec4(rgba * 255.0f) & 255u;\nreturn v.x | (v.y << 8u) | (v.z << 16u) | (v.w << 24u);\n}\nvec4 encodeUint32(uint value)\n{\nuvec4 v = uvec4(value, value >> 8u, value >> 16u, value >> 24u) & 255u;\nreturn vec4(v) / 255.0f;\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-descriptors.glsl":
/*!**************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-descriptors.glsl ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _KEYPOINT_DESCRIPTORS_GLSL\n#define _KEYPOINT_DESCRIPTORS_GLSL\n#if !defined(DESCRIPTOR_SIZE)\n#error Must define DESCRIPTOR_SIZE\n#elif !defined(_KEYPOINTS_GLSL)\n#error Must include keypoints.glsl\n#endif\nuint[DESCRIPTOR_SIZE] readKeypointDescriptor(sampler2D encodedKeypoints, int descriptorSize, int extraSize, int encoderLength, KeypointAddress address)\n{\nint descriptorOffset = sizeofEncodedKeypoint(0, extraSize) / 4;\nKeypointAddress descriptorAddress = KeypointAddress(address.base, descriptorOffset);\nuint[DESCRIPTOR_SIZE] descriptor;\nvec4 pixel; uvec4 bytes;\n@unroll\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\npixel = readKeypointData(encodedKeypoints, encoderLength, descriptorAddress);\nbytes = uvec4(pixel * 255.0f);\ndescriptor[i]   = bytes.r;\ndescriptor[i+1] = bytes.g;\ndescriptor[i+2] = bytes.b;\ndescriptor[i+3] = bytes.a;\ndescriptorAddress.offset++;\n}\nreturn descriptor;\n}\nuint[DESCRIPTOR_SIZE] readKeypointDescriptorFromDB(sampler2D descriptorDB, int descriptorDBStride, int index)\n{\nuint[DESCRIPTOR_SIZE] descriptor;\nint rasterIndex = index * (DESCRIPTOR_SIZE / 4) * int(index >= 0);\nvec4 pixel; uvec4 bytes; ivec2 pos;\n@unroll\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\npos = ivec2(rasterIndex % descriptorDBStride, rasterIndex / descriptorDBStride);\npixel = (index >= 0) ? texelFetch(descriptorDB, pos, 0) : vec4(0.0f);\nbytes = uvec4(pixel * 255.0f);\ndescriptor[i]   = bytes.r;\ndescriptor[i+1] = bytes.g;\ndescriptor[i+2] = bytes.b;\ndescriptor[i+3] = bytes.a;\nrasterIndex++;\n}\nreturn descriptor;\n}\nint distanceBetweenKeypointDescriptors(uint[DESCRIPTOR_SIZE] a, uint[DESCRIPTOR_SIZE] b)\n{\nconst int[256] POPCNT = int[256](0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8);\nuvec4 xor, u, v;\nint dist = 0;\nivec4 bits;\n@unroll\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\nu = uvec4(a[i], a[i+1], a[i+2], a[i+3]);\nv = uvec4(b[i], b[i+1], b[i+2], b[i+3]);\nxor = (u ^ v) & 255u;\nbits = ivec4(POPCNT[xor.x], POPCNT[xor.y], POPCNT[xor.z], POPCNT[xor.w]);\ndist += bits.x + bits.y + bits.z + bits.w;\n}\nreturn dist;\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-matches.glsl":
/*!**********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/keypoint-matches.glsl ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _KEYPOINT_MATCHES_GLSL\n#define _KEYPOINT_MATCHES_GLSL\n@include \"int32.glsl\"\nconst int MATCH_INDEX_BITS = int(@MATCH_INDEX_BITS@);\nconst int MATCH_INDEX_MASK = int(@MATCH_INDEX_MASK@);\nconst int MATCH_MAX_INDEX = int(@MATCH_MAX_INDEX@);\nconst int MATCH_MAX_DISTANCE = int(@MATCH_MAX_DISTANCE@);\nstruct KeypointMatch\n{\nint index;\nint dist;\n};\nvec4 encodeKeypointMatch(KeypointMatch candidate)\n{\nuint index = uint(candidate.index & MATCH_INDEX_MASK);\nuint dist = uint(clamp(candidate.dist, 0, MATCH_MAX_DISTANCE));\nuint u32 = index | (dist << MATCH_INDEX_BITS);\nreturn encodeUint32(u32);\n}\nKeypointMatch decodeKeypointMatch(vec4 rgba)\n{\nuint u32 = decodeUint32(rgba);\nint dist = int(u32 >> MATCH_INDEX_BITS);\nint index = int(u32 & uint(MATCH_INDEX_MASK));\nreturn KeypointMatch(index, dist);\n}\nconst KeypointMatch MATCH_NOT_FOUND = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/keypoints.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/keypoints.glsl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _KEYPOINTS_GLSL\n#define _KEYPOINTS_GLSL\n@include \"math.glsl\"\n@include \"fixed-point.glsl\"\n@include \"float16.glsl\"\n@include \"pyramids.glsl\"\nstruct Keypoint\n{\nvec2 position;\nfloat lod;\nfloat orientation;\nfloat score;\nuint flags;\n};\nstruct KeypointAddress\n{\nint base;\nint offset;\n};\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\nconst int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);\nconst uint KPF_NONE = 0u;\nconst uint KPF_NULL = 1u;\nconst uint KPF_DISCARDED = 2u;\n#define encodeKeypointScore(score) encodeFloat16(score)\n#define decodeKeypointScore(encodedScore) decodeFloat16(encodedScore)\n#define encodeKeypointOrientation(angle) ((angle) * INV_PI_OVER_2 + 0.5f)\n#define decodeKeypointOrientation(value) ((value) * TWO_PI - PI)\n#define encodeNullKeypoint() (vec4(1.0f))\n#define encodeDiscardedKeypoint() (vec4(0.0f))\n#define isNullKeypoint(keypoint) ((((keypoint).flags) & KPF_NULL) != 0u)\n#define isDiscardedKeypoint(keypoint) ((((keypoint).flags) & KPF_DISCARDED) != 0u)\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\n#define sizeofEncodedKeypointHeader() sizeofEncodedKeypoint(0,0)\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\nvec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nint rasterIndex = address.base + address.offset;\nvec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));\nreturn rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();\n}\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\n{\nint threadRaster = thread.y * encoderLength + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\nKeypointAddress address = KeypointAddress(\nkeypointIndex * pixelsPerKeypoint,\nthreadRaster % pixelsPerKeypoint\n);\nreturn address;\n}\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nKeypoint keypoint;\nKeypointAddress positionAddress = KeypointAddress(address.base, 0);\nKeypointAddress propertiesAddress = KeypointAddress(address.base, 1);\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\nkeypoint.position = fixtovec2(fixed2_t(\nencodedPosition.r | (encodedPosition.g << 8),\nencodedPosition.b | (encodedPosition.a << 8)\n));\nvec4 rawEncodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\nkeypoint.lod = decodeLod(rawEncodedProperties.r);\nkeypoint.orientation = decodeKeypointOrientation(rawEncodedProperties.g);\nkeypoint.score = decodeKeypointScore(rawEncodedProperties.ba);\nbool isNull = all(equal(rawEncodedPosition, vec4(1)));\nbool isDiscarded = all(equal(rawEncodedPosition + rawEncodedProperties, vec4(0)));\nkeypoint.score = (isNull || isDiscarded) ? -1.0f : keypoint.score;\nkeypoint.flags = KPF_NONE;\nkeypoint.flags |= KPF_NULL * uint(isNull);\nkeypoint.flags |= KPF_DISCARDED * uint(isDiscarded);\nreturn keypoint;\n}\nvec4 encodeKeypointPosition(vec2 position)\n{\nconst vec2 zeros = vec2(0.0f);\nfixed2_t pos = vec2tofix(max(position, zeros));\nfixed2_t lo = pos & 255;\nfixed2_t hi = (pos >> 8) & 255;\nreturn vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/math.glsl":
/*!**********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/math.glsl ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _MATH_GLSL\n#define _MATH_GLSL\n#define TWO_PI          6.28318530718f\n#define PI              3.14159265359f\n#define PI_OVER_2       1.57079632679f\n#define PI_OVER_4       0.78539816339f\n#define INV_PI          0.3183098861837907f\n#define INV_PI_OVER_2   0.15915494309189535f\nconst highp float INFINITY = 1.0f / 0.0f;\nfloat fastAtan(float x)\n{\nfloat w = 1.0f - abs(x);\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273f * w) * x) :\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x);\n}\nfloat fastAtan2(float y, float x)\n{\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/pyramids.glsl":
/*!**************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/pyramids.glsl ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _PYRAMIDS_GLSL\n#define _PYRAMIDS_GLSL\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\n#define encodeLod(lod) ((LOG2_PYRAMID_MAX_SCALE + (lod)) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS))\nfloat decodeLod(float encodedLod)\n{\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\nreturn lod - lod * step(1.0f, encodedLod);\n}\n#define LOD_EPS 0.0625f\nconst float ENCODED_LOD_EPS = (LOD_EPS / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS));\n#define isSameLod(lod1, lod2) (abs((lod1) - (lod2)) < LOD_EPS)\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < ENCODED_LOD_EPS)\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/quickselect.ignore.glsl":
/*!************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/quickselect.ignore.glsl ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _QUICKSELECT_GLSL\n#define _QUICKSELECT_GLSL\n#if defined(QUICKSELECT_UNSIGNED) && !defined(QUICKSELECT_SIGNED)\n#define QS_TYPE uint\n#define QS_TYPE4 uvec4\n#elif !defined(QUICKSELECT_UNSIGNED) && defined(QUICKSELECT_SIGNED)\n#define QS_TYPE int\n#define QS_TYPE4 ivec4\n#else\n#error Must define either QUICKSELECT_SIGNED or QUICKSELECT_UNSIGNED before including quickselect\n#endif\n#if defined(QUICKSELECT_ASCENDING) && !defined(QUICKSELECT_DESCENDING)\n#define QS_ORD(element,pivot) ((element) < (pivot))\n#elif defined(QUICKSELECT_DESCENDING) && !defined(QUICKSELECT_ASCENDING)\n#define QS_ORD(element,pivot) ((element) > (pivot))\n#else\n#error Must define either QUICKSELECT_ASCENDING or QUICKSELECT_DESCENDING before including quickselect\n#endif\n#ifdef QUICKSELECT_ARRAY\n#define QS_ARRAY QUICKSELECT_ARRAY\n#else\n#error Must define QUICKSELECT_ARRAY before including quickselect\n#endif\nint qspart(int l, int r, int p)\n{\n#define QS_SWAP(a,b) t = QS_ARRAY[(a)]; QS_ARRAY[(a)] = QS_ARRAY[(b)]; QS_ARRAY[(b)] = t\nhighp QS_TYPE e, t, mask, pivot = QS_ARRAY[p];\nhighp QS_TYPE4 tmp;\nint q, cond;\nQS_SWAP(p, r);\nq = l;\nfor(int i = l; i < r; i++) {\ne = QS_ARRAY[i];\nt = QS_ARRAY[q];\ncond = int(QS_ORD(e, pivot));\nmask = QS_TYPE(-cond);\ntmp = QS_TYPE4(mask & t, (~mask) & e, mask & e, (~mask) & t);\nQS_ARRAY[i] = tmp.x | tmp.y;\nQS_ARRAY[q] = tmp.z | tmp.w;\nq += cond;\n}\nQS_SWAP(q, r);\nreturn q;\n}\nhighp QS_TYPE quickselect(int l, int r, int k)\n{\nint p = -1337;\nivec2 idx = ivec2(l, r);\nwhile(idx.s < idx.t && p != k) {\np = qspart(idx.s, idx.t, (idx.s + idx.t) / 2);\nidx = int(k < p) * ivec2(idx.s, p-1) + int(k >= p) * ivec2(p+1, idx.t);\n}\nreturn (p == k) ? QS_ARRAY[k] : QS_ARRAY[idx.s];\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/include/subpixel.glsl":
/*!**************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/include/subpixel.glsl ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = "#ifndef _SUBPIXEL_GLSL\n#define _SUBPIXEL_GLSL\n#define subpixelAt(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)\nvec4 subpixelAtBI(sampler2D image, vec2 pos)\n{\nvec2 frc = fract(pos);\nvec2 ifrc = vec2(1.0f) - frc;\nvec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));\nvec4 pix00 = textureLod(image, p, 0.0f);\nvec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));\nvec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));\nvec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));\nmat4 pix = mat4(pix00, pix10, pix01, pix11);\nvec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);\nreturn pix * mul;\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/allocate-descriptors.glsl":
/*!****************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/allocate-descriptors.glsl ***!
  \****************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D inputEncodedKeypoints;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nconst vec4 EMPTY_DESCRIPTOR = vec4(0.0f);\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);\nint myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);\nint headerSize = sizeofEncodedKeypointHeader();\nbool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);\nint addressOffset = myAddress.offset;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);\ncolor = isDescriptor ? EMPTY_DESCRIPTOR : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/allocate-extra.glsl":
/*!**********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/allocate-extra.glsl ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D inputEncodedKeypoints;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);\nint myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);\nint headerSize = sizeofEncodedKeypointHeader();\nbool isHead = (myAddress.offset < headerSize / 4);\nbool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);\nbool isExtra = (!isHead && !isDescriptor);\nint numberOfExtraPixels = outputExtraSize / 4;\nint addressOffset = myAddress.offset - int(isDescriptor) * numberOfExtraPixels;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);\ncolor = isExtra ? vec4(0.0f) : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/apply-homography.glsl":
/*!************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/apply-homography.glsl ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform mat3 homography;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nvec3 pos3 = homography * vec3(keypoint.position, 1.0f);\ncolor = encodeKeypointPosition(pos3.xy / pos3.z);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/bf-knn.glsl":
/*!**************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/bf-knn.glsl ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"keypoint-descriptors.glsl\"\n@include \"keypoint-matches.glsl\"\nuniform sampler2D encodedMatches;\nuniform sampler2D encodedFilters;\nuniform int matcherLength;\nuniform sampler2D dbEncodedKeypoints;\nuniform int dbDescriptorSize;\nuniform int dbExtraSize;\nuniform int dbEncoderLength;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int passId;\n#ifndef NUMBER_OF_KEYPOINTS_PER_PASS\n#error Undefined NUMBER_OF_KEYPOINTS_PER_PASS\n#endif\nconst int INFINITE_DISTANCE = MATCH_MAX_DISTANCE + 1;\nvoid main()\n{\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * matcherLength;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\nif(isBadKeypoint(keypoint))\nreturn;\nKeypointMatch bestMatch = decodeKeypointMatch(threadPixel(encodedMatches));\nKeypointMatch filterMatch = decodeKeypointMatch(threadPixel(encodedFilters));\nuint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);\nuint[DESCRIPTOR_SIZE] dbDescriptor;\nint dbPixelsPerKeypoint = sizeofEncodedKeypoint(dbDescriptorSize, dbExtraSize) / 4;\nfor(int i = 0; i < NUMBER_OF_KEYPOINTS_PER_PASS; i++) {\nint dbKeypointIndex = passId * NUMBER_OF_KEYPOINTS_PER_PASS + i;\nKeypointAddress dbAddress = KeypointAddress(dbKeypointIndex * dbPixelsPerKeypoint, 0);\nKeypoint dbKeypoint = decodeKeypoint(dbEncodedKeypoints, dbEncoderLength, dbAddress);\ndbDescriptor = readKeypointDescriptor(dbEncodedKeypoints, dbDescriptorSize, dbExtraSize, dbEncoderLength, dbAddress);\nint dist = !isBadKeypoint(dbKeypoint) ? distanceBetweenKeypointDescriptors(descriptor, dbDescriptor) : INFINITE_DISTANCE;\nbestMatch.index = all(bvec2(\ndist < bestMatch.dist || (dist == bestMatch.dist && dbKeypointIndex > bestMatch.index),\ndist > filterMatch.dist || (dist == filterMatch.dist && dbKeypointIndex < filterMatch.index)\n)) ? dbKeypointIndex : bestMatch.index;\nbestMatch.dist = dbKeypointIndex == bestMatch.index ? dist : bestMatch.dist;\n}\ncolor = encodeKeypointMatch(bestMatch);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/brisk.ignore.glsl":
/*!********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/brisk.ignore.glsl ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image, layerA, layerB;\nuniform float scaleA, scaleB, lgM, h;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = pixel.r;\nivec2 zero = ivec2(0, 0);\nivec2 sizeA = textureSize(layerA, 0);\nivec2 sizeB = textureSize(layerB, 0);\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\nvec4 a00 = pixelAt(layerA, pa);\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\nvec4 b00 = pixelAt(layerB, pb);\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\nfloat maxScore = max(\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\n);\ncolor = vec4(0.0f, pixel.gba);\nif(score < maxScore || score == 0.0f)\nreturn;\nvec2 ea = fract(mid * scaleA);\nvec2 eb = fract(mid * scaleB);\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\na10.b * ea.x * (1.0f - ea.y) +\na01.b * (1.0f - ea.x) * ea.y +\na11.b * ea.x * ea.y;\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\nb10.b * eb.x * (1.0f - eb.y) +\nb01.b * (1.0f - eb.x) * eb.y +\nb11.b * eb.x * eb.y;\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\nfloat y1 = isa, y2 = isb, y3 = score;\nfloat x1 = lgM - (lgM + h) * a00.a;\nfloat x2 = lgM - (lgM + h) * b00.a;\nfloat x3 = lgM - (lgM + h) * pixel.a;\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\nif(abs(dn) < 0.00001f)\nreturn;\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\nif(a >= 0.0f)\nreturn;\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\nfloat xv = -b / (2.0f * a);\nfloat yv = c - (b * b) / (4.0f * a);\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\nreturn;\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/clip-border.glsl":
/*!*******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/clip-border.glsl ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform int imageWidth;\nuniform int imageHeight;\nuniform int borderTop;\nuniform int borderRight;\nuniform int borderBottom;\nuniform int borderLeft;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);\nvec2 p = keypoint.position;\nbool withinBorder = any(lessThan(\nvec4(p.x, p.y, -p.x, -p.y),\nvec4(borderLeft, borderTop, borderRight - (imageWidth - 1), borderBottom - (imageHeight - 1))\n));\nvec4 pixel = threadPixel(encodedKeypoints);\nvec4 nullPixel = encodeNullKeypoint();\ncolor = withinBorder ? nullPixel : pixel;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/clip.glsl":
/*!************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/clip.glsl ***!
  \************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int maxKeypoints;\nvoid main()\n{\nivec2 thread = threadLocation();\nint newEncoderLength = outputSize().x;\nKeypointAddress address = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nvec4 pixel = readKeypointData(encodedKeypoints, encoderLength, address);\ncolor = index < maxKeypoints ? pixel : encodeNullKeypoint();\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/discard-descriptors.ignore.glsl":
/*!**********************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/discard-descriptors.ignore.glsl ***!
  \**********************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int newEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, 0, extraSize);\nint myIndex = findKeypointIndex(myAddress, 0, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, myAddress.offset);\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/distance-filter.glsl":
/*!***********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/distance-filter.glsl ***!
  \***********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedKeypointsA;\nuniform int encoderLengthA;\nuniform sampler2D encodedKeypointsB;\nuniform int encoderLengthB;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nvec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);\ncolor = data;\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\nreturn;\nKeypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);\nKeypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);\ncolor = encodeNullKeypoint();\nif(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))\nreturn;\nvec2 delta = keypointA.position - keypointB.position;\nbool shouldKeep = (dot(delta, delta) <= threshold * threshold);\ncolor = shouldKeep ? data : encodeDiscardedKeypoint();\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-long-offsets.glsl":
/*!************************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-long-offsets.glsl ***!
  \************************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"float16.glsl\"\nuniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\n#ifndef MAX_ITERATIONS\n#error Undefined MAX_ITERATIONS\n#endif\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\n#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)\nvoid main()\n{\nvec4 pixel = threadPixel(offsetsImage);\nivec2 thread = threadLocation();\nint rasterIndex = thread.y * imageSize.x + thread.x;\nint offset = decodeSkipOffset(pixel);\nint totalOffset = offset;\nvec2 encodedScore = pixel.rb;\nivec2 pos = thread; int allow = 1;\n@unroll\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb));\nrasterIndex += allow * offset;\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = pixelAt(offsetsImage, pos);\noffset = decodeSkipOffset(pixel);\ntotalOffset += allow * offset;\n}\ntotalOffset = min(totalOffset, 65535);\ncolor.rb = encodedScore;\ncolor.ga = encodeSkipOffset(totalOffset);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-offsets.glsl":
/*!*******************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-offsets.glsl ***!
  \*******************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"float16.glsl\"\nuniform sampler2D corners;\nuniform ivec2 imageSize;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nivec2 pos = threadLocation();\nvec2 encodedScore = pixel.rb;\nint offset = 0, allow = 1, jumped = 0;\n#define READ(j) ; \\\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb)); \\\noffset += allow; \\\npos.x = (pos.x + 1) % imageSize.x; \\\npos.y += int(pos.x == 0); \\\npixel = (0 != (jumped |= int(pos.x == 0))) ? pixelAtShortOffset(corners, ivec2((j),1)) : pixelAtShortOffset(corners, ivec2((j),0))\nREAD(1); READ(2); READ(3); READ(4); READ(5); READ(6); READ(7);\ncolor.rb = encodedScore;\ncolor.ga = vec2(offset, 0) / 255.0f;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-positions.glsl":
/*!*********************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-positions.glsl ***!
  \*********************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\nuniform int passId;\nuniform int numPasses;\nuniform int keypointLimit;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\n{\nint notFirstPass = int(passId > 0);\nposition *= notFirstPass;\np |= -(1 - notFirstPass);\np -= notFirstPass;\nint rasterIndex = position.y * imageSize.x + position.x;\nwhile(position.y < imageSize.y && p != q) {\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = texelFetch(offsetsImage, position, 0);\np += int(!isEncodedFloat16Zero(pixel.rb));\nrasterIndex += max(1, decodeSkipOffset(pixel));\n}\nreturn (p == q);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = vec4(0.0f);\nif(address.offset != 0)\nreturn;\ncolor = threadPixel(encodedKeypoints);\nint numPixels = encoderLength * encoderLength;\nint maxKeypoints = numPixels / pixelsPerKeypoint;\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\nint targetPassId = q / maxKeypointsPerPass;\nif(passId != targetPassId)\nreturn;\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\nivec2 position = passId > 0 ? ivec2(lastKeypointFromPrevPass.position) : ivec2(0);\nvec4 pixel;\ncolor = encodeNullKeypoint();\nif(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\nreturn;\ncolor = encodeKeypointPosition(vec2(position));\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-properties.glsl":
/*!**********************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoint-properties.glsl ***!
  \**********************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D corners;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(encodedKeypoints);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec4 kpix = pixelAt(corners, ivec2(keypoint.position));\nkeypoint.score = decodeFloat16(kpix.rb);\ncolor.r = kpix.a;\ncolor.g = encodeKeypointOrientation(0.0f);\ncolor.ba = encodeKeypointScore(keypoint.score);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoints.glsl":
/*!************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-keypoints.glsl ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D corners;\nuniform mediump usampler2D lookupTable;\nuniform int stride;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int encoderCapacity;\nconst uvec2 NULL_ELEMENT = uvec2(0xFFFFu);\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nivec2 pos = ivec2(index % stride, index / stride);\nuvec4 entry = texelFetch(lookupTable, pos, 0);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nint rasterIndex = address.base + address.offset;\nint numberOfPixels = encoderLength * encoderLength;\nint numberOfValidPixels = numberOfPixels - (numberOfPixels % pixelsPerKeypoint);\nint maxEncoderCapacity = numberOfValidPixels / pixelsPerKeypoint;\ncolor = encodeNullKeypoint();\nif(all(equal(entry.xy, NULL_ELEMENT)) || index >= min(encoderCapacity, maxEncoderCapacity))\nreturn;\ncolor = encodeKeypointPosition(vec2(entry.xy));\nif(address.offset == 0)\nreturn;\ncolor = vec4(0.0f);\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\nreturn;\nvec4 pixel = texelFetch(corners, ivec2(entry.xy), 0);\nvec2 encodedScore = encodeKeypointScore(decodeFloat16(pixel.rb));\nfloat encodedOrientation = encodeKeypointOrientation(0.0f);\nfloat encodedLod = pixel.a;\ncolor = vec4(encodedLod, encodedOrientation, encodedScore);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-null-keypoints.glsl":
/*!*****************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/encode-null-keypoints.glsl ***!
  \*****************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nvoid main()\n{\ncolor = encodeNullKeypoint();\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/fast.glsl":
/*!************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/fast.glsl ***!
  \************************************************************************/
/***/ ((module) => {

module.exports = "@include \"pyramids.glsl\"\n@include \"float16.glsl\"\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lod;\nuniform int threshold;\n#define USE_VARYINGS 1\n#if !defined(FAST_TYPE)\n#error Undefined FAST_TYPE\n#elif FAST_TYPE == 916\nin vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,\nv_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;\n#else\n#error Invalid FAST_TYPE\n#endif\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\n#define XIP(v) textureLod(pyramid, (v), lod).g\nvoid main()\n{\nfloat pixel = threadPixel(pyramid).g;\nvec4 prev = threadPixel(corners);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat pot = exp2(lod);\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\nfloat ct = pixel + t, c_t = pixel - t;\ncolor = vec4(prev.r, pixel, prev.ba);\n#if FAST_TYPE == 916\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\n#if USE_VARYINGS\nfloat p0 = XIP(v_pix0), p4 = XIP(v_pix4), p8 = XIP(v_pix8), p12 = XIP(v_pix12);\n#else\nfloat p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);\n#endif\nbvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);\nbvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);\nbvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));\nbvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));\nif(!(any(bpairs) || any(dpairs)))\nreturn;\n#if USE_VARYINGS\nfloat p1 = XIP(v_pix1), p2 = XIP(v_pix2), p3 = XIP(v_pix3),\np5 = XIP(v_pix5), p6 = XIP(v_pix6), p7 = XIP(v_pix7),\np9 = XIP(v_pix9), p10 = XIP(v_pix10), p11 = XIP(v_pix11),\np13 = XIP(v_pix13), p14 = XIP(v_pix14), p15 = XIP(v_pix15);\n#else\nfloat p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1),\np5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3),\np9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1),\np13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);\n#endif\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nif(!isCorner)\nreturn;\nmat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\nfloat thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nfloat prevScore = decodeFloat16(prev.rb);\nvec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));\ncolor.rba = thisScore > prevScore ? thisResult : color.rba;\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/fast.vs.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/fast.vs.glsl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "uniform mediump float lod;\n#if !defined(FAST_TYPE)\n#error Undefined FAST_TYPE\n#elif FAST_TYPE == 916\nout vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,\nv_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;\n#else\n#error Invalid FAST_TYPE\n#endif\n#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)\nvoid vsmain()\n{\nfloat pot = exp2(lod);\n#if FAST_TYPE == 916\nv_pix0 = PIX(0,3); v_pix1 = PIX(1,3), v_pix2 = PIX(2,2), v_pix3 = PIX(3,1);\nv_pix4 = PIX(3,0); v_pix5 = PIX(3,-1), v_pix6 = PIX(2,-2), v_pix7 = PIX(1,-3);\nv_pix8 = PIX(0,-3); v_pix9 = PIX(-1,-3), v_pix10 = PIX(-2,-2), v_pix11 = PIX(-3,-1);\nv_pix12 = PIX(-3,0); v_pix13 = PIX(-3,1), v_pix14 = PIX(-2,2), v_pix15 = PIX(-1,3);\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/hamming-distance-filter.glsl":
/*!*******************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/hamming-distance-filter.glsl ***!
  \*******************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"keypoint-descriptors.glsl\"\nuniform sampler2D encodedKeypointsA;\nuniform int encoderLengthA;\nuniform sampler2D encodedKeypointsB;\nuniform int encoderLengthB;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nvec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);\ncolor = data;\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\nreturn;\nKeypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);\nKeypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);\ncolor = encodeNullKeypoint();\nif(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))\nreturn;\nuint[DESCRIPTOR_SIZE] descriptorA, descriptorB;\ndescriptorA = readKeypointDescriptor(encodedKeypointsA, descriptorSize, extraSize, encoderLengthA, address);\ndescriptorB = readKeypointDescriptor(encodedKeypointsB, descriptorSize, extraSize, encoderLengthB, address);\nint dist = distanceBetweenKeypointDescriptors(descriptorA, descriptorB);\nbool shouldKeep = (dist <= threshold);\ncolor = shouldKeep ? data : encodeDiscardedKeypoint();\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/harris-cutoff.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/harris-cutoff.glsl ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"float16.glsl\"\nuniform sampler2D corners;\nuniform sampler2D maxScore;\nuniform float quality;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\nfloat maxval = decodeFloat16(threadPixel(maxScore).rb);\nfloat threshold = maxval * clamp(quality, 0.0f, 1.0f);\ncolor = pixel;\ncolor.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/harris.glsl":
/*!**************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/harris.glsl ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = "@include \"pyramids.glsl\"\n@include \"float16.glsl\"\n@include \"filters.glsl\"\n#if !defined(WINDOW_SIZE)\n#error Undefined WINDOW_SIZE\n#endif\n#define WINDOW_RADIUS ((WINDOW_SIZE - 1) / 2)\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform sampler2D derivatives;\nuniform float lod;\nuniform float lodStep;\nuniform float gaussian[@WINDOW_SIZE@];\n#define G(x) gaussian[(x) + WINDOW_RADIUS]\n#define W(x,y) (G(x) * G(y))\n#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\\ndf = (1.0f + lod) * decodePairOfFloat16(dpix); \\\nh += vec3(df.x * df.x, df.x * df.y, df.y * df.y) * W((ox),(oy))\nvoid main()\n{\nfloat intensity = 0.0f;\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nvec4 dpix = vec4(0.0f);\nvec2 df = vec2(0.0f);\nvec3 h = vec3(0.0f);\ncolor = pixel;\n#if WINDOW_SIZE == 1\nH(0,0);\n#elif WINDOW_SIZE == 3\nH(-1,-1); H(0,-1); H(1,-1);\nH(-1,0); H(0,0); H(1,0);\nH(-1,1); H(0,1); H(1,1);\n#elif WINDOW_SIZE == 5\nH(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);\nH(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);\nH(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);\nH(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);\nH(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);\n#elif WINDOW_SIZE == 7\nH(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);\nH(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);\nH(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);\nH(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);\nH(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);\nH(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);\nH(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);\n#else\n#error Invalid WINDOW_SIZE\n#endif\nfloat response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\nresponse /= float(WINDOW_SIZE * WINDOW_SIZE);\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep);\nfloat currentScaleStrength = abs(laplacian(pyramid, vec2(thread), lod));\nfloat previousScaleStrength = abs(laplacian(pyramid, vec2(thread), lodPlus));\nfloat previousResponse = decodeFloat16(pixel.rb);\nvec4 result = vec4(encodeFloat16(response), encodeLod(lod), intensity);\ncolor.rbag = (currentScaleStrength >= previousScaleStrength || previousResponse == 0.0f) ? result : pixel.rbag;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/knn-init.glsl":
/*!****************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/knn-init.glsl ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoint-matches.glsl\"\nvoid main()\n{\n#if ENCODE_FILTERS != 0\nKeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, 0);\n#else\nKeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);\n#endif\ncolor = encodeKeypointMatch(initial);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/knn-transfer.glsl":
/*!********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/knn-transfer.glsl ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoint-matches.glsl\"\nuniform sampler2D encodedMatches;\nuniform sampler2D encodedKthMatches;\nuniform int numberOfMatchesPerKeypoint;\nuniform int kthMatch;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 matcherSize = textureSize(encodedMatches, 0);\nivec2 kthMatcherSize = textureSize(encodedKthMatches, 0);\nint rasterIndex = thread.y * matcherSize.x + thread.x;\nint matchIndex = rasterIndex / numberOfMatchesPerKeypoint;\nint matchCell = rasterIndex % numberOfMatchesPerKeypoint;\ncolor = threadPixel(encodedMatches);\nif(matchCell != kthMatch)\nreturn;\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\nif(matchIndex >= kthMatcherSize.x * kthMatcherSize.y)\nreturn;\nivec2 pos = ivec2(matchIndex % kthMatcherSize.x, matchIndex / kthMatcherSize.x);\ncolor = texelFetch(encodedKthMatches, pos, 0);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/laplacian.glsl":
/*!*****************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/laplacian.glsl ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = "@include \"pyramids.glsl\"\n@include \"float16.glsl\"\n@include \"filters.glsl\"\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lodStep;\nuniform float lodOffset;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat lod = decodeLod(pixel.a);\nfloat lodMinus = max(0.0f, lod - lodStep + lodOffset);\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep + lodOffset);\nfloat lapMinus = laplacian(pyramid, vec2(thread), lodMinus);\nfloat lapPlus = abs(lodPlus - lodMinus) < 1e-5 ? lapMinus : laplacian(pyramid, vec2(thread), lodPlus);\ncolor = encodePairOfFloat16(vec2(lapMinus, lapPlus));\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lk.glsl":
/*!**********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/lk.glsl ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"float16.glsl\"\nuniform sampler2D nextPyramid;\nuniform sampler2D prevPyramid;\nuniform sampler2D encodedFlow;\nuniform sampler2D prevKeypoints;\nuniform int level;\nuniform int depth;\nuniform int numberOfIterations;\nuniform float discardThreshold;\nuniform float epsilon;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef WINDOW_SIZE\n#error Undefined WINDOW_SIZE\n#endif\n#define NEXT_IMAGE 1\n#define PREV_IMAGE 0\nconst int WINDOW_RADIUS = (WINDOW_SIZE - 1) / 2;\nconst int WINDOW_SIZE_SQUARED = (WINDOW_SIZE) * (WINDOW_SIZE);\nconst int WINDOW_SIZE_PLUS = (WINDOW_SIZE) + 2;\nconst int WINDOW_SIZE_PLUS_SQUARED = WINDOW_SIZE_PLUS * WINDOW_SIZE_PLUS;\nconst int DBL_WINDOW_SIZE_PLUS_SQUARED = 2 * WINDOW_SIZE_PLUS_SQUARED;\nconst int WINDOW_RADIUS_PLUS = (WINDOW_SIZE_PLUS - 1) / 2;\nconst highp float FLT_SCALE = 9.5367431640625e-7;\nconst highp float FLT_EPSILON = 0.00000011920929f;\nint pixelBuffer[DBL_WINDOW_SIZE_PLUS_SQUARED];\n#define prevPixel(index) pixelBuffer[(index)]\n#define nextPixel(index) pixelBuffer[WINDOW_SIZE_PLUS_SQUARED + (index)]\n#define pixelIndex(i, j) (((j) + WINDOW_RADIUS_PLUS) * WINDOW_SIZE_PLUS + ((i) + WINDOW_RADIUS_PLUS))\nivec2 derivBuffer[WINDOW_SIZE_SQUARED];\n#define derivativesAt(x, y) derivBuffer[((y) + WINDOW_RADIUS) * WINDOW_SIZE + ((x) + WINDOW_RADIUS)]\nvoid readWindow(vec2 center, float lod)\n{\nconst int r = WINDOW_RADIUS;\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\nfloat pot = exp2(lod);\nivec2 offset; int idx;\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\\nidx = pixelIndex(offset.x, offset.y); \\\nnextPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g); \\\nprevPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g)\nfor(int j = 0; j < WINDOW_SIZE; j++) {\nfor(int i = 0; i < WINDOW_SIZE; i++) {\nreadPixelsAt(i-r, j-r);\n}\n}\nint r1 = r+1;\nfor(int k = 0; k < WINDOW_SIZE; k++) {\nreadPixelsAt(-r1, k-r);\nreadPixelsAt( r1, k-r);\nreadPixelsAt(k-r,-r1);\nreadPixelsAt(k-r, r1);\n}\nreadPixelsAt(-r1,-r1);\nreadPixelsAt( r1,-r1);\nreadPixelsAt(-r1, r1);\nreadPixelsAt( r1, r1);\n}\nivec2 computeDerivatives(int imageCode, ivec2 offset)\n{\nconst mat3 dx = mat3(\n3, 0, -3,\n10, 0, -10,\n3, 0, -3\n);\nconst mat3 dy = mat3(\n3, 10, 3,\n0, 0, 0,\n-3, -10, -3\n);\nint indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;\nmat3 window = mat3(\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\n0.0f,\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\n);\nmat3 fx = matrixCompMult(dx, window);\nmat3 fy = matrixCompMult(dy, window);\nconst vec3 ones = vec3(1.0f);\nreturn ivec2(\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\n);\n}\nint readBufferedPixel(int imageCode, ivec2 offset)\n{\nconst int r = WINDOW_RADIUS;\noffset = clamp(offset, -r, r);\nint indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\n}\nint readBufferedSubpixel(int imageCode, vec2 offset)\n{\nivec2 p = ivec2(floor(offset));\nvec2 frc = fract(offset);\nvec2 ifrc = vec2(1.0f) - frc;\nvec4 pix = vec4(\nreadBufferedPixel(imageCode, p),\nreadBufferedPixel(imageCode, p + ivec2(1,0)),\nreadBufferedPixel(imageCode, p + ivec2(0,1)),\nreadBufferedPixel(imageCode, p + ivec2(1,1))\n);\nvec4 sub = vec4(\nifrc.x * ifrc.y,\nfrc.x * ifrc.y,\nifrc.x * frc.y,\nfrc.x * frc.y\n);\nreturn int(0.5f + dot(sub*pix, vec4(1.0f)));\n}\nvec2 computeMismatch(vec2 pyrGuess, vec2 localGuess)\n{\nconst int r = WINDOW_RADIUS;\nint timeDerivative;\nivec2 mismatch = ivec2(0);\nint x, y, _x, _y;\nvec2 d = pyrGuess + localGuess;\n#define innerLoop() \\\nfor(_x = 0; _x < WINDOW_SIZE; _x++) { \\\nx = _x - r; y = _y - r; \\\ntimeDerivative = ( \\\nreadBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) - \\\nreadBufferedPixel(PREV_IMAGE, ivec2(x, y)) \\\n); \\\nmismatch += derivativesAt(x, y) * timeDerivative; \\\n}\n@unroll\nfor(_y = 0; _y < WINDOW_SIZE; _y++) {\ninnerLoop();\n}\nreturn vec2(mismatch) * FLT_SCALE;\n}\nbool isInsideImage(vec2 position)\n{\nvec2 imageSize = vec2(textureSize(nextPyramid, 0));\nvec2 border = vec2(WINDOW_SIZE);\nreturn all(bvec4(\ngreaterThanEqual(position, border),\nlessThan(position, imageSize - border)\n));\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedFlow);\nivec2 thread = threadLocation();\nfloat windowArea = float(WINDOW_SIZE * WINDOW_SIZE);\nconst int r = WINDOW_RADIUS;\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\ncolor = encodeNullPairOfFloat16();\nif(isNullKeypoint(keypoint))\nreturn;\ncolor = encodeDiscardedPairOfFloat16();\nif(isBadKeypoint(keypoint))\nreturn;\nvec2 pyrGuess = (level < depth - 1) ? decodePairOfFloat16(pixel) : vec2(0.0f);\npyrGuess *= 2.0f;\nreadWindow(keypoint.position, float(level));\nivec2 derivatives;\nivec3 harris3i = ivec3(0);\nfor(int j = 0; j < WINDOW_SIZE; j++) {\nfor(int i = 0; i < WINDOW_SIZE; i++) {\nderivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));\nharris3i += ivec3(\nderivatives.x * derivatives.x,\nderivatives.x * derivatives.y,\nderivatives.y * derivatives.y\n);\nderivativesAt(i-r, j-r) = derivatives;\n}\n}\nhighp vec3 harris = vec3(harris3i) * FLT_SCALE;\nhighp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);\nhighp float det = harris.x * harris.z - harris.y * harris.y;\nhighp float invDet = abs(det) >= FLT_EPSILON ? 1.0f / det : 0.0f;\nhighp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(\n(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)\n));\nint niceNumbers = int(abs(det) >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);\nbool goodKeypoint = (level > 0) || (niceNumbers != 0);\nhighp float eps2 = epsilon * epsilon;\nhighp vec2 mismatch, delta, localGuess = vec2(0.0f);\nfor(int k = 0; k < numberOfIterations; k++) {\nmismatch = niceNumbers != 0 ? computeMismatch(pyrGuess, localGuess) : vec2(0.0f);\ndelta = mismatch * invHarris * invDet;\nniceNumbers *= int(eps2 <= dot(delta, delta));\nlocalGuess += float(niceNumbers) * delta;\n}\nvec2 opticalFlow = pyrGuess + localGuess;\nbool mustDiscard = (level == 0) && any(bvec2(\n!goodKeypoint,\n!isInsideImage(keypoint.position + opticalFlow)\n));\ncolor = !mustDiscard ? encodePairOfFloat16(opticalFlow) : encodeDiscardedPairOfFloat16();\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lookup-of-locations.glsl":
/*!***************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/lookup-of-locations.glsl ***!
  \***************************************************************************************/
/***/ ((module) => {

module.exports = "#if @FS_USE_CUSTOM_PRECISION@\nprecision mediump int;\nprecision mediump float;\n#endif\n#if !defined(STAGE)\n#error Undefined STAGE\n#elif STAGE == 1\n@include \"float16.glsl\"\nuniform sampler2D corners;\n#elif STAGE < 1\nuniform mediump usampler2D lookupTable;\n#else\n#define SKIP_TEXTURE_READS 1\n#define DENSITY_FACTOR 0.10\nuniform mediump usampler2D lookupTable;\nuniform int blockSize;\nuniform int width;\nuniform int height;\nin vec2 v_topLeft, v_top, v_topRight,\nv_left, v_center, v_right,\nv_bottomLeft, v_bottom, v_bottomRight;\n#endif\nconst uvec2 NULL_ELEMENT = uvec2(0xFFFFu);\nvoid main()\n{\n#if STAGE == 1\nuvec2 outSize = uvec2(outputSize());\nuvec2 thread = uvec2(threadLocation());\nuvec2 size = uvec2(textureSize(corners, 0));\nuint location = thread.y * outSize.x + thread.x;\nivec2 pos = ivec2(location % size.x, location / size.x);\nvec4 pixel = location < size.x * size.y ? texelFetch(corners, pos, 0) : vec4(0.0f);\nbool isCorner = !isEncodedFloat16Zero(pixel.rb);\ncolor = isCorner ? uvec4(uvec2(pos), 1u, 0u) : uvec4(NULL_ELEMENT, 0u, 0u);\n#elif STAGE > 1\nint dblBlockSize = 2 * blockSize;\nivec2 thread = threadLocation();\nivec2 offset = thread % dblBlockSize;\nivec2 delta = thread - offset;\n#if SKIP_TEXTURE_READS\nif(blockSize >= 8) {\nuint sb = texture(lookupTable, texCoord).z;\nfloat p = max((float(sb) / float(blockSize)) / float(blockSize), DENSITY_FACTOR);\nfloat rowthr = float(dblBlockSize) * p + 3.0f * sqrt(p * (1.0f - p));\ncolor = uvec4(NULL_ELEMENT, 4u * sb, 0u);\nif(offset.y >= max(1, int(ceil(rowthr))))\nreturn;\n}\n#endif\n#define deltaCenter ivec2(0,0)\n#define deltaTop ivec2(0,-blockSize)\n#define deltaTopRight ivec2(blockSize,-blockSize)\n#define deltaRight ivec2(blockSize,0)\n#define deltaBottomRight ivec2(blockSize,blockSize)\n#define deltaBottom ivec2(0,blockSize)\n#define deltaBottomLeft ivec2(-blockSize,blockSize)\n#define deltaLeft ivec2(-blockSize,0)\n#define deltaTopLeft ivec2(-blockSize,-blockSize)\nivec2 boundary = ivec2(width - 1, height - 1) / blockSize;\nivec2 bottomRightPos = thread + deltaBottomRight;\nuvec2 valid = uvec2(\nbottomRightPos.x < width  || bottomRightPos.x / blockSize == boundary.x,\nbottomRightPos.y < height || bottomRightPos.y / blockSize == boundary.y\n);\nuvec4 mask[4] = uvec4[4](\nuvec4(1u, valid.x, valid.y, valid.x * valid.y),\nuvec4(1u, 1u, valid.y, valid.y),\nuvec4(1u, valid.x, 1u, valid.x),\nuvec4(1u)\n);\n#if SKIP_TEXTURE_READS\n#define calcSb(delta) texelFetch(lookupTable, blockSize * ((thread + (delta)) / blockSize), 0).z\nuint center = calcSb(deltaCenter);\nuint top = calcSb(deltaTop);\nuint topRight = calcSb(deltaTopRight);\nuint right = calcSb(deltaRight);\nuint bottomRight = calcSb(deltaBottomRight);\nuint bottom = calcSb(deltaBottom);\nuint bottomLeft = calcSb(deltaBottomLeft);\nuint left = calcSb(deltaLeft);\nuint topLeft = calcSb(deltaTopLeft);\n#else\n#define calcSb(pos) texture(lookupTable, (pos)).z\nuint center = calcSb(v_center);\nuint top = calcSb(v_top);\nuint topRight = calcSb(v_topRight);\nuint right = calcSb(v_right);\nuint bottomRight = calcSb(v_bottomRight);\nuint bottom = calcSb(v_bottom);\nuint bottomLeft = calcSb(v_bottomLeft);\nuint left = calcSb(v_left);\nuint topLeft = calcSb(v_topLeft);\n#endif\nuvec4 sums[4] = uvec4[4](\nuvec4(center, right, bottom, bottomRight),\nuvec4(left, center, bottomLeft, bottom),\nuvec4(top, topRight, center, right),\nuvec4(topLeft, top, left, center)\n);\nivec2 cmp = ivec2(greaterThanEqual(offset, ivec2(blockSize)));\nint option = 2 * cmp.y + cmp.x;\nuvec4 cdef = sums[option] * mask[option];\nuint c2b = cdef.x, d2b = cdef.y, e2b = cdef.z, f2b = cdef.w;\nuint sb = center;\nuint s2b = c2b + d2b + e2b + f2b;\ns2b = s2b < sb ? 0xFFFFu : min(0xFFFFu, s2b);\nuint w2b = uint(min(dblBlockSize, width - delta.x));\nuvec2 uoffset = uvec2(offset);\nuint ceiling = s2b >= uoffset.x ? (s2b - uoffset.x) / w2b + uint((s2b - uoffset.x) % w2b > 0u) : 0u;\ncolor = uvec4(NULL_ELEMENT, s2b, 0u);\nif(uoffset.y >= ceiling)\nreturn;\nuint i2b = uoffset.y * w2b + uoffset.x;\nuint j2b = i2b >= c2b ? i2b - c2b : 0u;\nuint k2b = j2b >= d2b ? j2b - d2b : 0u;\nuint l2b = k2b >= e2b ? k2b - e2b : 0u;\nuint wl = uint(min(blockSize, width - delta.x));\nuint wr = uint(min(blockSize, width - delta.x - blockSize));\nivec2 magicOffset = (\n(i2b < c2b) ? ivec2(i2b % wl, i2b / wl) : (\n(j2b < d2b) ? ivec2(j2b % wr, j2b / wr) + ivec2(blockSize, 0) : (\n(k2b < e2b) ? ivec2(k2b % wl, k2b / wl) + ivec2(0, blockSize) : (\n(l2b < f2b) ? ivec2(l2b % wr, l2b / wr) + ivec2(blockSize) : ivec2(0)\n))));\nuvec2 a2b = texelFetch(lookupTable, delta + magicOffset, 0).xy;\ncolor = uvec4(a2b, s2b, 0u);\n#else\nuvec4 pix = texture(lookupTable, texCoord);\ncolor = all(equal(pix.xy, NULL_ELEMENT)) ? vec4(0,1,1,1) : vec4(1,0,0,1);\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lookup-of-locations.vs.glsl":
/*!******************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/lookup-of-locations.vs.glsl ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = "#if !defined(STAGE) || STAGE < 1\n#error Invalid STAGE\n#else\nuniform mediump int blockSize;\nout vec2 v_topLeft, v_top, v_topRight,\nv_left, v_center, v_right,\nv_bottomLeft, v_bottom, v_bottomRight;\nvoid vsmain()\n{\nfloat b = float(blockSize);\n#define V(x,y) (texCoord + (vec2((x),(y)) * b) / texSize)\nv_topLeft = V(-1,-1); v_top = V(0,-1); v_topRight = V(1,-1);\nv_left = V(-1,0); v_center = V(0,0); v_right = V(1,0);\nv_bottomLeft = V(-1,1); v_bottom = V(0,1); v_bottomRight = V(1,1);\n}\n#endif"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/lsh-knn.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/lsh-knn.glsl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"keypoint-matches.glsl\"\n@include \"keypoint-descriptors.glsl\"\nuniform sampler2D candidates;\nuniform sampler2D filters;\nuniform int matcherLength;\nuniform sampler2D tables;\nuniform sampler2D descriptorDB;\nuniform int tableIndex;\nuniform int bucketCapacity;\nuniform int bucketsPerTable;\nuniform int tablesStride;\nuniform int descriptorDBStride;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if HASH_SIZE > SEQUENCE_MAXLEN\n#error LSH: invalid HASH_SIZE\n#elif SEQUENCE_COUNT * SEQUENCE_MAXLEN * 4 > 16384\n#error LSH: sequences are too large!\n#elif (SEQUENCE_COUNT * SEQUENCE_MAXLEN) % 4 > 0\n#error LSH: sequences of invalid size!\n#endif\nlayout(std140) uniform LSHSequences\n{\nuvec4 sequences[(SEQUENCE_COUNT * SEQUENCE_MAXLEN) / 4];\n};\n#if HASH_SIZE == 10\nconst int SWAP_COUNT[3] = int[3](1, 11, 56);\nconst int[56] SWAP = int[56](0,1,2,4,8,16,32,64,128,256,512,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768);\n#elif HASH_SIZE == 11\nconst int SWAP_COUNT[3] = int[3](1, 12, 67);\nconst int[67] SWAP = int[67](0,1,2,4,8,16,32,64,128,256,512,1024,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536);\n#elif HASH_SIZE == 12\nconst int SWAP_COUNT[3] = int[3](1, 13, 79);\nconst int[79] SWAP = int[79](0,1,2,4,8,16,32,64,128,256,512,1024,2048,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072);\n#elif HASH_SIZE == 13\nconst int SWAP_COUNT[3] = int[3](1, 14, 92);\nconst int[92] SWAP = int[92](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144);\n#elif HASH_SIZE == 14\nconst int SWAP_COUNT[3] = int[3](1, 15, 106);\nconst int[106] SWAP = int[106](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288);\n#elif HASH_SIZE == 15\nconst int SWAP_COUNT[3] = int[3](1, 16, 121);\nconst int[121] SWAP = int[121](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576);\n#elif HASH_SIZE == 16\nconst int SWAP_COUNT[3] = int[3](1, 17, 137);\nconst int[137] SWAP = int[137](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152);\n#elif HASH_SIZE == 17\nconst int SWAP_COUNT[3] = int[3](1, 18, 154);\nconst int[154] SWAP = int[154](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304);\n#elif HASH_SIZE == 18\nconst int SWAP_COUNT[3] = int[3](1, 19, 172);\nconst int[172] SWAP = int[172](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608);\n#elif HASH_SIZE == 19\nconst int SWAP_COUNT[3] = int[3](1, 20, 191);\nconst int[191] SWAP = int[191](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216);\n#elif HASH_SIZE == 20\nconst int SWAP_COUNT[3] = int[3](1, 21, 211);\nconst int[211] SWAP = int[211](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216,524289,524290,524292,524296,524304,524320,524352,524416,524544,524800,525312,526336,528384,532480,540672,557056,589824,655360,786432);\n#else\n#error Invalid HASH_SIZE\n#endif\n#if LEVEL < 0 || LEVEL > 2\n#error Invalid LEVEL\n#endif\nconst uint END_OF_LIST = 0xFFFFFFFFu;\nconst int NUMBER_OF_HASHES = SWAP_COUNT[LEVEL];\nuint sequenceElement(int sequenceIndex, int elementIndex)\n{\nint offset = (SEQUENCE_MAXLEN) * sequenceIndex + elementIndex;\nuvec4 tuple = sequences[offset / 4];\nreturn tuple[offset & 3];\n}\nint descriptorHash(uint[DESCRIPTOR_SIZE] descriptor, int sequenceIndex)\n{\nuint bit, b, m;\nint hash = 0;\n@unroll\nfor(int i = 0; i < HASH_SIZE; i++) {\nbit = sequenceElement(sequenceIndex, i);\nb = bit >> 3u;\nm = 1u << (bit & 7u);\nhash = (hash << 1) | int((descriptor[b] & m) != 0u);\n}\nreturn hash;\n}\n#define readTableData(tables, tablesStride, rasterIndex) decodeUint32(texelFetch((tables), ivec2((rasterIndex) % (tablesStride), (rasterIndex) / (tablesStride)), 0))\nvoid main()\n{\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * matcherLength;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\nif(isBadKeypoint(keypoint))\nreturn;\nKeypointMatch candidate = decodeKeypointMatch(threadPixel(candidates));\nKeypointMatch mfilter = decodeKeypointMatch(threadPixel(filters));\nuint[DESCRIPTOR_SIZE] candidateDescriptor;\nuint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);\nint hash0 = descriptorHash(descriptor, tableIndex);\nfor(int h = 0; h < NUMBER_OF_HASHES; h++) {\nint hash = hash0 ^ SWAP[h];\nint tableAddress = tableIndex * bucketsPerTable * bucketCapacity;\nint bucketAddress = tableAddress + hash * bucketCapacity;\nbool validEntry = true;\nfor(int b = 0; b < bucketCapacity; b++) {\nint entryAddress = bucketAddress + b;\nuint entry = validEntry ? readTableData(tables, tablesStride, entryAddress) : END_OF_LIST;\nvalidEntry = (validEntry && entry != END_OF_LIST);\nint candidateIndex = int(entry);\ncandidateDescriptor = readKeypointDescriptorFromDB(descriptorDB, descriptorDBStride, validEntry ? candidateIndex : -1);\nint descriptorDistance = distanceBetweenKeypointDescriptors(descriptor, candidateDescriptor);\nKeypointMatch match = KeypointMatch(candidateIndex, descriptorDistance);\nbool betterThanCandidate = (match.dist < candidate.dist) || (match.dist == candidate.dist && match.index > candidate.index);\nbool worseThanFilter = (match.dist > mfilter.dist) || (match.dist == mfilter.dist && match.index < mfilter.index);\nbool nicerMatch = (validEntry && betterThanCandidate && worseThanFilter);\nivec2 v = nicerMatch ? ivec2(match.index, match.dist) : ivec2(candidate.index, candidate.dist);\ncandidate = KeypointMatch(v.x, v.y);\n}\n}\ncolor = encodeKeypointMatch(candidate);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/mix-keypoints.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/mix-keypoints.glsl ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"int32.glsl\"\n#if !defined(STAGE)\n#error Undefined STAGE\n#elif STAGE == 1\nuniform sampler2D encodedKeypointsA;\nuniform sampler2D encodedKeypointsB;\nuniform int encoderLengthA;\nuniform int encoderLengthB;\nuniform int encoderCapacityA;\nuniform int encoderCapacityB;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#elif STAGE == 2\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int maxKeypoints;\n#elif STAGE == 3\nuniform sampler2D array;\nuniform int blockSize;\n#elif STAGE == 4\nuniform sampler2D array;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#elif STAGE == 5\nuniform sampler2D array;\n#else\n#error Invalid STAGE\n#endif\n#define NULL_KEYPOINT_INDEX 0xFFFF\nconst highp uint UNIT = 0x10000u;\nvoid main()\n{\n#if STAGE == 1\nivec2 thread = threadLocation();\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);\nint newKeypointIndex = keypointIndex < encoderCapacityA ? keypointIndex : keypointIndex - encoderCapacityA;\ncolor = encodeNullKeypoint();\nif(newKeypointIndex >= max(encoderCapacityA, encoderCapacityB))\nreturn;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\naddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);\nvec4 dataA = readKeypointData(encodedKeypointsA, encoderLengthA, addr);\nvec4 dataB = readKeypointData(encodedKeypointsB, encoderLengthB, addr);\ncolor = keypointIndex < encoderCapacityA ? dataA : dataB;\n#elif STAGE == 2\nivec2 thread = threadLocation();\nint keypointIndex = thread.y * outputSize().x + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress addr = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);\nbool isValid = !isNullKeypoint(keypoint) && keypointIndex < maxKeypoints;\nkeypointIndex = isValid ? keypointIndex : NULL_KEYPOINT_INDEX;\ncolor = encodeUint32(uint(keypointIndex & 0xFFFF) | (isValid ? UNIT : 0u));\n#elif STAGE == 3\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nint arrayLength = size.x * size.y;\nint arrayIndex = thread.y * size.x + thread.x;\nint arrayIndexLeft = arrayIndex - blockSize;\nint arrayIndexRight = arrayIndex + blockSize;\nint mask = int(arrayIndexRight < arrayLength || arrayIndexRight / blockSize == (arrayLength - 1) / blockSize);\narrayIndexLeft = max(0, arrayIndexLeft);\narrayIndexRight = min(arrayLength - 1, arrayIndexRight);\n#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)\nuvec3 entries32 = uvec3(\ndecodeUint32(threadPixel(array)),\ndecodeUint32(texelFetch(array, raster2pos(arrayIndexLeft), 0)),\ndecodeUint32(texelFetch(array, raster2pos(arrayIndexRight), 0))\n);\nivec3 sb = ivec3((entries32 >> 16u) & 0xFFFFu);\nsb.z *= mask;\nint dblBlockSize = 2 * blockSize;\nint offset = arrayIndex % dblBlockSize;\nint s2b = sb.x + (offset < blockSize ? sb.z : sb.y);\nint l2b = offset < blockSize ? sb.x : sb.y;\nuint keypointIndex = entries32.x & 0xFFFFu;\nuint shiftedS2b = uint(s2b) << 16u;\ncolor = encodeUint32(uint(NULL_KEYPOINT_INDEX) | shiftedS2b);\nif(offset >= s2b)\nreturn;\ncolor = encodeUint32(keypointIndex | shiftedS2b);\nif(offset < l2b)\nreturn;\nvec4 entry = texelFetch(array, raster2pos(arrayIndex + blockSize - l2b), 0);\nkeypointIndex = decodeUint32(entry) & 0xFFFFu;\ncolor = encodeUint32(keypointIndex | shiftedS2b);\n#elif STAGE == 4\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);\n#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)\nivec2 size = textureSize(array, 0);\nuint sortedPair = decodeUint32(texelFetch(array, raster2pos(keypointIndex), 0));\nint newKeypointIndex = int(sortedPair & 0xFFFFu);\ncolor = encodeNullKeypoint();\nif(newKeypointIndex == NULL_KEYPOINT_INDEX || keypointIndex >= size.x * size.y)\nreturn;\nKeypointAddress newAddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);\ncolor = readKeypointData(encodedKeypoints, encoderLength, newAddr);\n#elif STAGE == 5\nuint val = decodeUint32(threadPixel(array));\ncolor = (val & 0xFFFFu) == uint(NULL_KEYPOINT_INDEX) ? vec4(0,1,1,1) : vec4(1,0,0,1);\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/ncc.ignore.glsl":
/*!******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/ncc.ignore.glsl ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"float16.glsl\"\nuniform sampler2D encodedFlow;\nuniform sampler2D prevKeypoints;\nuniform sampler2D prevPyramid;\nuniform sampler2D nextPyramid;\nuniform int windowSize;\nuniform int patchSize;\nuniform float discardThreshold;\nuniform int level;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if !defined(MAX_WINDOW_SIZE_LOD1)\n#error Must define MAX_WINDOW_SIZE_LOD1\n#elif !defined(MAX_PATCH_SIZE)\n#define Must define MAX_PATCH_SIZE\n#endif\nconst int MAX_WINDOW_RADIUS = (MAX_WINDOW_SIZE_LOD1 - 1) / 2;\nconst int WINDOW_BUFFER_STRIDE = MAX_WINDOW_SIZE_LOD1 + (MAX_PATCH_SIZE - 1);\nconst int WINDOW_BUFFER_SIZE = WINDOW_BUFFER_STRIDE * WINDOW_BUFFER_STRIDE;\nfloat windowBuffer[WINDOW_BUFFER_SIZE];\nfloat windowMean;\nconst int PATCH_BUFFER_SIZE = MAX_PATCH_SIZE * MAX_PATCH_SIZE;\nfloat patchBuffer[PATCH_BUFFER_SIZE];\nfloat patchMean;\n#define windowIndex(i, j) (((j) + MAX_WINDOW_RADIUS) * WINDOW_BUFFER_STRIDE + ((i) + MAX_WINDOW_RADIUS))\n#define patchIndex(i, j) (((j) * MAX_PATCH_SIZE) + (i))\n#define windowRadius() ((windowSize - 1) / 2)\n#define windowPixel(i, j) windowBuffer[windowIndex((i), (j))]\n#define patchPixel(i, j) patchBuffer[patchIndex((i), (j))]\nvoid readWindow(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(nextPyramid, 0);\nfloat pot = exp2(lod);\nint r = windowRadius();\nint i, j;\nivec2 offset;\nfloat sum = 0.0f;\nfor(j = 0; j < windowSize; j++) {\nfor(i = 0; i < windowSize; i++) {\noffset = ivec2(i-r, j-r);\nsum += (windowPixel(i-r, j-r) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g);\n}\n}\nfor(j = 1; j < patchSize; j++) {\nfor(i = 0; i < windowSize; i++) {\noffset = ivec2(i-r, r+j);\nsum += (windowPixel(i-r, r+j) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g);\nsum += (windowPixel(r+j, i-r) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset.yx, pyrBaseSize).g);\n}\n}\nfor(j = 1; j < patchSize; j++) {\nfor(i = 1; i < patchSize; i++) {\noffset = ivec2(r+i, r+j);\nsum += (windowPixel(r+i, r+j) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g);\n}\n}\nint p = patchSize, w = windowSize;\nint windowArea = w * w + 2 * w * (p-1) + (p-1) * (p-1);\nwindowMean = sum / float(windowArea);\n}\nvoid readPatch(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\nfloat pot = exp2(lod);\nfloat sum = 0.0f;\nint r = patchSize / 2;\nivec2 offset;\nfor(int j = 0; j < patchSize; j++) {\nfor(int i = 0; i < patchSize; i++) {\noffset = ivec2(i-r, j-r);\nsum += (patchPixel(i, j) = pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g);\n}\n}\nint patchArea = patchSize * patchSize;\npatchMean = sum / float(patchArea);\n}\n#define encodeInvalidFlow() vec4(encodeFloat16NaN(), encodeFloat16NaN())\nfloat computeNCC(ivec2 offset)\n{\nint r = windowRadius();\nint x = clamp(offset.x, -r, r), y = clamp(offset.y, -r, r);\n#if 1\nfloat win = 0.0f, tpl = 0.0f;\nfloat covar = 0.0f, winvar = 0.0f, tplvar = 0.0f;\nfor(int i = 0; i < patchSize; i++) {\nfor(int j = 0; j < patchSize; j++) {\nwin = windowPixel(x+i, y+j) - windowMean;\ntpl = patchPixel(i, j) - patchMean;\ncovar += win * tpl;\nwinvar += win * win;\ntplvar += tpl * tpl;\n}\n}\nreturn covar / sqrt(winvar * tplvar);\n#else\nint covar = 0, winvar = 0, tplvar = 0;\nint wmean = int(round(255.0f * windowMean)), pmean = int(round(255.0f * patchMean));\nfor(int i = 0; i < patchSize; i++) {\nfor(int j = 0; j < patchSize; j++) {\nint win = int(255.0f * windowPixel(x+i, y+j)) - wmean;\nint tpl = int(255.0f * patchPixel(i, j)) - pmean;\ncovar += win * tpl;\nwinvar += win * win;\ntplvar += tpl * tpl;\n}\n}\nreturn (float(covar) / 65025.0f) / sqrt((float(winvar) / 65025.0f) * (float(tplvar) / 65025.0f));\n#endif\n}\nvec2 refineSubpixel(ivec2 flow)\n{\nfloat q1 = computeNCC(flow + ivec2(-1,-1));\nfloat q2 = computeNCC(flow + ivec2( 0,-1));\nfloat q3 = computeNCC(flow + ivec2( 1,-1));\nfloat q4 = computeNCC(flow + ivec2(-1, 0));\nfloat q5 = computeNCC(flow + ivec2( 0, 0));\nfloat q6 = computeNCC(flow + ivec2( 1, 0));\nfloat q7 = computeNCC(flow + ivec2(-1, 1));\nfloat q8 = computeNCC(flow + ivec2( 0, 1));\nfloat q9 = computeNCC(flow + ivec2( 1, 1));\nfloat a = (q1 - 2.0f * q2 + q3 + q4 - 2.0f * q5 + q6 + q7 - 2.0f * q8 + q9) / 6.0f;\nfloat b = (q1 - q3 - q7 + q9) / 4.0f;\nfloat c = (q1 + q2 + q3 - 2.0f * q4 - 2.0f * q5 - 2.0f * q6 + q7 + q8 + q9) / 6.0f;\nfloat d = (-q1 + q3 - q4 + q6 - q7 + q9) / 6.0f;\nfloat e = (-q1 - q2 - q3 + q7 + q8 + q9) / 6.0f;\nfloat hdet = 4.0f * a * c - b * b;\nbool hasMax = hdet > 0.0f && a < 0.0f;\nfloat det = hdet;\nvec2 pixelFlow = vec2(flow);\nvec2 subpixelFlow = hasMax ? vec2(b * e - 2.0f * c * d, b * d - 2.0f * a * e) / det : pixelFlow;\nreturn subpixelFlow;\nreturn distance(subpixelFlow, pixelFlow) < 2.0f ? subpixelFlow : pixelFlow;\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedFlow);\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\ncolor = encodeNullPairOfFloat16();\nif(isNullKeypoint(keypoint))\nreturn;\ncolor = encodePairOfFloat16(vec2(0.0f));\nif(isBadKeypoint(keypoint))\nreturn;\nconst int MAX_LOD = 0;\nvec2 flow = level < MAX_LOD ? decodePairOfFloat16(pixel) : vec2(0.0f);\nflow *= 2.0f;\nfloat lod = float(level);\nreadWindow(keypoint.position + flow, lod);\nreadPatch(keypoint.position + flow, lod);\nivec2 bestOffset = ivec2(0), currOffset;\nfloat bestNCC = -2.0f, currNCC;\nint r = windowRadius();\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\ncurrOffset = ivec2(i-r, j-r);\ncurrNCC = computeNCC(currOffset);\nbestOffset = bestNCC > currNCC ? bestOffset : currOffset;\nbestNCC = max(currNCC, bestNCC);\n}\n}\nflow += refineSubpixel(bestOffset);\ncolor = bestNCC >= discardThreshold ? encodePairOfFloat16(flow) : encodeInvalidFlow();\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-scale.glsl":
/*!********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-scale.glsl ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"pyramids.glsl\"\n@include \"float16.glsl\"\n@include \"filters.glsl\"\n#if !defined(USE_LAPLACIAN)\n#error Undefined USE_LAPLACIAN\n#endif\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lodStep;\n#if USE_LAPLACIAN\nuniform sampler2D pyrLaplacian;\n#endif\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\nfloat myEncodedLod = pixel.a;\nfloat lod = decodeLod(myEncodedLod);\nfloat lodPlus = lod + lodStep;\nfloat lodMinus = lod - lodStep;\nfloat pot = exp2(lod);\nfloat potPlus = exp2(lodPlus);\nfloat potMinus = exp2(lodMinus);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\n#define P(p,u,v) textureLod(corners, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\nvec4 pix[18] = vec4[18](\n#define D(u,v) P(potMinus,(u),(v))\nD(-1,-1), D(0,-1), D(1,-1),\nD(-1,0), D(0,0), D(1,0),\nD(-1,1), D(0,1), D(1,1)\n,\n#define U(u,v) P(potPlus,(u),(v))\nU(-1,-1), U(0,-1), U(1,-1),\nU(-1,0), U(0,0), U(1,0),\nU(-1,1), U(0,1), U(1,1)\n);\nfloat scores[18] = float[18](\n#define C(j) decodeFloat16(pix[j].rb)\nC(0), C(1), C(2),\nC(3), C(4), C(5),\nC(6), C(7), C(8)\n,\nC(9), C(10), C(11),\nC(12), C(13), C(14),\nC(15), C(16), C(17)\n);\nfloat lods[18] = float[18](\n#define E(j) decodeLod(pix[j].a)\nE(0), E(1), E(2),\nE(3), E(4), E(5),\nE(6), E(7), E(8)\n,\nE(9), E(10), E(11),\nE(12), E(13), E(14),\nE(15), E(16), E(17)\n);\n#if USE_LAPLACIAN\n#define L(p,u,v) textureLod(pyrLaplacian, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\nmat3 strengths[2] = mat3[2](mat3(\n#define Lm(u,v) abs(decodeFloat16(L(potMinus,(u),(v)).xy))\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\nLm(-1,0), Lm(0,0), Lm(1,0),\nLm(-1,1), Lm(0,1), Lm(1,1)\n), mat3(\n#define Lp(u,v) abs(decodeFloat16(L(potPlus,(u),(v)).zw))\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\nLp(-1,0), Lp(0,0), Lp(1,0),\nLp(-1,1), Lp(0,1), Lp(1,1)\n));\nfloat myStrength = abs(laplacian(pyramid, vec2(thread), lod));\n#else\n#define L(u,v) (((v)+1)*3 + ((u)+1))\nmat3 strengths[2] = mat3[2](mat3(\n#define Lm(u,v) scores[L((u),(v))]\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\nLm(-1,0), Lm(0,0), Lm(1,0),\nLm(-1,1), Lm(0,1), Lm(1,1)\n), mat3(\n#define Lp(u,v) scores[9 + L((u),(v))]\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\nLp(-1,0), Lp(0,0), Lp(1,0),\nLp(-1,1), Lp(0,1), Lp(1,1)\n));\nfloat myStrength = score;\n#endif\n#define B(j,lod) float(isSameLod(lods[j], (lod))) * float(scores[j] > 0.0f)\nmat3 nearLod[2] = mat3[2](mat3(\n#define Bm(j) B((j), lodMinus)\nBm(0), Bm(1), Bm(2),\nBm(3), Bm(4), Bm(5),\nBm(6), Bm(7), Bm(8)\n), mat3(\n#define Bp(j) B((j), lodPlus)\nBp(9), Bp(10), Bp(11),\nBp(12), Bp(13), Bp(14),\nBp(15), Bp(16), Bp(17)\n));\nmat3 upStrengths = matrixCompMult(strengths[1], nearLod[1]);\nmat3 downStrengths = matrixCompMult(strengths[0], nearLod[0]);\nvec3 maxUpStrength3 = max(upStrengths[0], max(upStrengths[1], upStrengths[2]));\nvec3 maxDownStrength3 = max(downStrengths[0], max(downStrengths[1], downStrengths[2]));\nvec3 maxStrength3 = max(maxUpStrength3, maxDownStrength3);\nfloat maxStrength = max(maxStrength3.x, max(maxStrength3.y, maxStrength3.z));\ncolor.rb = encodeFloat16(score * step(maxStrength, myStrength));\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-space.glsl":
/*!********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-space.glsl ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"pyramids.glsl\"\n@include \"float16.glsl\"\nuniform sampler2D corners;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat encodedLod = pixel.a;\nfloat score = decodeFloat16(pixel.rb);\nfloat lod = decodeLod(encodedLod);\nfloat pot = exp2(lod);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\n#if 1\nvec2 gridSize = vec2(pot);\nvec2 gridLocation = floor(mod(texCoord * texSize, gridSize));\nvec2 gridDelta = gridLocation / gridSize - vec2(0.5f);\nfloat gridStep = 1.0f / pot;\nconst float adjustment = 1.25f;\ncolor.rb = encodeFloat16(0.0f);\nif(max(abs(gridDelta.x), abs(gridDelta.y)) > adjustment * gridStep)\nreturn;\n#endif\n#define P(x,y) textureLod(corners, texCoord + pot * vec2((x), (y)) / texSize, 0.0f)\nvec4 pix[9] = vec4[9](\nP(-1,-1), P(0,-1), P(1,-1),\nP(-1,0), pixel, P(1,0),\nP(-1,1), P(0,1), P(1,1)\n);\n#define S(j) decodeFloat16(pix[j].rb)\nmat3 scores = mat3(\nS(0), S(1), S(2),\nS(3), S(4), S(5),\nS(6), S(7), S(8)\n);\n#define B(j) float(isSameLod(decodeLod(pix[j].a), lod))\nmat3 sameLod = mat3(\nB(0), B(1), B(2),\nB(3), B(4), B(5),\nB(6), B(7), B(8)\n);\nmat3 sameLodScores = matrixCompMult(scores, sameLod);\nvec3 maxScore3 = max(sameLodScores[0], max(sameLodScores[1], sameLodScores[2]));\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\ncolor.rb = encodeFloat16(score * step(maxScore, score));\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-suppression.glsl":
/*!**************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/nonmax-suppression.glsl ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"pyramids.glsl\"\n@include \"float16.glsl\"\nuniform sampler2D image;\nuniform float lodStep;\n#if !defined(MULTISCALE)\n#error Must define MULTISCALE\n#elif MULTISCALE != 0\n#define LOD_STEP (lodStep)\n#define USE_MIDDLE_RING\n#else\n#define LOD_STEP (0.0f)\n#endif\n#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))\n#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))\n#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))\n#define P(i) S3(p,i)\n#define Q(i) S2(q,i)\n#define R(i) S2(r,i)\nconst vec4 O = vec4(0.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat lod = decodeLod(pixel.a);\nfloat score = decodeFloat16(pixel.rb);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\nvec4 p[8] = vec4[8](\nPIX(0,1), PIX(1,1), PIX(1,0), PIX(1,-1),\nPIX(0,-1), PIX(-1,-1), PIX(-1,0), PIX(-1,1)\n);\n#ifdef USE_MIDDLE_RING\nvec4 q[16] = vec4[16](\nPIX(0,2), PIX(1,2), PIX(2,2), PIX(2,1),\nPIX(2,0), PIX(2,-1), PIX(2,-2), PIX(1,-2),\nPIX(0,-2), PIX(-1,-2), PIX(-2,-2), PIX(-2,-1),\nPIX(-2,0), PIX(-2,1), PIX(-2,2), PIX(-1,2)\n);\n#else\nvec4 q[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\n#ifdef USE_OUTER_RING\nvec4 r[16] = vec4[16](\nPIX(0,3), PIX(1,3), PIX(3,1), PIX(3,0),\nPIX(3,-1), PIX(1,-3), PIX(0,-3), PIX(-1,-3),\nPIX(-3,-1), PIX(-3,0), PIX(-3,1), PIX(-1,3),\nPIX(0,4), PIX(4,0), PIX(0,-4), PIX(-4,0)\n);\n#else\nvec4 r[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\nfloat alphaPlus = encodeLod(lod + LOD_STEP);\nfloat alphaMinus = encodeLod(lod - LOD_STEP);\nfloat alpha = encodeLod(lod);\nmat3 innerScore = mat3(\nP(0), P(1), P(2), P(3),\nP(4), P(5), P(6), P(7),\n0.0f);\nmat4 middleScore = mat4(\nQ(0), Q(1), Q(2), Q(3),\nQ(4), Q(5), Q(6), Q(7),\nQ(8), Q(9), Q(10), Q(11),\nQ(12), Q(13), Q(14), Q(15)\n);\nmat4 outerScore = mat4(\nR(0), R(1), R(2), R(3),\nR(4), R(5), R(6), R(7),\nR(8), R(9), R(10), R(11),\nR(12), R(13), R(14), R(15)\n);\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\nfloat finalScore = step(maxScore, score) * score;\ncolor.rb = encodeFloat16(finalScore);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/orb-descriptor.glsl":
/*!**********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/orb-descriptor.glsl ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedCorners;\nuniform int encoderLength;\nuniform sampler2D image;\nuniform int extraSize;\nconst int descriptorSize = 32;\n#define P(a,b,c,d) ivec4((a),(b),(c),(d))\nconst ivec4 pat31[256] = ivec4[256](\nP(8,-3,9,5),\nP(4,2,7,-12),\nP(-11,9,-8,2),\nP(7,-12,12,-13),\nP(2,-13,2,12),\nP(1,-7,1,6),\nP(-2,-10,-2,-4),\nP(-13,-13,-11,-8),\nP(-13,-3,-12,-9),\nP(10,4,11,9),\nP(-13,-8,-8,-9),\nP(-11,7,-9,12),\nP(7,7,12,6),\nP(-4,-5,-3,0),\nP(-13,2,-12,-3),\nP(-9,0,-7,5),\nP(12,-6,12,-1),\nP(-3,6,-2,12),\nP(-6,-13,-4,-8),\nP(11,-13,12,-8),\nP(4,7,5,1),\nP(5,-3,10,-3),\nP(3,-7,6,12),\nP(-8,-7,-6,-2),\nP(-2,11,-1,-10),\nP(-13,12,-8,10),\nP(-7,3,-5,-3),\nP(-4,2,-3,7),\nP(-10,-12,-6,11),\nP(5,-12,6,-7),\nP(5,-6,7,-1),\nP(1,0,4,-5),\nP(9,11,11,-13),\nP(4,7,4,12),\nP(2,-1,4,4),\nP(-4,-12,-2,7),\nP(-8,-5,-7,-10),\nP(4,11,9,12),\nP(0,-8,1,-13),\nP(-13,-2,-8,2),\nP(-3,-2,-2,3),\nP(-6,9,-4,-9),\nP(8,12,10,7),\nP(0,9,1,3),\nP(7,-5,11,-10),\nP(-13,-6,-11,0),\nP(10,7,12,1),\nP(-6,-3,-6,12),\nP(10,-9,12,-4),\nP(-13,8,-8,-12),\nP(-13,0,-8,-4),\nP(3,3,7,8),\nP(5,7,10,-7),\nP(-1,7,1,-12),\nP(3,-10,5,6),\nP(2,-4,3,-10),\nP(-13,0,-13,5),\nP(-13,-7,-12,12),\nP(-13,3,-11,8),\nP(-7,12,-4,7),\nP(6,-10,12,8),\nP(-9,-1,-7,-6),\nP(-2,-5,0,12),\nP(-12,5,-7,5),\nP(3,-10,8,-13),\nP(-7,-7,-4,5),\nP(-3,-2,-1,-7),\nP(2,9,5,-11),\nP(-11,-13,-5,-13),\nP(-1,6,0,-1),\nP(5,-3,5,2),\nP(-4,-13,-4,12),\nP(-9,-6,-9,6),\nP(-12,-10,-8,-4),\nP(10,2,12,-3),\nP(7,12,12,12),\nP(-7,-13,-6,5),\nP(-4,9,-3,4),\nP(7,-1,12,2),\nP(-7,6,-5,1),\nP(-13,11,-12,5),\nP(-3,7,-2,-6),\nP(7,-8,12,-7),\nP(-13,-7,-11,-12),\nP(1,-3,12,12),\nP(2,-6,3,0),\nP(-4,3,-2,-13),\nP(-1,-13,1,9),\nP(7,1,8,-6),\nP(1,-1,3,12),\nP(9,1,12,6),\nP(-1,-9,-1,3),\nP(-13,-13,-10,5),\nP(7,7,10,12),\nP(12,-5,12,9),\nP(6,3,7,11),\nP(5,-13,6,10),\nP(2,-12,2,3),\nP(3,8,4,-6),\nP(2,6,12,-13),\nP(9,-12,10,3),\nP(-8,4,-7,9),\nP(-11,12,-4,-6),\nP(1,12,2,-8),\nP(6,-9,7,-4),\nP(2,3,3,-2),\nP(6,3,11,0),\nP(3,-3,8,-8),\nP(7,8,9,3),\nP(-11,-5,-6,-4),\nP(-10,11,-5,10),\nP(-5,-8,-3,12),\nP(-10,5,-9,0),\nP(8,-1,12,-6),\nP(4,-6,6,-11),\nP(-10,12,-8,7),\nP(4,-2,6,7),\nP(-2,0,-2,12),\nP(-5,-8,-5,2),\nP(7,-6,10,12),\nP(-9,-13,-8,-8),\nP(-5,-13,-5,-2),\nP(8,-8,9,-13),\nP(-9,-11,-9,0),\nP(1,-8,1,-2),\nP(7,-4,9,1),\nP(-2,1,-1,-4),\nP(11,-6,12,-11),\nP(-12,-9,-6,4),\nP(3,7,7,12),\nP(5,5,10,8),\nP(0,-4,2,8),\nP(-9,12,-5,-13),\nP(0,7,2,12),\nP(-1,2,1,7),\nP(5,11,7,-9),\nP(3,5,6,-8),\nP(-13,-4,-8,9),\nP(-5,9,-3,-3),\nP(-4,-7,-3,-12),\nP(6,5,8,0),\nP(-7,6,-6,12),\nP(-13,6,-5,-2),\nP(1,-10,3,10),\nP(4,1,8,-4),\nP(-2,-2,2,-13),\nP(2,-12,12,12),\nP(-2,-13,0,-6),\nP(4,1,9,3),\nP(-6,-10,-3,-5),\nP(-3,-13,-1,1),\nP(7,5,12,-11),\nP(4,-2,5,-7),\nP(-13,9,-9,-5),\nP(7,1,8,6),\nP(7,-8,7,6),\nP(-7,-4,-7,1),\nP(-8,11,-7,-8),\nP(-13,6,-12,-8),\nP(2,4,3,9),\nP(10,-5,12,3),\nP(-6,-5,-6,7),\nP(8,-3,9,-8),\nP(2,-12,2,8),\nP(-11,-2,-10,3),\nP(-12,-13,-7,-9),\nP(-11,0,-10,-5),\nP(5,-3,11,8),\nP(-2,-13,-1,12),\nP(-1,-8,0,9),\nP(-13,-11,-12,-5),\nP(-10,-2,-10,11),\nP(-3,9,-2,-13),\nP(2,-3,3,2),\nP(-9,-13,-4,0),\nP(-4,6,-3,-10),\nP(-4,12,-2,-7),\nP(-6,-11,-4,9),\nP(6,-3,6,11),\nP(-13,11,-5,5),\nP(11,11,12,6),\nP(7,-5,12,-2),\nP(-1,12,0,7),\nP(-4,-8,-3,-2),\nP(-7,1,-6,7),\nP(-13,-12,-8,-13),\nP(-7,-2,-6,-8),\nP(-8,5,-6,-9),\nP(-5,-1,-4,5),\nP(-13,7,-8,10),\nP(1,5,5,-13),\nP(1,0,10,-13),\nP(9,12,10,-1),\nP(5,-8,10,-9),\nP(-1,11,1,-13),\nP(-9,-3,-6,2),\nP(-1,-10,1,12),\nP(-13,1,-8,-10),\nP(8,-11,10,-6),\nP(2,-13,3,-6),\nP(7,-13,12,-9),\nP(-10,-10,-5,-7),\nP(-10,-8,-8,-13),\nP(4,-6,8,5),\nP(3,12,8,-13),\nP(-4,2,-3,-3),\nP(5,-13,10,-12),\nP(4,-13,5,-1),\nP(-9,9,-4,3),\nP(0,3,3,-9),\nP(-12,1,-6,1),\nP(3,2,4,-8),\nP(-10,-10,-10,9),\nP(8,-13,12,12),\nP(-8,-12,-6,-5),\nP(2,2,3,7),\nP(10,6,11,-8),\nP(6,8,8,-12),\nP(-7,10,-6,5),\nP(-3,-9,-3,9),\nP(-1,-13,-1,5),\nP(-3,-7,-3,4),\nP(-8,-2,-8,3),\nP(4,2,12,12),\nP(2,-5,3,11),\nP(6,-9,11,-13),\nP(3,-1,7,12),\nP(11,-1,12,4),\nP(-3,0,-3,6),\nP(4,-11,4,12),\nP(2,-4,2,1),\nP(-10,-6,-8,1),\nP(-13,7,-11,1),\nP(-13,12,-11,-13),\nP(6,0,11,-13),\nP(0,-1,1,4),\nP(-13,3,-9,-2),\nP(-9,8,-6,-3),\nP(-13,-6,-8,-2),\nP(5,-9,8,10),\nP(2,7,3,-9),\nP(-1,-6,-1,-1),\nP(9,5,11,-2),\nP(11,-3,12,-8),\nP(3,0,3,5),\nP(-1,4,0,10),\nP(3,-6,4,5),\nP(-13,0,-10,5),\nP(5,8,12,11),\nP(8,9,9,-6),\nP(7,-4,8,-12),\nP(-10,4,-10,9),\nP(7,3,12,4),\nP(9,-7,10,-2),\nP(7,0,12,-2),\nP(-1,-6,0,-11)\n);\nvoid getPair(int index, mat2 rot, out vec2 p, out vec2 q)\n{\nivec4 data = pat31[index];\nvec2 op = vec2(data.xy);\nvec2 oq = vec2(data.zw);\np = rot * op;\nq = rot * oq;\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedCorners);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\ncolor = pixel;\nif(descriptorCell < 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nfloat degreesOrientation = round(360.0f + degrees(keypoint.orientation));\nfloat orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));\nfloat kcos = cos(orientation);\nfloat ksin = sin(orientation);\nmat2 rot = mat2(kcos, ksin, -ksin, kcos);\nfloat pot = exp2(keypoint.lod);\nint patternStart = 32 * descriptorCell;\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\nfor(int t = 0; t < 4; t++) {\nuint bits = 0u;\nvec2 p, q;\nvec4 a, b;\nint i = t * 8;\n@unroll\nfor(int j = 0; j < 8; j++) {\ngetPair(patternStart + i + j, rot, p, q);\na = texelFetch(image, ivec2(round(keypoint.position + pot * p)), 0);\nb = texelFetch(image, ivec2(round(keypoint.position + pot * q)), 0);\nbits |= uint(a.g < b.g) << j;\n}\ntest[t] = bits;\n}\ncolor = vec4(test[0], test[1], test[2], test[3]) / 255.0f;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/orb-orientation.glsl":
/*!***********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/orb-orientation.glsl ***!
  \***********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D image;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define P(x,y) ivec2((x),(y))\nconst int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);\nconst ivec2 diskPoint[708] = ivec2[708](\nP(0,-1),P(-1,0),P(1,0),P(0,1),\nP(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),\nP(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),\nP(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),\nP(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),\nP(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),\nP(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),\nP(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),\nP(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),\nP(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),\nP(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),\nP(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),\nP(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),\nP(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),\nP(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)\n);\nconst int DEFAULT_PATCH_RADIUS = 15;\nconst int MIN_PATCH_RADIUS = 2;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec2 m = vec2(0.0f);\nfloat pot = exp2(keypoint.lod);\nvec2 imageSize = vec2(textureSize(image, 0));\nint scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));\nint radius = max(scaledRadius, MIN_PATCH_RADIUS);\nint count = diskPointCount[radius];\nfor(int j = 0; j < count; j++) {\nvec2 offset = vec2(diskPoint[j]);\nvec2 position = keypoint.position + round(pot * offset);\nvec4 patchPixel = texture(image, (position + vec2(0.5f)) / imageSize);\nm += offset * patchPixel.g;\n}\nfloat angle = fastAtan2(m.y, m.x);\nfloat encodedOrientation = encodeKeypointOrientation(angle);\ncolor = vec4(0.0f, encodedOrientation, 0.0f, 0.0f);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/refine-scale.glsl":
/*!********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/refine-scale.glsl ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"filters.glsl\"\n#if !defined(METHOD)\n#error Undefined METHOD\n#endif\nuniform sampler2D pyramid;\nuniform float lodStep;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if METHOD == 1\nuniform int threshold;\n#endif\nconst float eps = 1e-6;\nfloat cornerStrength(vec2 position, float lod)\n{\n#if METHOD == 0\nreturn laplacian(pyramid, position, lod);\n#elif METHOD == 1\nfloat pot = exp2(lod);\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\n#define P(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\nmat4 mp = mat4(\nP(0,3),P(3,0),P(0,-3),P(-3,0),\nP(1,3),P(2,2),P(3,1),P(3,-1),\nP(2,-2),P(1,-3),P(-1,-3),P(-2,-2),\nP(-3,-1),P(-3,1),P(-2,2),P(-1,3)\n);\nfloat c = P(0,0);\nfloat ct = c + t, c_t = c - t;\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\nreturn max(dot(bs, ones), dot(ds, ones)) / 16.0f;\n#else\n#error Invalid method\n#endif\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nvec3 strength = vec3(\ncornerStrength(keypoint.position, max(0.0f, keypoint.lod - lodStep)),\ncornerStrength(keypoint.position, keypoint.lod),\ncornerStrength(keypoint.position, keypoint.lod + lodStep)\n);\nvec3 p = mat3(\n2, -3, 1,\n-4, 4, 0,\n2, -1, 0\n) * strength;\nfloat maxStrength = max(strength.x, max(strength.y, strength.z));\nvec3 diffStrength = abs(strength - vec3(maxStrength));\nvec3 strengthIndicators = vec3(lessThan(diffStrength, vec3(eps)));\nfloat maxPoint = min(1.0f, dot(vec3(0.0f, 0.5f, 1.0f), strengthIndicators));\nbool hasMax = p.x < -eps;\nfloat pmax = hasMax ? -0.5f * p.y / p.x : maxPoint;\nfloat alpha = abs(pmax - 0.5f) <= 0.5f ? pmax : maxPoint;\nfloat lodOffset = mix(-lodStep, lodStep, alpha);\nfloat lod = keypoint.lod + lodOffset;\ncolor.r = encodeLod(lod);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/score-findmax.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/score-findmax.glsl ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"float16.glsl\"\nuniform sampler2D corners;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 bounds = outputSize();\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = threadPixel(corners);\nvec4 p1 = texelFetch(corners, next1 % bounds, 0);\nvec4 p2 = texelFetch(corners, next2 % bounds, 0);\nvec4 p3 = texelFetch(corners, next3 % bounds, 0);\nfloat s0 = decodeFloat16(p0.rb);\nfloat s1 = decodeFloat16(p1.rb);\nfloat s2 = decodeFloat16(p2.rb);\nfloat s3 = decodeFloat16(p3.rb);\nbool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;\nbool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;\nbool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;\ncolor = vec4(0.0f);\ncolor.rb = b0 ? p0.rb : (\nb1 ? p1.rb : (\nb2 ? p2.rb : p3.rb\n)\n);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/shuffle.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/shuffle.glsl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if PERMUTATION_MAXLEN % 4 > 0 || PERMUTATION_MAXLEN * 4 > 16384\n#error Invalid PERMUTATION_MAXLEN\n#endif\nlayout(std140) uniform Permutation\n{\nivec4 permutation[PERMUTATION_MAXLEN / 4];\n};\nint permutationElement(int index)\n{\nint base = index - (index % PERMUTATION_MAXLEN);\nint offset = index - base;\nivec4 tuple = permutation[offset / 4];\nint newOffset = tuple[offset & 3];\nreturn base + newOffset;\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint otherIndex = permutationElement(myIndex);\nKeypointAddress otherAddress = KeypointAddress(otherIndex * pixelsPerKeypoint, myAddress.offset);\nKeypoint myKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nKeypoint otherKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, otherAddress);\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/sort-keypoints.glsl":
/*!**********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/sort-keypoints.glsl ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n#if !defined(STAGE)\n#error Undefined STAGE\n#elif STAGE == 1\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#elif STAGE == 2\nuniform sampler2D permutation;\nuniform int blockSize;\nuniform int dblLog2BlockSize;\n#elif STAGE == 3\nuniform sampler2D permutation;\nuniform int maxKeypoints;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\n#else\n#error Invalid STAGE\n#endif\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nvec4 encodePermutationElement(PermutationElement element)\n{\nconst vec2 ONES = vec2(1.0f);\nvec2 encodedScore = element.valid ? encodeFloat16(element.score) : ONES;\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\nreturn vec4(encodedIndex, encodedScore);\n}\nPermutationElement decodePermutationElement(vec4 pixel)\n{\nconst vec2 ONES = vec2(1.0f);\nPermutationElement element;\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\nelement.valid = !all(equal(pixel.ba, ONES));\nelement.score = element.valid ? decodeFloat16(pixel.ba) : -1.0f;\nreturn element;\n}\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\n{\nconst vec4 INVALID_PIXEL = vec4(1.0f);\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\nreturn decodePermutationElement(pixel);\n}\n#if STAGE == 2\nPermutationElement selectKth(sampler2D permutation, int k, int la, int ra, int lb, int rb)\n{\nfloat scoreA, scoreB;\nint ha, hb, ma, mb;\nbool discard1stHalf, altb;\nbool locked = false;\nint tmp, result = 0;\nint stride = outputSize().x;\nint height = outputSize().y;\nfor(int i = 0; i < dblLog2BlockSize; i++) {\ntmp = (lb > rb && !locked) ? (la+k) : result;\nresult = (la > ra && !locked) ? (lb+k) : tmp;\nlocked = locked || (la > ra) || (lb > rb);\nha = (ra - la + 1) / 2;\nhb = (rb - lb + 1) / 2;\nma = la + ha;\nmb = lb + hb;\nscoreA = readPermutationElement(permutation, ma, stride, height).score;\nscoreB = readPermutationElement(permutation, mb, stride, height).score;\ndiscard1stHalf = (k > ha + hb);\naltb = (-scoreA < -scoreB);\nk -= int(discard1stHalf && altb) * (ha + 1);\nk -= int(discard1stHalf && !altb) * (hb + 1);\nla += int(discard1stHalf && altb) * (ma + 1 - la);\nlb += int(discard1stHalf && !altb) * (mb + 1 - lb);\nra += int(!discard1stHalf && !altb) * (ma - 1 - ra);\nrb += int(!discard1stHalf && altb) * (mb - 1 - rb);\n}\nreturn readPermutationElement(permutation, result, stride, height);\n}\n#endif\nvoid main()\n{\n#if STAGE == 1\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint keypointIndex = thread.y * stride + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nPermutationElement element;\nelement.keypointIndex = keypointIndex;\nelement.score = keypoint.score;\nelement.valid = !isBadKeypoint(keypoint);\ncolor = encodePermutationElement(element);\n#elif STAGE == 2\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint elementIndex = thread.y * stride + thread.x;\nint blockIndex = elementIndex / blockSize;\nint blockOffset = elementIndex % blockSize;\nint la = blockIndex * blockSize;\nint lb = la + blockSize / 2;\nint ra = lb - 1;\nint rb = (blockIndex + 1) * blockSize - 1;\nint k = blockOffset;\nPermutationElement element = selectKth(permutation, k, la, ra, lb, rb);\ncolor = encodePermutationElement(element);\n#elif STAGE == 3\nivec2 thread = threadLocation();\nint newEncoderLength = outputSize().x;\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\nint myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nivec2 psize = textureSize(permutation, 0);\nPermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);\nint oldEncoderLength = textureSize(encodedKeypoints, 0).x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);\nvec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);\ncolor = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/subpixel-refinement.glsl":
/*!***************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/subpixel-refinement.glsl ***!
  \***************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"float16.glsl\"\n#if !defined(METHOD)\n#error Must define METHOD\n#endif\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int maxIterations;\nuniform float epsilon;\nconst int PATCH_RADIUS = 1;\nconst int PATCH_SIZE = 2 * PATCH_RADIUS + 1;\nconst int PATCH_SIZE_SQUARED = PATCH_SIZE * PATCH_SIZE;\nconst int LARGE_PATCH_RADIUS = PATCH_RADIUS + 1;\nconst int LARGE_PATCH_SIZE = 2 * LARGE_PATCH_RADIUS + 1;\nconst int LARGE_PATCH_SIZE_SQUARED = LARGE_PATCH_SIZE * LARGE_PATCH_SIZE;\nconst int LARGER_PATCH_RADIUS = LARGE_PATCH_RADIUS + 1;\nconst int LARGER_PATCH_SIZE = 2 * LARGER_PATCH_RADIUS + 1;\nconst int LARGER_PATCH_SIZE_SQUARED = LARGER_PATCH_SIZE * LARGER_PATCH_SIZE;\nconst float EPS = 1e-5;\nfloat smoothPixelBuffer[LARGER_PATCH_SIZE_SQUARED];\nvec2 derivativesBuffer[LARGE_PATCH_SIZE_SQUARED];\nfloat responseBuffer[PATCH_SIZE_SQUARED];\n#define patchPixelAt(u,v) smoothPixelBuffer[((v) + LARGER_PATCH_RADIUS) * LARGER_PATCH_SIZE + ((u) + LARGER_PATCH_RADIUS)]\n#define derivativesAt(u,v) derivativesBuffer[((v) + LARGE_PATCH_RADIUS) * LARGE_PATCH_SIZE + ((u) + LARGE_PATCH_RADIUS)]\n#define responseAt(u,v) responseBuffer[((v) + PATCH_RADIUS) * PATCH_SIZE + ((u) + PATCH_RADIUS)]\nvoid readPixels(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nfloat pot = exp2(lod);\nint u, v;\nfor(int j = 0; j < LARGER_PATCH_SIZE; j++) {\nfor(int i = 0; i < LARGER_PATCH_SIZE; i++) {\nu = i - LARGER_PATCH_RADIUS;\nv = j - LARGER_PATCH_RADIUS;\npatchPixelAt(u,v) = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2(u,v), pyrBaseSize).g;\n}\n}\n}\nvoid computeDerivatives()\n{\nconst mat3 dx = mat3(\n-1, 0, 1,\n-2, 0, 2,\n-1, 0, 1\n);\nconst mat3 dy = mat3(\n1, 2, 1,\n0, 0, 0,\n-1,-2,-1\n);\nint u, v;\nmat3 pix, convX, convY;\nconst vec3 ones = vec3(1.0f);\nfor(int j = 0; j < LARGE_PATCH_SIZE; j++) {\nfor(int i = 0; i < LARGE_PATCH_SIZE; i++) {\nu = i - LARGE_PATCH_RADIUS;\nv = j - LARGE_PATCH_RADIUS;\npix = mat3(\npatchPixelAt(u+1,v+1), patchPixelAt(u+0,v+1), patchPixelAt(u-1,v+1),\npatchPixelAt(u+1,v+0), patchPixelAt(u+0,v+0), patchPixelAt(u-1,v+0),\npatchPixelAt(u+1,v-1), patchPixelAt(u+0,v-1), patchPixelAt(u-1,v-1)\n);\nconvX = matrixCompMult(dx, pix);\nconvY = matrixCompMult(dy, pix);\nderivativesAt(u,v) = vec2(\ndot(ones, vec3(\ndot(convX[0], ones),\ndot(convX[1], ones),\ndot(convX[2], ones)\n)),\ndot(ones, vec3(\ndot(convY[0], ones),\ndot(convY[1], ones),\ndot(convY[2], ones)\n))\n);\n}\n}\n}\nvec2 computeResponseMap()\n{\nfloat patchArea = float(PATCH_SIZE * PATCH_SIZE);\nvec3 h; vec2 d, c = vec2(0.0f);\nconst vec3 ones = vec3(1.0f);\nfloat response, sum = 0.0f;\nint u, v;\n#define H(r,s) d = derivativesAt((r),(s)); h += vec3(d.x * d.x, d.x * d.y, d.y * d.y)\nfor(int j = 0; j < PATCH_SIZE; j++) {\nfor(int i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nh = vec3(0.0f);\nH(u-1,v-1); H(u+0,v-1); H(u+1,v-1);\nH(u-1,v+0); H(u+0,v+0); H(u+1,v+0);\nH(u-1,v+1); H(u+0,v+1); H(u+1,v+1);\nresponse = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\nresponse /= patchArea;\nresponseAt(u,v) = response;\nc += vec2(u,v) * response;\nsum += response;\n}\n}\nreturn abs(sum) > EPS ? c / sum : vec2(0.0f);\n}\n#if METHOD == 0\nvec2 quadratic1d()\n{\nfloat a = 0.5f * (responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0));\nfloat b = 0.5f * (responseAt(1,0) - responseAt(-1,0));\nfloat c = responseAt(0,0);\nfloat d = 0.5f * (responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1));\nfloat e = 0.5f * (responseAt(0,1) - responseAt(0,-1));\nfloat f = responseAt(0,0);\nbool hasMax = a < -EPS && d < -EPS;\nreturn hasMax ? -0.5f * vec2(b / a, e / d) : vec2(0.0f);\n}\n#endif\n#if METHOD == 1\nvec2 taylor2d()\n{\nfloat dx = (-responseAt(-1,0) + responseAt(1,0)) * 0.5f;\nfloat dy = (-responseAt(0,-1) + responseAt(0,1)) * 0.5f;\nfloat dxx = responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0);\nfloat dyy = responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1);\nfloat dxy = (responseAt(-1,-1) + responseAt(1,1) - responseAt(1,-1) - responseAt(-1,1)) * 0.25f;\nfloat det = dxx * dyy - dxy * dxy;\nmat2 inv = mat2(dyy, -dxy, -dxy, dxx);\nbool hasMax = det > EPS && dxx < 0.0f;\nreturn hasMax ? inv * vec2(dx, dy) / (-det) : vec2(0.0f);\n}\n#endif\n#if METHOD == 2\nvoid bilinearUpsample(ivec2 patchOffset, vec4 pixelsOfPatch)\n{\nint u, v, i, j;\nvec2 frc, ifrc; vec4 sub;\nconst vec4 ones = vec4(1.0f);\nfloat s = 1.0f / float(PATCH_SIZE - 1);\nint xoff = 2 * patchOffset.x;\nint yoff = 2 * patchOffset.y;\nfor(j = 0; j < PATCH_SIZE; j++) {\nfor(i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nfrc = vec2(i, j) * s;\nifrc = vec2(1.0f) - frc;\nsub = vec4(\nifrc.x * ifrc.y,\nfrc.x * ifrc.y,\nifrc.x * frc.y,\nfrc.x * frc.y\n);\npatchPixelAt(u+xoff,v+yoff) = dot(sub*pixelsOfPatch, ones);\n}\n}\n}\n#endif\n#if METHOD == 3\nvoid bicubicUpsample(ivec2 patchOffset, vec4 pixelsOfPatch, vec4 dx, vec4 dy, vec4 dxy)\n{\nfloat x, y, s = 1.0f / float(PATCH_SIZE - 1);\nint u, v, i, j;\nfloat f00 = pixelsOfPatch.x;\nfloat f10 = pixelsOfPatch.y;\nfloat f01 = pixelsOfPatch.z;\nfloat f11 = pixelsOfPatch.w;\nfloat fx00 = dx.x;\nfloat fx10 = dx.y;\nfloat fx01 = dx.z;\nfloat fx11 = dx.w;\nfloat fy00 = dy.x;\nfloat fy10 = dy.y;\nfloat fy01 = dy.z;\nfloat fy11 = dy.w;\nfloat fxy00 = dxy.x;\nfloat fxy10 = dxy.y;\nfloat fxy01 = dxy.z;\nfloat fxy11 = dxy.w;\nmat4 bicubic = mat4(\n1, 0, -3, 2,\n0, 0, 3, -2,\n0, 1, -2, 1,\n0, 0, -1, 1\n) * mat4(\nf00, f10, fx00, fx10,\nf01, f11, fx01, fx11,\nfy00, fy10, fxy00, fxy10,\nfy01, fy11, fxy01, fxy11\n) * mat4(\n1, 0, 0, 0,\n0, 0, 1, 0,\n-3, 3, -2, -1,\n2, -2, 1, 1\n);\nint xoff = 2 * patchOffset.x;\nint yoff = 2 * patchOffset.y;\nfor(j = 0; j < PATCH_SIZE; j++) {\nfor(i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nx = float(i) * s;\ny = float(j) * s;\npatchPixelAt(u+xoff,v+yoff) = dot(\nvec4(1, x, x*x, x*x*x),\nbicubic * vec4(1, y, y*y, y*y*y)\n);\n}\n}\n}\n#endif\n#if METHOD == 2 || METHOD == 3\nvoid upsamplePatch(int left, int top, int right, int bottom)\n{\nint x, y, k;\nvec4 ptch[9];\nvec2 d00, d10, d01, d11;\nfor(k = 0; k < 9; k++) {\nx = -1 + (k % 3);\ny = -1 + (k / 3);\nptch[k] = vec4(\npatchPixelAt(left+x, top+y),\npatchPixelAt(right+x, top+y),\npatchPixelAt(left+x, bottom+y),\npatchPixelAt(right+x, bottom+y)\n);\n}\nfor(k = 0; k < 9; k++) {\nx = -1 + (k % 3);\ny = -1 + (k / 3);\n#if METHOD == 2\nbilinearUpsample(ivec2(x, y), ptch[k]);\n#elif METHOD == 3\nd00 = derivativesAt(left+x, top+y);\nd10 = derivativesAt(right+x, top+y);\nd01 = derivativesAt(left+x, bottom+y);\nd11 = derivativesAt(right+x, bottom+y);\nbicubicUpsample(ivec2(x, y), ptch[k],\nvec4(d00.x, d10.x, d01.x, d11.x),\nvec4(d00.y, d10.y, d01.y, d11.y),\n0.25f * vec4(\n(patchPixelAt(left+x + 1,top+y + 1) + patchPixelAt(left+x - 1, top+y - 1)) - (patchPixelAt(left+x + 1, top+y - 1) + patchPixelAt(left+x - 1, top+y + 1)),\n(patchPixelAt(right+x + 1,top+y + 1) + patchPixelAt(right+x - 1, top+y - 1)) - (patchPixelAt(right+x + 1, top+y - 1) + patchPixelAt(right+x - 1, top+y + 1)),\n(patchPixelAt(left+x + 1,bottom+y + 1) + patchPixelAt(left+x - 1, bottom+y - 1)) - (patchPixelAt(left+x + 1, bottom+y - 1) + patchPixelAt(left+x - 1, bottom+y + 1)),\n(patchPixelAt(right+x + 1,bottom+y + 1) + patchPixelAt(right+x - 1, bottom+y - 1)) - (patchPixelAt(right+x + 1, bottom+y - 1) + patchPixelAt(right+x - 1, bottom+y + 1))\n)\n);\n#endif\n}\n}\nvec2 upsampleResponseMap(int left, int top, int right, int bottom)\n{\nupsamplePatch(left, top, right, bottom);\ncomputeDerivatives();\nreturn computeResponseMap();\n}\nvec2 iterativeUpsample(vec2 initialGuess)\n{\nint refine = 1;\nfloat scale = 0.5f;\nfloat eps2 = epsilon * epsilon;\nvec2 guess = initialGuess, localGuess = initialGuess;\nfor(int k = 0; k < maxIterations; k++) {\nivec4 quad = ivec4(floor(localGuess.x), floor(localGuess.y), ceil(localGuess.x), ceil(localGuess.y));\nvec2 response = (refine != 0) ? upsampleResponseMap(quad.x, quad.y, quad.z, quad.w) : vec2(0.0f);\nlocalGuess = response * scale;\nguess += localGuess;\nscale *= 0.5f;\nrefine *= int(dot(localGuess, localGuess) >= eps2);\n}\nreturn guess;\n}\n#endif\nvoid main()\n{\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ncolor = encodeNullPairOfFloat16();\nif(isNullKeypoint(keypoint))\nreturn;\ncolor = encodeDiscardedPairOfFloat16();\nif(isBadKeypoint(keypoint))\nreturn;\nreadPixels(keypoint.position, keypoint.lod);\ncomputeDerivatives();\nvec2 offset = computeResponseMap();\n#if METHOD == 0\noffset = quadratic1d();\n#elif METHOD == 1\noffset = taylor2d();\n#elif METHOD == 2 || METHOD == 3\noffset = iterativeUpsample(offset);\n#else\n#error Unknown METHOD\n#endif\nfloat pot = exp2(keypoint.lod);\ncolor = encodePairOfFloat16(offset * pot);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-flow.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-flow.glsl ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\n@include \"float16.glsl\"\nuniform sampler2D encodedFlow;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nint len = textureSize(encodedFlow, 0).x;\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\ncolor = pixel;\nif(isBadKeypoint(keypoint))\nreturn;\nivec2 location = ivec2(myIndex % len, myIndex / len);\nvec4 encodedFlow = myIndex < len * len ? pixelAt(encodedFlow, location) : encodeDiscardedKeypoint();\nbool discardFlow = isDiscardedPairOfFloat16(encodedFlow);\nvec2 flow = !discardFlow ? decodePairOfFloat16(encodedFlow) : vec2(0.0f);\nvec4 newPosition = encodeKeypointPosition(keypoint.position + flow);\nvec4 newPixel = myAddress.offset == 0 ? newPosition : pixel;\ncolor = !discardFlow ? newPixel : encodeDiscardedKeypoint();\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-orientation.glsl":
/*!****************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-orientation.glsl ***!
  \****************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedOrientations;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint orientationEncoderLength = textureSize(encodedOrientations, 0).x;\nivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);\nvec4 targetPixel = pixelAt(encodedOrientations, location);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nbool isValid = !isBadKeypoint(keypoint);\nfloat encodedOrientation = targetPixel.g;\ncolor = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.ba) : pixel;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-to-extra.glsl":
/*!*************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/transfer-to-extra.glsl ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedData;\nuniform int strideOfEncodedData;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvec4 readEncodedData(sampler2D encodedData, int strideOfEncodedData, int elementId, int pixelsPerElement, int pixelOffset)\n{\nint rasterIndex = elementId * pixelsPerElement + pixelOffset;\nivec2 pos = ivec2(rasterIndex % strideOfEncodedData, rasterIndex / strideOfEncodedData);\nreturn texelFetch(encodedData, pos, 0);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint headerSize = sizeofEncodedKeypointHeader();\nint extraCell = myAddress.offset - headerSize / 4;\nint numberOfExtraCells = extraSize / 4;\ncolor = threadPixel(encodedKeypoints);\nif(extraCell < 0 || extraCell >= numberOfExtraCells)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nif(isBadKeypoint(keypoint))\nreturn;\ncolor = readEncodedData(encodedData, strideOfEncodedData, myIndex, numberOfExtraCells, extraCell);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/keypoints/upload-keypoints.glsl":
/*!************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/keypoints/upload-keypoints.glsl ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"keypoints.glsl\"\nuniform sampler2D encodedKeypoints;\nuniform int startIndex;\nuniform int endIndex;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef BUFFER_SIZE\n#error Undefined BUFFER_SIZE\n#endif\nlayout(std140) uniform KeypointBuffer\n{\nvec4 keypointBuffer[BUFFER_SIZE];\n};\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = pixel;\nif(index < startIndex)\nreturn;\ncolor = encodeNullKeypoint();\nif(index >= endIndex)\nreturn;\nvec4 data = keypointBuffer[index - startIndex];\nswitch(address.offset) {\ncase 0: {\ncolor = encodeKeypointPosition(data.xy);\nbreak;\n}\ncase 1: {\nvec2 score = encodeKeypointScore(max(data.w, 0.0f));\nfloat scale = encodeLod(data.z);\nfloat rotation = encodeKeypointOrientation(0.0f);\ncolor = vec4(scale, rotation, score);\nbreak;\n}\ndefault: {\ncolor = vec4(0.0f);\nbreak;\n}\n}\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/pyramids/downsample2.glsl":
/*!******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/pyramids/downsample2.glsl ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nvoid main()\n{\n#if 1\ncolor = texture(image, texCoord);\n#else\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\ncolor = pixelAt(image, pos);\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/pyramids/downsample3.ignore.glsl":
/*!*************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/pyramids/downsample3.ignore.glsl ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 3, textureSize(image, 0) - ivec2(1));\ncolor = pixelAt(image, pos);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/pyramids/upsample2.glsl":
/*!****************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/pyramids/upsample2.glsl ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 2);\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/pyramids/upsample3.ignore.glsl":
/*!***********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/pyramids/upsample3.ignore.glsl ***!
  \***********************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 3);\ncolor = (((thread.x - (thread.y % 3) + 3) % 3) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/transforms/additive-mix.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/transforms/additive-mix.glsl ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"subpixel.glsl\"\nuniform sampler2D image0;\nuniform sampler2D image1;\nuniform float alpha;\nuniform float beta;\nuniform float gamma;\nconst vec4 BACKGROUND = vec4(0.0f);\nvoid main()\n{\nivec2 location = threadLocation();\nivec2 size0 = textureSize(image0, 0);\nivec2 size1 = textureSize(image1, 0);\nvec4 pix0 = all(lessThan(location, size0)) ? pixelAt(image0, location) : BACKGROUND;\nvec4 pix1 = all(lessThan(location, size1)) ? pixelAt(image1, location) : BACKGROUND;\nvec4 pix = clamp(alpha * pix0 + beta * pix1 + vec4(gamma), 0.0f, 1.0f);\ncolor = vec4(pix.rgb, 1.0f);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/transforms/resize.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/transforms/resize.glsl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "@include \"subpixel.glsl\"\nuniform sampler2D image;\nvoid main()\n{\nvec2 imageSize = vec2(textureSize(image, 0));\n#if !defined(INTERPOLATION_METHOD)\n#error Must define INTERPOLATION_METHOD\n#elif INTERPOLATION_METHOD == 0\nvec2 pos = texCoord * imageSize;\ncolor = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);\n#elif INTERPOLATION_METHOD == 1\ncolor = subpixelAtBI(image, texCoord * imageSize);\n#else\n#error Invalid INTERPOLATION_METHOD\n#endif\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/transforms/warp-perspective.glsl":
/*!*************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/transforms/warp-perspective.glsl ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = "@include \"subpixel.glsl\"\nuniform sampler2D image;\nuniform mat3 inverseHomography;\nconst vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\nvec2 perspectiveWarp(mat3 homography, vec2 p)\n{\nvec3 q = homography * vec3(p, 1.0f);\nreturn q.xy / q.z;\n}\nvoid main()\n{\nivec2 location = threadLocation();\nivec2 size = outputSize();\nconst vec2 zero = vec2(0.0f);\nvec2 target = perspectiveWarp(inverseHomography, vec2(location));\nbool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));\ncolor = withinBounds ? subpixelAtBI(image, target) : emptyColor;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/copy-components.glsl":
/*!*******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/copy-components.glsl ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = "@include \"colors.glsl\"\nuniform sampler2D dest, src;\nuniform int destComponents;\nuniform int srcComponentId;\nvoid main()\n{\nvec4 destPixel = threadPixel(dest);\nvec4 srcPixel = threadPixel(src);\nbvec4 flags = bvec4(\n(destComponents & PIXELCOMPONENT_RED) != 0,\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/copy-raster.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/copy-raster.glsl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "#if !defined(TYPE)\n#error Undefined TYPE\n#elif TYPE == 1\n@include \"keypoints.glsl\"\n#define nullPixel() encodeNullKeypoint()\n#elif TYPE == 2\n@include \"float16.glsl\"\n#define nullPixel() encodeNullPairOfFloat16()\n#else\n#error Invalid TYPE\n#endif\nuniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 imageSize = textureSize(image, 0);\nint rasterIndex = thread.y * outputSize().x + thread.x;\nbool isValidPixel = rasterIndex < imageSize.x * imageSize.y;\nivec2 pos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\nvec4 nullpix = nullPixel();\ncolor = isValidPixel ? texelFetch(image, pos, 0) : nullpix;\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/copy.glsl":
/*!********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/copy.glsl ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nvoid main()\n{\ncolor = threadPixel(image);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/crop.ignore.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/crop.ignore.glsl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nivec2 zero = ivec2(0, 0);\ncolor = pixelAt(image, clamp(thread, zero, size - 1));\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/fill-components.glsl":
/*!*******************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/fill-components.glsl ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = "@include \"colors.glsl\"\nuniform sampler2D image;\nuniform int pixelComponents;\nuniform float value;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nbvec4 flags = bvec4(\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(pixel, vec4(value), flags);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/fill.glsl":
/*!********************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/fill.glsl ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = "uniform float value;\nvoid main()\n{\ncolor = vec4(value);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/flip-y.vs.glsl":
/*!*************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/flip-y.vs.glsl ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = "void vsmain()\n{\ngl_Position *= vec4(1,-1,1,1);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/scan-minmax1d.ignore.glsl":
/*!************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/scan-minmax1d.ignore.glsl ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nivec2 jump = ivec2(1 << iterationNumber);\nivec2 groupSize = jump << 1;\nivec2 groupMask = groupSize - ivec2(1);\nivec2 groupId = thread >> (1 + iterationNumber);\nivec2 groupStart = groupId << (1 + iterationNumber);\nivec2 next = groupStart + ((thread - groupStart + jump) & groupMask);\nivec2 safeNext = min(next, last);\nivec2 nextSameRow = ivec2(safeNext.x, thread.y);\nivec2 nextSameCol = ivec2(thread.x, safeNext.y);\nvec4 pixel = texelFetch(image, thread, 0);\nvec4 nextSameRowPixel = texelFetch(image, nextSameRow, 0);\nvec4 nextSameColPixel = texelFetch(image, nextSameCol, 0);\ncolor = vec4(\nmax(pixel.r, nextSameRowPixel.r),\nmax(pixel.g, nextSameColPixel.g),\nmin(pixel.b, nextSameRowPixel.b),\nmin(pixel.a, nextSameColPixel.a)\n);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/scan-minmax2d.glsl":
/*!*****************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/scan-minmax2d.glsl ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = "uniform sampler2D image;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(image, thread, 0);\nvec4 p1 = texelFetch(image, min(next1, last), 0);\nvec4 p2 = texelFetch(image, min(next2, last), 0);\nvec4 p3 = texelFetch(image, min(next3, last), 0);\nvec4 pmax = max(max(p0, p1), max(p2, p3));\nvec4 pmin = min(min(p0, p1), min(p2, p3));\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/sobel-derivatives.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/sobel-derivatives.glsl ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "@include \"pyramids.glsl\"\n@include \"float16.glsl\"\nuniform sampler2D pyramid;\nuniform float lod;\n#define USE_VARYINGS 1\nin vec2 v_pix0, v_pix1, v_pix2,\nv_pix3, v_pix4, v_pix5,\nv_pix6, v_pix7, v_pix8;\nconst mat3 hkern = mat3(\n1.0f, 0.0f,-1.0f,\n2.0f, 0.0f,-2.0f,\n1.0f, 0.0f,-1.0f\n), vkern = mat3(\n1.0f, 2.0f, 1.0f,\n0.0f, 0.0f, 0.0f,\n-1.0f,-2.0f,-1.0f\n);\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\n#define XIP(v) textureLod(pyramid, (v), lod).g\nvoid main()\n{\nconst vec3 ones = vec3(1.0f);\nfloat pot = exp2(lod);\nmat3 win = mat3(\n#if USE_VARYINGS\nXIP(v_pix0), XIP(v_pix1), XIP(v_pix2),\nXIP(v_pix3), XIP(v_pix4), XIP(v_pix5),\nXIP(v_pix6), XIP(v_pix7), XIP(v_pix8)\n#else\nPIX(-1,-1), PIX(0,-1), PIX(1,-1),\nPIX(-1,0), PIX(0,0), PIX(1,0),\nPIX(-1,1), PIX(0,1), PIX(1,1)\n#endif\n);\nmat3 dx = matrixCompMult(hkern, win);\nmat3 dy = matrixCompMult(vkern, win);\nvec2 df = vec2(\ndot(dx[0] + dx[1] + dx[2], ones),\ndot(dy[0] + dy[1] + dy[2], ones)\n);\ncolor = encodePairOfFloat16(df);\n}"

/***/ }),

/***/ "./node_modules/speedy-vision/src/gpu/shaders/utils/sobel-derivatives.vs.glsl":
/*!************************************************************************************!*\
  !*** ./node_modules/speedy-vision/src/gpu/shaders/utils/sobel-derivatives.vs.glsl ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = "uniform mediump float lod;\nout vec2 v_pix0, v_pix1, v_pix2,\nv_pix3, v_pix4, v_pix5,\nv_pix6, v_pix7, v_pix8;\n#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)\nvoid vsmain()\n{\nfloat pot = exp2(lod);\nv_pix0 = PIX(-1,-1); v_pix1 = PIX(0,-1); v_pix2 = PIX(1,-1);\nv_pix3 = PIX(-1,0); v_pix4 = PIX(0,0); v_pix5 = PIX(1,0);\nv_pix6 = PIX(-1,1); v_pix7 = PIX(0,1); v_pix8 = PIX(1,1);\n}"

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inherits)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _possibleConstructorReturn)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js");


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : String(i);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************************************!*\
  !*** ./src/speedy-vision-mod/sink-image-data.js ***!
  \**************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureReader: () => (/* binding */ TextureReader),
/* harmony export */   "default": () => (/* binding */ SpeedyPipelineNodeImageSinkImageData)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var speedy_vision_src_core_pipeline_pipeline_node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! speedy-vision/src/core/pipeline/pipeline-node */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-node.js");
/* harmony import */ var speedy_vision_src_core_pipeline_pipeline_message__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! speedy-vision/src/core/pipeline/pipeline-message */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-message.js");
/* harmony import */ var speedy_vision_src_core_pipeline_pipeline_portbuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! speedy-vision/src/core/pipeline/pipeline-portbuilder */ "./node_modules/speedy-vision/src/core/pipeline/pipeline-portbuilder.js");
/* harmony import */ var speedy_vision_src_gpu_speedy_gpu__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! speedy-vision/src/gpu/speedy-gpu */ "./node_modules/speedy-vision/src/gpu/speedy-gpu.js");
/* harmony import */ var speedy_vision_src_gpu_speedy_texture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! speedy-vision/src/gpu/speedy-texture */ "./node_modules/speedy-vision/src/gpu/speedy-texture.js");
/* harmony import */ var speedy_vision_src_core_speedy_media__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! speedy-vision/src/core/speedy-media */ "./node_modules/speedy-vision/src/core/speedy-media.js");
/* harmony import */ var speedy_vision_src_core_speedy_media_source__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! speedy-vision/src/core/speedy-media-source */ "./node_modules/speedy-vision/src/core/speedy-media-source.js");
/* harmony import */ var speedy_vision_src_utils_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! speedy-vision/src/utils/utils */ "./node_modules/speedy-vision/src/utils/utils.js");
/* harmony import */ var speedy_vision_src_utils_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! speedy-vision/src/utils/types */ "./node_modules/speedy-vision/src/utils/types.js");
/* harmony import */ var speedy_vision_src_core_speedy_promise__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! speedy-vision/src/core/speedy-promise */ "./node_modules/speedy-vision/src/core/speedy-promise.js");
/* harmony import */ var speedy_vision_src_gpu_speedy_texture_reader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! speedy-vision/src/gpu/speedy-texture-reader */ "./node_modules/speedy-vision/src/gpu/speedy-texture-reader.js");





function _callSuper(t, o, e) { return o = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(o), (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }











var TextureReader = /*#__PURE__*/function (_SpeedyTextureReader) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(TextureReader, _SpeedyTextureReader);
  function TextureReader() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, TextureReader);
    return _callSuper(this, TextureReader);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(TextureReader, [{
    key: "readPixels",
    value: function readPixels(gpu, texture) {
      return gpu.readPixelsAsync(texture);
    }
  }]);
  return TextureReader;
}(speedy_vision_src_gpu_speedy_texture_reader__WEBPACK_IMPORTED_MODULE_15__.SpeedyTextureReader);
;
var SpeedyPipelineNodeImageSinkImageData = /*#__PURE__*/function (_SpeedyPipelineSinkNo) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(SpeedyPipelineNodeImageSinkImageData, _SpeedyPipelineSinkNo);
  //#_imageData = null;

  function SpeedyPipelineNodeImageSinkImageData() {
    var _this;
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image';
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, SpeedyPipelineNodeImageSinkImageData);
    _this = _callSuper(this, SpeedyPipelineNodeImageSinkImageData, [name, 0, [(0,speedy_vision_src_core_pipeline_pipeline_portbuilder__WEBPACK_IMPORTED_MODULE_7__.InputPort)().expects(speedy_vision_src_core_pipeline_pipeline_message__WEBPACK_IMPORTED_MODULE_6__.SpeedyPipelineMessageType.Image)]]);

    /** @type {ImageBitmap} output bitmap */
    _this._bitmap = null;

    //this.imageData = null;

    /** @type {ImageFormat} output format */
    _this._format = speedy_vision_src_utils_types__WEBPACK_IMPORTED_MODULE_13__.ImageFormat.RGBA;
    return _this;
  }

  /**
    * Export data from this node to the user
    * @returns {SpeedyPromise<SpeedyMedia>}
    */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(SpeedyPipelineNodeImageSinkImageData, [{
    key: "export",
    value: function _export() {
      var _this2 = this;
      var _this$input$read = /** @type {SpeedyPipelineMessageWithImage} */this.input().read(),
        image = _this$input$read.image,
        format = _this$input$read.format;
      return new speedy_vision_src_core_speedy_promise__WEBPACK_IMPORTED_MODULE_14__.SpeedyPromise(function (resolve) {
        var canvas = gpu.renderToCanvas(image);
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image.source, 0, 0);
        ctx.getImageData(0, 0, image.width, image.height).data.then(function (data) {
          //this._imageData = data;
          _this2._bitmap = data;
          _this2._format = format;
          resolve();
        });
      });
    }

    /**
     * Run the specific task of this node
     * @param {SpeedyGPU} gpu
     * @returns {void|SpeedyPromise<void>}
     */
  }, {
    key: "_run",
    value: function _run(gpu) {
      var _this3 = this;
      var _this$input$read2 = /** @type {SpeedyPipelineMessageWithImage} */this.input().read(),
        image = _this$input$read2.image,
        format = _this$input$read2.format;
      return new speedy_vision_src_core_speedy_promise__WEBPACK_IMPORTED_MODULE_14__.SpeedyPromise(function (resolve) {
        var canvas = gpu.renderToCanvas(image);
        createImageBitmap(canvas, 0, canvas.height - image.height, image.width, image.height).then(function (bitmap) {
          _this3._bitmap = bitmap;
          _this3._format = format;
          resolve();
        });
      });
    }
  }]);
  return SpeedyPipelineNodeImageSinkImageData;
}(speedy_vision_src_core_pipeline_pipeline_node__WEBPACK_IMPORTED_MODULE_5__.SpeedyPipelineSinkNode);

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7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QWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxTQUFTLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLGdCQUFnQixzQ0FBc0MsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxTQUFTLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLFFBQVEsUUFBUSxPQUFPLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxTQUFTLFFBQVEsUUFBUSxTQUFTLFFBQVEsUUFBUSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFFBQVEsUUFBUSxRQUFRLE9BQU8sU0FBUyxRQUFRLFFBQVEsU0FBUyxRQUFRLFFBQVEsU0FBUyxRQUFRLFFBQVEsU0FBUyxRQUFRLFFBQVEsU0FBUyxRQUFRLFFBQVEsU0FBUyxRQUFRLFFBQVEsUUFBUSxRQUFRLFNBQVMsU0FBUyxRQUFRLFFBQVEsT0FBTyxRQUFRLFFBQVEsU0FBUyxRQUFRLFFBQVEsUUFBUSxRQUFRLE9BQU8sT0FBTyxTQUFTLFNBQVMsT0FBTyxTQUFTLFFBQVEsUUFBUSxTQUFTLFFBQVEsUUFBUSxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsU0FBUyxpQkFBaUIsc0NBQXNDLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsU0FBUyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLFNBQVMsUUFBUSxRQUFRLFFBQVEsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFFBQVEsU0FBUyxTQUFTLFFBQVEsU0FBUyxTQUFTLFFBQVEsU0FBUyxTQUFTLE9BQU8sUUFBUSxPQUFPLFFBQVEsUUFBUSxRQUFRLE9BQU8sT0FBTyxTQUFTLE9BQU8sUUFBUSxPQUFPLFFBQVEsUUFBUSxRQUFRLE9BQU8sT0FBTyxTQUFTLE9BQU8sT0FBTyxPQUFPLE9BQU8sUUFBUSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsUUFBUSxRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsT0FBTyxTQUFTLFNBQVMsUUFBUSxTQUFTLFNBQVMsUUFBUSxTQUFTLFNBQVMsUUFBUSxTQUFTLFNBQVMsT0FBTyxPQUFPLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxRQUFRLFFBQVEsUUFBUSxRQUFRLFNBQVMsU0FBUyxPQUFPLFNBQVMsU0FBUyxRQUFRLFNBQVMsU0FBUyxRQUFRLFNBQVMsU0FBUyxRQUFRLFNBQVMsU0FBUyxPQUFPLE9BQU8sU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLE9BQU8sT0FBTyxPQUFPLE9BQU8sUUFBUSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsUUFBUSxTQUFTLFNBQVMsUUFBUSxTQUFTLFFBQVEsU0FBUyxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLE9BQU8sU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsU0FBUyxPQUFPLE9BQU8sU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxRQUFRLFNBQVMsUUFBUSxTQUFTLFFBQVEsU0FBUyxRQUFRLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxPQUFPLFNBQVMsU0FBUyxTQUFTLFNBQVMsUUFBUSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsUUFBUSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsUUFBUSxTQUFTLFNBQVMsU0FBUyxTQUFTLE9BQU8sT0FBTyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxPQUFPLE9BQU8sT0FBTyxPQUFPLFFBQVEsU0FBUyxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUyxpQkFBaUIsNEZBQTRGLEdBQUc7Ozs7Ozs7Ozs7QUNBNXpMLDBDQUEwQyxvQ0FBb0MscUJBQXFCLHVCQUF1QixzQkFBc0IsbU1BQW1NLDBHQUEwRyxvQ0FBb0MsMENBQTBDLDRCQUE0QixpQ0FBaUMsZ0JBQWdCLGtDQUFrQyxnREFBZ0Qsc0RBQXNELHlDQUF5QywyQ0FBMkMsc0NBQXNDLGdEQUFnRCx3R0FBd0csb0RBQW9ELHVDQUF1Qyw2Q0FBNkMsOENBQThDLDBGQUEwRiwyQkFBMkIsNkRBQTZELDJEQUEyRCx3Q0FBd0MsV0FBVzs7Ozs7Ozs7OztBQ0F4OEMsMEhBQTBILDBDQUEwQyxpQ0FBaUMseUJBQXlCLGtDQUFrQyxnQkFBZ0IsdUVBQXVFLCtCQUErQiw0Q0FBNEMsc0RBQXNELHlEQUF5RCxrREFBa0Qsa0lBQWtJLHFGQUFxRix5RkFBeUYsbUZBQW1GLDZFQUE2RSx1QkFBdUIsR0FBRzs7Ozs7Ozs7OztBQ0E3aUMsdUVBQXVFLDBCQUEwQixnQkFBZ0Isa0NBQWtDLDZCQUE2Qiw4QkFBOEIsR0FBRzs7Ozs7Ozs7OztBQ0FqTjs7Ozs7Ozs7OztBQ0FBLCtIQUErSCx3QkFBd0IsOENBQThDLCtCQUErQiw2REFBNkQsaU5BQWlOLGdEQUFnRCxpR0FBaUcsR0FBRzs7Ozs7Ozs7OztBQ0F0b0Isd0pBQXdKLHVEQUF1RDs7Ozs7Ozs7OztBQ0EvTSxpdkJBQWl2Qix1Q0FBdUMsbUNBQW1DLEdBQUcsNkJBQTZCLGFBQWEsNkNBQTZDLEdBQUcsc0NBQXNDLDhCQUE4Qix5Q0FBeUMsR0FBRzs7Ozs7Ozs7OztBQ0F4Z0M7Ozs7Ozs7Ozs7QUNBQSwyRkFBMkYsd0NBQXdDLHlEQUF5RCxHQUFHLGtDQUFrQyx5RUFBeUUsMEJBQTBCLEdBQUc7Ozs7Ozs7Ozs7QUNBdlUsb1lBQW9ZLGlFQUFpRSxzRkFBc0YsbUNBQW1DLGNBQWMsWUFBWSwwQkFBMEIscUJBQXFCLFNBQVMsK0VBQStFLGdDQUFnQyw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNkJBQTZCLEdBQUcsb0JBQW9CLEdBQUcsa0hBQWtILG1DQUFtQyxvRUFBb0UsY0FBYyxhQUFhLFVBQVUsMEJBQTBCLHFCQUFxQixTQUFTLGtGQUFrRix1RUFBdUUsZ0NBQWdDLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDRCQUE0QixnQkFBZ0IsR0FBRyxvQkFBb0IsR0FBRyw2RkFBNkYsb2lCQUFvaUIsa0JBQWtCLGVBQWUsYUFBYSwwQkFBMEIscUJBQXFCLFNBQVMsMENBQTBDLDBDQUEwQyx1QkFBdUIsMkVBQTJFLDRDQUE0QyxHQUFHLGNBQWMsR0FBRzs7Ozs7Ozs7OztBQ0E1Z0YsZ0tBQWdLLHVEQUF1RCxxREFBcUQsMkRBQTJELHlCQUF5QixZQUFZLFdBQVcsSUFBSSxzREFBc0Qsd0RBQXdELGlFQUFpRSxnREFBZ0QsMkJBQTJCLEdBQUcsaURBQWlELGdDQUFnQywwQ0FBMEMsZ0RBQWdELG9DQUFvQyxHQUFHLDJGQUEyRjs7Ozs7Ozs7OztBQ0FyNkIsb01BQW9NLGdCQUFnQixZQUFZLG9CQUFvQixjQUFjLGFBQWEsSUFBSSwyQkFBMkIsV0FBVyxhQUFhLElBQUkseURBQXlELDZEQUE2RCwyQkFBMkIsMkJBQTJCLGdDQUFnQyxtK0JBQW0rQixrREFBa0QseUdBQXlHLG1GQUFtRixHQUFHLDRHQUE0Ryx5REFBeUQsK0VBQStFLDREQUE0RCxzSEFBc0gsaUJBQWlCLEdBQUcsb0dBQW9HLG9CQUFvQixxRUFBcUUsdUVBQXVFLCtGQUErRiw2REFBNkQsMklBQTJJLG1HQUFtRyxtREFBbUQsMkVBQTJFLGdFQUFnRSx3REFBd0Qsb0ZBQW9GLG9FQUFvRSw0QkFBNEIsNENBQTRDLHNEQUFzRCxrQkFBa0IsR0FBRywrQ0FBK0MsZ0NBQWdDLGlEQUFpRCwwQkFBMEIsaUNBQWlDLCtDQUErQyxHQUFHOzs7Ozs7Ozs7O0FDQWhrSCw4VkFBOFYsNEJBQTRCLDBCQUEwQixtSUFBbUksR0FBRyxzQ0FBc0MsOEZBQThGLEdBQUc7Ozs7Ozs7Ozs7QUNBanFCLHd5QkFBd3lCLGlFQUFpRSx1RUFBdUUsbUpBQW1KLG9HQUFvRyw0Q0FBNEMsR0FBRyxxSEFBcUg7Ozs7Ozs7Ozs7QUNBMzBDLGs4QkFBazhCLDBDQUEwQywrQkFBK0IsaUVBQWlFLHFCQUFxQixjQUFjLGdCQUFnQixRQUFRLGlCQUFpQixPQUFPLE1BQU0sa0JBQWtCLGtCQUFrQiwrQkFBK0Isd0JBQXdCLCtEQUErRCw4QkFBOEIsOEJBQThCLFlBQVksR0FBRyxnQkFBZ0IsV0FBVyxHQUFHLG1EQUFtRCxnQkFBZ0IsMEJBQTBCLGtDQUFrQyxnREFBZ0QseUVBQXlFLEdBQUcsa0RBQWtELEdBQUc7Ozs7Ozs7Ozs7QUNBeHRELDJNQUEyTSx3QkFBd0IsK0JBQStCLG1FQUFtRSwwQ0FBMEMsNERBQTRELDREQUE0RCw0REFBNEQsOENBQThDLGtGQUFrRixtQkFBbUIsR0FBRzs7Ozs7Ozs7OztBQ0F6ckIsdUZBQXVGLGtDQUFrQyw2QkFBNkIsaUNBQWlDLG1DQUFtQyw4QkFBOEIsa0NBQWtDLDJDQUEyQyxnQkFBZ0Isa0NBQWtDLHNIQUFzSCxvRkFBb0YsaURBQWlELCtFQUErRSx1Q0FBdUMseUZBQXlGLDZGQUE2RixzSEFBc0gsR0FBRzs7Ozs7Ozs7OztBQ0F2aEMsdUZBQXVGLGtDQUFrQyw2QkFBNkIsaUNBQWlDLG1DQUFtQyw4QkFBOEIsa0NBQWtDLGdCQUFnQixrQ0FBa0Msc0hBQXNILG9GQUFvRixpREFBaUQsb0RBQW9ELCtFQUErRSw0Q0FBNEMsZ0RBQWdELGlGQUFpRix5RkFBeUYsNkZBQTZGLDJHQUEyRyxHQUFHOzs7Ozs7Ozs7O0FDQTNwQyx1RUFBdUUscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLGdCQUFnQiw2Q0FBNkMsa0NBQWtDLGtHQUFrRyxnQkFBZ0Isa0NBQWtDLCtFQUErRSxzQ0FBc0MseURBQXlELG1EQUFtRCxHQUFHOzs7Ozs7Ozs7O0FDQXBwQiw0SkFBNEosbUNBQW1DLDRCQUE0Qix1Q0FBdUMsK0JBQStCLDBCQUEwQiw4QkFBOEIscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLHFCQUFxQixvSkFBb0osZ0JBQWdCLGtDQUFrQywwREFBMEQsK0VBQStFLGtGQUFrRiwrRUFBK0UsK0NBQStDLHNDQUFzQyw2RUFBNkUsK0VBQStFLGlJQUFpSSxxQ0FBcUMscUZBQXFGLGlCQUFpQixrQ0FBa0MsTUFBTSxrRUFBa0Usd0ZBQXdGLHVGQUF1Rix1SEFBdUgsMkhBQTJILDhQQUE4UCw4RUFBOEUsR0FBRyx5Q0FBeUMsR0FBRzs7Ozs7Ozs7OztBQ0F2MUUsMERBQTBELHVDQUF1QyxnQkFBZ0Isa0NBQWtDLHdCQUF3QiwyQkFBMkIsdUNBQXVDLHVDQUF1QyxxREFBcUQsc0VBQXNFLHNFQUFzRSxpQ0FBaUMsK0NBQStDLCtDQUErQywrQ0FBK0MsaUNBQWlDLCtDQUErQywrQ0FBK0MsK0NBQStDLGtIQUFrSCxnQ0FBZ0MsZ0RBQWdELGdDQUFnQyxnQ0FBZ0MsMklBQTJJLDJJQUEySSwwRUFBMEUsMEVBQTBFLHVDQUF1QyxxQ0FBcUMscUNBQXFDLHVDQUF1QywrQ0FBK0MsaUNBQWlDLG9FQUFvRSx3QkFBd0IsbUZBQW1GLGtHQUFrRyw2QkFBNkIsc0NBQXNDLHFFQUFxRSxtREFBbUQsa0RBQWtELCtEQUErRCxHQUFHOzs7Ozs7Ozs7O0FDQXJ3RSxzRUFBc0UsMEJBQTBCLHdCQUF3QiwwQkFBMEIsMkJBQTJCLHlCQUF5QixxQ0FBcUMsNkJBQTZCLHdCQUF3Qiw0QkFBNEIsZ0JBQWdCLGtDQUFrQywrRkFBK0YsNEVBQTRFLDZCQUE2QixvS0FBb0ssNkNBQTZDLHdDQUF3QywyQ0FBMkMsR0FBRzs7Ozs7Ozs7OztBQ0E3MUIsa0ZBQWtGLDZCQUE2Qix3QkFBd0IsNEJBQTRCLDJCQUEyQixnQkFBZ0Isa0NBQWtDLHdDQUF3QyxxR0FBcUcsb0VBQW9FLDBFQUEwRSw4REFBOEQsR0FBRzs7Ozs7Ozs7OztBQ0E1a0Isa0ZBQWtGLDZCQUE2Qix3QkFBd0IsNEJBQTRCLCtCQUErQixnQkFBZ0Isa0NBQWtDLDBGQUEwRiwyREFBMkQsK0VBQStFLGdHQUFnRywwRUFBMEUsR0FBRzs7Ozs7Ozs7OztBQ0Fyb0IsbUZBQW1GLDZCQUE2QixzQ0FBc0MsNkJBQTZCLDZCQUE2Qix3QkFBd0IsNEJBQTRCLDBCQUEwQixnQkFBZ0Isa0NBQWtDLGtHQUFrRyxvRUFBb0UsK0VBQStFLDJFQUEyRSxlQUFlLGtFQUFrRSxrRkFBa0Ysa0ZBQWtGLCtCQUErQixxRUFBcUUsb0NBQW9DLCtFQUErRSxvQ0FBb0MscUVBQXFFLHVEQUF1RCxpRUFBaUUsd0RBQXdELEdBQUc7Ozs7Ozs7Ozs7QUNBeDNDLDRFQUE0RSwwQkFBMEIsOFBBQThQLHlDQUF5QyxrQ0FBa0Msc0RBQXNELHVDQUF1QywyQkFBMkIsK0JBQStCLHNCQUFzQixjQUFjLDBCQUEwQixvQkFBb0IsTUFBTSwwRUFBMEUsZ0NBQWdDLG9FQUFvRSxxQ0FBcUMsbUNBQW1DLGdDQUFnQyxHQUFHLHdDQUF3QywwQkFBMEIsMkNBQTJDLEdBQUc7Ozs7Ozs7Ozs7QUNBdmlDLHVFQUF1RSwwQkFBMEIsZ0JBQWdCLG9DQUFvQywrQkFBK0IsK0JBQStCLHdDQUF3QyxvQkFBb0IsNkVBQTZFLHFCQUFxQix1Q0FBdUMsOEJBQThCLGlKQUFpSixTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsUUFBUSwwQkFBMEIsc0NBQXNDLEdBQUc7Ozs7Ozs7Ozs7QUNBL3JCLDhFQUE4RSwwQkFBMEIscUJBQXFCLHdCQUF3Qiw0QkFBNEIscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLHlLQUF5SyxxQ0FBcUMsMkJBQTJCLDJCQUEyQixvQkFBb0IsMERBQTBELDZDQUE2Qyx5RUFBeUUsZ0RBQWdELDRDQUE0QyxpREFBaUQsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0Isa0NBQWtDLCtFQUErRSxrR0FBa0csZ0VBQWdFLHFCQUFxQixrQ0FBa0Msd0NBQXdDLGdEQUFnRCxtREFBbUQsMEZBQTBGLDZDQUE2QyxxQ0FBcUMsK0RBQStELGtIQUFrSCwrR0FBK0csb0ZBQW9GLGFBQWEsK0JBQStCLG1IQUFtSCxpREFBaUQsR0FBRzs7Ozs7Ozs7OztBQ0E1bUUseUVBQXlFLHFDQUFxQyw2QkFBNkIsd0JBQXdCLDRCQUE0QixnQkFBZ0Isa0NBQWtDLDZDQUE2QywrRUFBK0Usa0dBQWtHLGdFQUFnRSxnQkFBZ0Isa0NBQWtDLCtFQUErRSx5REFBeUQsMENBQTBDLG1CQUFtQiw0Q0FBNEMsaURBQWlELEdBQUc7Ozs7Ozs7Ozs7QUNBdDJCLHlFQUF5RSx5Q0FBeUMscUJBQXFCLDZCQUE2Qix3QkFBd0IsNEJBQTRCLDhCQUE4Qiw0Q0FBNEMsZ0JBQWdCLGtDQUFrQyxrR0FBa0csb0VBQW9FLG9EQUFvRCxnREFBZ0QsK0VBQStFLGtEQUFrRCxxREFBcUQsa0ZBQWtGLG1FQUFtRSwrQkFBK0Isc0dBQXNHLGlEQUFpRCxrQ0FBa0MscUJBQXFCLGtFQUFrRSx1REFBdUQsbUVBQW1FLDZEQUE2RCw2QkFBNkIsNkRBQTZELEdBQUc7Ozs7Ozs7Ozs7QUNBNStDLDZEQUE2RCwrQkFBK0IsR0FBRzs7Ozs7Ozs7OztBQ0EvRixtR0FBbUcsNEJBQTRCLG9CQUFvQix3QkFBd0IsZ1BBQWdQLGlMQUFpTCx1Q0FBdUMsbUNBQW1DLGtDQUFrQyw0QkFBNEIsd0JBQXdCLHFEQUFxRCx3Q0FBd0MsdUNBQXVDLCtEQUErRCxrRUFBa0UsbUdBQW1HLDZFQUE2RSxzRUFBc0UsZ0VBQWdFLCtGQUErRix1RkFBdUYsNENBQTRDLDhQQUE4UCxzTkFBc04sMldBQTJXLDh2RUFBOHZFLHdCQUF3Qix3RUFBd0Usd0VBQXdFLHlGQUF5RixtREFBbUQseURBQXlELGdDQUFnQywwQkFBMEIsZ0NBQWdDLDBCQUEwQixnQ0FBZ0MsMEJBQTBCLDhEQUE4RCwyQ0FBMkMsbUVBQW1FLDZEQUE2RCxXQUFXOzs7Ozs7Ozs7O0FDQXIxSyw0Q0FBNEMseU5BQXlOLDRIQUE0SCx3QkFBd0IsMkNBQTJDLHdEQUF3RCxxQkFBcUIsMkRBQTJELHNCQUFzQixnRUFBZ0UsdUJBQXVCLDhEQUE4RCxXQUFXOzs7Ozs7Ozs7O0FDQWx3QiwySEFBMkgsNkJBQTZCLHNDQUFzQyw2QkFBNkIsNkJBQTZCLHdCQUF3Qiw0QkFBNEIsd0JBQXdCLGdCQUFnQixrQ0FBa0Msa0dBQWtHLG9FQUFvRSwrRUFBK0UsMkVBQTJFLGVBQWUsa0VBQWtFLGtGQUFrRixrRkFBa0YsK0JBQStCLHFFQUFxRSxvQ0FBb0MsK0VBQStFLG9DQUFvQyxxRUFBcUUsaURBQWlELDhHQUE4Ryw4R0FBOEcsMEVBQTBFLHdDQUF3Qyx3REFBd0QsR0FBRzs7Ozs7Ozs7OztBQ0FycUQsdUVBQXVFLDZCQUE2Qix3QkFBd0IsZ0JBQWdCLG9DQUFvQyx3Q0FBd0MseURBQXlELHdEQUF3RCxnQkFBZ0IsaUVBQWlFLEdBQUc7Ozs7Ozs7Ozs7QUNBN1osOE9BQThPLDRCQUE0QixnQ0FBZ0Msb0JBQW9CLHdCQUF3Qix3Q0FBd0MsdUpBQXVKLG1EQUFtRCxtRkFBbUYseUJBQXlCLGtDQUFrQyxvQ0FBb0MseUJBQXlCLHVCQUF1QixzQkFBc0IsZ0JBQWdCLCtCQUErQixvQ0FBb0MsU0FBUyxRQUFRLFdBQVcsUUFBUSxPQUFPLFdBQVcsUUFBUSxPQUFPLG9DQUFvQyxVQUFVLFNBQVMsU0FBUyxRQUFRLFlBQVksVUFBVSxTQUFTLFNBQVMsUUFBUSxXQUFXLFNBQVMsUUFBUSxRQUFRLE9BQU8sV0FBVyxTQUFTLFFBQVEsUUFBUSxPQUFPLFdBQVcsU0FBUyxRQUFRLFFBQVEsT0FBTyxvQ0FBb0MsVUFBVSxVQUFVLFNBQVMsU0FBUyxTQUFTLFFBQVEsWUFBWSxVQUFVLFVBQVUsU0FBUyxTQUFTLFNBQVMsUUFBUSxZQUFZLFVBQVUsVUFBVSxTQUFTLFNBQVMsU0FBUyxRQUFRLFdBQVcsU0FBUyxTQUFTLFFBQVEsUUFBUSxRQUFRLE9BQU8sV0FBVyxTQUFTLFNBQVMsUUFBUSxRQUFRLFFBQVEsT0FBTyxXQUFXLFNBQVMsU0FBUyxRQUFRLFFBQVEsUUFBUSxPQUFPLFdBQVcsU0FBUyxTQUFTLFFBQVEsUUFBUSxRQUFRLE9BQU8sc0lBQXNJLCtDQUErQyxvRUFBb0UsMEVBQTBFLCtFQUErRSxtREFBbUQseUVBQXlFLGlIQUFpSCxHQUFHOzs7Ozs7Ozs7O0FDQXB5RSxvRUFBb0UscUZBQXFGLG9GQUFvRiwrQ0FBK0MsR0FBRzs7Ozs7Ozs7OztBQ0EvUix1RkFBdUYsc0NBQXNDLHlDQUF5Qyx1QkFBdUIsZ0JBQWdCLGtDQUFrQyxxREFBcUQsMkRBQTJELHdEQUF3RCw0REFBNEQsMkRBQTJELHNDQUFzQyxvQ0FBb0MsK0NBQStDLGdFQUFnRSxrRkFBa0YsZ0RBQWdELEdBQUc7Ozs7Ozs7Ozs7QUNBNTBCLDhIQUE4SCw0QkFBNEIsd0JBQXdCLDBCQUEwQixnQkFBZ0Isa0NBQWtDLG9DQUFvQyxpQ0FBaUMsd0RBQXdELGdGQUFnRiw4REFBOEQsd0dBQXdHLHVEQUF1RCxHQUFHOzs7Ozs7Ozs7O0FDQTNxQix3R0FBd0csZ0NBQWdDLGdDQUFnQyxrQ0FBa0Msb0JBQW9CLG9CQUFvQixpQ0FBaUMsaUNBQWlDLHdCQUF3Qiw2QkFBNkIsd0JBQXdCLDRCQUE0Qix5SkFBeUosZ0VBQWdFLGlEQUFpRCwyRUFBMkUsd0VBQXdFLDREQUE0RCxtREFBbUQsb0RBQW9ELGdEQUFnRCx5UUFBeVEsa0pBQWtKLDhCQUE4QixrREFBa0Qsd0JBQXdCLGdCQUFnQixRQUFRLDJEQUEyRCwwQ0FBMEMsZ0hBQWdILCtIQUErSCxpQkFBaUIsTUFBTSxpQkFBaUIsaUJBQWlCLE1BQU0seUJBQXlCLEdBQUcsR0FBRyxlQUFlLGlCQUFpQixpQkFBaUIsTUFBTSx5QkFBeUIseUJBQXlCLHdCQUF3Qix3QkFBd0IsR0FBRyx3QkFBd0Isd0JBQXdCLHdCQUF3Qix3QkFBd0IsR0FBRywwREFBMEQsNkRBQTZELDZEQUE2RCx5REFBeUQsK2hCQUEraEIsdUNBQXVDLHVDQUF1QywrQkFBK0Isb0lBQW9JLEdBQUcsdURBQXVELDhCQUE4QixnQ0FBZ0MseURBQXlELG1FQUFtRSxHQUFHLHlEQUF5RCxpQ0FBaUMsMkJBQTJCLCtCQUErQixvTUFBb00seUZBQXlGLDhDQUE4QyxHQUFHLHlEQUF5RCw4QkFBOEIscUJBQXFCLDRCQUE0QixtQkFBbUIsaUNBQWlDLHNDQUFzQyxrQkFBa0IsUUFBUSxnQkFBZ0IsWUFBWSxvSUFBb0ksc0RBQXNELEtBQUssdUJBQXVCLGtCQUFrQixPQUFPLGNBQWMsR0FBRyxvQ0FBb0MsR0FBRyxzQ0FBc0MscURBQXFELGtDQUFrQyxxR0FBcUcsR0FBRyxnQkFBZ0Isd0NBQXdDLGtDQUFrQyxzREFBc0QsOEJBQThCLDJEQUEyRCwrRUFBK0Usa0ZBQWtGLDRFQUE0RSxvQ0FBb0MsdUNBQXVDLHlDQUF5QyxzQ0FBc0MsZ0ZBQWdGLG1CQUFtQiw4Q0FBOEMsb0JBQW9CLDRCQUE0QixpQkFBaUIsaUJBQWlCLE1BQU0saUJBQWlCLGlCQUFpQixNQUFNLGdFQUFnRSx1SEFBdUgsd0NBQXdDLEdBQUcsR0FBRyxpREFBaUQsd0VBQXdFLDhEQUE4RCxtRUFBbUUsc0pBQXNKLG1HQUFtRyx3REFBd0QsdUNBQXVDLHNEQUFzRCxpQkFBaUIsd0JBQXdCLE1BQU0sbUZBQW1GLHdDQUF3QyxnREFBZ0QsMkNBQTJDLEdBQUcsMkNBQTJDLHFIQUFxSCwyRkFBMkYsR0FBRzs7Ozs7Ozs7OztBQ0F2OE4sdUVBQXVFLDBCQUEwQiw4SEFBOEgsMERBQTBELDJHQUEyRyx3QkFBd0Isb0JBQW9CLHFCQUFxQiwyR0FBMkcsb0RBQW9ELGdCQUFnQixzREFBc0QseUNBQXlDLDhDQUE4QyxrREFBa0QsMERBQTBELHFGQUFxRixrREFBa0QsNkVBQTZFLG9EQUFvRCxrQ0FBa0MsdUNBQXVDLGdDQUFnQyw4Q0FBOEMsNkNBQTZDLG1GQUFtRix1RUFBdUUsMkNBQTJDLG9EQUFvRCxHQUFHLGdkQUFnZCxtREFBbUQsNktBQTZLLCtKQUErSiw4SkFBOEosOEJBQThCLHdDQUF3QyxrQ0FBa0MsOENBQThDLG9DQUFvQyw0Q0FBNEMsZ0NBQWdDLHNDQUFzQywyRkFBMkYsMkJBQTJCLHFDQUFxQywrQkFBK0IsMkNBQTJDLGlDQUFpQyx5Q0FBeUMsNkJBQTZCLG1DQUFtQyxzTUFBc00sZ0VBQWdFLGlDQUFpQywyQ0FBMkMsOERBQThELG1CQUFtQixtQ0FBbUMsK0NBQStDLHNEQUFzRCxnQ0FBZ0Msc0dBQXNHLHVDQUF1QyxtQ0FBbUMseUNBQXlDLHlDQUF5Qyx5Q0FBeUMseUNBQXlDLGtEQUFrRCw4REFBOEQsd1JBQXdSLGlFQUFpRSw4QkFBOEIsb0RBQW9ELDJFQUEyRSxXQUFXOzs7Ozs7Ozs7O0FDQTdzSiwrR0FBK0csNEdBQTRHLGtCQUFrQiw2QkFBNkIsbUZBQW1GLGlCQUFpQixxQkFBcUIsb0JBQW9CLG1CQUFtQixpQkFBaUIsMEJBQTBCLG1CQUFtQix1QkFBdUIsR0FBRzs7Ozs7Ozs7OztBQ0FsZ0Isd0pBQXdKLDRCQUE0Qiw0QkFBNEIsMkJBQTJCLGlDQUFpQyx5QkFBeUIsNkJBQTZCLDhCQUE4QiwyQkFBMkIsaUNBQWlDLHFDQUFxQyw2QkFBNkIsd0JBQXdCLDRCQUE0QixvU0FBb1MsMERBQTBELElBQUksbUVBQW1FLDBOQUEwTixxRUFBcUUsaVJBQWlSLHFFQUFxRSw2VUFBNlUscUVBQXFFLDhZQUE4WSxzRUFBc0Usd2RBQXdkLHNFQUFzRSxrakJBQWtqQixzRUFBc0Usa3BCQUFrcEIsc0VBQXNFLHd2QkFBd3ZCLHNFQUFzRSxzM0JBQXMzQixzRUFBc0UsMi9CQUEyL0Isc0VBQXNFLHVvQ0FBdW9DLDBJQUEwSSxpREFBaUQsOERBQThELGdFQUFnRSxzQ0FBc0MsMkJBQTJCLEdBQUcsNEVBQTRFLGlCQUFpQixlQUFlLDBCQUEwQixlQUFlLE1BQU0sMENBQTBDLGdCQUFnQix1QkFBdUIsc0RBQXNELEdBQUcsY0FBYyxHQUFHLHVMQUF1TCxrQ0FBa0MsMERBQTBELCtFQUErRSxrRkFBa0YsK0VBQStFLCtDQUErQyxzQ0FBc0MseUVBQXlFLG9FQUFvRSw0Q0FBNEMsaUlBQWlJLHFEQUFxRCxpQkFBaUIsc0JBQXNCLE1BQU0sNkJBQTZCLG1FQUFtRSwyREFBMkQseUJBQXlCLGlCQUFpQixvQkFBb0IsTUFBTSx1Q0FBdUMsNEZBQTRGLG9EQUFvRCxrQ0FBa0MseUhBQXlILCtGQUErRiwwRUFBMEUsOEhBQThILG9IQUFvSCwyRUFBMkUsaUdBQWlHLHNDQUFzQyxHQUFHLEdBQUcseUNBQXlDLEdBQUc7Ozs7Ozs7Ozs7QUNBempXLDJLQUEySyxzQ0FBc0MsNkJBQTZCLDZCQUE2QiwrQkFBK0IsK0JBQStCLDZCQUE2Qix3QkFBd0IsNEJBQTRCLHVEQUF1RCw2QkFBNkIsd0JBQXdCLDRCQUE0QiwyQkFBMkIsNENBQTRDLHdCQUF3Qiw0Q0FBNEMscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLDRDQUE0Qyw0R0FBNEcsZ0JBQWdCLGtEQUFrRCwrRkFBK0YseUVBQXlFLDZHQUE2RywrQkFBK0IsMEVBQTBFLCtFQUErRSw0RUFBNEUseUVBQXlFLHlFQUF5RSwyREFBMkQsb0RBQW9ELDJEQUEyRCwrRUFBK0UsK0VBQStFLDRFQUE0RSwyRUFBMkUsZ0VBQWdFLDZFQUE2RSxvREFBb0QsNEJBQTRCLG9DQUFvQyxnREFBZ0QsOENBQThDLCtDQUErQyxnSEFBZ0gsMENBQTBDLDBEQUEwRCw0UEFBNFAsaURBQWlELGVBQWUsbUNBQW1DLHlDQUF5QyxzREFBc0QsNkNBQTZDLDZDQUE2QyxxQ0FBcUMsK0RBQStELDRCQUE0QixtREFBbUQsMkJBQTJCLDhFQUE4RSxnREFBZ0QsbURBQW1ELG9EQUFvRCwrRUFBK0UsK0ZBQStGLHlFQUF5RSw4RkFBOEYsa0ZBQWtGLG1EQUFtRCwrQkFBK0IsMEZBQTBGLCtGQUErRixxRUFBcUUsZ0VBQWdFLHVGQUF1RixXQUFXOzs7Ozs7Ozs7O0FDQTdrSix3R0FBd0csa0NBQWtDLGdDQUFnQyxnQ0FBZ0MseUJBQXlCLHdCQUF3QixpQ0FBaUMsb0JBQW9CLDZCQUE2Qix3QkFBd0IsNEJBQTRCLHdOQUF3TiwrRUFBK0UsNkVBQTZFLHlDQUF5QyxtQkFBbUIsZ0VBQWdFLHVDQUF1QyxrQkFBa0IseVhBQXlYLGtEQUFrRCx3QkFBd0IseUJBQXlCLFdBQVcsZUFBZSxtQkFBbUIsYUFBYSxnQkFBZ0IsTUFBTSxhQUFhLGdCQUFnQixNQUFNLDJCQUEyQiwrR0FBK0csR0FBRyxHQUFHLGFBQWEsZUFBZSxNQUFNLGFBQWEsZ0JBQWdCLE1BQU0sMkJBQTJCLCtHQUErRyxrSEFBa0gsR0FBRyxHQUFHLGFBQWEsZUFBZSxNQUFNLGFBQWEsZUFBZSxNQUFNLDJCQUEyQiwrR0FBK0csR0FBRyxHQUFHLG9DQUFvQyx5REFBeUQsdUNBQXVDLEdBQUcsMkNBQTJDLGtEQUFrRCx3QkFBd0IsbUJBQW1CLHdCQUF3QixlQUFlLGlCQUFpQixlQUFlLE1BQU0saUJBQWlCLGVBQWUsTUFBTSwyQkFBMkIsMEdBQTBHLEdBQUcsR0FBRyx3Q0FBd0MscUNBQXFDLEdBQUcsNkdBQTZHLHlCQUF5Qiw2REFBNkQsc0NBQXNDLG1EQUFtRCxpQkFBaUIsZUFBZSxNQUFNLGlCQUFpQixlQUFlLE1BQU0sMkNBQTJDLHFDQUFxQyxxQkFBcUIsc0JBQXNCLHNCQUFzQixHQUFHLEdBQUcsdUNBQXVDLCtDQUErQyxzRkFBc0YsaUJBQWlCLGVBQWUsTUFBTSxpQkFBaUIsZUFBZSxNQUFNLHdEQUF3RCxtREFBbUQscUJBQXFCLHNCQUFzQixzQkFBc0IsR0FBRyxHQUFHLG1HQUFtRyxXQUFXLG9DQUFvQyw2Q0FBNkMsNkNBQTZDLDZDQUE2Qyw2Q0FBNkMsNkNBQTZDLDZDQUE2Qyw2Q0FBNkMsNkNBQTZDLDZDQUE2QyxxRkFBcUYsdUNBQXVDLHFGQUFxRixrREFBa0Qsa0RBQWtELG9DQUFvQyx3Q0FBd0MsbUJBQW1CLDhCQUE4QixrR0FBa0csc0JBQXNCLDZFQUE2RSxHQUFHLGdCQUFnQix3Q0FBd0Msa0NBQWtDLDJEQUEyRCwrRUFBK0Usa0ZBQWtGLDRFQUE0RSxvQ0FBb0MsdUNBQXVDLDBDQUEwQyxzQ0FBc0Msd0JBQXdCLHdFQUF3RSxlQUFlLDJCQUEyQiw0Q0FBNEMsMkNBQTJDLDBDQUEwQyxpQ0FBaUMseUJBQXlCLGlCQUFpQixnQkFBZ0IsTUFBTSxpQkFBaUIsZ0JBQWdCLE1BQU0sK0JBQStCLG1DQUFtQywyREFBMkQsa0NBQWtDLEdBQUcsR0FBRyxxQ0FBcUMsd0ZBQXdGLEdBQUc7Ozs7Ozs7Ozs7QUNBaGlNLG1NQUFtTSw0QkFBNEIsd0JBQXdCLG9EQUFvRCx3QkFBd0Isa0NBQWtDLG9DQUFvQyx3Q0FBd0MsK0JBQStCLHNDQUFzQyxnQ0FBZ0MsaUNBQWlDLHdCQUF3QixnQ0FBZ0Msa0NBQWtDLGdCQUFnQiw0QkFBNEIsOFZBQThWLHFNQUFxTSw4TEFBOEwseWNBQXljLGdFQUFnRSw2VkFBNlYsMkJBQTJCLDhVQUE4VSw4REFBOEQsZ0VBQWdFLGlGQUFpRix5RkFBeUYsNERBQTRELCtFQUErRSxrRUFBa0UsR0FBRzs7Ozs7Ozs7OztBQ0FybUcsbUdBQW1HLGdCQUFnQixrQ0FBa0Msb0NBQW9DLDZCQUE2Qix3Q0FBd0Msb0NBQW9DLHdCQUF3QixnQkFBZ0IsNEJBQTRCLG1DQUFtQywrREFBK0Qsd0RBQXdELDhCQUE4QixpQ0FBaUMsaUNBQWlDLDhFQUE4RSx3TUFBd00sd0hBQXdILDJJQUEySSx1REFBdUQsa0ZBQWtGLG1FQUFtRSwwREFBMEQsR0FBRzs7Ozs7Ozs7OztBQ0FsNEMsaUdBQWlHLHdCQUF3Qix3cUJBQXdxQixnQkFBZ0Isa0NBQWtDLGlDQUFpQyx3Q0FBd0MsZ0JBQWdCLDRCQUE0QixpSEFBaUgscU9BQXFPLGdFQUFnRSwwT0FBME8sZ0VBQWdFLHNEQUFzRCwrQ0FBK0MsK0JBQStCLG1GQUFtRix1SUFBdUksc0lBQXNJLDhFQUE4RSx1R0FBdUcsa0dBQWtHLHVGQUF1RixtSEFBbUgsOEdBQThHLDBFQUEwRSxtREFBbUQsdUNBQXVDLEdBQUc7Ozs7Ozs7Ozs7QUNBbDJGLGdGQUFnRiw0QkFBNEIsMEJBQTBCLHdCQUF3QixnQ0FBZ0MsNG1JQUE0bUksOERBQThELDRCQUE0QiwwQkFBMEIsMEJBQTBCLGVBQWUsZUFBZSxHQUFHLGdCQUFnQiwyQ0FBMkMsa0NBQWtDLGtHQUFrRyxnRkFBZ0YsZ0JBQWdCLGlDQUFpQyw2RUFBNkUsc0NBQXNDLDJFQUEyRSxtRkFBbUYsZ0NBQWdDLGdDQUFnQywyQ0FBMkMsaUNBQWlDLHlDQUF5Qyx5Q0FBeUMsaUJBQWlCLE9BQU8sTUFBTSxpQkFBaUIsWUFBWSxZQUFZLGdCQUFnQiwwQkFBMEIsT0FBTyxNQUFNLDJDQUEyQyxzRUFBc0Usc0VBQXNFLCtCQUErQixHQUFHLGlCQUFpQixHQUFHLDREQUE0RCxHQUFHOzs7Ozs7Ozs7O0FDQWxyTCx1RUFBdUUscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLGdKQUFnSixxN0xBQXE3TCxzQ0FBc0MsaUNBQWlDLGdCQUFnQiw2Q0FBNkMsa0NBQWtDLDJEQUEyRCwrRUFBK0Usa0ZBQWtGLCtFQUErRSxzQkFBc0IsaUNBQWlDLCtDQUErQyxrRUFBa0UsbURBQW1ELHFDQUFxQyxpQkFBaUIsV0FBVyxNQUFNLG1DQUFtQywwREFBMEQsd0VBQXdFLDZCQUE2QixHQUFHLG9DQUFvQyw4REFBOEQscURBQXFELEdBQUc7Ozs7Ozs7Ozs7QUNBcDFPLDJKQUEySix3QkFBd0IscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLHlDQUF5QyxpQ0FBaUMsbURBQW1ELDREQUE0RCwyQ0FBMkMscURBQXFELGdPQUFnTyxtQkFBbUIsZ0NBQWdDLHdFQUF3RSx5RkFBeUYsbURBQW1ELHlEQUF5RCxnQ0FBZ0MsMEJBQTBCLGdDQUFnQywwQkFBMEIsZ0NBQWdDLDBCQUEwQixtREFBbUQseUNBQXlDLGdCQUFnQiw2Q0FBNkMsa0NBQWtDLGtHQUFrRyxnQkFBZ0Isa0NBQWtDLCtFQUErRSxzQ0FBc0MsK01BQStNLCtEQUErRCxtRUFBbUUsd0RBQXdELG9FQUFvRSw4RUFBOEUsMkJBQTJCLHFEQUFxRCwyREFBMkQsa0RBQWtELHVDQUF1QywyQkFBMkIsR0FBRzs7Ozs7Ozs7OztBQ0FqL0UsdUVBQXVFLDhCQUE4QixnQkFBZ0Isa0NBQWtDLDhCQUE4QixvQ0FBb0MsZ0NBQWdDLHNDQUFzQyxxRkFBcUYsb0ZBQW9GLG9GQUFvRix1RkFBdUYsaUNBQWlDLG1EQUFtRCxtREFBbUQsbURBQW1ELGtDQUFrQyxrQ0FBa0Msa0NBQWtDLGtDQUFrQyw2Q0FBNkMsNkNBQTZDLDZDQUE2QyxxQkFBcUIsc0VBQXNFLEdBQUc7Ozs7Ozs7Ozs7QUNBMXBDLGtGQUFrRiw2QkFBNkIsd0JBQXdCLDRCQUE0QixvSkFBb0osNENBQTRDLElBQUksc0NBQXNDLGtEQUFrRCw0QkFBNEIsd0NBQXdDLG9DQUFvQywwQkFBMEIsR0FBRyxnQkFBZ0Isa0NBQWtDLCtFQUErRSxvR0FBb0csd0VBQXdFLCtDQUErQyxtR0FBbUcsbUZBQW1GLHlGQUF5RiwwRUFBMEUsR0FBRzs7Ozs7Ozs7OztBQ0E1dkMsaUpBQWlKLDZCQUE2Qix3QkFBd0IsNEJBQTRCLGtEQUFrRCx3QkFBd0IsK0JBQStCLGtEQUFrRCwyQkFBMkIscUNBQXFDLDZCQUE2Qix3QkFBd0IsbUVBQW1FLG9CQUFvQixjQUFjLGFBQWEsSUFBSSw4REFBOEQsK0JBQStCLDBFQUEwRSxxR0FBcUcsMENBQTBDLEdBQUcsNERBQTRELCtCQUErQiw2QkFBNkIsK0VBQStFLDhDQUE4QyxrRUFBa0UsaUJBQWlCLEdBQUcsK0dBQStHLHdDQUF3QyxrRUFBa0UsMEVBQTBFLHlDQUF5QyxHQUFHLCtHQUErRyx1QkFBdUIscUJBQXFCLDRCQUE0QixzQkFBc0Isc0JBQXNCLDhCQUE4Qiw4QkFBOEIsaUJBQWlCLHNCQUFzQixNQUFNLCtDQUErQywrQ0FBK0MsNENBQTRDLHlCQUF5Qix5QkFBeUIsZUFBZSxlQUFlLHlFQUF5RSx5RUFBeUUsaUNBQWlDLDZCQUE2Qiw4Q0FBOEMsK0NBQStDLG9EQUFvRCxxREFBcUQsc0RBQXNELHFEQUFxRCxHQUFHLHFFQUFxRSxHQUFHLHdCQUF3QixrREFBa0QsOEJBQThCLG1EQUFtRCwrRUFBK0Usa0ZBQWtGLCtFQUErRSw2QkFBNkIsd0NBQXdDLGlDQUFpQywyQ0FBMkMsNENBQTRDLG9EQUFvRCw4QkFBOEIsa0RBQWtELDRDQUE0Qyw2Q0FBNkMsa0NBQWtDLDhCQUE4QixrQkFBa0IsNENBQTRDLHNCQUFzQix5RUFBeUUsNENBQTRDLG9EQUFvRCx3Q0FBd0MsdUdBQXVHLGdGQUFnRiw0Q0FBNEMsc0dBQXNHLDREQUE0RCwrRUFBK0UseUdBQXlHLG9GQUFvRixnR0FBZ0csV0FBVzs7Ozs7Ozs7OztBQ0FuakosNkpBQTZKLHFDQUFxQyw2QkFBNkIsd0JBQXdCLDRCQUE0Qiw0QkFBNEIsd0JBQXdCLDZCQUE2Qiw4Q0FBOEMseURBQXlELGtEQUFrRCwwREFBMEQsMkVBQTJFLHlEQUF5RCw0REFBNEQsOEVBQThFLHlCQUF5QixxREFBcUQsbURBQW1ELDJDQUEyQyxvWUFBb1ksOENBQThDLHdCQUF3QixXQUFXLGlCQUFpQix1QkFBdUIsTUFBTSxpQkFBaUIsdUJBQXVCLE1BQU0sOEJBQThCLDhCQUE4QixrR0FBa0csR0FBRyxHQUFHLEdBQUcsOEJBQThCLDJEQUEyRCx5REFBeUQsV0FBVyx5QkFBeUIsK0JBQStCLGlCQUFpQixzQkFBc0IsTUFBTSxpQkFBaUIsc0JBQXNCLE1BQU0sNkJBQTZCLDZCQUE2QixrT0FBa08sa0NBQWtDLGtDQUFrQyw2TUFBNk0sR0FBRyxHQUFHLEdBQUcsOEJBQThCLG1EQUFtRCxVQUFVLHVCQUF1QiwrQkFBK0IsNkJBQTZCLFdBQVcsNkNBQTZDLDJEQUEyRCxnQkFBZ0IsTUFBTSxpQkFBaUIsZ0JBQWdCLE1BQU0sdUJBQXVCLHVCQUF1QixpQkFBaUIsY0FBYyxZQUFZLFdBQVcsY0FBYyxZQUFZLFdBQVcsY0FBYyxZQUFZLFdBQVcscUZBQXFGLHdCQUF3Qiw2QkFBNkIsNEJBQTRCLGtCQUFrQixHQUFHLEdBQUcsK0NBQStDLEdBQUcsd0NBQXdDLGlGQUFpRix3REFBd0QsNEJBQTRCLGlGQUFpRix3REFBd0QsNEJBQTRCLHFDQUFxQywwREFBMEQsR0FBRyw2Q0FBNkMsMERBQTBELDBEQUEwRCwwRUFBMEUsMEVBQTBFLGtHQUFrRyxvQ0FBb0Msd0NBQXdDLHdDQUF3QywyREFBMkQsR0FBRywwRkFBMEYsaUJBQWlCLGtCQUFrQixTQUFTLCtCQUErQix5Q0FBeUMsK0JBQStCLCtCQUErQixhQUFhLGdCQUFnQixNQUFNLGFBQWEsZ0JBQWdCLE1BQU0sdUJBQXVCLHVCQUF1Qix1QkFBdUIsMEJBQTBCLG9GQUFvRiw2REFBNkQsR0FBRyxHQUFHLEdBQUcscUhBQXFILCtDQUErQyxpQkFBaUIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLG9CQUFvQixvQkFBb0Isb0JBQW9CLG9CQUFvQixvQkFBb0Isb0JBQW9CLG9CQUFvQixvQkFBb0Isc0JBQXNCLHNCQUFzQixzQkFBc0Isc0JBQXNCLGlRQUFpUSwrQkFBK0IsK0JBQStCLGFBQWEsZ0JBQWdCLE1BQU0sYUFBYSxnQkFBZ0IsTUFBTSx1QkFBdUIsdUJBQXVCLG1CQUFtQixtQkFBbUIsbUdBQW1HLEdBQUcsR0FBRyxHQUFHLHlHQUF5RyxjQUFjLGVBQWUsMEJBQTBCLGFBQWEsT0FBTyxNQUFNLG1CQUFtQixtQkFBbUIsb0pBQW9KLEdBQUcsYUFBYSxPQUFPLE1BQU0sbUJBQW1CLG1CQUFtQiwwREFBMEQsd0RBQXdELHNDQUFzQyx3Q0FBd0MseUNBQXlDLDh3QkFBOHdCLFdBQVcsR0FBRyx1RUFBdUUsMENBQTBDLHVCQUF1Qiw4QkFBOEIsR0FBRyw4Q0FBOEMsaUJBQWlCLHFCQUFxQixpQ0FBaUMsdURBQXVELGlCQUFpQixtQkFBbUIsTUFBTSx1R0FBdUcsbUdBQW1HLGdDQUFnQyxzQkFBc0IsZ0JBQWdCLHFEQUFxRCxHQUFHLGVBQWUsR0FBRyx3QkFBd0Isa0NBQWtDLDJEQUEyRCwrRUFBK0Usa0ZBQWtGLCtFQUErRSxvQ0FBb0MsdUNBQXVDLHlDQUF5QyxzQ0FBc0MsOENBQThDLHVCQUF1QixxQ0FBcUMsMENBQTBDLHlDQUF5Qyx1RUFBdUUsdUVBQXVFLDRDQUE0QyxHQUFHOzs7Ozs7Ozs7O0FDQTFnUyx3R0FBd0cscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLGdCQUFnQiw2Q0FBNkMsa0NBQWtDLDBDQUEwQyxvR0FBb0csaUZBQWlGLHdFQUF3RSxnQkFBZ0Isc0NBQXNDLHVEQUF1RCxzR0FBc0csMkRBQTJELDJFQUEyRSxzRUFBc0UsOERBQThELDhEQUE4RCxHQUFHOzs7Ozs7Ozs7O0FDQWxvQyxxRkFBcUYscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLGdCQUFnQiw2Q0FBNkMsa0NBQWtDLG9HQUFvRyx3RUFBd0UsdUVBQXVFLGlHQUFpRyw0REFBNEQsaUZBQWlGLDBDQUEwQywyQ0FBMkMsaUdBQWlHLEdBQUc7Ozs7Ozs7Ozs7QUNBcDhCLDZFQUE2RSxrQ0FBa0MscUNBQXFDLDZCQUE2Qix3QkFBd0IsNEJBQTRCLCtIQUErSCwrREFBK0QsMEZBQTBGLHlDQUF5QyxHQUFHLGdCQUFnQixrQ0FBa0Msb0dBQW9HLHdFQUF3RSxpREFBaUQsb0RBQW9ELHlDQUF5Qyx3Q0FBd0MsK0RBQStELGlGQUFpRixzQ0FBc0Msb0dBQW9HLEdBQUc7Ozs7Ozs7Ozs7QUNBMXRDLGtGQUFrRix5QkFBeUIsdUJBQXVCLDZCQUE2Qix3QkFBd0IsNEJBQTRCLHFHQUFxRyxtQ0FBbUMsSUFBSSxnQkFBZ0IsNkNBQTZDLGtDQUFrQyxrR0FBa0csb0VBQW9FLGdCQUFnQixpQ0FBaUMsK0JBQStCLGdDQUFnQyxpREFBaUQsMEJBQTBCLFdBQVcsMENBQTBDLFFBQVEsR0FBRyxXQUFXLHNEQUFzRCxrQ0FBa0MsbURBQW1ELHVDQUF1QyxRQUFRLEdBQUcsWUFBWSxxQkFBcUIsUUFBUSxHQUFHLEdBQUcsR0FBRzs7Ozs7Ozs7OztBQ0F6bEMsMENBQTBDLGdCQUFnQiwwQ0FBMEMseUNBQXlDLGdFQUFnRSw4QkFBOEIsV0FBVzs7Ozs7Ozs7OztBQ0F0UCwwQ0FBMEMsZ0JBQWdCLGtDQUFrQyxnRUFBZ0UsOEJBQThCLEdBQUc7Ozs7Ozs7Ozs7QUNBN0wsMENBQTBDLGdCQUFnQixrQ0FBa0MsMENBQTBDLHVGQUF1RixHQUFHOzs7Ozs7Ozs7O0FDQWhPLDBDQUEwQyxnQkFBZ0Isa0NBQWtDLDBDQUEwQyxpR0FBaUcsR0FBRzs7Ozs7Ozs7OztBQ0ExTyx1RUFBdUUsMkJBQTJCLHNCQUFzQixxQkFBcUIsc0JBQXNCLHFDQUFxQyxnQkFBZ0Isb0NBQW9DLHVDQUF1Qyx1Q0FBdUMsc0ZBQXNGLHNGQUFzRix5RUFBeUUsOEJBQThCLEdBQUc7Ozs7Ozs7Ozs7QUNBaG1CLHNFQUFzRSxnQkFBZ0IsK0NBQStDLGdKQUFnSix5RUFBeUUscUZBQXFGLHVEQUF1RDs7Ozs7Ozs7OztBQ0ExZSxzRUFBc0UsaUNBQWlDLHVEQUF1RCxrREFBa0Qsc0NBQXNDLG9CQUFvQixHQUFHLGdCQUFnQixvQ0FBb0MsNEJBQTRCLCtCQUErQixtRUFBbUUsK0ZBQStGLGtFQUFrRSxHQUFHOzs7Ozs7Ozs7O0FDQW5tQix3RUFBd0UsNkJBQTZCLDZCQUE2QixnQkFBZ0IscUNBQXFDLG1DQUFtQyxrTkFBa04sZ0VBQWdFLEdBQUc7Ozs7Ozs7Ozs7QUNBL2UsNFNBQTRTLGdCQUFnQixrQ0FBa0MsMENBQTBDLHlEQUF5RCw4REFBOEQsMEVBQTBFLDZCQUE2Qiw2REFBNkQsR0FBRzs7Ozs7Ozs7OztBQ0F0cUIsMENBQTBDLGdCQUFnQiw2QkFBNkIsR0FBRzs7Ozs7Ozs7OztBQ0ExRiwwQ0FBMEMsZ0JBQWdCLGtDQUFrQyw0QkFBNEIsMkJBQTJCLHdEQUF3RCxHQUFHOzs7Ozs7Ozs7O0FDQTlNLG9FQUFvRSw4QkFBOEIsc0JBQXNCLGdCQUFnQixrQ0FBa0Msc05BQXNOLHlDQUF5QyxHQUFHOzs7Ozs7Ozs7O0FDQTVhLHNDQUFzQyxnQkFBZ0Isc0JBQXNCLEdBQUc7Ozs7Ozs7Ozs7QUNBL0Usa0NBQWtDLGdDQUFnQyxHQUFHOzs7Ozs7Ozs7O0FDQXJFLDBDQUEwQyw4QkFBOEIsZ0JBQWdCLGtDQUFrQyx1Q0FBdUMsMkNBQTJDLDhCQUE4Qix5Q0FBeUMsa0RBQWtELHNEQUFzRCx1RUFBdUUsbUNBQW1DLGtEQUFrRCxrREFBa0QsNENBQTRDLDREQUE0RCw0REFBNEQsOEpBQThKLEdBQUc7Ozs7Ozs7Ozs7QUNBOTRCLDBDQUEwQyw4QkFBOEIsZ0JBQWdCLGtDQUFrQyx1Q0FBdUMsb0NBQW9DLGdDQUFnQyxzQ0FBc0MscUZBQXFGLG9GQUFvRixvRkFBb0YsdUZBQXVGLHlDQUF5QyxtREFBbUQsbURBQW1ELG1EQUFtRCw0Q0FBNEMsNENBQTRDLHNEQUFzRCxHQUFHOzs7Ozs7Ozs7O0FDQWw3QixtR0FBbUcsb0JBQW9CLDJHQUEyRyxpS0FBaUssd0lBQXdJLCtCQUErQix3QkFBd0IsZ1JBQWdSLHVDQUF1Qyx1Q0FBdUMsMEZBQTBGLGtDQUFrQyxHQUFHOzs7Ozs7Ozs7O0FDQS9oQyw0Q0FBNEMsb0ZBQW9GLG1GQUFtRix3QkFBd0IsdUJBQXVCLG9CQUFvQixtQkFBbUIsc0JBQXNCLG1CQUFtQixrQkFBa0Isc0JBQXNCLG1CQUFtQixrQkFBa0IsR0FBRzs7Ozs7Ozs7Ozs7Ozs7O0FDQW5aO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDTGU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0orQztBQUMvQztBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQWE7QUFDL0M7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDakJlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0xpRDtBQUNsQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQiw4REFBYztBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQmtDO0FBQzZCO0FBQ2hEO0FBQ2YsZUFBZSxzREFBTztBQUN0QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUyxxRUFBcUI7QUFDOUI7Ozs7Ozs7Ozs7Ozs7OztBQ1RlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDTmtDO0FBQ25CO0FBQ2Ysa0JBQWtCLHNEQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWa0M7QUFDUztBQUM1QjtBQUNmLFVBQVUsMkRBQVc7QUFDckIscUJBQXFCLHNEQUFPO0FBQzVCOzs7Ozs7Ozs7Ozs7Ozs7QUNMZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7Ozs7OztVQ1JBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOMkc7QUFDa0I7QUFDaEM7QUFDaEM7QUFDUTtBQUNIO0FBQ2E7QUFDekI7QUFDTTtBQUNVO0FBQ1k7QUFHM0UsSUFBT2MsYUFBYSwwQkFBQUMsb0JBQUE7RUFBQUMsMkVBQUEsQ0FBQUYsYUFBQSxFQUFBQyxvQkFBQTtFQUN2QixTQUFBRCxjQUFBLEVBQWM7SUFBQUcsaUZBQUEsT0FBQUgsYUFBQTtJQUFBLE9BQUFJLFVBQUEsT0FBQUosYUFBQTtFQUVkO0VBQUNLLDhFQUFBLENBQUFMLGFBQUE7SUFBQU0sR0FBQTtJQUFBQyxLQUFBLEVBQ0QsU0FBQUMsV0FBV0MsR0FBRyxFQUFFQyxPQUFPLEVBQUU7TUFDdEIsT0FBT0QsR0FBRyxDQUFDRSxlQUFlLENBQUNELE9BQU8sQ0FBQztJQUN0QztFQUFDO0VBQUEsT0FBQVYsYUFBQTtBQUFBLEVBTitCRCw2RkFBbUI7QUFPdEQ7QUFBQyxJQUNtQmEsb0NBQW9DLDBCQUFBQyxxQkFBQTtFQUFBWCwyRUFBQSxDQUFBVSxvQ0FBQSxFQUFBQyxxQkFBQTtFQUVyRDs7RUFFQSxTQUFBRCxxQ0FBQSxFQUNBO0lBQUEsSUFBQUUsS0FBQTtJQUFBLElBRFlDLElBQUksR0FBQUMsU0FBQSxDQUFBQyxNQUFBLFFBQUFELFNBQUEsUUFBQUUsU0FBQSxHQUFBRixTQUFBLE1BQUcsT0FBTztJQUFBYixpRkFBQSxPQUFBUyxvQ0FBQTtJQUV0QkUsS0FBQSxHQUFBVixVQUFBLE9BQUFRLG9DQUFBLEdBQU1HLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FDWHpCLCtGQUFTLENBQUMsQ0FBQyxDQUFDNkIsT0FBTyxDQUFDL0IsdUdBQXlCLENBQUNnQyxLQUFLLENBQUMsQ0FDdkQ7O0lBRUQ7SUFDQU4sS0FBQSxDQUFLTyxPQUFPLEdBQUcsSUFBSTs7SUFFbkI7O0lBRUE7SUFDQVAsS0FBQSxDQUFLUSxPQUFPLEdBQUd6Qix1RUFBVyxDQUFDMEIsSUFBSTtJQUFDLE9BQUFULEtBQUE7RUFDcEM7O0VBRUQ7QUFDSDtBQUNBO0FBQ0E7RUFIR1QsOEVBQUEsQ0FBQU8sb0NBQUE7SUFBQU4sR0FBQTtJQUFBQyxLQUFBLEVBSUEsU0FBQWlCLFFBQUEsRUFDQTtNQUFBLElBQUFDLE1BQUE7TUFDSSxJQUFBQyxnQkFBQSxHQUEwQiw2Q0FBZ0QsSUFBSSxDQUFDQyxLQUFLLENBQUMsQ0FBQyxDQUFDQyxJQUFJLENBQUMsQ0FBQztRQUFyRkMsS0FBSyxHQUFBSCxnQkFBQSxDQUFMRyxLQUFLO1FBQUVDLE1BQU0sR0FBQUosZ0JBQUEsQ0FBTkksTUFBTTtNQUNyQixPQUFPLElBQUloQyxpRkFBYSxDQUFDLFVBQUFpQyxPQUFPLEVBQUk7UUFDbkMsSUFBTUMsTUFBTSxHQUFHdkIsR0FBRyxDQUFDd0IsY0FBYyxDQUFDSixLQUFLLENBQUM7UUFDeEMsSUFBTUssR0FBRyxHQUFHRixNQUFNLENBQUNHLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFDbkNELEdBQUcsQ0FBQ0UsU0FBUyxDQUFDUCxLQUFLLENBQUNRLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pDSCxHQUFHLENBQUNJLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFVCxLQUFLLENBQUNVLEtBQUssRUFBRVYsS0FBSyxDQUFDVyxNQUFNLENBQUMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLENBQUMsVUFBQUQsSUFBSSxFQUFJO1VBQ2hFO1VBQ0FoQixNQUFJLENBQUNKLE9BQU8sR0FBR29CLElBQUk7VUFDbkJoQixNQUFJLENBQUNILE9BQU8sR0FBR1EsTUFBTTtVQUNyQkMsT0FBTyxDQUFDLENBQUM7UUFBQyxDQUFDLENBQUM7TUFDcEIsQ0FBQyxDQUFDO0lBQ0g7O0lBRUE7QUFDSDtBQUNBO0FBQ0E7QUFDQTtFQUpHO0lBQUF6QixHQUFBO0lBQUFDLEtBQUEsRUFLQSxTQUFBb0MsS0FBS2xDLEdBQUcsRUFDUjtNQUFBLElBQUFtQyxNQUFBO01BQ0ksSUFBQUMsaUJBQUEsR0FBMEIsNkNBQWdELElBQUksQ0FBQ2xCLEtBQUssQ0FBQyxDQUFDLENBQUNDLElBQUksQ0FBQyxDQUFDO1FBQXJGQyxLQUFLLEdBQUFnQixpQkFBQSxDQUFMaEIsS0FBSztRQUFFQyxNQUFNLEdBQUFlLGlCQUFBLENBQU5mLE1BQU07TUFFckIsT0FBTyxJQUFJaEMsaUZBQWEsQ0FBQyxVQUFBaUMsT0FBTyxFQUFJO1FBQ2hDLElBQU1DLE1BQU0sR0FBR3ZCLEdBQUcsQ0FBQ3dCLGNBQWMsQ0FBQ0osS0FBSyxDQUFDO1FBQ3hDaUIsaUJBQWlCLENBQUNkLE1BQU0sRUFBRSxDQUFDLEVBQUVBLE1BQU0sQ0FBQ1EsTUFBTSxHQUFHWCxLQUFLLENBQUNXLE1BQU0sRUFBRVgsS0FBSyxDQUFDVSxLQUFLLEVBQUVWLEtBQUssQ0FBQ1csTUFBTSxDQUFDLENBQUNFLElBQUksQ0FBQyxVQUFBSyxNQUFNLEVBQUk7VUFDakdILE1BQUksQ0FBQ3ZCLE9BQU8sR0FBRzBCLE1BQU07VUFDckJILE1BQUksQ0FBQ3RCLE9BQU8sR0FBR1EsTUFBTTtVQUNyQkMsT0FBTyxDQUFDLENBQUM7UUFDYixDQUFDLENBQUM7TUFDTixDQUFDLENBQUM7SUFDTjtFQUFDO0VBQUEsT0FBQW5CLG9DQUFBO0FBQUEsRUF2RDhEekIsaUdBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9jb3JlL3BpcGVsaW5lL3BpcGVsaW5lLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9jb3JlL3BpcGVsaW5lL3BpcGVsaW5lLW5vZGUuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9jb3JlL3BpcGVsaW5lL3BpcGVsaW5lLXBvcnQuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9jb3JlL3BpcGVsaW5lL3BpcGVsaW5lLXBvcnRidWlsZGVyLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvY29yZS9waXBlbGluZS9waXBlbGluZS1wb3J0c3BlYy5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2NvcmUvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9jb3JlL3NwZWVkeS1tZWRpYS1zb3VyY2UuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9jb3JlL3NwZWVkeS1tZWRpYS5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2NvcmUvc3BlZWR5LW5hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2NvcmUvc3BlZWR5LXByb21pc2UuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9jb3JlL3NwZWVkeS1zaXplLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3Byb2dyYW1zL2ZpbHRlcnMuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvcHJvZ3JhbXMva2V5cG9pbnRzLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3Byb2dyYW1zL3B5cmFtaWRzLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3Byb2dyYW1zL3RyYW5zZm9ybXMuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvcHJvZ3JhbXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVyLWRlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlci1wcmVwcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL2NvbnZvbHV0aW9uLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS8gc3luYyBeXFwuXFwvLiokIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvIHN5bmMgXlxcLlxcLy4qJCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zcGVlZHktZGVzY3JpcHRvcmRiLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS1nbC5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zcGVlZHktZ3B1LmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS1sc2guanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc3BlZWR5LXByb2dyYW0tY2VudGVyLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS1wcm9ncmFtLWdyb3VwLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS1wcm9ncmFtLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS10ZXh0dXJlLXBvb2wuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc3BlZWR5LXRleHR1cmUtcmVhZGVyLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS10ZXh0dXJlLXVwbG9hZGVyLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS10ZXh0dXJlLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvdXRpbHMvYXNhcC5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL3V0aWxzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL3V0aWxzL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy91dGlscy9vYnNlcnZhYmxlLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvdXRpbHMvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2ZpbHRlcnMvY29udm9sdXRpb24xZC5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvZmlsdGVycy9jb252b2x1dGlvbjJkLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL2Zhc3QtbWVkaWFuLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL25pZ2h0dmlzaW9uLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL25vcm1hbGl6ZS1pbWFnZS5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvZmlsdGVycy9yZ2IyZ3JleS5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9jb2xvcnMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvZmlsdGVycy5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9maXhlZC1wb2ludC5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9mbG9hdDE2Lmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2dsb2JhbC5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9pbnQzMi5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9rZXlwb2ludC1kZXNjcmlwdG9ycy5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9rZXlwb2ludC1tYXRjaGVzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2tleXBvaW50cy5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9tYXRoLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL3B5cmFtaWRzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL3F1aWNrc2VsZWN0Lmlnbm9yZS5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9zdWJwaXhlbC5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2FsbG9jYXRlLWRlc2NyaXB0b3JzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvYWxsb2NhdGUtZXh0cmEuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9hcHBseS1ob21vZ3JhcGh5Lmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvYmYta25uLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvYnJpc2suaWdub3JlLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvY2xpcC1ib3JkZXIuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9jbGlwLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZGlzY2FyZC1kZXNjcmlwdG9ycy5pZ25vcmUuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9kaXN0YW5jZS1maWx0ZXIuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnQtbG9uZy1vZmZzZXRzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZW5jb2RlLWtleXBvaW50LW9mZnNldHMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnQtcG9zaXRpb25zLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZW5jb2RlLWtleXBvaW50LXByb3BlcnRpZXMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnRzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZW5jb2RlLW51bGwta2V5cG9pbnRzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZmFzdC5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2Zhc3QudnMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9oYW1taW5nLWRpc3RhbmNlLWZpbHRlci5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2hhcnJpcy1jdXRvZmYuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9oYXJyaXMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9rbm4taW5pdC5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2tubi10cmFuc2Zlci5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2xhcGxhY2lhbi5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2xrLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvbG9va3VwLW9mLWxvY2F0aW9ucy5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2xvb2t1cC1vZi1sb2NhdGlvbnMudnMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9sc2gta25uLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvbWl4LWtleXBvaW50cy5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL25jYy5pZ25vcmUuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9ub25tYXgtc2NhbGUuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9ub25tYXgtc3BhY2UuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9ub25tYXgtc3VwcHJlc3Npb24uZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9vcmItZGVzY3JpcHRvci5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL29yYi1vcmllbnRhdGlvbi5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL3JlZmluZS1zY2FsZS5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL3Njb3JlLWZpbmRtYXguZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9zaHVmZmxlLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvc29ydC1rZXlwb2ludHMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9zdWJwaXhlbC1yZWZpbmVtZW50Lmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvdHJhbnNmZXItZmxvdy5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL3RyYW5zZmVyLW9yaWVudGF0aW9uLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvdHJhbnNmZXItdG8tZXh0cmEuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy91cGxvYWQta2V5cG9pbnRzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9weXJhbWlkcy9kb3duc2FtcGxlMi5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvcHlyYW1pZHMvZG93bnNhbXBsZTMuaWdub3JlLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9weXJhbWlkcy91cHNhbXBsZTIuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3B5cmFtaWRzL3Vwc2FtcGxlMy5pZ25vcmUuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3RyYW5zZm9ybXMvYWRkaXRpdmUtbWl4Lmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy90cmFuc2Zvcm1zL3Jlc2l6ZS5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdHJhbnNmb3Jtcy93YXJwLXBlcnNwZWN0aXZlLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9jb3B5LWNvbXBvbmVudHMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3V0aWxzL2NvcHktcmFzdGVyLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9jb3B5Lmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9jcm9wLmlnbm9yZS5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvZmlsbC1jb21wb25lbnRzLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9maWxsLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9mbGlwLXkudnMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3V0aWxzL3NjYW4tbWlubWF4MWQuaWdub3JlLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9zY2FuLW1pbm1heDJkLmdsc2wiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9zb2JlbC1kZXJpdmF0aXZlcy5nbHNsIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvc29iZWwtZGVyaXZhdGl2ZXMudnMuZ2xzbCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vU3BlZWR5VmlzaW9uU2lua0ltYWdlRGF0YS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL1NwZWVkeVZpc2lvblNpbmtJbWFnZURhdGEvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9TcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhLy4vc3JjL3NwZWVkeS12aXNpb24tbW9kL3NpbmstaW1hZ2UtZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJTcGVlZHlWaXNpb25TaW5rSW1hZ2VEYXRhXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlNwZWVkeVZpc2lvblNpbmtJbWFnZURhdGFcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gIiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogcGlwZWxpbmUtbWVzc2FnZS5qc1xuICogQSBtZXNzYWdlIHRoYXQgaXMgc2hhcmVkIGJldHdlZW4gbm9kZXMgb2YgYSBwaXBlbGluZVxuICovXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgSW1hZ2VGb3JtYXQgfSBmcm9tICcuLi8uLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBBYnN0cmFjdE1ldGhvZEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCB7IFNwZWVkeVRleHR1cmUsIFNwZWVkeURyYXdhYmxlVGV4dHVyZSB9IGZyb20gJy4uLy4uL2dwdS9zcGVlZHktdGV4dHVyZSc7XG5pbXBvcnQgeyBTcGVlZHlMU0ggfSBmcm9tICcuLi8uLi9ncHUvc3BlZWR5LWxzaCc7XG5cbi8qKlxuICogVHlwZXMgb2YgbWVzc2FnZXNcbiAqIEBlbnVtIHtTeW1ib2x9XG4gKi9cbmV4cG9ydCBjb25zdCBTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgTm90aGluZzogU3ltYm9sKCdOb3RoaW5nJyksXG4gICAgSW1hZ2U6IFN5bWJvbCgnSW1hZ2UnKSxcbiAgICBLZXlwb2ludHM6IFN5bWJvbCgnS2V5cG9pbnRzJyksXG4gICAgVmVjdG9yMjogU3ltYm9sKCdWZWN0b3IyJyksXG4gICAgTFNIVGFibGVzOiBTeW1ib2woJ0xTSFRhYmxlcycpLFxuICAgIEtleXBvaW50TWF0Y2hlczogU3ltYm9sKCdLZXlwb2ludE1hdGNoZXMnKSxcbn0pO1xuXG4vKipcbiAqIEEgbWVzc2FnZSB0aGF0IGlzIHNoYXJlZCBiZXR3ZWVuIG5vZGVzIG9mIGEgcGlwZWxpbmVcbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UGlwZWxpbmVNZXNzYWdlXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGV9IHR5cGUgbWVzc2FnZSB0eXBlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSlcbiAgICB7XG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZX0gbWVzc2FnZSB0eXBlICovXG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgdHlwZVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdHlwZSBvZiB0aGlzIG1lc3NhZ2UgaXMgZXF1YWwgdG8gcGFyYW1ldGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGV9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNUeXBlKHR5cGUpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIGFuIGVtcHR5IG1lc3NhZ2U/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUeXBlKFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuTm90aGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3Qua2V5cyhTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlKS5maW5kKFxuICAgICAgICAgICAgdHlwZSA9PiBTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlW3R5cGVdID09PSB0aGlzLnR5cGVcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gYG1lc3NhZ2Ugb2YgdHlwZSAke3R5cGV9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcGFyYW1ldGVyc1xuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9IHRoaXMgbWVzc2FnZVxuICAgICAqL1xuICAgIHNldCguLi5hcmdzKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEFic3RyYWN0TWV0aG9kRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtZXNzYWdlIG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZX0gdHlwZVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh0eXBlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1lc3NhZ2UodHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFuIGVtcHR5IG1lc3NhZ2UgY2Fycnlpbmcgbm90aGluZ1xuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UGlwZWxpbmVNZXNzYWdlV2l0aE5vdGhpbmcgZXh0ZW5kcyBTcGVlZHlQaXBlbGluZU1lc3NhZ2VcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHN1cGVyKFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuTm90aGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlfSB0aGlzIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZXQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbWVzc2FnZSB0cmFuc3BvcnRpbmcgYW4gaW1hZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVBpcGVsaW5lTWVzc2FnZVdpdGhJbWFnZSBleHRlbmRzIFNwZWVkeVBpcGVsaW5lTWVzc2FnZVxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoU3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZS5JbWFnZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IHRoZSBpbWFnZSB3ZSBjYXJyeSAqL1xuICAgICAgICB0aGlzLl9pbWFnZSA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtJbWFnZUZvcm1hdH0gaW1hZ2UgZm9ybWF0ICovXG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IEltYWdlRm9ybWF0LlJHQkE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeURyYXdhYmxlVGV4dHVyZX0gaW1hZ2UgdGhlIGltYWdlIHdlIGNhcnJ5XG4gICAgICogQHBhcmFtIHtJbWFnZUZvcm1hdH0gW2Zvcm1hdF0gaW1hZ2UgZm9ybWF0XG4gICAgICogQHJldHVybnMge1NwZWVkeVBpcGVsaW5lTWVzc2FnZX0gdGhpcyBtZXNzYWdlXG4gICAgICovXG4gICAgc2V0KGltYWdlLCBmb3JtYXQgPSBJbWFnZUZvcm1hdC5SR0JBKVxuICAgIHtcbiAgICAgICAgLy8gc2V0IHBhcmFtZXRlcnNcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xuXG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSB3ZSBjYXJyeVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IGltYWdlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VGb3JtYXR9XG4gICAgICovXG4gICAgZ2V0IGZvcm1hdCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIG1lc3NhZ2UgdHJhbnNwb3J0aW5nIGtleXBvaW50c1xuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UGlwZWxpbmVNZXNzYWdlV2l0aEtleXBvaW50cyBleHRlbmRzIFNwZWVkeVBpcGVsaW5lTWVzc2FnZVxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoU3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZS5LZXlwb2ludHMpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfSBlbmNvZGVkIGtleXBvaW50cyAqL1xuICAgICAgICB0aGlzLl9lbmNvZGVkS2V5cG9pbnRzID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gZGVzY3JpcHRvciBzaXplIGluIGJ5dGVzICovXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0b3JTaXplID0gMDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gZXh0cmEgc2l6ZSBpbiBieXRlcyAqL1xuICAgICAgICB0aGlzLl9leHRyYVNpemUgPSAwO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBlbmNvZGVyIGxlbmd0aCAqL1xuICAgICAgICB0aGlzLl9lbmNvZGVyTGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfSBlbmNvZGVkS2V5cG9pbnRzIGVuY29kZWQga2V5cG9pbnRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc2NyaXB0b3JTaXplIGluIGJ5dGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4dHJhU2l6ZSBpbiBieXRlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmNvZGVyTGVuZ3RoIHBvc2l0aXZlIGludGVnZXJcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlfSB0aGlzIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZXQoZW5jb2RlZEtleXBvaW50cywgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSwgZW5jb2Rlckxlbmd0aClcbiAgICB7XG4gICAgICAgIC8vIHNldCBwYXJhbWV0ZXJzXG4gICAgICAgIHRoaXMuX2VuY29kZWRLZXlwb2ludHMgPSBlbmNvZGVkS2V5cG9pbnRzO1xuICAgICAgICB0aGlzLl9kZXNjcmlwdG9yU2l6ZSA9IGRlc2NyaXB0b3JTaXplIHwgMDtcbiAgICAgICAgdGhpcy5fZXh0cmFTaXplID0gZXh0cmFTaXplIHwgMDtcbiAgICAgICAgdGhpcy5fZW5jb2Rlckxlbmd0aCA9IGVuY29kZXJMZW5ndGggfCAwO1xuXG4gICAgICAgIC8vIHZhbGlkYXRlXG4gICAgICAgIFV0aWxzLmFzc2VydCh0aGlzLl9kZXNjcmlwdG9yU2l6ZSA+PSAwICYmIHRoaXMuX2V4dHJhU2l6ZSA+PSAwKTtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KHRoaXMuX2VuY29kZXJMZW5ndGggPT09IHRoaXMuX2VuY29kZWRLZXlwb2ludHMud2lkdGgsICdJbnZhbGlkIGVuY29kZXJMZW5ndGgnKTtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KHRoaXMuX2VuY29kZWRLZXlwb2ludHMud2lkdGggPT09IHRoaXMuX2VuY29kZWRLZXlwb2ludHMuaGVpZ2h0LCAnSW52YWxpZCBlbmNvZGVkS2V5cG9pbnRzIHRleHR1cmUnKTtcblxuICAgICAgICAvLyBkb25lIVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVkIGtleXBvaW50c1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IGVuY29kZWRLZXlwb2ludHMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZWRLZXlwb2ludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRvciBzaXplLCBpbiBieXRlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0b3JTaXplKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdG9yU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYSBzaXplLCBpbiBieXRlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV4dHJhU2l6ZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0cmFTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXIgbGVuZ3RoXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZW5jb2Rlckxlbmd0aCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rlckxlbmd0aDtcbiAgICB9XG59XG5cbi8qXG4gKiBBIG1lc3NhZ2UgdHJhbnNwb3J0aW5nIGEgc2V0IG9mIDJEIHZlY3RvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVBpcGVsaW5lTWVzc2FnZVdpdGgyRFZlY3RvcnMgZXh0ZW5kcyBTcGVlZHlQaXBlbGluZU1lc3NhZ2VcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHN1cGVyKFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuVmVjdG9yMik7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IHRoZSBzZXQgb2YgdmVjdG9ycyAqL1xuICAgICAgICB0aGlzLl92ZWN0b3JzID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfSB2ZWN0b3JzIHRoZSBzZXQgb2YgdmVjdG9yc1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9IHRoaXMgbWVzc2FnZVxuICAgICAqL1xuICAgIHNldCh2ZWN0b3JzKVxuICAgIHtcbiAgICAgICAgLy8gc2V0IHBhcmFtZXRlcnNcbiAgICAgICAgdGhpcy5fdmVjdG9ycyA9IHZlY3RvcnM7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNldCBvZiB2ZWN0b3JzXG4gICAgICogQHJldHVybnMge1NwZWVkeURyYXdhYmxlVGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgdmVjdG9ycygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVjdG9ycztcbiAgICB9XG59XG5cbi8qKlxuICogQSBtZXNzYWdlIHRyYW5zcG9ydGluZyBMU0ggdGFibGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoTFNIVGFibGVzIGV4dGVuZHMgU3BlZWR5UGlwZWxpbmVNZXNzYWdlXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBzdXBlcihTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlLkxTSFRhYmxlcyk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlMU0h9IExTSCBkYXRhIHN0cnVjdHVyZSAqL1xuICAgICAgICB0aGlzLl9sc2ggPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtTcGVlZHlMU0h9IGxzaFxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9IHRoaXMgbWVzc2FnZVxuICAgICAqL1xuICAgIHNldChsc2gpXG4gICAge1xuICAgICAgICAvLyBzZXQgcGFyYW1ldGVyc1xuICAgICAgICB0aGlzLl9sc2ggPSBsc2g7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTFNIIGRhdGEgc3RydWN0dXJlXG4gICAgICogQHJldHVybnMge1NwZWVkeUxTSH1cbiAgICAgKi9cbiAgICBnZXQgbHNoKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sc2g7XG4gICAgfVxufVxuXG4vKlxuICogQSBtZXNzYWdlIHRyYW5zcG9ydGluZyBhIHNldCBvZiBrZXlwb2ludCBtYXRjaGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoS2V5cG9pbnRNYXRjaGVzIGV4dGVuZHMgU3BlZWR5UGlwZWxpbmVNZXNzYWdlXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBzdXBlcihTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlLktleXBvaW50TWF0Y2hlcyk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IGtleXBvaW50IG1hdGNoZXMgKG5vdGU6IDEgcGl4ZWwgZW5jb2RlcyAxIG1hdGNoKSAqL1xuICAgICAgICB0aGlzLl9lbmNvZGVkTWF0Y2hlcyA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IG51bWJlciBvZiBtYXRjaGVzIHBlciBrZXlwb2ludCAqL1xuICAgICAgICB0aGlzLl9tYXRjaGVzUGVyS2V5cG9pbnQgPSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IGVuY29kZWRNYXRjaGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hdGNoZXNQZXJLZXlwb2ludFxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9IHRoaXMgbWVzc2FnZVxuICAgICAqL1xuICAgIHNldChlbmNvZGVkTWF0Y2hlcywgbWF0Y2hlc1BlcktleXBvaW50KVxuICAgIHtcbiAgICAgICAgLy8gc2V0IHBhcmFtZXRlcnNcbiAgICAgICAgdGhpcy5fZW5jb2RlZE1hdGNoZXMgPSBlbmNvZGVkTWF0Y2hlcztcbiAgICAgICAgdGhpcy5fbWF0Y2hlc1BlcktleXBvaW50ID0gbWF0Y2hlc1BlcktleXBvaW50IHwgMDtcblxuICAgICAgICAvLyB2YWxpZGF0ZVxuICAgICAgICBVdGlscy5hc3NlcnQodGhpcy5fbWF0Y2hlc1BlcktleXBvaW50ID4gMCk7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1hdGNoZXNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCBlbmNvZGVkTWF0Y2hlcygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlZE1hdGNoZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIG1hdGNoZXMgcGVyIGtleXBvaW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWF0Y2hlc1BlcktleXBvaW50KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRjaGVzUGVyS2V5cG9pbnQ7XG4gICAgfVxufVxuXG5cblxuXG5cblxuLy9cbi8vIFV0aWxpdGllc1xuLy9cblxuXG5cbi8qKiBNYXAgbWVzc2FnZSB0eXBlIHRvIG1lc3NhZ2UgY2xhc3MgKi9cbmNvbnN0IE1FU1NBR0VfQ0xBU1MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBbU3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZS5Ob3RoaW5nXTogU3BlZWR5UGlwZWxpbmVNZXNzYWdlV2l0aE5vdGhpbmcsXG4gICAgW1NwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuSW1hZ2VdOiBTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoSW1hZ2UsXG4gICAgW1NwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuS2V5cG9pbnRzXTogU3BlZWR5UGlwZWxpbmVNZXNzYWdlV2l0aEtleXBvaW50cyxcbiAgICBbU3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZS5WZWN0b3IyXTogU3BlZWR5UGlwZWxpbmVNZXNzYWdlV2l0aDJEVmVjdG9ycyxcbiAgICBbU3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZS5MU0hUYWJsZXNdOiBTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoTFNIVGFibGVzLFxuICAgIFtTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlLktleXBvaW50TWF0Y2hlc106IFNwZWVkeVBpcGVsaW5lTWVzc2FnZVdpdGhLZXlwb2ludE1hdGNoZXMsXG59KTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtZXNzYWdlIG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlfSB0eXBlXG4gKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlfVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlKHR5cGUpXG57XG4gICAgLy9yZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoTUVTU0FHRV9DTEFTU1t0eXBlXSwgW10pO1xuICAgIHJldHVybiBuZXcgTUVTU0FHRV9DTEFTU1tcbiAgICAgICAgLy8gZXJyb3IgVFMyNTM4OiBUeXBlICdTeW1ib2wnIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGluZGV4IHR5cGUuXG4gICAgICAgIC8vIGhlY2ssIHdoYXQgdGhlIGhhY2suLi5cbiAgICAgICAgLyoqIEB0eXBlIHthbnl9ICovICggdHlwZSApXG4gICAgXTtcbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBwaXBlbGluZS1ub2RlLmpzXG4gKiBOb2RlIG9mIGEgcGlwZWxpbmVcbiAqL1xuXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IExJVFRMRV9FTkRJQU4gfSBmcm9tICcuLi8uLi91dGlscy9nbG9iYWxzJztcbmltcG9ydCB7IFNwZWVkeVByb21pc2UgfSBmcm9tICcuLi9zcGVlZHktcHJvbWlzZSc7XG5pbXBvcnQgeyBBYnN0cmFjdE1ldGhvZEVycm9yLCBJbGxlZ2FsQXJndW1lbnRFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzL2Vycm9ycyc7XG5pbXBvcnQgeyBTcGVlZHlQaXBlbGluZVBvcnQsIFNwZWVkeVBpcGVsaW5lSW5wdXRQb3J0LCBTcGVlZHlQaXBlbGluZU91dHB1dFBvcnQgfSBmcm9tICcuL3BpcGVsaW5lLXBvcnQnO1xuaW1wb3J0IHsgU3BlZWR5UGlwZWxpbmVQb3J0QnVpbGRlciB9IGZyb20gJy4vcGlwZWxpbmUtcG9ydGJ1aWxkZXInO1xuaW1wb3J0IHsgU3BlZWR5R1BVIH0gZnJvbSAnLi4vLi4vZ3B1L3NwZWVkeS1ncHUnO1xuaW1wb3J0IHsgU3BlZWR5VGV4dHVyZSwgU3BlZWR5RHJhd2FibGVUZXh0dXJlIH0gZnJvbSAnLi4vLi4vZ3B1L3NwZWVkeS10ZXh0dXJlJztcbmltcG9ydCB7IFNwZWVkeVRleHR1cmVSZWFkZXIgfSBmcm9tICcuLi8uLi9ncHUvc3BlZWR5LXRleHR1cmUtcmVhZGVyJztcblxuLyoqIEB0eXBlZGVmIHtPYmplY3Q8c3RyaW5nLFNwZWVkeVBpcGVsaW5lSW5wdXRQb3J0Pn0gSW5wdXRQb3J0RGljdGlvbmFyeSAqL1xuLyoqIEB0eXBlZGVmIHtPYmplY3Q8c3RyaW5nLFNwZWVkeVBpcGVsaW5lT3V0cHV0UG9ydD59IE91dHB1dFBvcnREaWN0aW9uYXJ5ICovXG5cbi8qKiBHZW5lcmF0ZSBhIHJhbmRvbSBuYW1lIGZvciBhIG5vZGUgKi9cbmNvbnN0IGdlbmVyYXRlUmFuZG9tTmFtZSA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cigyKTtcblxuLyoqIENyZWF0ZSBhbiBlbXB0eSBpbnB1dCBwb3J0IGRpY3Rpb25hcnkgKi9cbmNvbnN0IGNyZWF0ZUlucHV0UG9ydERpY3Rpb25hcnkgPSAoKSA9PiAvKiogQHR5cGUge0lucHV0UG9ydERpY3Rpb25hcnl9ICovICggT2JqZWN0LmNyZWF0ZShudWxsKSApO1xuXG4vKiogQ3JlYXRlIGFuIGVtcHR5IG91dHB1dCBwb3J0IGRpY3Rpb25hcnkgKi9cbmNvbnN0IGNyZWF0ZU91dHB1dFBvcnREaWN0aW9uYXJ5ID0gKCkgPT4gLyoqIEB0eXBlIHtPdXRwdXRQb3J0RGljdGlvbmFyeX0gKi8gKCBPYmplY3QuY3JlYXRlKG51bGwpICk7XG5cbi8qKlxuICogTWFwIGFuIGFycmF5IG9mIGlucHV0IHBvcnRzIHRvIGFuIElucHV0UG9ydERpY3Rpb25hcnkgd2hvc2Uga2V5cyBhcmUgdGhlaXIgbmFtZXNcbiAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVJbnB1dFBvcnRbXX0gcG9ydHNcbiAqIEByZXR1cm5zIHtJbnB1dFBvcnREaWN0aW9uYXJ5fVxuICovXG5mdW5jdGlvbiBJbnB1dFBvcnREaWN0aW9uYXJ5KHBvcnRzKVxue1xuICAgIHJldHVybiBwb3J0cy5yZWR1Y2UoKGRpY3QsIHBvcnQpID0+ICgoZGljdFtwb3J0Lm5hbWVdID0gcG9ydCksIGRpY3QpLCBjcmVhdGVJbnB1dFBvcnREaWN0aW9uYXJ5KCkpO1xufVxuXG4vKipcbiAqIE1hcCBhbiBhcnJheSBvZiBvdXRwdXQgcG9ydHMgdG8gYW4gT3V0cHV0UG9ydERpY3Rpb25hcnkgd2hvc2Uga2V5cyBhcmUgdGhlaXIgbmFtZXNcbiAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVPdXRwdXRQb3J0W119IHBvcnRzXG4gKiBAcmV0dXJucyB7T3V0cHV0UG9ydERpY3Rpb25hcnl9XG4gKi9cbmZ1bmN0aW9uIE91dHB1dFBvcnREaWN0aW9uYXJ5KHBvcnRzKVxue1xuICAgIHJldHVybiBwb3J0cy5yZWR1Y2UoKGRpY3QsIHBvcnQpID0+ICgoZGljdFtwb3J0Lm5hbWVdID0gcG9ydCksIGRpY3QpLCBjcmVhdGVPdXRwdXRQb3J0RGljdGlvbmFyeSgpKTtcbn1cblxuLyoqIEEgZmxhZyB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgKi9cbmxldCBfdGV4VmlldyA9IGZhbHNlO1xuXG5cblxuLyoqXG4gKiBOb2RlIG9mIGEgcGlwZWxpbmVcbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UGlwZWxpbmVOb2RlXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIHRoZSBuYW1lIG9mIHRoaXMgbm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGV4Q291bnRdIG51bWJlciBvZiB3b3JrIHRleHR1cmVzXG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZVBvcnRCdWlsZGVyW119IFtwb3J0QnVpbGRlcnNdIHBvcnQgYnVpbGRlcnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gZ2VuZXJhdGVSYW5kb21OYW1lKCksIHRleENvdW50ID0gMCwgcG9ydEJ1aWxkZXJzID0gW10pXG4gICAge1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhpcyBub2RlICovXG4gICAgICAgIHRoaXMuX25hbWUgPSBTdHJpbmcobmFtZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlEcmF3YWJsZVRleHR1cmVbXX0gd29yayB0ZXh0dXJlKHMpICovXG4gICAgICAgIHRoaXMuX3RleCA9IChuZXcgQXJyYXkodGV4Q291bnQpKS5maWxsKG51bGwpO1xuXG5cblxuICAgICAgICAvLyBidWlsZCB0aGUgcG9ydHNcbiAgICAgICAgY29uc3QgcG9ydHMgPSBwb3J0QnVpbGRlcnMubWFwKGJ1aWxkZXIgPT4gYnVpbGRlci5idWlsZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IGlucHV0UG9ydHMgPSAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lSW5wdXRQb3J0W119ICovICggcG9ydHMuZmlsdGVyKHBvcnQgPT4gcG9ydC5pc0lucHV0UG9ydCgpKSApO1xuICAgICAgICBjb25zdCBvdXRwdXRQb3J0cyA9IC8qKiBAdHlwZSB7U3BlZWR5UGlwZWxpbmVPdXRwdXRQb3J0W119ICovICggcG9ydHMuZmlsdGVyKHBvcnQgPT4gcG9ydC5pc091dHB1dFBvcnQoKSkgKTtcblxuICAgICAgICAvKiogQHR5cGUge0lucHV0UG9ydERpY3Rpb25hcnl9IGlucHV0IHBvcnRzICovXG4gICAgICAgIHRoaXMuX2lucHV0UG9ydHMgPSBJbnB1dFBvcnREaWN0aW9uYXJ5KGlucHV0UG9ydHMpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7T3V0cHV0UG9ydERpY3Rpb25hcnl9IG91dHB1dCBwb3J0cyAqL1xuICAgICAgICB0aGlzLl9vdXRwdXRQb3J0cyA9IE91dHB1dFBvcnREaWN0aW9uYXJ5KG91dHB1dFBvcnRzKTtcblxuXG5cbiAgICAgICAgLy8gdmFsaWRhdGVcbiAgICAgICAgaWYodGhpcy5fbmFtZS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgSW52YWxpZCBuYW1lIFwiJHt0aGlzLl9uYW1lfVwiIGZvciBub2RlICR7dGhpcy5mdWxsTmFtZX1gKTtcbiAgICAgICAgZWxzZSBpZihwb3J0QnVpbGRlcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYE5vIHBvcnRzIGhhdmUgYmVlbiBmb3VuZCBpbiBub2RlICR7dGhpcy5mdWxsTmFtZX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIG5vZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hbWUgYW5kIHR5cGUgb2YgdGhpcyBub2RlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZnVsbE5hbWUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX1bJHt0aGlzLm5hbWV9XWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBpbnB1dCBwb3J0IGJ5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BvcnROYW1lXVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZUlucHV0UG9ydH1cbiAgICAgKi9cbiAgICBpbnB1dChwb3J0TmFtZSA9IFNwZWVkeVBpcGVsaW5lSW5wdXRQb3J0LkRFRkFVTFRfTkFNRSlcbiAgICB7XG4gICAgICAgIGlmKHBvcnROYW1lIGluIHRoaXMuX2lucHV0UG9ydHMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRQb3J0c1twb3J0TmFtZV07XG5cbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBDYW4ndCBmaW5kIGlucHV0IHBvcnQgJHtwb3J0TmFtZX0gaW4gbm9kZSAke3RoaXMuZnVsbE5hbWV9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBvdXRwdXQgcG9ydCBieSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwb3J0TmFtZV1cbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVPdXRwdXRQb3J0fVxuICAgICAqL1xuICAgIG91dHB1dChwb3J0TmFtZSA9IFNwZWVkeVBpcGVsaW5lT3V0cHV0UG9ydC5ERUZBVUxUX05BTUUpXG4gICAge1xuICAgICAgICBpZihwb3J0TmFtZSBpbiB0aGlzLl9vdXRwdXRQb3J0cylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRwdXRQb3J0c1twb3J0TmFtZV07XG5cbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBDYW4ndCBmaW5kIG91dHB1dCBwb3J0ICR7cG9ydE5hbWV9IGluIG5vZGUgJHt0aGlzLmZ1bGxOYW1lfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhIGZyb20gdGhlIGlucHV0IHBvcnRzIGFuZCBleGVjdXRlXG4gICAgICogdGhlIHRhc2sgdGhhdCB0aGlzIG5vZGUgaXMgc3VwcG9zZWQgdG8hXG4gICAgICogQHBhcmFtIHtTcGVlZHlHUFV9IGdwdVxuICAgICAqIEByZXR1cm5zIHt2b2lkfFNwZWVkeVByb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgZXhlY3V0ZShncHUpXG4gICAge1xuICAgICAgICBsZXQgcG9ydE5hbWU7XG5cbiAgICAgICAgLy8gY2xlYXIgb3V0cHV0IHBvcnRzXG4gICAgICAgIGZvcihwb3J0TmFtZSBpbiB0aGlzLl9vdXRwdXRQb3J0cylcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFBvcnRzW3BvcnROYW1lXS5jbGVhck1lc3NhZ2UoKTtcblxuICAgICAgICAvLyBsZXQgdGhlIGlucHV0IHBvcnRzIHJlY2VpdmUgd2hhdCBpcyBkdWVcbiAgICAgICAgZm9yKHBvcnROYW1lIGluIHRoaXMuX2lucHV0UG9ydHMpXG4gICAgICAgICAgICB0aGlzLl9pbnB1dFBvcnRzW3BvcnROYW1lXS5wdWxsTWVzc2FnZSh0aGlzLmZ1bGxOYW1lKTtcblxuICAgICAgICAvLyBydW4gdGhlIHRhc2tcbiAgICAgICAgY29uc3QgcnVuVGFzayA9IHRoaXMuX3J1bihncHUpO1xuICAgICAgICBpZih0eXBlb2YgcnVuVGFzayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZvcihwb3J0TmFtZSBpbiB0aGlzLl9vdXRwdXRQb3J0cykgLy8gZW5zdXJlIHRoYXQgbm8gb3V0cHV0IHBvcnRzIGFyZSBlbXB0eVxuICAgICAgICAgICAgICAgIFV0aWxzLmFzc2VydCh0aGlzLl9vdXRwdXRQb3J0c1twb3J0TmFtZV0uaGFzTWVzc2FnZSgpLCBgRGlkIHlvdSBmb3JnZXQgdG8gd3JpdGUgZGF0YSB0byB0aGUgb3V0cHV0IHBvcnQgJHtwb3J0TmFtZX0gb2YgJHt0aGlzLmZ1bGxOYW1lfT9gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHJldHVybiBydW5UYXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZm9yKHBvcnROYW1lIGluIHRoaXMuX291dHB1dFBvcnRzKSAvLyBlbnN1cmUgdGhhdCBubyBvdXRwdXQgcG9ydHMgYXJlIGVtcHR5XG4gICAgICAgICAgICAgICAgVXRpbHMuYXNzZXJ0KHRoaXMuX291dHB1dFBvcnRzW3BvcnROYW1lXS5oYXNNZXNzYWdlKCksIGBEaWQgeW91IGZvcmdldCB0byB3cml0ZSBkYXRhIHRvIHRoZSBvdXRwdXQgcG9ydCAke3BvcnROYW1lfSBvZiAke3RoaXMuZnVsbE5hbWV9P2ApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIHNwZWNpZmljIHRhc2sgb2YgdGhpcyBub2RlXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtTcGVlZHlHUFV9IGdwdVxuICAgICAqIEByZXR1cm5zIHt2b2lkfFNwZWVkeVByb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgX3J1bihncHUpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2RFcnJvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoaXMgbm9kZVxuICAgICAqIEBwYXJhbSB7U3BlZWR5R1BVfSBncHVcbiAgICAgKi9cbiAgICBpbml0KGdwdSlcbiAgICB7XG4gICAgICAgIGdwdS5zdWJzY3JpYmUodGhpcy5fYWxsb2NhdGVXb3JrVGV4dHVyZXMsIHRoaXMsIGdwdSk7XG4gICAgICAgIHRoaXMuX2FsbG9jYXRlV29ya1RleHR1cmVzKGdwdSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgdGhpcyBub2RlXG4gICAgICogQHBhcmFtIHtTcGVlZHlHUFV9IGdwdVxuICAgICAqL1xuICAgIHJlbGVhc2UoZ3B1KVxuICAgIHtcbiAgICAgICAgdGhpcy5fZGVhbGxvY2F0ZVdvcmtUZXh0dXJlcyhncHUpO1xuICAgICAgICBncHUudW5zdWJzY3JpYmUodGhpcy5fYWxsb2NhdGVXb3JrVGV4dHVyZXMsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBwb3J0c1xuICAgICAqL1xuICAgIGNsZWFyUG9ydHMoKVxuICAgIHtcbiAgICAgICAgbGV0IHBvcnROYW1lO1xuXG4gICAgICAgIGZvcihwb3J0TmFtZSBpbiB0aGlzLl9pbnB1dFBvcnRzKVxuICAgICAgICAgICAgdGhpcy5faW5wdXRQb3J0c1twb3J0TmFtZV0uY2xlYXJNZXNzYWdlKCk7XG5cbiAgICAgICAgZm9yKHBvcnROYW1lIGluIHRoaXMuX291dHB1dFBvcnRzKVxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0UG9ydHNbcG9ydE5hbWVdLmNsZWFyTWVzc2FnZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYWxsIG5vZGVzIHRoYXQgZmVlZCBpbnB1dCB0byB0aGlzIG5vZGVcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVOb2RlW119XG4gICAgICovXG4gICAgaW5wdXROb2RlcygpXG4gICAge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuXG4gICAgICAgIGZvcihjb25zdCBwb3J0TmFtZSBpbiB0aGlzLl9pbnB1dFBvcnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5faW5wdXRQb3J0c1twb3J0TmFtZV07XG4gICAgICAgICAgICBpZihwb3J0LmluY29taW5nTGluayAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gocG9ydC5pbmNvbWluZ0xpbmsubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBhIHNvdXJjZSBvZiB0aGUgcGlwZWxpbmU/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTb3VyY2UoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgYSBzaW5rIG9mIHRoZSBwaXBlbGluZT9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NpbmsoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIG5vdGU6IGEgcG9ydGFsIHNpbmsgaGFzIG5vIG91dHB1dCBwb3J0cywgYnV0IGl0IGlzbid0IGEgc2luayBvZiB0aGUgcGlwZWxpbmUhXG4gICAgICAgIC8vcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX291dHB1dFBvcnRzKS5sZW5ndGggPT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZSB3b3JrIHRleHR1cmUocylcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICovXG4gICAgX2FsbG9jYXRlV29ya1RleHR1cmVzKGdwdSlcbiAgICB7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLl90ZXgubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICB0aGlzLl90ZXhbal0gPSBncHUudGV4dHVyZVBvb2wuYWxsb2NhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWFsbG9jYXRlIHdvcmsgdGV4dHVyZShzKVxuICAgICAqIEBwYXJhbSB7U3BlZWR5R1BVfSBncHVcbiAgICAgKi9cbiAgICBfZGVhbGxvY2F0ZVdvcmtUZXh0dXJlcyhncHUpXG4gICAge1xuICAgICAgICBmb3IobGV0IGogPSB0aGlzLl90ZXgubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICB0aGlzLl90ZXhbal0gPSBncHUudGV4dHVyZVBvb2wuZnJlZSh0aGlzLl90ZXhbal0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3BlY3QgdGhlIHBpeGVscyBvZiBhIHRleHR1cmUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAqIEBwYXJhbSB7U3BlZWR5R1BVfSBncHVcbiAgICAgKiBAcGFyYW0ge1NwZWVkeURyYXdhYmxlVGV4dHVyZX0gdGV4dHVyZVxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIF9pbnNwZWN0KGdwdSwgdGV4dHVyZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVSZWFkZXIgPSBuZXcgU3BlZWR5VGV4dHVyZVJlYWRlcigpO1xuICAgICAgICB0ZXh0dXJlUmVhZGVyLmluaXQoZ3B1KTtcbiAgICAgICAgY29uc3QgcGl4ZWxzID0gdGV4dHVyZVJlYWRlci5yZWFkUGl4ZWxzU3luYyh0ZXh0dXJlKTtcbiAgICAgICAgdGV4dHVyZVJlYWRlci5yZWxlYXNlKGdwdSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBpeGVscyk7IC8vIGNvcHkgdGhlIGFycmF5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zcGVjdCB0aGUgcGl4ZWxzIG9mIGEgdGV4dHVyZSBhcyB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICogQHBhcmFtIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IHRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7VWludDMyQXJyYXl9XG4gICAgICovXG4gICAgX2luc3BlY3QzMihncHUsIHRleHR1cmUpXG4gICAge1xuICAgICAgICBVdGlscy5hc3NlcnQoTElUVExFX0VORElBTik7IC8vIG1ha2Ugc3VyZSB3ZSB1c2UgbGl0dGxlLWVuZGlhblxuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KHRoaXMuX2luc3BlY3QoZ3B1LCB0ZXh0dXJlKS5idWZmZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZpc3VhbGx5IGluc3BlY3QgYSB0ZXh0dXJlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICogQHBhcmFtIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IHRleHR1cmVcbiAgICAgKi9cbiAgICBfdmlzdWFsaXplKGdwdSwgdGV4dHVyZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGdwdS5yZW5kZXJUb0NhbnZhcyh0ZXh0dXJlKTtcbiAgICAgICAgaWYoIV90ZXhWaWV3KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgICBfdGV4VmlldyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogU291cmNlIG5vZGUgKGEgbm9kZSB3aXRoIG5vIGlucHV0IHBvcnRzKVxuICogQGFic3RyYWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlQaXBlbGluZVNvdXJjZU5vZGUgZXh0ZW5kcyBTcGVlZHlQaXBlbGluZU5vZGVcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gdGhlIG5hbWUgb2YgdGhpcyBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0ZXhDb3VudF0gbnVtYmVyIG9mIHdvcmsgdGV4dHVyZXNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXJbXX0gW3BvcnRCdWlsZGVyc10gcG9ydCBidWlsZGVyc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSB1bmRlZmluZWQsIHRleENvdW50ID0gdW5kZWZpbmVkLCBwb3J0QnVpbGRlcnMgPSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBzdXBlcihuYW1lLCB0ZXhDb3VudCwgcG9ydEJ1aWxkZXJzKTtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KE9iamVjdC5rZXlzKHRoaXMuX2lucHV0UG9ydHMpLmxlbmd0aCA9PSAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIGEgc291cmNlIG9mIHRoZSBwaXBlbGluZT9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NvdXJjZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogU2luayBub2RlIChhIG5vZGUgd2l0aCBubyBvdXRwdXQgcG9ydHMpXG4gKiBAYWJzdHJhY3RcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVBpcGVsaW5lU2lua05vZGUgZXh0ZW5kcyBTcGVlZHlQaXBlbGluZU5vZGVcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gdGhlIG5hbWUgb2YgdGhpcyBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0ZXhDb3VudF0gbnVtYmVyIG9mIHdvcmsgdGV4dHVyZXNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXJbXX0gW3BvcnRCdWlsZGVyc10gcG9ydCBidWlsZGVyc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSB1bmRlZmluZWQsIHRleENvdW50ID0gdW5kZWZpbmVkLCBwb3J0QnVpbGRlcnMgPSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBzdXBlcihuYW1lLCB0ZXhDb3VudCwgcG9ydEJ1aWxkZXJzKTtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KE9iamVjdC5rZXlzKHRoaXMuX291dHB1dFBvcnRzKS5sZW5ndGggPT0gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3J0IGRhdGEgZnJvbSB0aGlzIG5vZGUgdG8gdGhlIHVzZXJcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGV4cG9ydCgpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2RFcnJvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgYSBzaW5rIG9mIHRoZSBwaXBlbGluZT9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NpbmsoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIHBpcGVsaW5lLXBvcnQuanNcbiAqIFBvcnQgb2YgYSBub2RlIG9mIGEgcGlwZWxpbmVcbiAqL1xuXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IElsbGVnYWxBcmd1bWVudEVycm9yLCBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IsIEFic3RyYWN0TWV0aG9kRXJyb3IsIE5vdFN1cHBvcnRlZEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCB7IFNwZWVkeVBpcGVsaW5lUG9ydFNwZWMgfSBmcm9tICcuL3BpcGVsaW5lLXBvcnRzcGVjJztcbmltcG9ydCB7IFNwZWVkeVBpcGVsaW5lTWVzc2FnZSwgU3BlZWR5UGlwZWxpbmVNZXNzYWdlV2l0aE5vdGhpbmcgfSBmcm9tICcuL3BpcGVsaW5lLW1lc3NhZ2UnO1xuaW1wb3J0IHsgU3BlZWR5UGlwZWxpbmVOb2RlIH0gZnJvbSAnLi9waXBlbGluZS1ub2RlJztcblxuLy8gQ29uc3RhbnRzXG5jb25zdCBERUZBVUxUX0lOUFVUX1BPUlRfTkFNRSA9ICdpbic7XG5jb25zdCBERUZBVUxUX09VVFBVVF9QT1JUX05BTUUgPSAnb3V0JztcbmNvbnN0IEFDQ0VQVEFCTEVfUE9SVF9OQU1FID0gL15bYS16XVthLXpBLVowLTldKiQvO1xuY29uc3QgRU1QVFlfTUVTU0FHRSA9IG5ldyBTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoTm90aGluZygpO1xuXG4vKipcbiAqIFBvcnQgb2YgYSBub2RlIG9mIGEgcGlwZWxpbmVcbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UGlwZWxpbmVQb3J0XG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGlzIHBvcnQgXG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZVBvcnRTcGVjfSBzcGVjIHBvcnQgc3BlY2lmaWNhdGlvblxuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVOb2RlfSBub2RlIHRoZSBub2RlIHRvIHdoaWNoIHRoaXMgcG9ydCBiZWxvbmdzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgc3BlYywgbm9kZSlcbiAgICB7XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGlzIHBvcnQgKi9cbiAgICAgICAgdGhpcy5fbmFtZSA9IFN0cmluZyhuYW1lKTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lUG9ydFNwZWN9IHRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoaXMgcG9ydCAqL1xuICAgICAgICB0aGlzLl9zcGVjID0gc3BlYztcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lTm9kZX0gdGhlIG5vZGUgdG8gd2hpY2ggdGhpcyBwb3J0IGJlbG9uZ3MgKi9cbiAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9IHRoZSBtZXNzYWdlIGxvY2F0ZWQgaW4gdGhpcyBwb3J0ICovXG4gICAgICAgIHRoaXMuX21lc3NhZ2UgPSBFTVBUWV9NRVNTQUdFO1xuXG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UndmUgZ290IGFuIGFjY2VwdGFibGUgcG9ydCBuYW1lXG4gICAgICAgIFV0aWxzLmFzc2VydChBQ0NFUFRBQkxFX1BPUlRfTkFNRS50ZXN0KHRoaXMuX25hbWUpLCBgUG9ydCBuYW1lIFwiJHt0aGlzLl9uYW1lfVwiIGlzIG5vdCBhY2NlcHRhYmxlYCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBwb3J0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSB0byB3aGljaCB0aGlzIHBvcnQgYmVsb25nc1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU5vZGV9XG4gICAgICovXG4gICAgZ2V0IG5vZGUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0aGlzIHBvcnQgdG8gYW5vdGhlclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVQb3J0fSBwb3J0XG4gICAgICovXG4gICAgY29ubmVjdFRvKHBvcnQpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2RFcnJvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgYW4gaW5wdXQgcG9ydD9cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0lucHV0UG9ydCgpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2RFcnJvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgYW4gb3V0cHV0IHBvcnQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPdXRwdXRQb3J0KClcbiAgICB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0lucHV0UG9ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBtZXNzYWdlIHN0b3JlZCBpbiB0aGlzIHBvcnRcbiAgICAgKi9cbiAgICBjbGVhck1lc3NhZ2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZSA9IEVNUFRZX01FU1NBR0U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhlcmUgYSB2YWxpZCBtZXNzYWdlIGxvY2F0ZWQgaW4gdGhpcyBwb3J0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc01lc3NhZ2UoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9tZXNzYWdlLmlzRW1wdHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBtZXNzYWdlIHRoYXQgaXMgaW4gdGhpcyBwb3J0XG4gICAgICogQHJldHVybnMge1NwZWVkeVBpcGVsaW5lTWVzc2FnZX1cbiAgICAgKi9cbiAgICByZWFkKClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuX21lc3NhZ2UuaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihgQ2FuJ3QgcmVhZCBmcm9tIHBvcnQgJHt0aGlzLm5hbWV9OiBub3RoaW5nIHRvIHJlYWRgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIG1lc3NhZ2UgdG8gdGhpcyBwb3J0XG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICB3cml0ZShtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKGBDYW4ndCB3cml0ZSAke21lc3NhZ2V9IHRvIHBvcnQgJHt0aGlzLm5hbWV9OiB1bnN1cHBvcnRlZCBvcGVyYXRpb25gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHBvcnQgbmFtZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBERUZBVUxUX05BTUUoKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEFic3RyYWN0TWV0aG9kRXJyb3IoKTtcbiAgICB9XG59XG5cbi8qKlxuICogT3V0cHV0IHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVBpcGVsaW5lT3V0cHV0UG9ydCBleHRlbmRzIFNwZWVkeVBpcGVsaW5lUG9ydFxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhpcyBwb3J0IFxuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVQb3J0U3BlY30gc3BlYyBwb3J0IHNwZWNpZmljYXRpb25cbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lTm9kZX0gbm9kZSB0aGUgbm9kZSB0byB3aGljaCB0aGlzIHBvcnQgYmVsb25nc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNwZWMsIG5vZGUpXG4gICAge1xuICAgICAgICBzdXBlcihuYW1lLCBzcGVjLCBub2RlKTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lTWVzc2FnZX0gY2FjaGVkIG1lc3NhZ2UgKi9cbiAgICAgICAgdGhpcy5fY2FjaGVkTWVzc2FnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0aGlzIHBvcnQgdG8gYW5vdGhlclxuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVJbnB1dFBvcnR9IHBvcnRcbiAgICAgKi9cbiAgICBjb25uZWN0VG8ocG9ydClcbiAgICB7XG4gICAgICAgIGlmKCFwb3J0LmlzSW5wdXRQb3J0KCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IGNvbm5lY3Qgb3V0cHV0IHBvcnQgJHt0aGlzLm5hbWV9IHRvIHBvcnQgJHtwb3J0Lm5hbWV9OiBleHBlY3RlZCBhbiBpbnB1dCBwb3J0YCk7XG5cbiAgICAgICAgcG9ydC5jb25uZWN0VG8odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBhbiBpbnB1dCBwb3J0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzSW5wdXRQb3J0KClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIG1lc3NhZ2UgdG8gdGhpcyBwb3J0XG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2V9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICB3cml0ZShtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgaWYoIXRoaXMuX3NwZWMuYWNjZXB0cyhtZXNzYWdlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgQ2FuJ3Qgd3JpdGUgJHttZXNzYWdlfSB0byBwb3J0ICR7dGhpcy5uYW1lfS4gJHt0aGlzLl9zcGVjfWApO1xuXG4gICAgICAgIHRoaXMuX21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgbWVzc2FnZSB0byB0aGlzIHBvcnQgdXNpbmcgYSBjYWNoZWQgbWVzc2FnZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgdG8gYmUgcGFzc2VkIHRvIFNwZWVkeVBpcGVsaW5lTWVzc2FnZS5zZXQoKVxuICAgICAqL1xuICAgIHN3cml0ZSguLi5hcmdzKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5fY2FjaGVkTWVzc2FnZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkTWVzc2FnZSA9IFNwZWVkeVBpcGVsaW5lTWVzc2FnZS5jcmVhdGUodGhpcy5fc3BlYy5leHBlY3RlZE1lc3NhZ2VUeXBlKTtcblxuICAgICAgICB0aGlzLndyaXRlKHRoaXMuX2NhY2hlZE1lc3NhZ2Uuc2V0KC4uLmFyZ3MpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHBvcnQgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBERUZBVUxUX05BTUUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfT1VUUFVUX1BPUlRfTkFNRTtcbiAgICB9XG59XG5cbi8qKlxuICogSW5wdXQgcG9ydFxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UGlwZWxpbmVJbnB1dFBvcnQgZXh0ZW5kcyBTcGVlZHlQaXBlbGluZVBvcnRcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoaXMgcG9ydCBcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lUG9ydFNwZWN9IHNwZWMgcG9ydCBzcGVjaWZpY2F0aW9uXG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZU5vZGV9IG5vZGUgdGhlIG5vZGUgdG8gd2hpY2ggdGhpcyBwb3J0IGJlbG9uZ3NcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzcGVjLCBub2RlKVxuICAgIHtcbiAgICAgICAgc3VwZXIobmFtZSwgc3BlYywgbm9kZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlQaXBlbGluZU91dHB1dFBvcnR8bnVsbH0gaW5jb21pbmcgbGluayAqL1xuICAgICAgICB0aGlzLl9pbmNvbWluZ0xpbmsgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluY29taW5nIGxpbmtcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVPdXRwdXRQb3J0fG51bGx9XG4gICAgICovXG4gICAgZ2V0IGluY29taW5nTGluaygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5jb21pbmdMaW5rO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdGhpcyBwb3J0IHRvIGFub3RoZXJcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lT3V0cHV0UG9ydH0gcG9ydFxuICAgICAqL1xuICAgIGNvbm5lY3RUbyhwb3J0KVxuICAgIHtcbiAgICAgICAgaWYoIXBvcnQuaXNPdXRwdXRQb3J0KCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IGNvbm5lY3QgaW5wdXQgcG9ydCAke3RoaXMubmFtZX0gb2YgXCIke3RoaXMubm9kZS5mdWxsTmFtZX1cIiB0byBpbnB1dCBwb3J0ICR7cG9ydC5uYW1lfSBvZiBcIiR7cG9ydC5ub2RlLmZ1bGxOYW1lfVwiOiBleHBlY3RlZCBhbiBvdXRwdXQgcG9ydGApO1xuICAgICAgICBlbHNlIGlmKCF0aGlzLl9zcGVjLmlzQ29tcGF0aWJsZVdpdGgocG9ydC5fc3BlYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IGNvbm5lY3QgcG9ydCAke3RoaXMubmFtZX0gb2YgXCIke3RoaXMubm9kZS5mdWxsTmFtZX1cIiB0byBwb3J0ICR7cG9ydC5uYW1lfSBvZiBcIiR7cG9ydC5ub2RlLmZ1bGxOYW1lfVwiOiBpbmNvbXBhdGlibGUgdHlwZXNgKTtcblxuICAgICAgICB0aGlzLl9pbmNvbWluZ0xpbmsgPSBwb3J0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVubGluayB0aGlzIHBvcnRcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KClcbiAgICB7XG4gICAgICAgIHRoaXMuX2luY29taW5nTGluayA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBhbiBpbnB1dCBwb3J0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzSW5wdXRQb3J0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgYSBtZXNzYWdlIHVzaW5nIHRoZSBpbmNvbWluZyBsaW5rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtub2RlTmFtZV1cbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlfVxuICAgICAqL1xuICAgIHB1bGxNZXNzYWdlKG5vZGVOYW1lID0gJycpXG4gICAge1xuICAgICAgICBjb25zdCBuYW1lID0gbm9kZU5hbWUubGVuZ3RoID4gMCA/IGAke3RoaXMubmFtZX0gb2YgJHtub2RlTmFtZX1gIDogdGhpcy5uYW1lO1xuXG4gICAgICAgIGlmKHRoaXMuX2luY29taW5nTGluayA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihgTm8gaW5jb21pbmcgbGluayBmb3IgaW5wdXQgcG9ydCAke25hbWV9YCk7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2luY29taW5nTGluay5yZWFkKCk7XG4gICAgICAgIGlmKCF0aGlzLl9zcGVjLmFjY2VwdHMobWVzc2FnZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IHJlY2VpdmUgJHttZXNzYWdlfSBhdCBwb3J0ICR7bmFtZX06ICR7dGhpcy5fc3BlY31gKTtcblxuICAgICAgICByZXR1cm4gKHRoaXMuX21lc3NhZ2UgPSBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHBvcnQgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBERUZBVUxUX05BTUUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfSU5QVVRfUE9SVF9OQU1FO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBwaXBlbGluZS1wb3J0YnVpbGRlci5qc1xuICogQnVpbGRlciBvZiBhIHBvcnQgb2YgYSBub2RlIG9mIGEgcGlwZWxpbmVcbiAqL1xuXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IFNwZWVkeVBpcGVsaW5lUG9ydCwgU3BlZWR5UGlwZWxpbmVJbnB1dFBvcnQsIFNwZWVkeVBpcGVsaW5lT3V0cHV0UG9ydCB9IGZyb20gJy4vcGlwZWxpbmUtcG9ydCc7XG5pbXBvcnQgeyBTcGVlZHlQaXBlbGluZVBvcnRTcGVjIH0gZnJvbSAnLi9waXBlbGluZS1wb3J0c3BlYyc7XG5pbXBvcnQgeyBTcGVlZHlQaXBlbGluZU1lc3NhZ2UsIFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUgfSBmcm9tICcuL3BpcGVsaW5lLW1lc3NhZ2UnO1xuaW1wb3J0IHsgU3BlZWR5UGlwZWxpbmVOb2RlIH0gZnJvbSAnLi9waXBlbGluZS1ub2RlJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3BpcGVsaW5lLXBvcnRzcGVjJykuU3BlZWR5UGlwZWxpbmVNZXNzYWdlQ29uc3RyYWludH0gU3BlZWR5UGlwZWxpbmVNZXNzYWdlQ29uc3RyYWludFxuICovXG5cbi8qKlxuICogQnVpbGRlciBvZiBhIHBvcnQgb2YgYSBub2RlIG9mIGEgcGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXJcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7dHlwZW9mIFNwZWVkeVBpcGVsaW5lUG9ydH0gcG9ydENsYXNzIGlucHV0IG9yIG91dHB1dD9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9ydE5hbWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwb3J0Q2xhc3MsIHBvcnROYW1lKVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHt0eXBlb2YgU3BlZWR5UGlwZWxpbmVQb3J0fSBpbnB1dCBvciBvdXRwdXQ/ICovXG4gICAgICAgIHRoaXMuX2NsYXNzID0gcG9ydENsYXNzO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBwb3J0IG5hbWUgKi9cbiAgICAgICAgdGhpcy5fbmFtZSA9IFN0cmluZyhwb3J0TmFtZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlfSBhY2NlcHRlZCBtZXNzYWdlIHR5cGUgKi9cbiAgICAgICAgdGhpcy5fdHlwZSA9IFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuTm90aGluZztcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lTWVzc2FnZUNvbnN0cmFpbnR9IG1lc3NhZ2UgdmFsaWRhdGlvbiBmdW5jdGlvbiAqL1xuICAgICAgICB0aGlzLl9tZXNzYWdlQ29uc3RyYWludCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNsYXJlIHRoYXQgdGhlIG5ldyBwb3J0IGV4cGVjdHMgYSBjZXJ0YWluIHR5cGUgb2YgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlVHlwZX0gdHlwZSBleHBlY3RlZCB0eXBlXG4gICAgICogQHJldHVybnMge1NwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXJ9IHRoaXMgYnVpbGRlclxuICAgICAqL1xuICAgIGV4cGVjdHModHlwZSlcbiAgICB7XG4gICAgICAgIFV0aWxzLmFzc2VydCh0aGlzLl90eXBlID09IFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuTm90aGluZyk7XG4gICAgICAgIFV0aWxzLmFzc2VydCh0eXBlICE9IFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuTm90aGluZyk7XG5cbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjbGFyZSB0aGF0IHRoZSBuZXcgcG9ydCBleHBlY3RzIG1lc3NhZ2VzIHNhdGlzZnlpbmcgYSBjb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2VDb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHJldHVybnMge1NwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXJ9IHRoaXMgYnVpbGRlclxuICAgICAqL1xuICAgIHNhdGlzZnlpbmcoY29uc3RyYWludClcbiAgICB7XG4gICAgICAgIFV0aWxzLmFzc2VydCh0aGlzLl90eXBlICE9IFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuTm90aGluZywgJ1lvdSBtdXN0IGZpcnN0IGRlY2xhcmUgd2hhdCB0eXBlIG9mIG1lc3NhZ2UgdGhpcyBwb3J0IGV4cGVjdHMnKTtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KHRoaXMuX21lc3NhZ2VDb25zdHJhaW50ID09PSB1bmRlZmluZWQpO1xuICAgICAgICBVdGlscy5hc3NlcnQodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdmdW5jdGlvbicpO1xuXG4gICAgICAgIHRoaXMuX21lc3NhZ2VDb25zdHJhaW50ID0gY29uc3RyYWludDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIHBvcnRcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVBpcGVsaW5lTm9kZX0gbm9kZSB0aGUgbm9kZSB0byB3aGljaCB0aGUgbmV3IHBvcnQgd2lsbCBiZWxvbmdcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UGlwZWxpbmVQb3J0fVxuICAgICAqL1xuICAgIGJ1aWxkKG5vZGUpXG4gICAge1xuICAgICAgICBjb25zdCBzcGVjID0gbmV3IFNwZWVkeVBpcGVsaW5lUG9ydFNwZWModGhpcy5fdHlwZSwgdGhpcy5fbWVzc2FnZUNvbnN0cmFpbnQpO1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QodGhpcy5fY2xhc3MsIFt0aGlzLl9uYW1lLCBzcGVjLCBub2RlXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBidWlsZGVyIGZvciBhbiBpbnB1dCBwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3BvcnROYW1lXVxuICogQHJldHVybnMge1NwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJbnB1dFBvcnQocG9ydE5hbWUgPSBTcGVlZHlQaXBlbGluZUlucHV0UG9ydC5ERUZBVUxUX05BTUUpXG57XG4gICAgcmV0dXJuIG5ldyBTcGVlZHlQaXBlbGluZVBvcnRCdWlsZGVyKFNwZWVkeVBpcGVsaW5lSW5wdXRQb3J0LCBwb3J0TmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1aWxkZXIgZm9yIGFuIG91dHB1dCBwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3BvcnROYW1lXVxuICogQHJldHVybnMge1NwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPdXRwdXRQb3J0KHBvcnROYW1lID0gU3BlZWR5UGlwZWxpbmVPdXRwdXRQb3J0LkRFRkFVTFRfTkFNRSlcbntcbiAgICByZXR1cm4gbmV3IFNwZWVkeVBpcGVsaW5lUG9ydEJ1aWxkZXIoU3BlZWR5UGlwZWxpbmVPdXRwdXRQb3J0LCBwb3J0TmFtZSk7XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogcGlwZWxpbmUtcG9ydHNwZWMuanNcbiAqIFNwZWNpZmljYXRpb24gKHJlcXVpcmVtZW50cykgb2YgYSBwb3J0IG9mIGEgbm9kZSBvZiBhIHBpcGVsaW5lXG4gKi9cblxuaW1wb3J0IHsgU3BlZWR5UGlwZWxpbmVNZXNzYWdlLCBTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlIH0gZnJvbSAnLi9waXBlbGluZS1tZXNzYWdlJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuXG4vKipcbiAqIEEgbWVzc2FnZSBjb25zdHJhaW50IGlzIGEgbWVzc2FnZSB2YWxpZGF0aW9uIHByZWRpY2F0ZVxuICogQHR5cGVkZWYge2Z1bmN0aW9uKFNwZWVkeVBpcGVsaW5lTWVzc2FnZSk6IGJvb2xlYW59IFNwZWVkeVBpcGVsaW5lTWVzc2FnZUNvbnN0cmFpbnRcbiAqL1xuXG4vKipcbiAqIEEgdmFsaWRhdGlvbiBwcmVkaWNhdGUgdGhhdCB2YWxpZGF0ZXMgYWxsIG1lc3NhZ2VzXG4gKiBAdHlwZSB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlQ29uc3RyYWludH1cbiAqL1xuY29uc3Qgbm9uZSA9IG1lc3NhZ2UgPT4gdHJ1ZTtcblxuLyoqXG4gKiBTcGVjaWZpY2F0aW9uIChyZXF1aXJlbWVudHMpIG9mIGEgcG9ydCBvZiBhIG5vZGUgb2YgYSBwaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UGlwZWxpbmVQb3J0U3BlY1xue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlfSBleHBlY3RlZE1lc3NhZ2VUeXBlIGV4cGVjdGVkIG1lc3NhZ2UgdHlwZVxuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlQ29uc3RyYWludH0gW21lc3NhZ2VDb25zdHJhaW50XSBtZXNzYWdlIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihleHBlY3RlZE1lc3NhZ2VUeXBlLCBtZXNzYWdlQ29uc3RyYWludCA9IG5vbmUpXG4gICAge1xuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGV9IGV4cGVjdGVkIG1lc3NhZ2UgdHlwZSAqL1xuICAgICAgICB0aGlzLl9leHBlY3RlZE1lc3NhZ2VUeXBlID0gZXhwZWN0ZWRNZXNzYWdlVHlwZTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lTWVzc2FnZUNvbnN0cmFpbnR9IG1lc3NhZ2UgdmFsaWRhdGlvbiBmdW5jdGlvbiAqL1xuICAgICAgICB0aGlzLl9pc1ZhbGlkTWVzc2FnZSA9ICh0eXBlb2YgbWVzc2FnZUNvbnN0cmFpbnQgPT09ICdmdW5jdGlvbicpID8gbWVzc2FnZUNvbnN0cmFpbnQgOiBub25lO1xuXG5cbiAgICAgICAgLy8gZXhwZWN0IGEgdmFsaWQgdHlwZVxuICAgICAgICBVdGlscy5hc3NlcnQodGhpcy5fZXhwZWN0ZWRNZXNzYWdlVHlwZSAhPSBTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlLk5vdGhpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0d28gc3BlY3MgaGF2ZSB0aGUgc2FtZSBleHBlY3RlZCB0eXBlXG4gICAgICogQHBhcmFtIHtTcGVlZHlQaXBlbGluZVBvcnRTcGVjfSBzcGVjXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb21wYXRpYmxlV2l0aChzcGVjKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGVjdGVkTWVzc2FnZVR5cGUgPT0gc3BlYy5fZXhwZWN0ZWRNZXNzYWdlVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgZ2l2ZW4gbWVzc2FnZSBhY2NlcHRlZCBieSBhIHBvcnQgdGhhdCBhYmlkZXMgYnkgdGhpcyBzcGVjaWZpY2F0aW9uP1xuICAgICAqIEBwYXJhbSB7U3BlZWR5UGlwZWxpbmVNZXNzYWdlfSBtZXNzYWdlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYWNjZXB0cyhtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuaGFzVHlwZSh0aGlzLl9leHBlY3RlZE1lc3NhZ2VUeXBlKSAmJiB0aGlzLl9pc1ZhbGlkTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKVxuICAgIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IE9iamVjdC5rZXlzKFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUpLmZpbmQoXG4gICAgICAgICAgICB0eXBlID0+IFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGVbdHlwZV0gPT09IHRoaXMuX2V4cGVjdGVkTWVzc2FnZVR5cGVcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gYFBvcnQgZXhwZWN0cyAke3R5cGV9IHNhdGlzZnlpbmcgJHt0aGlzLl9pc1ZhbGlkTWVzc2FnZX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIG1lc3NhZ2UgdHlwZVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlfVxuICAgICAqL1xuICAgIGdldCBleHBlY3RlZE1lc3NhZ2VUeXBlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBlY3RlZE1lc3NhZ2VUeXBlO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzZXR0aW5ncy5qc1xuICogR2xvYmFsIHNldHRpbmdzXG4gKi9cblxuaW1wb3J0IHsgU3BlZWR5TmFtZXNwYWNlIH0gZnJvbSAnLi9zcGVlZHktbmFtZXNwYWNlJztcbmltcG9ydCB7IFNwZWVkeUdMIH0gZnJvbSAnLi4vZ3B1L3NwZWVkeS1nbCc7XG5pbXBvcnQgeyBJbGxlZ2FsQXJndW1lbnRFcnJvciB9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9ncHUvc3BlZWR5LWdsJykuUG93ZXJQcmVmZXJlbmNlfSBQb3dlclByZWZlcmVuY2UgKi9cbi8qKiBAdHlwZWRlZiB7XCJyYWZcIiB8IFwiYXNhcFwifSBHUFVQb2xsaW5nTW9kZSAqL1xuXG5cbi8qKiBAdHlwZSB7R1BVUG9sbGluZ01vZGV9IERlZmF1bHQgR1BVIHBvbGxpbmcgbW9kZSAqL1xuY29uc3QgREVGQVVMVF9HUFVfUE9MTElOR19NT0RFID0gJ3JhZic7XG5cbi8qKiBAdHlwZSB7R1BVUG9sbGluZ01vZGV9IEdQVSBwb2xsaW5nIG1vZGUgKi9cbmxldCBncHVQb2xsaW5nTW9kZSA9IERFRkFVTFRfR1BVX1BPTExJTkdfTU9ERTtcblxuXG5cbi8qKlxuICogR2xvYmFsIHNldHRpbmdzXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5ncyBleHRlbmRzIFNwZWVkeU5hbWVzcGFjZVxue1xuICAgIC8qKlxuICAgICAqIFBvd2VyIHByZWZlcmVuY2Ugb2YgdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7UG93ZXJQcmVmZXJlbmNlfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcG93ZXJQcmVmZXJlbmNlKClcbiAgICB7XG4gICAgICAgIHJldHVybiBTcGVlZHlHTC5wb3dlclByZWZlcmVuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG93ZXIgcHJlZmVyZW5jZSBvZiB0aGUgV2ViR0wgY29udGV4dFxuICAgICAqIEBwYXJhbSB7UG93ZXJQcmVmZXJlbmNlfSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXQgcG93ZXJQcmVmZXJlbmNlKHZhbHVlKVxuICAgIHtcbiAgICAgICAgU3BlZWR5R0wucG93ZXJQcmVmZXJlbmNlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR1BVIHBvbGxpbmcgbW9kZVxuICAgICAqIEByZXR1cm5zIHtHUFVQb2xsaW5nTW9kZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGdwdVBvbGxpbmdNb2RlKClcbiAgICB7XG4gICAgICAgIHJldHVybiBncHVQb2xsaW5nTW9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHUFUgcG9sbGluZyBtb2RlXG4gICAgICogQHBhcmFtIHtHUFVQb2xsaW5nTW9kZX0gdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0IGdwdVBvbGxpbmdNb2RlKHZhbHVlKVxuICAgIHtcbiAgICAgICAgaWYodmFsdWUgIT09ICdyYWYnICYmIHZhbHVlICE9PSAnYXNhcCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYEludmFsaWQgR1BVIHBvbGxpbmcgbW9kZTogXCIke3ZhbHVlfVwiYCk7XG5cbiAgICAgICAgZ3B1UG9sbGluZ01vZGUgPSB2YWx1ZTtcbiAgICB9XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogc3BlZWR5LW1lZGlhLXNvdXJjZS5qc1xuICogV3JhcHBlcnMgYXJvdW5kIDxpbWc+LCA8dmlkZW8+LCA8Y2FudmFzPiwgZXRjLlxuICovXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgU3BlZWR5UHJvbWlzZSB9IGZyb20gJy4vc3BlZWR5LXByb21pc2UnO1xuaW1wb3J0IHsgQWJzdHJhY3RNZXRob2RFcnJvciwgSWxsZWdhbEFyZ3VtZW50RXJyb3IsIElsbGVnYWxPcGVyYXRpb25FcnJvciwgVGltZW91dEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCB7IE1lZGlhVHlwZSB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJ1xuXG4vKiogQHR5cGVkZWYge0hUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gU3BlZWR5TWVkaWFTb3VyY2VOYXRpdmVFbGVtZW50ICovXG5cbi8qKiBJbnRlcm5hbCB0b2tlbiBmb3IgcHJvdGVjdGVkIGNvbnN0cnVjdG9ycyAqL1xuY29uc3QgUFJJVkFURV9UT0tFTiA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IG1lZGlhIHNvdXJjZTogYSB3cmFwcGVyIGFyb3VuZCBuYXRpdmVcbiAqIGVsZW1lbnRzIHN1Y2ggYXM6IEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxWaWRlb0VsZW1lbnQsXG4gKiBhbmQgc28gb25cbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5TWVkaWFTb3VyY2VcbntcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzeW1ib2x9IHRva2VuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW4pXG4gICAge1xuICAgICAgICAvLyB0aGUgY29uc3RydWN0b3IgaXMgbm90IHB1YmxpY1xuICAgICAgICBpZih0b2tlbiAhPT0gUFJJVkFURV9UT0tFTilcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoKTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeU1lZGlhU291cmNlTmF0aXZlRWxlbWVudH0gdW5kZXJseWluZyBtZWRpYSBvYmplY3QgKi9cbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIG1lZGlhIHNvdXJjZVxuICAgICAqIEBwYXJhbSB7U3BlZWR5TWVkaWFTb3VyY2VOYXRpdmVFbGVtZW50fSB3cmFwcGVkT2JqZWN0XG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8U3BlZWR5TWVkaWFTb3VyY2U+fVxuICAgICAqL1xuICAgIHN0YXRpYyBsb2FkKHdyYXBwZWRPYmplY3QpXG4gICAge1xuICAgICAgICBpZih3cmFwcGVkT2JqZWN0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBTcGVlZHlJbWFnZU1lZGlhU291cmNlLmxvYWQod3JhcHBlZE9iamVjdCk7XG4gICAgICAgIGVsc2UgaWYod3JhcHBlZE9iamVjdCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gU3BlZWR5VmlkZW9NZWRpYVNvdXJjZS5sb2FkKHdyYXBwZWRPYmplY3QpO1xuICAgICAgICBlbHNlIGlmKHdyYXBwZWRPYmplY3QgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBTcGVlZHlDYW52YXNNZWRpYVNvdXJjZS5sb2FkKHdyYXBwZWRPYmplY3QpO1xuICAgICAgICBlbHNlIGlmKHdyYXBwZWRPYmplY3QgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcClcbiAgICAgICAgICAgIHJldHVybiBTcGVlZHlCaXRtYXBNZWRpYVNvdXJjZS5sb2FkKHdyYXBwZWRPYmplY3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYFVuc3VwcG9ydGVkIG1lZGlhIHR5cGU6ICR7d3JhcHBlZE9iamVjdH1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5kZXJseWluZyB3cmFwcGVkIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlNZWRpYVNvdXJjZU5hdGl2ZUVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IGRhdGEoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIHVuZGVybHlpbmcgbWVkaWEgbG9hZGVkP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTG9hZGVkKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB1bmRlcmx5aW5nIG1lZGlhIHNvdXJjZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm5zIHtNZWRpYVR5cGV9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEFic3RyYWN0TWV0aG9kRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZWRpYSB3aWR0aCwgaW4gcGl4ZWxzXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEFic3RyYWN0TWV0aG9kRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZWRpYSBoZWlnaHQsIGluIHBpeGVsc1xuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2RFcnJvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgbWVkaWEgc291cmNlXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8U3BlZWR5TWVkaWFTb3VyY2U+fVxuICAgICAqL1xuICAgIGNsb25lKClcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBBYnN0cmFjdE1ldGhvZEVycm9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgb2JqZWN0XG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgcmVsZWFzZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2RhdGEgPSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSB1bmRlcmx5aW5nIG1lZGlhXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtTcGVlZHlNZWRpYVNvdXJjZU5hdGl2ZUVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYVNvdXJjZT59XG4gICAgICovXG4gICAgX2xvYWQoZWxlbWVudClcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBBYnN0cmFjdE1ldGhvZEVycm9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYW4gZXZlbnQgdG8gYmUgdHJpZ2dlcmVkIGluIGFuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XSBpbiBtc1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9taXNlPEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBfd2FpdFVudGlsKGVsZW1lbnQsIGV2ZW50TmFtZSwgdGltZW91dCA9IDMwMDAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGVlZHlQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIFV0aWxzLmxvZyhgV2FpdGluZyBmb3IgJHtldmVudE5hbWV9IHRvIGJlIHRyaWdnZXJlZCBpbiAke2VsZW1lbnR9Li4uYCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUaW1lb3V0RXJyb3IoYCR7ZXZlbnROYW1lfSBoYXMgbm90IGJlZW4gdHJpZ2dlcmVkIGluICR7ZWxlbWVudH06IHRpbWVvdXQgKCR7dGltZW91dH1tcylgKSk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEltYWdlIG1lZGlhIHNvdXJjZTpcbiAqIGEgd3JhcHBlciBhcm91bmQgSFRNTEltYWdlRWxlbWVudFxuICovXG5jbGFzcyBTcGVlZHlJbWFnZU1lZGlhU291cmNlIGV4dGVuZHMgU3BlZWR5TWVkaWFTb3VyY2VcbntcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3ltYm9sfSB0b2tlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuKVxuICAgIHtcbiAgICAgICAgc3VwZXIodG9rZW4pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgZWxlbWVudCAqL1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5kZXJseWluZyB3cmFwcGVkIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBkYXRhKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB1bmRlcmx5aW5nIG1lZGlhIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIHtNZWRpYVR5cGV9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhVHlwZS5JbWFnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZWRpYSB3aWR0aCwgaW4gcGl4ZWxzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPyB0aGlzLl9kYXRhLm5hdHVyYWxXaWR0aCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVkaWEgaGVpZ2h0LCBpbiBwaXhlbHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPyB0aGlzLl9kYXRhLm5hdHVyYWxIZWlnaHQgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgbWVkaWEgc291cmNlXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8U3BlZWR5TWVkaWFTb3VyY2U+fVxuICAgICAqL1xuICAgIGNsb25lKClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuX2RhdGEgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoYE1lZGlhIG5vdCBsb2FkZWRgKTtcblxuICAgICAgICBjb25zdCBuZXdOb2RlID0gLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAoIHRoaXMuX2RhdGEuY2xvbmVOb2RlKHRydWUpICk7XG4gICAgICAgIHJldHVybiBTcGVlZHlJbWFnZU1lZGlhU291cmNlLmxvYWQobmV3Tm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgdW5kZXJseWluZyBtZWRpYVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYVNvdXJjZT59XG4gICAgICovXG4gICAgX2xvYWQoaW1hZ2UpXG4gICAge1xuICAgICAgICBpZih0aGlzLmlzTG9hZGVkKCkpXG4gICAgICAgICAgICB0aGlzLnJlbGVhc2UoKTtcblxuICAgICAgICBpZihpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApIHsgLy8gYWxyZWFkeSBsb2FkZWQ/XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwZWVkeVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGltYWdlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTcGVlZHlNZWRpYVNvdXJjZS5fd2FpdFVudGlsKGltYWdlLCAnbG9hZCcpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgdW5kZXJseWluZyBtZWRpYVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYVNvdXJjZT59XG4gICAgICovXG4gICAgc3RhdGljIGxvYWQoaW1hZ2UpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFNwZWVkeUltYWdlTWVkaWFTb3VyY2UoUFJJVkFURV9UT0tFTikuX2xvYWQoaW1hZ2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWaWRlbyBtZWRpYSBzb3VyY2U6XG4gKiBhIHdyYXBwZXIgYXJvdW5kIEhUTUxWaWRlb0VsZW1lbnRcbiAqL1xuY2xhc3MgU3BlZWR5VmlkZW9NZWRpYVNvdXJjZSBleHRlbmRzIFNwZWVkeU1lZGlhU291cmNlXG57XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N5bWJvbH0gdG9rZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbilcbiAgICB7XG4gICAgICAgIHN1cGVyKHRva2VuKTtcblxuICAgICAgICAvKiogQHR5cGUge0hUTUxWaWRlb0VsZW1lbnR9IHZpZGVvIGVsZW1lbnQgKi9cbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVuZGVybHlpbmcgd3JhcHBlZCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7SFRNTFZpZGVvRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdW5kZXJseWluZyBtZWRpYSBzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7TWVkaWFUeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKClcbiAgICB7XG4gICAgICAgIHJldHVybiBNZWRpYVR5cGUuVmlkZW87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVkaWEgd2lkdGgsIGluIHBpeGVsc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKClcbiAgICB7XG4gICAgICAgIC8vIFdhcm5pbmc6IHZpZGVvV2lkdGggJiB2aWRlb0hlaWdodCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lICEhIVxuICAgICAgICAvLyBzbyB5b3UgY2FuJ3QgY2FjaGUgdGhlc2UgZGltZW5zaW9uc1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YSA/IHRoaXMuX2RhdGEudmlkZW9XaWR0aCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVkaWEgaGVpZ2h0LCBpbiBwaXhlbHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPyB0aGlzLl9kYXRhLnZpZGVvSGVpZ2h0IDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGlzIG1lZGlhIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9taXNlPFNwZWVkeU1lZGlhU291cmNlPn1cbiAgICAgKi9cbiAgICBjbG9uZSgpXG4gICAge1xuICAgICAgICBpZih0aGlzLl9kYXRhID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKGBNZWRpYSBub3QgbG9hZGVkYCk7XG5cbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IC8qKiBAdHlwZSB7SFRNTFZpZGVvRWxlbWVudH0gKi8gKCB0aGlzLl9kYXRhLmNsb25lTm9kZSh0cnVlKSApO1xuICAgICAgICByZXR1cm4gU3BlZWR5VmlkZW9NZWRpYVNvdXJjZS5sb2FkKG5ld05vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIHVuZGVybHlpbmcgbWVkaWFcbiAgICAgKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnR9IHZpZGVvXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8U3BlZWR5TWVkaWFTb3VyY2U+fVxuICAgICAqL1xuICAgIF9sb2FkKHZpZGVvKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5pc0xvYWRlZCgpKVxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG5cbiAgICAgICAgaWYodmlkZW8ucmVhZHlTdGF0ZSA+PSA0KSB7IC8vIGFscmVhZHkgbG9hZGVkP1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGVlZHlQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB2aWRlbztcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3YWl0VW50aWwoJ2NhbnBsYXknKTsgLy8gdXNlIHJlYWR5U3RhdGUgPj0gM1xuICAgICAgICAgICAgcmV0dXJuIFNwZWVkeU1lZGlhU291cmNlLl93YWl0VW50aWwodmlkZW8sICdjYW5wbGF5dGhyb3VnaCcpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB2aWRlbztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSB1bmRlcmx5aW5nIG1lZGlhXG4gICAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9taXNlPFNwZWVkeU1lZGlhU291cmNlPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9hZCh2aWRlbylcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5VmlkZW9NZWRpYVNvdXJjZShQUklWQVRFX1RPS0VOKS5fbG9hZCh2aWRlbyk7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbnZhcyBtZWRpYSBzb3VyY2U6XG4gKiBhIHdyYXBwZXIgYXJvdW5kIEhUTUxDYW52YXNFbGVtZW50XG4gKi9cbmNsYXNzIFNwZWVkeUNhbnZhc01lZGlhU291cmNlIGV4dGVuZHMgU3BlZWR5TWVkaWFTb3VyY2VcbntcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3ltYm9sfSB0b2tlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuKVxuICAgIHtcbiAgICAgICAgc3VwZXIodG9rZW4pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBlbGVtZW50ICovXG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB1bmRlcmx5aW5nIHdyYXBwZWQgb2JqZWN0XG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBkYXRhKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB1bmRlcmx5aW5nIG1lZGlhIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIHtNZWRpYVR5cGV9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhVHlwZS5DYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVkaWEgd2lkdGgsIGluIHBpeGVsc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhID8gdGhpcy5fZGF0YS53aWR0aCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVkaWEgaGVpZ2h0LCBpbiBwaXhlbHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPyB0aGlzLl9kYXRhLmhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhpcyBtZWRpYSBzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYVNvdXJjZT59XG4gICAgICovXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5fZGF0YSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihgTWVkaWEgbm90IGxvYWRlZGApO1xuXG4gICAgICAgIGNvbnN0IG5ld0NhbnZhcyA9IFV0aWxzLmNyZWF0ZUNhbnZhcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBuZXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgbmV3Q29udGV4dC5kcmF3SW1hZ2UodGhpcy5fZGF0YSwgMCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIFNwZWVkeUNhbnZhc01lZGlhU291cmNlLmxvYWQobmV3Q2FudmFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSB1bmRlcmx5aW5nIG1lZGlhXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8U3BlZWR5TWVkaWFTb3VyY2U+fVxuICAgICAqL1xuICAgIF9sb2FkKGNhbnZhcylcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuaXNMb2FkZWQoKSlcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBjYW52YXM7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSB1bmRlcmx5aW5nIG1lZGlhXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8U3BlZWR5TWVkaWFTb3VyY2U+fVxuICAgICAqL1xuICAgIHN0YXRpYyBsb2FkKGNhbnZhcylcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5Q2FudmFzTWVkaWFTb3VyY2UoUFJJVkFURV9UT0tFTikuX2xvYWQoY2FudmFzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQml0bWFwIG1lZGlhIHNvdXJjZTpcbiAqIGEgd3JhcHBlciBhcm91bmQgSW1hZ2VCaXRtYXBcbiAqL1xuY2xhc3MgU3BlZWR5Qml0bWFwTWVkaWFTb3VyY2UgZXh0ZW5kcyBTcGVlZHlNZWRpYVNvdXJjZVxue1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzeW1ib2x9IHRva2VuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW4pXG4gICAge1xuICAgICAgICBzdXBlcih0b2tlbik7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtJbWFnZUJpdG1hcH0gaW1hZ2UgYml0bWFwICovXG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB1bmRlcmx5aW5nIHdyYXBwZWQgb2JqZWN0XG4gICAgICogQHJldHVybnMge0ltYWdlQml0bWFwfVxuICAgICAqL1xuICAgIGdldCBkYXRhKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB1bmRlcmx5aW5nIG1lZGlhIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIHtNZWRpYVR5cGV9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhVHlwZS5CaXRtYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVkaWEgd2lkdGgsIGluIHBpeGVsc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhID8gdGhpcy5fZGF0YS53aWR0aCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVkaWEgaGVpZ2h0LCBpbiBwaXhlbHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPyB0aGlzLl9kYXRhLmhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhpcyBtZWRpYSBzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYVNvdXJjZT59XG4gICAgICovXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5fZGF0YSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihgTWVkaWEgbm90IGxvYWRlZGApO1xuXG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLl9kYXRhKS50aGVuKFxuICAgICAgICAgICAgICAgIG5ld0JpdG1hcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NvdXJjZSA9IG5ldyBTcGVlZHlCaXRtYXBNZWRpYVNvdXJjZShQUklWQVRFX1RPS0VOKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U291cmNlLl9sb2FkKG5ld0JpdG1hcCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICByZWxlYXNlKClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuX2RhdGEgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY2xvc2UoKTtcblxuICAgICAgICByZXR1cm4gc3VwZXIucmVsZWFzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIHVuZGVybHlpbmcgbWVkaWFcbiAgICAgKiBAcGFyYW0ge0ltYWdlQml0bWFwfSBiaXRtYXBcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYVNvdXJjZT59XG4gICAgICovXG4gICAgX2xvYWQoYml0bWFwKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5pc0xvYWRlZCgpKVxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTcGVlZHlQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGJpdG1hcDtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIHVuZGVybHlpbmcgbWVkaWFcbiAgICAgKiBAcGFyYW0ge0ltYWdlQml0bWFwfSBiaXRtYXBcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYVNvdXJjZT59XG4gICAgICovXG4gICAgc3RhdGljIGxvYWQoYml0bWFwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGVlZHlCaXRtYXBNZWRpYVNvdXJjZShQUklWQVRFX1RPS0VOKS5fbG9hZChiaXRtYXApO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzcGVlZHktbWVkaWEuanNcbiAqIFNwZWVkeU1lZGlhIGltcGxlbWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgU3BlZWR5R1BVIH0gZnJvbSAnLi4vZ3B1L3NwZWVkeS1ncHUnO1xuaW1wb3J0IHsgU3BlZWR5VGV4dHVyZSB9IGZyb20gJy4uL2dwdS9zcGVlZHktdGV4dHVyZSc7XG5pbXBvcnQgeyBNZWRpYVR5cGUsIEltYWdlRm9ybWF0IH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnXG5pbXBvcnQgeyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IsIElsbGVnYWxBcmd1bWVudEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgU3BlZWR5TWVkaWFTb3VyY2UgfSBmcm9tICcuL3NwZWVkeS1tZWRpYS1zb3VyY2UnO1xuaW1wb3J0IHsgU3BlZWR5UHJvbWlzZSB9IGZyb20gJy4vc3BlZWR5LXByb21pc2UnO1xuaW1wb3J0IHsgU3BlZWR5U2l6ZSB9IGZyb20gJy4vc3BlZWR5LXNpemUnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zcGVlZHktbWVkaWEtc291cmNlJykuU3BlZWR5TWVkaWFTb3VyY2VOYXRpdmVFbGVtZW50fSBTcGVlZHlNZWRpYVNvdXJjZU5hdGl2ZUVsZW1lbnQgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTcGVlZHlNZWRpYU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7SW1hZ2VGb3JtYXR9IFtmb3JtYXRdIGRlZmF1bHQgaXMgUkdCQVxuICovXG5cbi8qKiBBIGhlbHBlciB1c2VkIHRvIGtlZXAgdGhlIGNvbnN0cnVjdG9yIG9mIFNwZWVkeU1lZGlhIHByaXZhdGUgKi9cbmNvbnN0IFBSSVZBVEVfVE9LRU4gPSBTeW1ib2woKTtcblxuLyoqXG4gKiBTcGVlZHlNZWRpYSBlbmNhcHN1bGF0ZXMgYSBtZWRpYSBlbGVtZW50XG4gKiAoZS5nLiwgaW1hZ2UsIHZpZGVvLCBjYW52YXMpXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlNZWRpYVxue1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIENvbnN0cnVjdG9yLiBJdCByZWNlaXZlcyBhIFZBTElEIG1lZGlhIHNvdXJjZSB0aGF0IGlzIEFMUkVBRFkgTE9BREVELlxuICAgICAqIEBwYXJhbSB7c3ltYm9sfSB0b2tlblxuICAgICAqIEBwYXJhbSB7U3BlZWR5TWVkaWFTb3VyY2V9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7U3BlZWR5TWVkaWFPcHRpb25zfSBbb3B0aW9uc10gb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbiwgc291cmNlLCBvcHRpb25zID0ge30pXG4gICAge1xuICAgICAgICAvLyBwcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgICAgIGlmKHRva2VuICE9PSBQUklWQVRFX1RPS0VOKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcigpO1xuXG5cblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeU1lZGlhU291cmNlfSBtZWRpYSBzb3VyY2UgKi9cbiAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7SW1hZ2VGb3JtYXR9IGZvcm1hdCAqL1xuICAgICAgICB0aGlzLl9mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiBJbWFnZUZvcm1hdC5SR0JBO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5TWVkaWFPcHRpb25zfSBvcHRpb25zICovXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuZnJlZXplKHsgLi4ub3B0aW9ucywgZm9ybWF0OiB0aGlzLl9mb3JtYXQgfSk7XG5cblxuXG4gICAgICAgIC8vIHZhbGlkYXRlXG4gICAgICAgIGlmKCFzb3VyY2UuaXNMb2FkZWQoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoYFNvdXJjZSBub3QgbG9hZGVkOiAke3NvdXJjZX1gKTtcbiAgICAgICAgZWxzZSBpZih0aGlzLl9mb3JtYXQgIT09IEltYWdlRm9ybWF0LlJHQkEgJiYgdGhpcy5fZm9ybWF0ICE9PSBJbWFnZUZvcm1hdC5HUkVZKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBJbnZhbGlkIGZvcm1hdDogJHt0aGlzLl9mb3JtYXR9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIG1lZGlhIHNvdXJjZVxuICAgICAqIFdpbGwgd2FpdCB1bnRpbCB0aGUgSFRNTCBtZWRpYSBzb3VyY2UgaXMgbG9hZGVkXG4gICAgICogQHBhcmFtIHtTcGVlZHlNZWRpYVNvdXJjZU5hdGl2ZUVsZW1lbnR9IG1lZGlhU291cmNlIEFuIGltYWdlLCB2aWRlbyBvciBjYW52YXNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeU1lZGlhT3B0aW9uc30gW29wdGlvbnNdIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbG9nXSBzaG93IGxvZyBtZXNzYWdlP1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9taXNlPFNwZWVkeU1lZGlhPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9hZChtZWRpYVNvdXJjZSwgb3B0aW9ucyA9IHt9LCBsb2cgPSB0cnVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFNwZWVkeU1lZGlhU291cmNlLmxvYWQobWVkaWFTb3VyY2UpLnRoZW4oc291cmNlID0+IHtcbiAgICAgICAgICAgIFV0aWxzLmFzc2VydChzb3VyY2Uud2lkdGggIT09IDAgJiYgc291cmNlLmhlaWdodCAhPT0gMCk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIHVzZXIgY291bGQgcGFzcyBhbiBpbnZhbGlkIGZvcm1hdCBpbiBvcHRpb25zIGlmIEltYWdlRm9ybWF0IGlzIG1hZGUgcHVibGljXG4gICAgICAgICAgICBjb25zdCBtZWRpYSA9IG5ldyBTcGVlZHlNZWRpYShQUklWQVRFX1RPS0VOLCBzb3VyY2UsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBzaG93IGxvZyBtZXNzYWdlXG4gICAgICAgICAgICBpZihsb2cpXG4gICAgICAgICAgICAgICAgVXRpbHMubG9nKGBMb2FkZWQgU3BlZWR5TWVkaWEgd2l0aCBhICR7bWVkaWFTb3VyY2V9LmApO1xuXG4gICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgcmV0dXJuIG1lZGlhO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgZWxlbWVudCAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpIGVuY2Fwc3VsYXRlZCBieSB0aGlzIFNwZWVkeU1lZGlhIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlNZWRpYVNvdXJjZU5hdGl2ZUVsZW1lbnR9IHRoZSBtZWRpYSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0IHNvdXJjZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlID8gdGhpcy5fc291cmNlLmRhdGEgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBtZWRpYSBhdHRhY2hlZCB0byB0aGlzIFNwZWVkeU1lZGlhIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtcImltYWdlXCIgfCBcInZpZGVvXCIgfCBcImNhbnZhc1wiIHwgXCJiaXRtYXBcIiB8IFwidW5rbm93blwifVxuICAgICAqL1xuICAgIGdldCB0eXBlKClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuaXNSZWxlYXNlZCgpKVxuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcblxuICAgICAgICBzd2l0Y2godGhpcy5fc291cmNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVkaWFUeXBlLkltYWdlOlxuICAgICAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuXG4gICAgICAgICAgICBjYXNlIE1lZGlhVHlwZS5WaWRlbzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZpZGVvJztcblxuICAgICAgICAgICAgY2FzZSBNZWRpYVR5cGUuQ2FudmFzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnY2FudmFzJztcblxuICAgICAgICAgICAgY2FzZSBNZWRpYVR5cGUuQml0bWFwOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYml0bWFwJztcblxuICAgICAgICAgICAgZGVmYXVsdDogLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuXG4gICAgICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBtZWRpYVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1lZGlhIHdpZHRoXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2Uud2lkdGggOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgbWVkaWFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtZWRpYSBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UuaGVpZ2h0IDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGlzIG1lZGlhLCBpbiBwaXhlbHNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5U2l6ZX1cbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlID8gbmV3IFNwZWVkeVNpemUodGhpcy5fc291cmNlLndpZHRoLCB0aGlzLl9zb3VyY2UuaGVpZ2h0KSA6IG5ldyBTcGVlZHlTaXplKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWFkLW9ubHkgb2JqZWN0IGZlYXR1cmluZyBhZHZhbmNlZCBvcHRpb25zXG4gICAgICogcmVsYXRlZCB0byB0aGlzIFNwZWVkeU1lZGlhIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlNZWRpYU9wdGlvbnN9XG4gICAgICovXG4gICAgZ2V0IG9wdGlvbnMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1lZGlhXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgcmVsZWFzZSgpXG4gICAge1xuICAgICAgICBpZighdGhpcy5pc1JlbGVhc2VkKCkpIHtcbiAgICAgICAgICAgIFV0aWxzLmxvZygnUmVsZWFzaW5nIFNwZWVkeU1lZGlhIG9iamVjdC4uLicpO1xuICAgICAgICAgICAgdGhpcy5fc291cmNlID0gdGhpcy5fc291cmNlLnJlbGVhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhcyB0aGlzIG1lZGlhIGJlZW4gcmVsZWFzZWQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWxlYXNlZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBTcGVlZHlNZWRpYSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYT59IGEgY2xvbmUgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgLy8gaGFzIHRoZSBtZWRpYSBiZWVuIHJlbGVhc2VkP1xuICAgICAgICBpZih0aGlzLmlzUmVsZWFzZWQoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoYENhbid0IGNsb25lIGEgU3BlZWR5TWVkaWEgdGhhdCBoYXMgYmVlbiByZWxlYXNlZGApO1xuXG4gICAgICAgIC8vIGNsb25lIHRoZSBvYmplY3RcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgU3BlZWR5TWVkaWEoUFJJVkFURV9UT0tFTiwgdGhpcy5fc291cmNlLCB0aGlzLl9vcHRpb25zKTtcblxuICAgICAgICAvLyBkb25lIVxuICAgICAgICByZXR1cm4gU3BlZWR5UHJvbWlzZS5yZXNvbHZlKGNsb25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgbWVkaWEgdG8gYW4gSW1hZ2VCaXRtYXBcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxJbWFnZUJpdG1hcD59XG4gICAgICovXG4gICAgdG9CaXRtYXAoKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5pc1JlbGVhc2VkKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKCdDYW5cXCd0IGNvbnZlcnQgU3BlZWR5TWVkaWEgdG8gSW1hZ2VCaXRtYXA6IHRoZSBtZWRpYSBoYXMgYmVlbiByZWxlYXNlZCcpO1xuICAgICAgICBlbHNlIGlmKCF0aGlzLl9zb3VyY2UuaXNMb2FkZWQoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoJ0NhblxcJ3QgY29udmVydCBTcGVlZHlNZWRpYSB0byBiaXRtYXA6IHRoZSBtZWRpYSBoYXNuXFwndCBiZWVuIGxvYWRlZCcpO1xuICAgICAgICBlbHNlIGlmKHRoaXMuX3NvdXJjZS50eXBlID09IE1lZGlhVHlwZS5CaXRtYXApXG4gICAgICAgICAgICByZXR1cm4gU3BlZWR5UHJvbWlzZS5yZXNvbHZlKHRoaXMuX3NvdXJjZS5kYXRhKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGVlZHlQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuX3NvdXJjZS5kYXRhKS50aGVuKHJlc29sdmUsIHJlamVjdCkpO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIHNwZWVkeS1uYW1lc3BhY2UuanNcbiAqIFN5bWJvbGl6ZXMgYSBuYW1lc3BhY2VcbiAqL1xuXG5pbXBvcnQgeyBBYnN0cmFjdE1ldGhvZEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJ1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IG5hbWVzcGFjZVxuICogQGFic3RyYWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlOYW1lc3BhY2VcbntcbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2VzIGNhbid0IGJlIGluc3RhbnRpYXRlZC5cbiAgICAgKiBPbmx5IHN0YXRpYyBtZXRob2RzIGFyZSBhbGxvd2VkLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEB0aHJvd3MgU3BlZWR5RXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICAvLyBvbmx5IHN0YXRpYyBtZXRob2RzIGFyZSBhbGxvd2VkXG4gICAgICAgIHRocm93IG5ldyBBYnN0cmFjdE1ldGhvZEVycm9yKGBOYW1lc3BhY2VzIGNhbid0IGJlIGluc3RhbnRpYXRlZGApO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzcGVlZHktcHJvbWlzZS5qc1xuICogU3BlZWR5IFByb21pc2VzOiBhIGZhc3QgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXNcbiAqL1xuXG5jb25zdCBQRU5ESU5HID0gMDtcbmNvbnN0IEZVTEZJTExFRCA9IDE7XG5jb25zdCBSRUpFQ1RFRCA9IDI7XG5cbmNvbnN0IFNVU1BFTkRfQVNZTkMgPSAxO1xuY29uc3QgYXNhcCA9ICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgIT09ICd1bmRlZmluZWQnICYmIHF1ZXVlTWljcm90YXNrKSB8fCAvLyBicm93c2Vyc1xuICAgICAgICAgICAgICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5uZXh0VGljaykgfHwgLy8gbm9kZS5qc1xuICAgICAgICAgICAgIChmID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZigpKSk7IC8vIG1vc3QgY29tcGF0aWJsZVxuXG4vKipcbiAqIFNwZWVkeVByb21pc2U6IFN1cGVyIEZhc3QgUHJvbWlzZXMuIFNwZWVkeVByb21pc2VzIGNhblxuICogaW50ZXJvcGVyYXRlIHdpdGggRVM2IFByb21pc2VzLiBUaGlzIGltcGxlbWVudGF0aW9uIGlzXG4gKiBiYXNlZCBvbiB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlQcm9taXNlXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGZ1bmN0aW9uKFQ9KTogdm9pZCwgZnVuY3Rpb24oRXJyb3IpOiB2b2lkKTogdm9pZH0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gUEVORElORztcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fb25GdWxmaWxsbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uUmVqZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSAwO1xuICAgICAgICB0aGlzWzBdID0gdGhpcztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9mbGFncyA9IDA7XG5cbiAgICAgICAgdGhpcy5fZnVsZmlsbCA9IHRoaXMuX2Z1bGZpbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVqZWN0ID0gdGhpcy5fcmVqZWN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSB0aGlzLl9yZXNvbHZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdElmQXN5bmMgPSB0aGlzLl9icm9hZGNhc3RJZkFzeW5jLmJpbmQodGhpcyk7XG5cbiAgICAgICAgY2FsbGJhY2sodGhpcy5fZnVsZmlsbCwgdGhpcy5fcmVqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBoYW5kbGVyc1xuICAgICAqIEB0ZW1wbGF0ZSBVLCBWPW5ldmVyXG4gICAgICogQHBhcmFtIHtudWxsfHVuZGVmaW5lZHwoZnVuY3Rpb24oVCk6IFV8UHJvbWlzZUxpa2U8VT58U3BlZWR5UHJvbWlzZTxVPil9IG9uRnVsZmlsbG1lbnQgY2FsbGVkIHdoZW4gdGhlIFNwZWVkeVByb21pc2UgaXMgZnVsZmlsbGVkXG4gICAgICogQHBhcmFtIHtudWxsfHVuZGVmaW5lZHwoZnVuY3Rpb24oRXJyb3IpOiBWfFByb21pc2VMaWtlPFY+fFNwZWVkeVByb21pc2U8Vj4pfSBbb25SZWplY3Rpb25dIGNhbGxlZCB3aGVuIHRoZSBTcGVlZHlQcm9taXNlIGlzIHJlamVjdGVkXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8VT59XG4gICAgICovXG4gICAgdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbiA9IG51bGwpXG4gICAge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBTcGVlZHlQcm9taXNlKHRoaXMuX25vcCk7XG4gICAgICAgIGNoaWxkLl9vbkZ1bGZpbGxtZW50ID0gdHlwZW9mIG9uRnVsZmlsbG1lbnQgPT09ICdmdW5jdGlvbicgJiYgb25GdWxmaWxsbWVudDtcbiAgICAgICAgY2hpbGQuX29uUmVqZWN0aW9uID0gdHlwZW9mIG9uUmVqZWN0aW9uID09PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0aW9uO1xuICAgICAgICBjaGlsZC5fcGFyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzW3RoaXMuX2NoaWxkcmVuKytdID0gY2hpbGQ7IC8vIGF0dGFjaCBjaGlsZFxuICAgICAgICB0aGlzLl9mbGFncyAmPSB+U1VTUEVORF9BU1lOQzsgLy8gcmVzdG9yZSB0aGUgYXN5bmMgYmVoYXZpb3JcbiAgICAgICAgdGhpcy5fbm90aWZ5KCk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHVwIHJlamVjdGlvbiBoYW5kbGVyXG4gICAgICogQHRlbXBsYXRlIFUsIFY9bmV2ZXJcbiAgICAgKiBAcGFyYW0ge251bGx8dW5kZWZpbmVkfChmdW5jdGlvbihFcnJvcik6IFZ8UHJvbWlzZUxpa2U8Vj58U3BlZWR5UHJvbWlzZTxWPil9IFtvblJlamVjdGlvbl0gY2FsbGVkIHdoZW4gdGhlIFNwZWVkeVByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxWPn1cbiAgICAgKi9cbiAgICBjYXRjaChvblJlamVjdGlvbilcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBjYWxsYmFjayB3aGVuIHRoZSBwcm9taXNlIGlzIHNldHRsZWRcbiAgICAgKiAoaS5lLiwgZnVsZmlsbGVkIG9yIHJlamVjdGVkKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gb25GaW5hbGx5XG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8VD59XG4gICAgICovXG4gICAgZmluYWxseShvbkZpbmFsbHkpXG4gICAge1xuICAgICAgICBjb25zdCBmbiA9IHZhbCA9PiB7IG9uRmluYWxseSgpOyByZXR1cm4gdmFsOyB9O1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZuLCBmbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIGNvbXB1dGF0aW9uIGltbWVkaWF0ZWx5LCBzeW5jaHJvbm91c2x5LlxuICAgICAqIENhbid0IGFmZm9yZCB0byBzcGVuZCBhbnkgdGltZSBhdCBhbGwgd2FpdGluZyBmb3IgbWljcm8tdGFza3MsIGV0Yy5cbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxUPn0gdGhpc1xuICAgICAqL1xuICAgIHR1cmJvY2hhcmdlKClcbiAgICB7XG4gICAgICAgIGxldCBteSA9IHRoaXM7XG5cbiAgICAgICAgLy8gc3VzcGVuZCB0aGUgYXN5bmMgYmVoYXZpb3JcbiAgICAgICAgdGhpcy5fZmxhZ3MgfD0gU1VTUEVORF9BU1lOQztcbiAgICAgICAgd2hpbGUobXkuX3BhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBteSA9IG15Ll9wYXJlbnQ7XG4gICAgICAgICAgICBteS5fZmxhZ3MgfD0gU1VTUEVORF9BU1lOQztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGlmeSB0aGUgY2hpbGRyZW4gb2YgdGhlIHJvb3RcbiAgICAgICAgbXkuX25vdGlmeSgpOyAvLyB3aWxsIGJlIHN5bmNocm9ub3VzXG5cbiAgICAgICAgLy8gcmV0dXJuIHRoaXMgU3BlZWR5UHJvbWlzZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKVxuICAgIHtcbiAgICAgICAgc3dpdGNoKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFBFTkRJTkc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBTcGVlZHlQcm9taXNlIHsgPHBlbmRpbmc+IH1gO1xuICAgICAgICAgICAgY2FzZSBGVUxGSUxMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBTcGVlZHlQcm9taXNlIHsgPGZ1bGZpbGxlZD4gJHt0aGlzLl92YWx1ZX0gfWA7XG4gICAgICAgICAgICBjYXNlIFJFSkVDVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiBgU3BlZWR5UHJvbWlzZSB7IDxyZWplY3RlZD4gJHt0aGlzLl92YWx1ZX0gfWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN5bWJvbC50b1N0cmluZ1RhZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKClcbiAgICB7XG4gICAgICAgIHJldHVybiAnU3BlZWR5UHJvbWlzZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlc29sdmVkIFNwZWVkeVByb21pc2VcbiAgICAgKiBAdGVtcGxhdGUgVVxuICAgICAqIEBwYXJhbSB7VX0gW3ZhbHVlXVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9taXNlPFU+fVxuICAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlKHZhbHVlKVxuICAgIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBTcGVlZHlQcm9taXNlKHRoaXMuX3Nub3ApO1xuXG4gICAgICAgIGlmKCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICd0aGVuJyBpbiB2YWx1ZSkgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAndGhlbicgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAvLyByZXNvbHZlIGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZ1bGZpbGwgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlamVjdGVkIFNwZWVkeVByb21pc2VcbiAgICAgKiBAdGVtcGxhdGUgVVxuICAgICAqIEBwYXJhbSB7RXJyb3J9IHJlYXNvblxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9taXNlPFU+fVxuICAgICAqL1xuICAgIHN0YXRpYyByZWplY3QocmVhc29uKVxuICAgIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBTcGVlZHlQcm9taXNlKHRoaXMuX3Nub3ApO1xuICAgICAgICBwcm9taXNlLl92YWx1ZSA9IHJlYXNvbjtcbiAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNwZWVkeVByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheVxuICAgICAqIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgdGhlIGlucHV0IHByb21pc2VzL3ZhbHVlcyxcbiAgICAgKiBpbiB0aGVpciBnaXZlbiBvcmRlci4gVGhlIHJldHVybmVkIFNwZWVkeVByb21pc2Ugd2lsbFxuICAgICAqIHJlc29sdmUgaWYgYWxsIGlucHV0IHByb21pc2VzIHJlc29sdmUsIG9yIHJlamVjdCBpZlxuICAgICAqIGFueSBpbnB1dCBwcm9taXNlIHJlamVjdHMuXG4gICAgICogQHRlbXBsYXRlIFVcbiAgICAgKiBAcGFyYW0ge0l0ZXJhYmxlPFU+fEl0ZXJhYmxlPFNwZWVkeVByb21pc2U8VT4+fEl0ZXJhYmxlPFByb21pc2U8VT4+fSBpdGVyYWJsZSBlLmcuLCBhIFNwZWVkeVByb21pc2VbXSwgYSB0aGVuYWJsZVtdXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8VVtdPn1cbiAgICAgKlxuICAgICAqIEZJWE1FIGl0ZXJhYmxlcyBuZWVkIG5vdCBiZSBhbGwgPFU+XG4gICAgICovXG4gICAgc3RhdGljIGFsbChpdGVyYWJsZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBnZXQgZWxlbWVudHNcbiAgICAgICAgICAgIGZvcihjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKVxuICAgICAgICAgICAgICAgIGlucHV0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIHJlc29sdmUgc3luY2hyb25vdXNseSBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHNcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmKGxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXNvbHZlIGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICBsZXQgY291bnRlciA9IGxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc29sdmUgPSBpID0+ICh2YWwgPT4geyBvdXRwdXRbaV0gPSB2YWw7IGlmKDAgPT0gLS1jb3VudGVyKSByZXNvbHZlKG91dHB1dCk7IH0pO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGlucHV0W2ldO1xuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQuX19wcm90b19fID09PSBTcGVlZHlQcm9taXNlLnByb3RvdHlwZSB8fCBlbGVtZW50Ll9fcHJvdG9fXyA9PT0gUHJvbWlzZS5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudGhlbihwYXJ0aWFsUmVzb2x2ZShpKSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIFNwZWVkeVByb21pc2UucmVzb2x2ZShlbGVtZW50KS50aGVuKHBhcnRpYWxSZXNvbHZlKGkpLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGdldHMgZnVsZmlsbGVkIG9yIHJlamVjdGVkIGFzIHNvb25cbiAgICAgKiBhcyB0aGUgZmlyc3QgcHJvbWlzZSBpbiB0aGUgaXRlcmFibGUgZ2V0cyBmdWxmaWxsZWQgb3JcbiAgICAgKiByZWplY3RlZCAod2l0aCBpdHMgdmFsdWUvcmVhc29uKS5cbiAgICAgKiBAdGVtcGxhdGUgVVxuICAgICAqIEBwYXJhbSB7SXRlcmFibGU8VT58SXRlcmFibGU8U3BlZWR5UHJvbWlzZTxVPj58SXRlcmFibGU8UHJvbWlzZTxVPj59IGl0ZXJhYmxlIGUuZy4sIGEgU3BlZWR5UHJvbWlzZVtdLCBhIHRoZW5hYmxlW11cbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxVPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgcmFjZShpdGVyYWJsZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBnZXQgZWxlbWVudHNcbiAgICAgICAgICAgIGZvcihjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKVxuICAgICAgICAgICAgICAgIGlucHV0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBpdGVyYWJsZSBpcyBlbXB0eSwgdGhlIHByb21pc2VcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgcGVuZGluZyBmb3JldmVyLi4uXG5cbiAgICAgICAgICAgIC8vIHJlc29sdmUgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50Ll9fcHJvdG9fXyA9PT0gU3BlZWR5UHJvbWlzZS5wcm90b3R5cGUgfHwgZWxlbWVudC5fX3Byb3RvX18gPT09IFByb21pc2UucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIFNwZWVkeVByb21pc2UucmVzb2x2ZShlbGVtZW50KS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bGZpbGwgdGhpcyBwcm9taXNlIHdpdGggYSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICAgKi9cbiAgICBfZnVsZmlsbCh2YWx1ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKEZVTEZJTExFRCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlamVjdCB0aGlzIHByb21pc2Ugd2l0aCBhIHJlYXNvblxuICAgICAqIEBwYXJhbSB7RXJyb3J9IHJlYXNvblxuICAgICAqL1xuICAgIF9yZWplY3QocmVhc29uKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoUkVKRUNURUQsIHJlYXNvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdGF0ZSBhbmQgdGhlIHZhbHVlIG9mIHRoaXMgcHJvbWlzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7VHxFcnJvcn0gdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0U3RhdGUoc3RhdGUsIHZhbHVlKVxuICAgIHtcbiAgICAgICAgLy8gdGhlIHByb21pc2UgaXMgYWxyZWFkeSBmdWxmaWxsZWQgb3IgcmVqZWN0ZWRcbiAgICAgICAgaWYodGhpcy5fc3RhdGUgIT0gUEVORElORylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBzZXQgdGhlIG5ldyBzdGF0ZVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgbXkgY2hpbGRyZW4gdGhhdCB0aGlzIHByb21pc2UgaXMgbm9cbiAgICAgKiBsb25nZXIgcGVuZGluZy4gVGhpcyBpcyBhbiBhc3luYyBvcGVyYXRpb246XG4gICAgICogbXkgY2hpbGRlbiB3aWxsIGJlIG5vdGlmaWVkIFwiYXMgc29vblxuICAgICAqIGFzIHBvc3NpYmxlXCIgKGl0IHdpbGwgYmUgc2NoZWR1bGVkKS5cbiAgICAgKiBXZSBtYXkgZm9yY2UgdGhpcyB0byBiZSBzeW5jaHJvbm91cywgdGhvdWdoXG4gICAgICovXG4gICAgX25vdGlmeSgpXG4gICAge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmKHRoaXMuX3N0YXRlID09IFBFTkRJTkcpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gaGF2ZSB3ZSB0dXJib2NoYXJnZWQgdGhpcyBwcm9taXNlP1xuICAgICAgICBpZih0aGlzLl9mbGFncyAmIFNVU1BFTkRfQVNZTkMpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jyb2FkY2FzdCgpOyAvLyBleGVjdXRlIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluc3RhbGwgYSB0aW1lciAoZGVmYXVsdCBiZWhhdmlvcilcbiAgICAgICAgYXNhcCh0aGlzLl9icm9hZGNhc3RJZkFzeW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kXG4gICAgICovXG4gICAgX2Jyb2FkY2FzdElmQXN5bmMoKVxuICAgIHtcbiAgICAgICAgLy8gd2UgbWF5IGhhdmUgaW5zdGFsbGVkIGEgdGltZXIgYXQgc29tZVxuICAgICAgICAvLyBwb2ludCwgYnV0IHR1cmJvY2hhcmdlZCB0aGUgcHJvbWlzZSBsYXRlclxuICAgICAgICBpZighKHRoaXMuX2ZsYWdzICYgU1VTUEVORF9BU1lOQykpXG4gICAgICAgICAgICB0aGlzLl9icm9hZGNhc3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxsIG15IGNoaWxkcmVuIHRoYXQgdGhpcyBwcm9taXNlXG4gICAgICogaXMgZWl0aGVyIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAgICAgKiBUaGlzIGlzIGEgc3luY2hyb25vdXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgX2Jyb2FkY2FzdCgpXG4gICAge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICAgIGlmKHN0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2hpbGQuX29uRnVsZmlsbG1lbnQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2sgIT09IGNoaWxkLl9ub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fcmVzb2x2ZShjYWxsYmFjayh0aGlzLl92YWx1ZSkpOyAvLyBwcm9taXNlIHJlc29sdXRpb24gcHJvY2VkdXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX29uRnVsZmlsbG1lbnQgPSBjaGlsZC5fbm9wOyAvLyB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fZnVsZmlsbCh0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2hpbGQuX29uUmVqZWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrICE9PSBjaGlsZC5fbm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX3Jlc29sdmUoY2FsbGJhY2sodGhpcy5fdmFsdWUpKTsgLy8gcHJvbWlzZSByZXNvbHV0aW9uIHByb2NlZHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl9vblJlamVjdGlvbiA9IGNoaWxkLl9ub3A7IC8vIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl9yZWplY3QodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLl9yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVxuICAgICAqIGJhc2VkIG9uIHRoZSBQcm9taXNlcy9BKyBzcGVjXG4gICAgICogQHBhcmFtIHtUfSB4XG4gICAgICovXG4gICAgX3Jlc29sdmUoeClcbiAgICB7XG4gICAgICAgIGlmKCh0eXBlb2YgeCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHggIT09ICdmdW5jdGlvbicpIHx8ICh4ID09PSBudWxsKSkgeyAvLyBpZih4ICE9PSBPYmplY3QoeCkpXG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsKHgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoeCA9PT0gdGhpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gQ2lyY3VsYXIgcmVmZXJlbmNlXG5cbiAgICAgICAgaWYoeC5fX3Byb3RvX18gPT09IFNwZWVkeVByb21pc2UucHJvdG90eXBlIHx8IHguX19wcm90b19fID09PSBQcm9taXNlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgeC50aGVuKHRoaXMuX3Jlc29sdmUsIHRoaXMuX3JlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGhlbiA9IHgudGhlbjtcbiAgICAgICAgICAgIGlmKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc29sdmUgPSB0aGlzLl9yZXNvbHZlLCByZWplY3QgPSB0aGlzLl9yZWplY3Q7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0+IHsgcmVzb2x2ZSh5KTsgcmVzb2x2ZSA9IHJlamVjdCA9IHRoaXMuX25vcDsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPT4geyByZWplY3Qocik7IHJlc29sdmUgPSByZWplY3QgPSB0aGlzLl9ub3A7IH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICBpZihyZXNvbHZlICE9PSB0aGlzLl9ub3AgJiYgcmVqZWN0ICE9PSB0aGlzLl9ub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsZmlsbCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOby1vcGVyYXRpb25cbiAgICAgKi9cbiAgICBfbm9wKClcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIG5vLW9wZXJhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBfc25vcCgpXG4gICAge1xuICAgIH1cbn1cblxuLy9tb2R1bGUuZXhwb3J0cyA9IHsgU3BlZWR5UHJvbWlzZSB9O1xuXG4vKlxuLy8gVW5jb21tZW50IHRvIHRlc3QgcGVyZm9ybWFuY2Ugd2l0aCByZWd1bGFyIFByb21pc2VzXG5tb2R1bGUuZXhwb3J0cyA9IHsgU3BlZWR5UHJvbWlzZTogUHJvbWlzZSB9O1xuUHJvbWlzZS5wcm90b3R5cGUudHVyYm9jaGFyZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfTtcbiovXG4iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzcGVlZHktc2l6ZS5qc1xuICogU2l6ZSBvZiBhIHJlY3RhbmdsZVxuICovXG5cbi8qKlxuICogU2l6ZSBvZiBhIHJlY3RhbmdsZVxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5U2l6ZVxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIG5vbi1uZWdhdGl2ZSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IG5vbi1uZWdhdGl2ZSBudW1iZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IHdpZHRoICovXG4gICAgICAgIHRoaXMuX3dpZHRoID0gTWF0aC5tYXgoMCwgK3dpZHRoKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gaGVpZ2h0ICovXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IE1hdGgubWF4KDAsICtoZWlnaHQpO1xuICAgIH1cblxuXG5cbiAgICAvL1xuICAgIC8vID09PT09IE1FVEhPRFMgPT09PT1cbiAgICAvL1xuXG4gICAgLyoqXG4gICAgICogV2lkdGhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgodmFsdWUpXG4gICAge1xuICAgICAgICB0aGlzLl93aWR0aCA9IE1hdGgubWF4KDAsICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG4gICAgc2V0IGhlaWdodCh2YWx1ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IE1hdGgubWF4KDAsICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKClcbiAgICB7XG4gICAgICAgIHJldHVybiBgU3BlZWR5U2l6ZSgke3RoaXMud2lkdGh9LCAke3RoaXMuaGVpZ2h0fSlgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgc2l6ZSBlcXVhbCB0byBhbm90aGVyU2l6ZT9cbiAgICAgKiBAcGFyYW0ge1NwZWVkeVNpemV9IGFub3RoZXJTaXplXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZXF1YWxzKGFub3RoZXJTaXplKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IGFub3RoZXJTaXplLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBhbm90aGVyU2l6ZS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFyZWEgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYXJlYSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBmaWx0ZXJzLmpzXG4gKiBJbWFnZSBmaWx0ZXJpbmcgb24gdGhlIEdQVVxuICovXG5cbmltcG9ydCB7IFNwZWVkeUdQVSB9IGZyb20gJy4uL3NwZWVkeS1ncHUnO1xuaW1wb3J0IHsgU3BlZWR5UHJvZ3JhbUdyb3VwIH0gZnJvbSAnLi4vc3BlZWR5LXByb2dyYW0tZ3JvdXAnO1xuaW1wb3J0IHsgaW1wb3J0U2hhZGVyIH0gZnJvbSAnLi4vc2hhZGVyLWRlY2xhcmF0aW9uJztcbmltcG9ydCB7IGNvbnZYLCBjb252WSB9IGZyb20gJy4uL3NoYWRlcnMvZmlsdGVycy9jb252b2x1dGlvbic7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcblxuXG5cbi8vXG4vLyBTaGFkZXJzXG4vL1xuXG4vLyBDb252ZXJ0IHRvIGdyZXlzY2FsZVxuY29uc3QgcmdiMmdyZXkgPSBpbXBvcnRTaGFkZXIoJ2ZpbHRlcnMvcmdiMmdyZXkuZ2xzbCcpXG4gICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2ltYWdlJyk7XG5cbi8vIENvbnZvbHV0aW9uXG5jb25zdCBjb252b2x1dGlvbiA9IFszLCA1LCA3XS5yZWR1Y2UoKG9iaiwga3NpemUpID0+ICgob2JqW2tzaXplXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRTaGFkZXIoJ2ZpbHRlcnMvY29udm9sdXRpb24yZC5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ0tFUk5FTF9TSVpFX1NRVUFSRUQnOiBrc2l6ZSAqIGtzaXplIH0pXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdpbWFnZScsICdrZXJuZWwnKVxuICAgICAgICAgICAgICAgICAgICApLCBvYmopLCB7fSk7XG5cbi8vIFNlcGFyYWJsZSBjb252b2x1dGlvblxuY29uc3QgY29udm9sdXRpb25YID0gWzMsIDUsIDcsIDksIDExLCAxMywgMTVdLnJlZHVjZSgob2JqLCBrc2l6ZSkgPT4gKChvYmpba3NpemVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRTaGFkZXIoJ2ZpbHRlcnMvY29udm9sdXRpb24xZC5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdLRVJORUxfU0laRSc6IGtzaXplLCAnQVhJUyc6IDAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdpbWFnZScsICdrZXJuZWwnKVxuICAgICAgICAgICAgICAgICAgICAgKSwgb2JqKSwge30pO1xuXG5jb25zdCBjb252b2x1dGlvblkgPSBbMywgNSwgNywgOSwgMTEsIDEzLCAxNV0ucmVkdWNlKChvYmosIGtzaXplKSA9PiAoKG9ialtrc2l6ZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFNoYWRlcignZmlsdGVycy9jb252b2x1dGlvbjFkLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ0tFUk5FTF9TSVpFJzoga3NpemUsICdBWElTJzogMSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2ltYWdlJywgJ2tlcm5lbCcpXG4gICAgICAgICAgICAgICAgICAgICApLCBvYmopLCB7fSk7XG4vLyBNZWRpYW4gZmlsdGVyXG5jb25zdCBtZWRpYW4gPSBbMywgNSwgN10ucmVkdWNlKChvYmosIGtzaXplKSA9PiAoKG9ialtrc2l6ZV0gPVxuICAgICAgICAgICAgICAgICAgIGltcG9ydFNoYWRlcignZmlsdGVycy9mYXN0LW1lZGlhbi5nbHNsJylcbiAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdLRVJORUxfU0laRSc6IGtzaXplIH0pXG4gICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnaW1hZ2UnKVxuICAgICAgICAgICAgICAgKSwgb2JqKSwge30pO1xuXG4vLyBOb3JtYWxpemUgaW1hZ2VcbmNvbnN0IG5vcm1hbGl6ZUdyZXlzY2FsZSA9IGltcG9ydFNoYWRlcignZmlsdGVycy9ub3JtYWxpemUtaW1hZ2UuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdHUkVZU0NBTEUnOiAxIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdtaW5tYXgyZCcsICdtaW5WYWx1ZScsICdtYXhWYWx1ZScpO1xuXG5jb25zdCBub3JtYWxpemVDb2xvcmVkID0gaW1wb3J0U2hhZGVyKCdmaWx0ZXJzL25vcm1hbGl6ZS1pbWFnZS5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdHUkVZU0NBTEUnOiAwIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnbWlubWF4MmRSR0InLCAnbWluVmFsdWUnLCAnbWF4VmFsdWUnKTtcblxuLy8gTmlnaHR2aXNpb25cbmNvbnN0IG5pZ2h0dmlzaW9uID0gaW1wb3J0U2hhZGVyKCdmaWx0ZXJzL25pZ2h0dmlzaW9uLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdHUkVZU0NBTEUnOiAwIH0pXG4gICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2ltYWdlJywgJ2lsbHVtaW5hdGlvbk1hcCcsICdnYWluJywgJ29mZnNldCcsICdkZWNheScpO1xuXG5jb25zdCBuaWdodHZpc2lvbkdyZXlzY2FsZSA9IGltcG9ydFNoYWRlcignZmlsdGVycy9uaWdodHZpc2lvbi5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnR1JFWVNDQUxFJzogMSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdpbWFnZScsICdpbGx1bWluYXRpb25NYXAnLCAnZ2FpbicsICdvZmZzZXQnLCAnZGVjYXknKTtcblxuXG5cbi8vXG4vLyBVdGlsaXRpZXNcbi8vXG5cbi8vIEhhbmR5IGNvbnZlcnNpb24gZm9yIEdhdXNzaWFuIGZpbHRlcnNcbi8vIChzeW1tZXRyaWMga2VybmVsLCBhcHByb3guIHplcm8gYWZ0ZXIgMypzaWdtYSlcbmNvbnN0IGtzaXplMnNpZ21hID0ga3NpemUgPT4gTWF0aC5tYXgoMS4wLCBrc2l6ZSAvIDYuMCk7XG5cbi8vIEdlbmVyYXRlIGEgMUQgR2F1c3NpYW4ga2VybmVsXG5jb25zdCBnYXVzc2lhbiA9IGtzaXplID0+IFV0aWxzLmdhdXNzaWFuS2VybmVsKGtzaXplMnNpZ21hKGtzaXplKSwga3NpemUpO1xuXG4vLyBHZW5lcmF0ZSBhIDFEIEJveCBmaWx0ZXJcbmNvbnN0IGJveCA9IGtzaXplID0+IChuZXcgQXJyYXkoa3NpemUpKS5maWxsKDEuMCAvIGtzaXplKTtcblxuXG5cbi8qKlxuICogU3BlZWR5UHJvZ3JhbUdyb3VwRmlsdGVyc1xuICogSW1hZ2UgZmlsdGVyaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlQcm9ncmFtR3JvdXBGaWx0ZXJzIGV4dGVuZHMgU3BlZWR5UHJvZ3JhbUdyb3VwXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3B1KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZ3B1KTtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLy8gY29udmVydCB0byBncmV5c2NhbGVcbiAgICAgICAgICAgIC5kZWNsYXJlKCdyZ2IyZ3JleScsIHJnYjJncmV5KVxuXG4gICAgICAgICAgICAvLyBtZWRpYW4gZmlsdGVyc1xuICAgICAgICAgICAgLmRlY2xhcmUoJ21lZGlhbjMnLCBtZWRpYW5bM10pIC8vIDN4MyB3aW5kb3dcbiAgICAgICAgICAgIC5kZWNsYXJlKCdtZWRpYW41JywgbWVkaWFuWzVdKSAvLyA1eDUgd2luZG93XG4gICAgICAgICAgICAuZGVjbGFyZSgnbWVkaWFuNycsIG1lZGlhbls3XSkgLy8gN3g3IHdpbmRvd1xuXG4gICAgICAgICAgICAvLyAyRCBjb252b2x1dGlvblxuICAgICAgICAgICAgLmRlY2xhcmUoJ2NvbnZvbHV0aW9uMycsIGNvbnZvbHV0aW9uWzNdKSAvLyAzeDMga2VybmVsXG4gICAgICAgICAgICAuZGVjbGFyZSgnY29udm9sdXRpb241JywgY29udm9sdXRpb25bNV0pIC8vIDV4NSBrZXJuZWxcbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb252b2x1dGlvbjcnLCBjb252b2x1dGlvbls3XSkgLy8gN3g3IGtlcm5lbFxuXG4gICAgICAgICAgICAvLyAxRCBzZXBhcmFibGUgY29udm9sdXRpb25cbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb252b2x1dGlvbjN4JywgY29udm9sdXRpb25YWzNdKSAvLyAxeDMga2VybmVsXG4gICAgICAgICAgICAuZGVjbGFyZSgnY29udm9sdXRpb24zeScsIGNvbnZvbHV0aW9uWVszXSkgLy8gM3gxIGtlcm5lbFxuICAgICAgICAgICAgLmRlY2xhcmUoJ2NvbnZvbHV0aW9uNXgnLCBjb252b2x1dGlvblhbNV0pIC8vIDF4NSBrZXJuZWxcbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb252b2x1dGlvbjV5JywgY29udm9sdXRpb25ZWzVdKSAvLyA1eDEga2VybmVsXG4gICAgICAgICAgICAuZGVjbGFyZSgnY29udm9sdXRpb243eCcsIGNvbnZvbHV0aW9uWFs3XSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb252b2x1dGlvbjd5JywgY29udm9sdXRpb25ZWzddKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2NvbnZvbHV0aW9uOXgnLCBjb252b2x1dGlvblhbOV0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnY29udm9sdXRpb245eScsIGNvbnZvbHV0aW9uWVs5XSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb252b2x1dGlvbjExeCcsIGNvbnZvbHV0aW9uWFsxMV0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnY29udm9sdXRpb24xMXknLCBjb252b2x1dGlvbllbMTFdKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2NvbnZvbHV0aW9uMTN4JywgY29udm9sdXRpb25YWzEzXSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb252b2x1dGlvbjEzeScsIGNvbnZvbHV0aW9uWVsxM10pXG4gICAgICAgICAgICAuZGVjbGFyZSgnY29udm9sdXRpb24xNXgnLCBjb252b2x1dGlvblhbMTVdKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2NvbnZvbHV0aW9uMTV5JywgY29udm9sdXRpb25ZWzE1XSlcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGltYWdlXG4gICAgICAgICAgICAuZGVjbGFyZSgnbm9ybWFsaXplR3JleXNjYWxlJywgbm9ybWFsaXplR3JleXNjYWxlKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ25vcm1hbGl6ZUNvbG9yZWQnLCBub3JtYWxpemVDb2xvcmVkKVxuXG4gICAgICAgICAgICAvLyBuaWdodHZpc2lvblxuICAgICAgICAgICAgLmRlY2xhcmUoJ25pZ2h0dmlzaW9uJywgbmlnaHR2aXNpb24pXG4gICAgICAgICAgICAuZGVjbGFyZSgnbmlnaHR2aXNpb25HcmV5c2NhbGUnLCBuaWdodHZpc2lvbkdyZXlzY2FsZSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdpbGx1bWluYXRpb25NYXBMb1gnLCBjb252WChVdGlscy5nYXVzc2lhbktlcm5lbCg4MCwgMzEpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdpbGx1bWluYXRpb25NYXBMb1knLCBjb252WShVdGlscy5nYXVzc2lhbktlcm5lbCg4MCwgMzEpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdpbGx1bWluYXRpb25NYXBYJywgY29udlgoVXRpbHMuZ2F1c3NpYW5LZXJuZWwoODAsIDYzKSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnaWxsdW1pbmF0aW9uTWFwWScsIGNvbnZZKFV0aWxzLmdhdXNzaWFuS2VybmVsKDgwLCA2MykpKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2lsbHVtaW5hdGlvbk1hcEhpWCcsIGNvbnZYKFV0aWxzLmdhdXNzaWFuS2VybmVsKDgwLCAyNTUpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdpbGx1bWluYXRpb25NYXBIaVknLCBjb252WShVdGlscy5nYXVzc2lhbktlcm5lbCg4MCwgMjU1KSkpXG5cbiAgICAgICAgICAgIC8vIGdhdXNzaWFuOiBzZXBhcmFibGUga2VybmVsc1xuICAgICAgICAgICAgLy8gc2VlIGFsc286IGh0dHA6Ly9kZXYudGhlb21hZGVyLmNvbS9nYXVzc2lhbi1rZXJuZWwtY2FsY3VsYXRvci9cbiAgICAgICAgICAgIC5kZWNsYXJlKCdnYXVzc2lhbjN4JywgY29udlgoWyAwLjI1LCAwLjUsIDAuMjUgXSkpIC8vIHNpZ21hIH4gMS4wXG4gICAgICAgICAgICAuZGVjbGFyZSgnZ2F1c3NpYW4zeScsIGNvbnZZKFsgMC4yNSwgMC41LCAwLjI1IF0pKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2dhdXNzaWFuNXgnLCBjb252WChbIDAuMDUsIDAuMjUsIDAuNCwgMC4yNSwgMC4wNSBdKSkgLy8gc2lnbWEgfiAxLjBcbiAgICAgICAgICAgIC5kZWNsYXJlKCdnYXVzc2lhbjV5JywgY29udlkoWyAwLjA1LCAwLjI1LCAwLjQsIDAuMjUsIDAuMDUgXSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnZ2F1c3NpYW43eCcsIGNvbnZYKGdhdXNzaWFuKDcpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdnYXVzc2lhbjd5JywgY29udlkoZ2F1c3NpYW4oNykpKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2dhdXNzaWFuOXgnLCBjb252WChnYXVzc2lhbig5KSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnZ2F1c3NpYW45eScsIGNvbnZZKGdhdXNzaWFuKDkpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdnYXVzc2lhbjExeCcsIGNvbnZYKGdhdXNzaWFuKDExKSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnZ2F1c3NpYW4xMXknLCBjb252WShnYXVzc2lhbigxMSkpKVxuXG4gICAgICAgICAgICAvLyBib3ggZmlsdGVyOiBzZXBhcmFibGUga2VybmVsc1xuICAgICAgICAgICAgLmRlY2xhcmUoJ2JveDN4JywgY29udlgoYm94KDMpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdib3gzeScsIGNvbnZZKGJveCgzKSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnYm94NXgnLCBjb252WChib3goNSkpKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2JveDV5JywgY29udlkoYm94KDUpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdib3g3eCcsIGNvbnZYKGJveCg3KSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnYm94N3knLCBjb252WShib3goNykpKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2JveDl4JywgY29udlgoYm94KDkpKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdib3g5eScsIGNvbnZZKGJveCg5KSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnYm94MTF4JywgY29udlgoYm94KDExKSkpXG4gICAgICAgICAgICAuZGVjbGFyZSgnYm94MTF5JywgY29udlkoYm94KDExKSkpXG4gICAgICAgIDtcbiAgICB9XG59XG4iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBrZXlwb2ludHMuanNcbiAqIEZhY2FkZSBmb3IgdmFyaW91cyBrZXlwb2ludCBkZXRlY3Rpb24gYWxnb3JpdGhtc1xuICovXG5cbmltcG9ydCB7IFNwZWVkeUdQVSB9IGZyb20gJy4uL3NwZWVkeS1ncHUnO1xuaW1wb3J0IHsgU3BlZWR5UHJvZ3JhbUdyb3VwIH0gZnJvbSAnLi4vc3BlZWR5LXByb2dyYW0tZ3JvdXAnO1xuaW1wb3J0IHsgU3BlZWR5VGV4dHVyZSwgU3BlZWR5RHJhd2FibGVUZXh0dXJlIH0gZnJvbSAnLi4vc3BlZWR5LXRleHR1cmUnO1xuaW1wb3J0IHsgTFNIX1NFUVVFTkNFX0NPVU5ULCBMU0hfU0VRVUVOQ0VfTUFYTEVOLCBMU0hfQUNDRVBUQUJMRV9ERVNDUklQVE9SX1NJWkVTLCBMU0hfQUNDRVBUQUJMRV9IQVNIX1NJWkVTIH0gZnJvbSAnLi4vc3BlZWR5LWxzaCc7XG5pbXBvcnQgeyBpbXBvcnRTaGFkZXIgfSBmcm9tICcuLi9zaGFkZXItZGVjbGFyYXRpb24nO1xuXG5cbi8vIEZBU1QgY29ybmVyIGRldGVjdG9yXG5jb25zdCBmYXN0OV8xNiA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2Zhc3QuZ2xzbCcsICdrZXlwb2ludHMvZmFzdC52cy5nbHNsJylcbiAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnRkFTVF9UWVBFJzogOTE2IH0pXG4gICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2Nvcm5lcnMnLCAncHlyYW1pZCcsICdsb2QnLCAndGhyZXNob2xkJyk7XG5cbi8vIEhhcnJpcyBjb3JuZXIgZGV0ZWN0b3JcbmNvbnN0IGhhcnJpcyA9IFsxLCAzLCA1LCA3XS5yZWR1Y2UoKG9iaiwgd2luKSA9PiAoKG9ialt3aW5dID1cbiAgICAgICAgICAgICAgICAgICBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9oYXJyaXMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnV0lORE9XX1NJWkUnOiB3aW4gfSlcbiAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdjb3JuZXJzJywgJ3B5cmFtaWQnLCAnZGVyaXZhdGl2ZXMnLCAnbG9kJywgJ2xvZFN0ZXAnLCAnZ2F1c3NpYW4nKVxuICAgICAgICAgICAgICAgKSwgb2JqKSwge30pO1xuXG5jb25zdCBoYXJyaXNTY29yZUZpbmRNYXggPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9zY29yZS1maW5kbWF4Lmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnY29ybmVycycsICdpdGVyYXRpb25OdW1iZXInKTtcblxuY29uc3QgaGFycmlzU2NvcmVDdXRvZmYgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9oYXJyaXMtY3V0b2ZmLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdjb3JuZXJzJywgJ21heFNjb3JlJywgJ3F1YWxpdHknKTtcblxuLy8gU3VicGl4ZWwgcmVmaW5lbWVudFxuY29uc3Qgc3VicGl4ZWxRdWFkcmF0aWMxZCA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL3N1YnBpeGVsLXJlZmluZW1lbnQuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnTUVUSE9EJzogMCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ3B5cmFtaWQnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcsICdtYXhJdGVyYXRpb25zJywgJ2Vwc2lsb24nKTtcblxuY29uc3Qgc3VicGl4ZWxUYXlsb3IyZCA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL3N1YnBpeGVsLXJlZmluZW1lbnQuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnTUVUSE9EJzogMSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ3B5cmFtaWQnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcsICdtYXhJdGVyYXRpb25zJywgJ2Vwc2lsb24nKTtcblxuY29uc3Qgc3VicGl4ZWxCaWxpbmVhciA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL3N1YnBpeGVsLXJlZmluZW1lbnQuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnTUVUSE9EJzogMiB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ3B5cmFtaWQnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcsICdtYXhJdGVyYXRpb25zJywgJ2Vwc2lsb24nKTtcblxuY29uc3Qgc3VicGl4ZWxCaWN1YmljID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvc3VicGl4ZWwtcmVmaW5lbWVudC5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ01FVEhPRCc6IDMgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ3B5cmFtaWQnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcsICdtYXhJdGVyYXRpb25zJywgJ2Vwc2lsb24nKTtcblxuLy8gU2NhbGUgcmVmaW5lbWVudFxuY29uc3QgcmVmaW5lU2NhbGVMb0cgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9yZWZpbmUtc2NhbGUuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ01FVEhPRCc6IDAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygncHlyYW1pZCcsICdsb2RTdGVwJywgJ2VuY29kZWRLZXlwb2ludHMnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnKTtcblxuY29uc3QgcmVmaW5lU2NhbGVGQVNUOTE2ID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvcmVmaW5lLXNjYWxlLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnTUVUSE9EJzogMSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygncHlyYW1pZCcsICdsb2RTdGVwJywgJ2VuY29kZWRLZXlwb2ludHMnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnLCAndGhyZXNob2xkJyk7XG5cbi8vIFBpeGVsIGFsbG9jYXRpb25cbmNvbnN0IGFsbG9jYXRlRGVzY3JpcHRvcnMgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9hbGxvY2F0ZS1kZXNjcmlwdG9ycy5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnaW5wdXRFbmNvZGVkS2V5cG9pbnRzJywgJ2lucHV0RGVzY3JpcHRvclNpemUnLCAnaW5wdXRFeHRyYVNpemUnLCAnaW5wdXRFbmNvZGVyTGVuZ3RoJywgJ291dHB1dERlc2NyaXB0b3JTaXplJywgJ291dHB1dEV4dHJhU2l6ZScsICdvdXRwdXRFbmNvZGVyTGVuZ3RoJyk7XG5cbmNvbnN0IGFsbG9jYXRlRXh0cmEgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9hbGxvY2F0ZS1leHRyYS5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdpbnB1dEVuY29kZWRLZXlwb2ludHMnLCAnaW5wdXREZXNjcmlwdG9yU2l6ZScsICdpbnB1dEV4dHJhU2l6ZScsICdpbnB1dEVuY29kZXJMZW5ndGgnLCAnb3V0cHV0RGVzY3JpcHRvclNpemUnLCAnb3V0cHV0RXh0cmFTaXplJywgJ291dHB1dEVuY29kZXJMZW5ndGgnKTtcblxuY29uc3QgdHJhbnNmZXJUb0V4dHJhID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvdHJhbnNmZXItdG8tZXh0cmEuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnZW5jb2RlZERhdGEnLCAnc3RyaWRlT2ZFbmNvZGVkRGF0YScsICdlbmNvZGVkS2V5cG9pbnRzJywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJyk7XG5cbi8vIE9SQiBkZXNjcmlwdG9yc1xuY29uc3Qgb3JiRGVzY3JpcHRvciA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL29yYi1kZXNjcmlwdG9yLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2ltYWdlJywgJ2VuY29kZWRDb3JuZXJzJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJyk7XG5cbmNvbnN0IG9yYk9yaWVudGF0aW9uID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvb3JiLW9yaWVudGF0aW9uLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdpbWFnZScsICdlbmNvZGVkS2V5cG9pbnRzJywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJyk7XG5cbi8vIE5vbi1tYXhpbXVtIHN1cHByZXNzaW9uXG5jb25zdCBub25NYXhTdXBwcmVzc2lvbiA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL25vbm1heC1zdXBwcmVzc2lvbi5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnTVVMVElTQ0FMRSc6IDAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnaW1hZ2UnLCAnbG9kU3RlcCcpO1xuXG5jb25zdCBtdWx0aXNjYWxlTm9uTWF4U3VwcHJlc3Npb24gPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9ub25tYXgtc3VwcHJlc3Npb24uZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdNVUxUSVNDQUxFJzogMSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnaW1hZ2UnLCAnbG9kU3RlcCcpO1xuXG5jb25zdCBub25tYXhTcGFjZSA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL25vbm1heC1zcGFjZS5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2Nvcm5lcnMnKTtcblxuY29uc3Qgbm9ubWF4U2NhbGUgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9ub25tYXgtc2NhbGUuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdVU0VfTEFQTEFDSUFOJzogMSB9KVxuICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnY29ybmVycycsICdweXJhbWlkJywgJ3B5ckxhcGxhY2lhbicsICdsb2RTdGVwJyk7XG5cbmNvbnN0IG5vbm1heFNjYWxlU2ltcGxlID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvbm9ubWF4LXNjYWxlLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdVU0VfTEFQTEFDSUFOJzogMCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdjb3JuZXJzJywgJ3B5cmFtaWQnLCAnbG9kU3RlcCcpO1xuXG5jb25zdCBsYXBsYWNpYW4gPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9sYXBsYWNpYW4uZ2xzbCcpXG4gICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdjb3JuZXJzJywgJ3B5cmFtaWQnLCAnbG9kU3RlcCcsICdsb2RPZmZzZXQnKTtcblxuLy8gS2V5cG9pbnQgdHJhY2tpbmcgJiBvcHRpY2FsLWZsb3dcbmNvbnN0IGxrID0gWzMsIDUsIDcsIDksIDExLCAxMywgMTUsIDE3LCAxOSwgMjFdLnJlZHVjZSgob2JqLCB3aW4pID0+ICgob2JqW3dpbl0gPVxuICAgICAgICAgICAgICAgaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvbGsuZ2xzbCcpXG4gICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnV0lORE9XX1NJWkUnOiB3aW4gfSlcbiAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdlbmNvZGVkRmxvdycsICdwcmV2S2V5cG9pbnRzJywgJ25leHRQeXJhbWlkJywgJ3ByZXZQeXJhbWlkJywgJ2xldmVsJywgJ2RlcHRoJywgJ251bWJlck9mSXRlcmF0aW9ucycsICdkaXNjYXJkVGhyZXNob2xkJywgJ2Vwc2lsb24nLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnKVxuICAgICAgICAgICApLCBvYmopLCB7fSk7XG5cbmNvbnN0IHRyYW5zZmVyRmxvdyA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL3RyYW5zZmVyLWZsb3cuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnZW5jb2RlZEZsb3cnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcpO1xuXG4vLyBCcnV0ZS1mb3JjZSBtYXRjaGluZ1xuY29uc3QgYmZNYXRjaGVySW5pdENhbmRpZGF0ZXMgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9rbm4taW5pdC5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnRU5DT0RFX0ZJTFRFUlMnOiAwIH0pO1xuXG5jb25zdCBiZk1hdGNoZXJJbml0RmlsdGVycyA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2tubi1pbml0Lmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdFTkNPREVfRklMVEVSUyc6IDEgfSk7XG5cbmNvbnN0IGJmTWF0Y2hlclRyYW5zZmVyID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMva25uLXRyYW5zZmVyLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdlbmNvZGVkTWF0Y2hlcycsICdlbmNvZGVkS3RoTWF0Y2hlcycsICdudW1iZXJPZk1hdGNoZXNQZXJLZXlwb2ludCcsICdrdGhNYXRjaCcpO1xuXG5jb25zdCBiZk1hdGNoZXIzMiA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2JmLWtubi5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdERVNDUklQVE9SX1NJWkUnOiAzMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdOVU1CRVJfT0ZfS0VZUE9JTlRTX1BFUl9QQVNTJzogMTYsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdlbmNvZGVkTWF0Y2hlcycsICdlbmNvZGVkRmlsdGVycycsICdtYXRjaGVyTGVuZ3RoJywgJ2RiRW5jb2RlZEtleXBvaW50cycsICdkYkRlc2NyaXB0b3JTaXplJywgJ2RiRXh0cmFTaXplJywgJ2RiRW5jb2Rlckxlbmd0aCcsICdlbmNvZGVkS2V5cG9pbnRzJywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJywgJ3Bhc3NJZCcpO1xuXG5jb25zdCBiZk1hdGNoZXI2NCA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2JmLWtubi5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdERVNDUklQVE9SX1NJWkUnOiA2NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdOVU1CRVJfT0ZfS0VZUE9JTlRTX1BFUl9QQVNTJzogOCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2VuY29kZWRNYXRjaGVzJywgJ2VuY29kZWRGaWx0ZXJzJywgJ21hdGNoZXJMZW5ndGgnLCAnZGJFbmNvZGVkS2V5cG9pbnRzJywgJ2RiRGVzY3JpcHRvclNpemUnLCAnZGJFeHRyYVNpemUnLCAnZGJFbmNvZGVyTGVuZ3RoJywgJ2VuY29kZWRLZXlwb2ludHMnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnLCAncGFzc0lkJyk7XG5cbi8vIExTSC1iYXNlZCBLTk4gbWF0Y2hpbmdcbmNvbnN0IGxzaEtubkluaXRDYW5kaWRhdGVzID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMva25uLWluaXQuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ0VOQ09ERV9GSUxURVJTJzogMCB9KTtcblxuY29uc3QgbHNoS25uSW5pdEZpbHRlcnMgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9rbm4taW5pdC5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnRU5DT0RFX0ZJTFRFUlMnOiAxIH0pO1xuXG5jb25zdCBsc2hLbm4gPSBMU0hfQUNDRVBUQUJMRV9ERVNDUklQVE9SX1NJWkVTLnJlZHVjZSgob2JqLCBkZXNjcmlwdG9yU2l6ZSkgPT4gKChvYmpbZGVzY3JpcHRvclNpemVdID0gTFNIX0FDQ0VQVEFCTEVfSEFTSF9TSVpFUy5yZWR1Y2UoKG9iaiwgaGFzaFNpemUpID0+ICgob2JqW2hhc2hTaXplXSA9IFswLCAxLCAyXS5yZWR1Y2UoKG9iaiwgbGV2ZWwpID0+ICgob2JqW2xldmVsXSA9XG4gICAgICAgICAgICAgICAgICBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9sc2gta25uLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAnREVTQ1JJUFRPUl9TSVpFJzogZGVzY3JpcHRvclNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgJ0hBU0hfU0laRSc6IGhhc2hTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICdMRVZFTCc6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICdTRVFVRU5DRV9NQVhMRU4nOiBMU0hfU0VRVUVOQ0VfTUFYTEVOLFxuICAgICAgICAgICAgICAgICAgICAgICdTRVFVRU5DRV9DT1VOVCc6IExTSF9TRVFVRU5DRV9DT1VOVCxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnY2FuZGlkYXRlcycsICdmaWx0ZXJzJywgJ21hdGNoZXJMZW5ndGgnLCAndGFibGVzJywgJ2Rlc2NyaXB0b3JEQicsICd0YWJsZUluZGV4JywgJ2J1Y2tldENhcGFjaXR5JywgJ2J1Y2tldHNQZXJUYWJsZScsICd0YWJsZXNTdHJpZGUnLCAnZGVzY3JpcHRvckRCU3RyaWRlJywgJ2VuY29kZWRLZXlwb2ludHMnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnKVxuICAgICAgICAgICAgICApLCBvYmopLCB7fSkpLCBvYmopLCB7fSkpLCBvYmopLCB7fSk7XG5cbmNvbnN0IGxzaEtublRyYW5zZmVyID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMva25uLXRyYW5zZmVyLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnZW5jb2RlZE1hdGNoZXMnLCAnZW5jb2RlZEt0aE1hdGNoZXMnLCAnbnVtYmVyT2ZNYXRjaGVzUGVyS2V5cG9pbnQnLCAna3RoTWF0Y2gnKTtcblxuLy8gS2V5cG9pbnQgc29ydGluZ1xuY29uc3Qgc29ydENyZWF0ZVBlcm11dGF0aW9uID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvc29ydC1rZXlwb2ludHMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdTVEFHRSc6IDEgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2VuY29kZWRLZXlwb2ludHMnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnKTtcblxuY29uc3Qgc29ydE1lcmdlUGVybXV0YXRpb24gPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9zb3J0LWtleXBvaW50cy5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnU1RBR0UnOiAyIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ3Blcm11dGF0aW9uJywgJ2Jsb2NrU2l6ZScsICdkYmxMb2cyQmxvY2tTaXplJyk7XG5cbmNvbnN0IHNvcnRBcHBseVBlcm11dGF0aW9uID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvc29ydC1rZXlwb2ludHMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ1NUQUdFJzogMyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdwZXJtdXRhdGlvbicsICdtYXhLZXlwb2ludHMnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnKTtcblxuLy8gS2V5cG9pbnQgbWl4aW5nXG5jb25zdCBtaXhLZXlwb2ludHNQcmVJbml0ID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvbWl4LWtleXBvaW50cy5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdTVEFHRSc6IDEgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdlbmNvZGVkS2V5cG9pbnRzQScsICdlbmNvZGVkS2V5cG9pbnRzQicsICdlbmNvZGVyTGVuZ3RoQScsICdlbmNvZGVyTGVuZ3RoQicsICdlbmNvZGVyQ2FwYWNpdHlBJywgJ2VuY29kZXJDYXBhY2l0eUInLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnKTtcblxuY29uc3QgbWl4S2V5cG9pbnRzSW5pdCA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL21peC1rZXlwb2ludHMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnU1RBR0UnOiAyIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcsICdtYXhLZXlwb2ludHMnKTtcblxuY29uc3QgbWl4S2V5cG9pbnRzU29ydCA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL21peC1rZXlwb2ludHMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnU1RBR0UnOiAzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnYXJyYXknLCAnYmxvY2tTaXplJyk7XG5cbmNvbnN0IG1peEtleXBvaW50c1ZpZXcgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9taXgta2V5cG9pbnRzLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ1NUQUdFJzogNSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2FycmF5Jyk7XG5cbmNvbnN0IG1peEtleXBvaW50c0FwcGx5ID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvbWl4LWtleXBvaW50cy5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnU1RBR0UnOiA0IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2FycmF5JywgJ2VuY29kZWRLZXlwb2ludHMnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnKTtcblxuLy8gS2V5cG9pbnQgZW5jb2RpbmdcbmNvbnN0IGluaXRMb29rdXBUYWJsZSA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2xvb2t1cC1vZi1sb2NhdGlvbnMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdGU19PVVRQVVRfVFlQRSc6IDIsICdTVEFHRSc6IDEgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2Nvcm5lcnMnKTtcblxuY29uc3Qgc29ydExvb2t1cFRhYmxlID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvbG9va3VwLW9mLWxvY2F0aW9ucy5nbHNsJywgJ2tleXBvaW50cy9sb29rdXAtb2YtbG9jYXRpb25zLnZzLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnRlNfT1VUUFVUX1RZUEUnOiAyLCAnRlNfVVNFX0NVU1RPTV9QUkVDSVNJT04nOiAxLCAnU1RBR0UnOiAyIH0pXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdsb29rdXBUYWJsZScsICdibG9ja1NpemUnLCAnd2lkdGgnLCAnaGVpZ2h0Jyk7XG5cbmNvbnN0IHZpZXdMb29rdXBUYWJsZSA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2xvb2t1cC1vZi1sb2NhdGlvbnMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7ICdTVEFHRSc6IC0xIH0pXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdsb29rdXBUYWJsZScpO1xuXG5jb25zdCBlbmNvZGVLZXlwb2ludHMgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnRzLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnY29ybmVycycsICdsb29rdXBUYWJsZScsICdzdHJpZGUnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnLCAnZW5jb2RlckNhcGFjaXR5Jyk7XG5cbmNvbnN0IGVuY29kZUtleXBvaW50U2tpcE9mZnNldHMgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnQtb2Zmc2V0cy5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdjb3JuZXJzJywgJ2ltYWdlU2l6ZScpO1xuXG5jb25zdCBlbmNvZGVLZXlwb2ludExvbmdTa2lwT2Zmc2V0cyA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2VuY29kZS1rZXlwb2ludC1sb25nLW9mZnNldHMuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ01BWF9JVEVSQVRJT05TJzogNiB9KSAvLyBkZXBlbmRlbnQgdGV4dHVyZSByZWFkcyA6KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdvZmZzZXRzSW1hZ2UnLCAnaW1hZ2VTaXplJyk7XG5cbmNvbnN0IGVuY29kZUtleXBvaW50UG9zaXRpb25zID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvZW5jb2RlLWtleXBvaW50LXBvc2l0aW9ucy5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnb2Zmc2V0c0ltYWdlJywgJ2ltYWdlU2l6ZScsICdwYXNzSWQnLCAnbnVtUGFzc2VzJywgJ2tleXBvaW50TGltaXQnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcpO1xuXG5jb25zdCBlbmNvZGVLZXlwb2ludFByb3BlcnRpZXMgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnQtcHJvcGVydGllcy5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2Nvcm5lcnMnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcpO1xuXG5jb25zdCBlbmNvZGVOdWxsS2V5cG9pbnRzID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvZW5jb2RlLW51bGwta2V5cG9pbnRzLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoKTtcblxuY29uc3QgdHJhbnNmZXJPcmllbnRhdGlvbiA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL3RyYW5zZmVyLW9yaWVudGF0aW9uLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2VuY29kZWRPcmllbnRhdGlvbnMnLCAnZW5jb2RlZEtleXBvaW50cycsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcpO1xuXG5jb25zdCB1cGxvYWRLZXlwb2ludHMgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy91cGxvYWQta2V5cG9pbnRzLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVCT3MgY2FuIGhvbGQgYXQgbGVhc3QgMTZLQiBvZiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdsLk1BWF9VTklGT1JNX0JMT0NLX1NJWkUgPj0gMTYzODRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIEdMIEVTIDMgcmVmZXJlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVhY2gga2V5cG9pbnQgdXNlcyAxNiBieXRlcyAodmVjNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdCVUZGRVJfU0laRSc6IDEwMjQgLy8xNjM4NCAvIDE2XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnZW5jb2RlZEtleXBvaW50cycsICdzdGFydEluZGV4JywgJ2VuZEluZGV4JywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJyk7XG5cbi8vIEdlb21ldHJpYyB0cmFuc2Zvcm1hdGlvbnNcbmNvbnN0IGFwcGx5SG9tb2dyYXBoeSA9IGltcG9ydFNoYWRlcigna2V5cG9pbnRzL2FwcGx5LWhvbW9ncmFwaHkuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnaG9tb2dyYXBoeScsICdlbmNvZGVkS2V5cG9pbnRzJywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJyk7XG5cbi8vIEtleXBvaW50IGZpbHRlcnNcbmNvbnN0IGNsaXBCb3JkZXIgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9jbGlwLWJvcmRlci5nbHNsJylcbiAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdpbWFnZVdpZHRoJywgJ2ltYWdlSGVpZ2h0JywgJ2JvcmRlclRvcCcsICdib3JkZXJSaWdodCcsICdib3JkZXJCb3R0b20nLCAnYm9yZGVyTGVmdCcsICdlbmNvZGVkS2V5cG9pbnRzJywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJyk7XG5cbmNvbnN0IGRpc3RhbmNlRmlsdGVyID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvZGlzdGFuY2UtZmlsdGVyLmdsc2wnKVxuICAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdlbmNvZGVkS2V5cG9pbnRzQScsICdlbmNvZGVyTGVuZ3RoQScsICdlbmNvZGVkS2V5cG9pbnRzQicsICdlbmNvZGVyTGVuZ3RoQicsICdkZXNjcmlwdG9yU2l6ZScsICdleHRyYVNpemUnLCAnZW5jb2Rlckxlbmd0aCcsICd0aHJlc2hvbGQnKTtcblxuY29uc3QgaGFtbWluZ0Rpc3RhbmNlRmlsdGVyMzIgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9oYW1taW5nLWRpc3RhbmNlLWZpbHRlci5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aERlZmluZXMoeyAnREVTQ1JJUFRPUl9TSVpFJzogMzIgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnZW5jb2RlZEtleXBvaW50c0EnLCAnZW5jb2Rlckxlbmd0aEEnLCAnZW5jb2RlZEtleXBvaW50c0InLCAnZW5jb2Rlckxlbmd0aEInLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnLCAndGhyZXNob2xkJyk7XG5cbmNvbnN0IGhhbW1pbmdEaXN0YW5jZUZpbHRlcjY0ID0gaW1wb3J0U2hhZGVyKCdrZXlwb2ludHMvaGFtbWluZy1kaXN0YW5jZS1maWx0ZXIuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ0RFU0NSSVBUT1JfU0laRSc6IDY0IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2VuY29kZWRLZXlwb2ludHNBJywgJ2VuY29kZXJMZW5ndGhBJywgJ2VuY29kZWRLZXlwb2ludHNCJywgJ2VuY29kZXJMZW5ndGhCJywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJywgJ3RocmVzaG9sZCcpO1xuXG4vLyBPdGhlciB1dGlsaXRpZXNcbmNvbnN0IHNodWZmbGUgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9zaHVmZmxlLmdsc2wnKVxuICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHsgJ1BFUk1VVEFUSU9OX01BWExFTic6IDIwNDggfSlcbiAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdlbmNvZGVkS2V5cG9pbnRzJywgJ2Rlc2NyaXB0b3JTaXplJywgJ2V4dHJhU2l6ZScsICdlbmNvZGVyTGVuZ3RoJyk7XG5cbmNvbnN0IGNsaXAgPSBpbXBvcnRTaGFkZXIoJ2tleXBvaW50cy9jbGlwLmdsc2wnKVxuICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2VuY29kZWRLZXlwb2ludHMnLCAnZGVzY3JpcHRvclNpemUnLCAnZXh0cmFTaXplJywgJ2VuY29kZXJMZW5ndGgnLCAnbWF4S2V5cG9pbnRzJyk7XG5cbi8qKlxuICogU3BlZWR5UHJvZ3JhbUdyb3VwS2V5cG9pbnRzXG4gKiBLZXlwb2ludCBkZXRlY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVByb2dyYW1Hcm91cEtleXBvaW50cyBleHRlbmRzIFNwZWVkeVByb2dyYW1Hcm91cFxue1xuICAgIC8qKlxuICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTcGVlZHlHUFV9IGdwdVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdwdSlcbiAgICB7XG4gICAgICAgIHN1cGVyKGdwdSk7XG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGQVNUIGNvcm5lciBkZXRlY3RvclxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC5kZWNsYXJlKCdmYXN0OV8xNicsIGZhc3Q5XzE2LCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSGFycmlzIGNvcm5lciBkZXRlY3RvclxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC5kZWNsYXJlKCdoYXJyaXMxJywgaGFycmlzWzFdLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2hhcnJpczMnLCBoYXJyaXNbM10sIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnaGFycmlzNScsIGhhcnJpc1s1XSwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucHJvZ3JhbS51c2VzUGluZ3BvbmdSZW5kZXJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdoYXJyaXM3JywgaGFycmlzWzddLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2hhcnJpc1Njb3JlRmluZE1heCcsIGhhcnJpc1Njb3JlRmluZE1heCwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucHJvZ3JhbS51c2VzUGluZ3BvbmdSZW5kZXJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdoYXJyaXNTY29yZUN1dG9mZicsIGhhcnJpc1Njb3JlQ3V0b2ZmKVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU3VicGl4ZWwgcmVmaW5lbWVudFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC5kZWNsYXJlKCdzdWJwaXhlbFF1YWRyYXRpYzFkJywgc3VicGl4ZWxRdWFkcmF0aWMxZClcbiAgICAgICAgICAgIC5kZWNsYXJlKCdzdWJwaXhlbFRheWxvcjJkJywgc3VicGl4ZWxUYXlsb3IyZClcbiAgICAgICAgICAgIC5kZWNsYXJlKCdzdWJwaXhlbEJpY3ViaWMnLCBzdWJwaXhlbEJpY3ViaWMpXG4gICAgICAgICAgICAuZGVjbGFyZSgnc3VicGl4ZWxCaWxpbmVhcicsIHN1YnBpeGVsQmlsaW5lYXIpXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTY2FsZSByZWZpbmVtZW50XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLmRlY2xhcmUoJ3JlZmluZVNjYWxlTG9HJywgcmVmaW5lU2NhbGVMb0cpXG4gICAgICAgICAgICAuZGVjbGFyZSgncmVmaW5lU2NhbGVGQVNUOTE2JywgcmVmaW5lU2NhbGVGQVNUOTE2KVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gUGl4ZWwgYWxsb2NhdGlvblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC5kZWNsYXJlKCdhbGxvY2F0ZURlc2NyaXB0b3JzJywgYWxsb2NhdGVEZXNjcmlwdG9ycylcbiAgICAgICAgICAgIC5kZWNsYXJlKCdhbGxvY2F0ZUV4dHJhJywgYWxsb2NhdGVFeHRyYSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCd0cmFuc2ZlclRvRXh0cmEnLCB0cmFuc2ZlclRvRXh0cmEpXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPUkIgZGVzY3JpcHRvcnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAuZGVjbGFyZSgnb3JiRGVzY3JpcHRvcicsIG9yYkRlc2NyaXB0b3IpXG4gICAgICAgICAgICAuZGVjbGFyZSgnb3JiT3JpZW50YXRpb24nLCBvcmJPcmllbnRhdGlvbilcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE5vbi1tYXhpbXVtIHN1cHByZXNzaW9uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLmRlY2xhcmUoJ25vbm1heCcsIG5vbk1heFN1cHByZXNzaW9uKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ3B5cm5vbm1heCcsIG11bHRpc2NhbGVOb25NYXhTdXBwcmVzc2lvbilcbiAgICAgICAgICAgIC5kZWNsYXJlKCdub25tYXhTcGFjZScsIG5vbm1heFNwYWNlKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ25vbm1heFNjYWxlJywgbm9ubWF4U2NhbGUpXG4gICAgICAgICAgICAuZGVjbGFyZSgnbm9ubWF4U2NhbGVTaW1wbGUnLCBub25tYXhTY2FsZVNpbXBsZSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdsYXBsYWNpYW4nLCBsYXBsYWNpYW4pXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBMSyBvcHRpY2FsLWZsb3dcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAuZGVjbGFyZSgnbGsyMScsIGxrWzIxXSwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucHJvZ3JhbS51c2VzUGluZ3BvbmdSZW5kZXJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdsazE5JywgbGtbMTldLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2xrMTcnLCBsa1sxN10sIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnbGsxNScsIGxrWzE1XSwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucHJvZ3JhbS51c2VzUGluZ3BvbmdSZW5kZXJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdsazEzJywgbGtbMTNdLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2xrMTEnLCBsa1sxMV0sIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnbGs5JywgbGtbOV0sIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnbGs3JywgbGtbN10sIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnbGs1JywgbGtbNV0sIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnbGszJywgbGtbM10sIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgndHJhbnNmZXJGbG93JywgdHJhbnNmZXJGbG93KVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQnJ1dGUtZm9yY2UgS05OIG1hdGNoaW5nXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLmRlY2xhcmUoJ2JmTWF0Y2hlckluaXRDYW5kaWRhdGVzJywgYmZNYXRjaGVySW5pdENhbmRpZGF0ZXMpXG4gICAgICAgICAgICAuZGVjbGFyZSgnYmZNYXRjaGVySW5pdEZpbHRlcnMnLCBiZk1hdGNoZXJJbml0RmlsdGVycylcbiAgICAgICAgICAgIC5kZWNsYXJlKCdiZk1hdGNoZXJUcmFuc2ZlcicsIGJmTWF0Y2hlclRyYW5zZmVyLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2JmTWF0Y2hlcjMyJywgYmZNYXRjaGVyMzIsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnYmZNYXRjaGVyNjQnLCBiZk1hdGNoZXI2NCwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucHJvZ3JhbS51c2VzUGluZ3BvbmdSZW5kZXJpbmcoKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIExTSC1iYXNlZCBLTk4gbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAuZGVjbGFyZSgnbHNoS25uSW5pdENhbmRpZGF0ZXMnLCBsc2hLbm5Jbml0Q2FuZGlkYXRlcylcbiAgICAgICAgICAgIC5kZWNsYXJlKCdsc2hLbm5Jbml0RmlsdGVycycsIGxzaEtubkluaXRGaWx0ZXJzKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2xzaEtublRyYW5zZmVyJywgbHNoS25uVHJhbnNmZXIsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBLZXlwb2ludCBzb3J0aW5nXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLmRlY2xhcmUoJ3NvcnRDcmVhdGVQZXJtdXRhdGlvbicsIHNvcnRDcmVhdGVQZXJtdXRhdGlvbilcbiAgICAgICAgICAgIC5kZWNsYXJlKCdzb3J0TWVyZ2VQZXJtdXRhdGlvbicsIHNvcnRNZXJnZVBlcm11dGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ3NvcnRBcHBseVBlcm11dGF0aW9uJywgc29ydEFwcGx5UGVybXV0YXRpb24pXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBLZXlwb2ludCBtaXhpbmdcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAuZGVjbGFyZSgnbWl4S2V5cG9pbnRzUHJlSW5pdCcsIG1peEtleXBvaW50c1ByZUluaXQpXG4gICAgICAgICAgICAuZGVjbGFyZSgnbWl4S2V5cG9pbnRzSW5pdCcsIG1peEtleXBvaW50c0luaXQpXG4gICAgICAgICAgICAuZGVjbGFyZSgnbWl4S2V5cG9pbnRzU29ydCcsIG1peEtleXBvaW50c1NvcnQsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVjbGFyZSgnbWl4S2V5cG9pbnRzVmlldycsIG1peEtleXBvaW50c1ZpZXcpXG4gICAgICAgICAgICAuZGVjbGFyZSgnbWl4S2V5cG9pbnRzQXBwbHknLCBtaXhLZXlwb2ludHNBcHBseSlcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEtleXBvaW50IGVuY29kZXJzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLmRlY2xhcmUoJ2VuY29kZU51bGxLZXlwb2ludHMnLCBlbmNvZGVOdWxsS2V5cG9pbnRzKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2VuY29kZUtleXBvaW50cycsIGVuY29kZUtleXBvaW50cylcbiAgICAgICAgICAgIC5kZWNsYXJlKCdpbml0TG9va3VwVGFibGUnLCBpbml0TG9va3VwVGFibGUpXG4gICAgICAgICAgICAuZGVjbGFyZSgnc29ydExvb2t1cFRhYmxlJywgc29ydExvb2t1cFRhYmxlLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ3ZpZXdMb29rdXBUYWJsZScsIHZpZXdMb29rdXBUYWJsZSlcblxuXG4gICAgICAgICAgICAuZGVjbGFyZSgnZW5jb2RlS2V5cG9pbnRTa2lwT2Zmc2V0cycsIGVuY29kZUtleXBvaW50U2tpcE9mZnNldHMpXG4gICAgICAgICAgICAuZGVjbGFyZSgnZW5jb2RlS2V5cG9pbnRMb25nU2tpcE9mZnNldHMnLCBlbmNvZGVLZXlwb2ludExvbmdTa2lwT2Zmc2V0cywge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucHJvZ3JhbS51c2VzUGluZ3BvbmdSZW5kZXJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdlbmNvZGVLZXlwb2ludFBvc2l0aW9ucycsIGVuY29kZUtleXBvaW50UG9zaXRpb25zLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2VuY29kZUtleXBvaW50UHJvcGVydGllcycsIGVuY29kZUtleXBvaW50UHJvcGVydGllcylcblxuXG5cbiAgICAgICAgICAgIC5kZWNsYXJlKCd0cmFuc2Zlck9yaWVudGF0aW9uJywgdHJhbnNmZXJPcmllbnRhdGlvbilcbiAgICAgICAgICAgIC5kZWNsYXJlKCd1cGxvYWRLZXlwb2ludHMnLCB1cGxvYWRLZXlwb2ludHMsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBHZW9tZXRyaWMgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLmRlY2xhcmUoJ2FwcGx5SG9tb2dyYXBoeScsIGFwcGx5SG9tb2dyYXBoeSlcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEtleXBvaW50IGZpbHRlcnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAuZGVjbGFyZSgnY2xpcEJvcmRlcicsIGNsaXBCb3JkZXIpXG4gICAgICAgICAgICAuZGVjbGFyZSgnZGlzdGFuY2VGaWx0ZXInLCBkaXN0YW5jZUZpbHRlcilcbiAgICAgICAgICAgIC5kZWNsYXJlKCdoYW1taW5nRGlzdGFuY2VGaWx0ZXIzMicsIGhhbW1pbmdEaXN0YW5jZUZpbHRlcjMyKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2hhbW1pbmdEaXN0YW5jZUZpbHRlcjY0JywgaGFtbWluZ0Rpc3RhbmNlRmlsdGVyNjQpXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPdGhlciB1dGlsaXRpZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAuZGVjbGFyZSgnc2h1ZmZsZScsIHNodWZmbGUpXG4gICAgICAgICAgICAuZGVjbGFyZSgnY2xpcCcsIGNsaXApXG4gICAgICAgIDtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBMU0gtYmFzZWQgS05OIG1hdGNoaW5nXG4gICAgICAgIC8vXG4gICAgICAgIGZvcihjb25zdCBkZXNjcmlwdG9yU2l6ZSBvZiBPYmplY3Qua2V5cyhsc2hLbm4pKSB7XG4gICAgICAgICAgICBmb3IoY29uc3QgaGFzaFNpemUgb2YgT2JqZWN0LmtleXMobHNoS25uW2Rlc2NyaXB0b3JTaXplXSkpIHtcbiAgICAgICAgICAgICAgICBmb3IoY29uc3QgbGV2ZWwgb2YgT2JqZWN0LmtleXMobHNoS25uW2Rlc2NyaXB0b3JTaXplXVtoYXNoU2l6ZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgbHNoS25uJHtkZXNjcmlwdG9yU2l6ZX1oJHtoYXNoU2l6ZX1sdiR7bGV2ZWx9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJlKG5hbWUsIGxzaEtubltkZXNjcmlwdG9yU2l6ZV1baGFzaFNpemVdW2xldmVsXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wcm9ncmFtLnVzZXNQaW5ncG9uZ1JlbmRlcmluZygpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBweXJhbWlkcy5qc1xuICogSW1hZ2UgcHlyYW1pZHNcbiAqL1xuXG5pbXBvcnQgeyBTcGVlZHlHUFUgfSBmcm9tICcuLi9zcGVlZHktZ3B1JztcbmltcG9ydCB7IFNwZWVkeVByb2dyYW1Hcm91cCB9IGZyb20gJy4uL3NwZWVkeS1wcm9ncmFtLWdyb3VwJztcbmltcG9ydCB7IFNwZWVkeVRleHR1cmUsIFNwZWVkeURyYXdhYmxlVGV4dHVyZSB9IGZyb20gJy4uL3NwZWVkeS10ZXh0dXJlJztcbmltcG9ydCB7IGltcG9ydFNoYWRlciB9IGZyb20gJy4uL3NoYWRlci1kZWNsYXJhdGlvbic7XG5pbXBvcnQgeyBjb252WCwgY29udlksIGNvbnYyRCB9IGZyb20gJy4uL3NoYWRlcnMvZmlsdGVycy9jb252b2x1dGlvbic7XG5cblxuXG4vL1xuLy8gU2hhZGVyc1xuLy9cblxuY29uc3QgdXBzYW1wbGUyID0gaW1wb3J0U2hhZGVyKCdweXJhbWlkcy91cHNhbXBsZTIuZ2xzbCcpLndpdGhBcmd1bWVudHMoJ2ltYWdlJyk7XG5jb25zdCBkb3duc2FtcGxlMiA9IGltcG9ydFNoYWRlcigncHlyYW1pZHMvZG93bnNhbXBsZTIuZ2xzbCcpLndpdGhBcmd1bWVudHMoJ2ltYWdlJyk7XG5cblxuLyoqXG4gKiBTcGVlZHlQcm9ncmFtR3JvdXBQeXJhbWlkc1xuICogSW1hZ2UgcHlyYW1pZHNcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVByb2dyYW1Hcm91cFB5cmFtaWRzIGV4dGVuZHMgU3BlZWR5UHJvZ3JhbUdyb3VwXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3B1KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZ3B1KTtcbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLy8gdXBzYW1wbGluZyAmIGRvd25zYW1wbGluZ1xuICAgICAgICAgICAgLmRlY2xhcmUoJ3Vwc2FtcGxlMicsIHVwc2FtcGxlMilcbiAgICAgICAgICAgIC5kZWNsYXJlKCdkb3duc2FtcGxlMicsIGRvd25zYW1wbGUyKVxuXG4gICAgICAgICAgICAvLyBzZXBhcmFibGUga2VybmVscyBmb3IgZ2F1c3NpYW4gc21vb3RoaW5nXG4gICAgICAgICAgICAvLyB1c2UgW2MsIGIsIGEsIGIsIGNdIHdoZXJlIGErMmMgPSAyYiBhbmQgYSsyYisyYyA9IDFcbiAgICAgICAgICAgIC8vIHBpY2sgYSA9IDAuNCBmb3IgZ2F1c3NpYW4gYXBwcm94aW1hdGlvbiAoc2lnbWEgPSAxKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ3Ntb290aFgnLCBjb252WChbXG4gICAgICAgICAgICAgICAgMC4wNSwgMC4yNSwgMC40LCAwLjI1LCAwLjA1XG4gICAgICAgICAgICBdKSlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdzbW9vdGhZJywgY29udlkoW1xuICAgICAgICAgICAgICAgIDAuMDUsIDAuMjUsIDAuNCwgMC4yNSwgMC4wNVxuICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLmRlY2xhcmUoJ3JlZHVjZScsIGNvbnYyRChbXG4gICAgICAgICAgICAgICAgMC4wMDI1MCwgMC4wMTI1MCwgMC4wMjAwMCwgMC4wMTI1MCwgMC4wMDI1MCxcbiAgICAgICAgICAgICAgICAwLjAxMjUwLCAwLjA2MjUwLCAwLjEwMDAwLCAwLjA2MjUwLCAwLjAxMjUwLFxuICAgICAgICAgICAgICAgIDAuMDIwMDAsIDAuMTAwMDAsIDAuMTYwMDAsIDAuMTAwMDAsIDAuMDIwMDAsXG4gICAgICAgICAgICAgICAgMC4wMTI1MCwgMC4wNjI1MCwgMC4xMDAwMCwgMC4wNjI1MCwgMC4wMTI1MCxcbiAgICAgICAgICAgICAgICAwLjAwMjUwLCAwLjAxMjUwLCAwLjAyMDAwLCAwLjAxMjUwLCAwLjAwMjUwXG4gICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNtb290aGluZyBmb3IgMnggaW1hZ2VcbiAgICAgICAgICAgIC8vIHNhbWUgcnVsZXMgYXMgYWJvdmUgd2l0aCBzdW0oaykgPSAyXG4gICAgICAgICAgICAuZGVjbGFyZSgnc21vb3RoWDInLCBjb252WChbXG4gICAgICAgICAgICAgICAgMC4xLCAwLjUsIDAuOCwgMC41LCAwLjFcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGlzIHdvdWxkIHNhdHVyYXRlIHRoZSBpbWFnZSwgYnV0IHdlIGFwcGx5IGl0XG4gICAgICAgICAgICAgICAgLy8gb24gYSAyeCB1cHNhbXBsZWQgdmVyc2lvbiB3aXRoIGxvdHMgb2YgemVybyBwaXhlbHNcbiAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ3Ntb290aFkyJywgY29udlkoW1xuICAgICAgICAgICAgICAgIDAuMSwgMC41LCAwLjgsIDAuNSwgMC4xXG4gICAgICAgICAgICBdLCAxLjAgLyAyLjApKVxuICAgICAgICA7XG4gICAgfVxufSIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIHRyYW5zZm9ybXMuanNcbiAqIEdlb21ldHJpYyB0cmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5pbXBvcnQgeyBTcGVlZHlHUFUgfSBmcm9tICcuLi9zcGVlZHktZ3B1JztcbmltcG9ydCB7IFNwZWVkeVByb2dyYW1Hcm91cCB9IGZyb20gJy4uL3NwZWVkeS1wcm9ncmFtLWdyb3VwJztcbmltcG9ydCB7IGltcG9ydFNoYWRlciB9IGZyb20gJy4uL3NoYWRlci1kZWNsYXJhdGlvbic7XG5pbXBvcnQgeyBJbGxlZ2FsQXJndW1lbnRFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzL2Vycm9ycyc7XG5cblxuXG4vL1xuLy8gU2hhZGVyc1xuLy9cblxuLy8gUGVyc3BlY3RpdmUgd2FycFxuY29uc3Qgd2FycFBlcnNwZWN0aXZlID0gaW1wb3J0U2hhZGVyKCd0cmFuc2Zvcm1zL3dhcnAtcGVyc3BlY3RpdmUuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnaW1hZ2UnLCAnaW52ZXJzZUhvbW9ncmFwaHknKTtcblxuLy8gUmVzaXplIGltYWdlXG5jb25zdCByZXNpemVOZWFyZXN0ID0gaW1wb3J0U2hhZGVyKCd0cmFuc2Zvcm1zL3Jlc2l6ZS5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgIC53aXRoRGVmaW5lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgJ0lOVEVSUE9MQVRJT05fTUVUSE9EJzogMCAvLyBOZWFyZXN0IG5laWdoYm9yc1xuICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgIC53aXRoQXJndW1lbnRzKCdpbWFnZScpO1xuXG5jb25zdCByZXNpemVCaWxpbmVhciA9IGltcG9ydFNoYWRlcigndHJhbnNmb3Jtcy9yZXNpemUuZ2xzbCcpXG4gICAgICAgICAgICAgICAgICAgICAgLndpdGhEZWZpbmVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0lOVEVSUE9MQVRJT05fTUVUSE9EJzogMSAvLyBCaWxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAud2l0aEFyZ3VtZW50cygnaW1hZ2UnKTtcblxuLy8gQWRkaXRpdmUgbWl4IChUT0RPIGNyZWF0ZSBhIG5ldyBwcm9ncmFtIGdyb3VwPylcbmNvbnN0IGFkZGl0aXZlTWl4ID0gaW1wb3J0U2hhZGVyKCd0cmFuc2Zvcm1zL2FkZGl0aXZlLW1peC5nbHNsJylcbiAgICAgICAgICAgICAgICAgICAgLndpdGhBcmd1bWVudHMoJ2ltYWdlMCcsICdpbWFnZTEnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScpO1xuXG4vKipcbiAqIFNwZWVkeVByb2dyYW1Hcm91cFRyYW5zZm9ybXNcbiAqIEdlb21ldHJpYyB0cmFuc2Zvcm1hdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVByb2dyYW1Hcm91cFRyYW5zZm9ybXMgZXh0ZW5kcyBTcGVlZHlQcm9ncmFtR3JvdXBcbntcbiAgICAvKipcbiAgICAgKiBDbGFzcyBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3BlZWR5R1BVfSBncHVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihncHUpXG4gICAge1xuICAgICAgICBzdXBlcihncHUpO1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAuZGVjbGFyZSgnd2FycFBlcnNwZWN0aXZlJywgd2FycFBlcnNwZWN0aXZlKVxuICAgICAgICAgICAgLmRlY2xhcmUoJ3Jlc2l6ZU5lYXJlc3QnLCByZXNpemVOZWFyZXN0KVxuICAgICAgICAgICAgLmRlY2xhcmUoJ3Jlc2l6ZUJpbGluZWFyJywgcmVzaXplQmlsaW5lYXIpXG4gICAgICAgICAgICAuZGVjbGFyZSgnYWRkaXRpdmVNaXgnLCBhZGRpdGl2ZU1peClcbiAgICAgICAgO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiB1dGlscy5qc1xuICogR1BVIHV0aWxpdGllc1xuICovXG5cbmltcG9ydCB7IFNwZWVkeUdQVSB9IGZyb20gJy4uL3NwZWVkeS1ncHUnO1xuaW1wb3J0IHsgU3BlZWR5UHJvZ3JhbUdyb3VwIH0gZnJvbSAnLi4vc3BlZWR5LXByb2dyYW0tZ3JvdXAnO1xuaW1wb3J0IHsgU3BlZWR5VGV4dHVyZSwgU3BlZWR5RHJhd2FibGVUZXh0dXJlIH0gZnJvbSAnLi4vc3BlZWR5LXRleHR1cmUnO1xuaW1wb3J0IHsgaW1wb3J0U2hhZGVyIH0gZnJvbSAnLi4vc2hhZGVyLWRlY2xhcmF0aW9uJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuXG5cblxuLy9cbi8vIFNoYWRlcnNcbi8vXG5cbi8vIENvcHkgaW1hZ2VcbmNvbnN0IGNvcHkgPSBpbXBvcnRTaGFkZXIoJ3V0aWxzL2NvcHkuZ2xzbCcpLndpdGhBcmd1bWVudHMoJ2ltYWdlJyk7XG5cbi8vIENvcHkga2V5cG9pbnRzXG5jb25zdCBjb3B5S2V5cG9pbnRzID0gaW1wb3J0U2hhZGVyKCd1dGlscy9jb3B5LXJhc3Rlci5nbHNsJykud2l0aERlZmluZXMoeyAnVFlQRSc6IDEgfSkud2l0aEFyZ3VtZW50cygnaW1hZ2UnKTtcblxuLy8gQ29weSAyRCB2ZWN0b3JzXG5jb25zdCBjb3B5MkRWZWN0b3JzID0gaW1wb3J0U2hhZGVyKCd1dGlscy9jb3B5LXJhc3Rlci5nbHNsJykud2l0aERlZmluZXMoeyAnVFlQRSc6IDIgfSkud2l0aEFyZ3VtZW50cygnaW1hZ2UnKTtcblxuLy8gRmxpcCB5LWF4aXMgZm9yIG91dHB1dFxuY29uc3QgZmxpcFkgPSBpbXBvcnRTaGFkZXIoJ3V0aWxzL2NvcHkuZ2xzbCcsICd1dGlscy9mbGlwLXkudnMuZ2xzbCcpLndpdGhBcmd1bWVudHMoJ2ltYWdlJyk7XG5cbi8vIEZpbGwgaW1hZ2Ugd2l0aCBhIGNvbnN0YW50XG5jb25zdCBmaWxsID0gaW1wb3J0U2hhZGVyKCd1dGlscy9maWxsLmdsc2wnKS53aXRoQXJndW1lbnRzKCd2YWx1ZScpO1xuXG4vLyBGaWxsIHplcm8gb3IgbW9yZSBjb2xvciBjb21wb25lbnRzIG9mIHRoZSBpbnB1dCBpbWFnZSB3aXRoIGEgY29uc3RhbnQgdmFsdWVcbmNvbnN0IGZpbGxDb21wb25lbnRzID0gaW1wb3J0U2hhZGVyKCd1dGlscy9maWxsLWNvbXBvbmVudHMuZ2xzbCcpLndpdGhBcmd1bWVudHMoJ2ltYWdlJywgJ3BpeGVsQ29tcG9uZW50cycsICd2YWx1ZScpO1xuXG4vLyBDb3B5IHRoZSBzcmMgY29tcG9uZW50IG9mIHNyYyB0byB6ZXJvIG9yIG1vcmUgY29sb3IgY29tcG9uZW50cyBvZiBhIGNvcHkgb2YgZGVzdFxuY29uc3QgY29weUNvbXBvbmVudHMgPSBpbXBvcnRTaGFkZXIoJ3V0aWxzL2NvcHktY29tcG9uZW50cy5nbHNsJykud2l0aEFyZ3VtZW50cygnZGVzdCcsICdzcmMnLCAnZGVzdENvbXBvbmVudHMnLCAnc3JjQ29tcG9uZW50SWQnKTtcblxuLy8gU2NhbiB0aGUgZW50aXJlIGltYWdlIGFuZCBmaW5kIHRoZSBtaW5pbXVtICYgbWF4aW11bSBwaXhlbCBpbnRlbnNpdHlcbmNvbnN0IHNjYW5NaW5NYXgyRCA9IGltcG9ydFNoYWRlcigndXRpbHMvc2Nhbi1taW5tYXgyZC5nbHNsJykud2l0aEFyZ3VtZW50cygnaW1hZ2UnLCAnaXRlcmF0aW9uTnVtYmVyJyk7XG5cbi8vIENvbXB1dGUgdGhlIHBhcnRpYWwgZGVyaXZhdGl2ZXMgb2YgYW4gaW1hZ2VcbmNvbnN0IHNvYmVsRGVyaXZhdGl2ZXMgPSBpbXBvcnRTaGFkZXIoJ3V0aWxzL3NvYmVsLWRlcml2YXRpdmVzLmdsc2wnLCAndXRpbHMvc29iZWwtZGVyaXZhdGl2ZXMudnMuZ2xzbCcpLndpdGhBcmd1bWVudHMoJ3B5cmFtaWQnLCAnbG9kJyk7XG5cblxuXG5cbi8qKlxuICogU3BlZWR5UHJvZ3JhbUdyb3VwVXRpbHNcbiAqIFV0aWxpdHkgb3BlcmF0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UHJvZ3JhbUdyb3VwVXRpbHMgZXh0ZW5kcyBTcGVlZHlQcm9ncmFtR3JvdXBcbntcbiAgICAvKipcbiAgICAgKiBDbGFzcyBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3BlZWR5R1BVfSBncHVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihncHUpXG4gICAge1xuICAgICAgICBzdXBlcihncHUpO1xuICAgICAgICB0aGlzXG4gICAgICAgICAgICAvLyByZW5kZXIgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgLmRlY2xhcmUoJ3JlbmRlclRvQ2FudmFzJywgZmxpcFksIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0ucmVuZGVyc1RvQ2FudmFzKClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIGNvcHkgaW1hZ2VcbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb3B5JywgY29weSlcblxuICAgICAgICAgICAgLy8gY29weSBrZXlwb2ludHNcbiAgICAgICAgICAgIC5kZWNsYXJlKCdjb3B5S2V5cG9pbnRzJywgY29weUtleXBvaW50cylcblxuICAgICAgICAgICAgLy8gY29weSAyRCB2ZWN0b3JzXG4gICAgICAgICAgICAuZGVjbGFyZSgnY29weTJEVmVjdG9ycycsIGNvcHkyRFZlY3RvcnMpXG5cbiAgICAgICAgICAgIC8vIEZpbGwgaW1hZ2Ugd2l0aCBhIGNvbnN0YW50XG4gICAgICAgICAgICAuZGVjbGFyZSgnZmlsbCcsIGZpbGwpXG5cbiAgICAgICAgICAgIC8vIEZpbGwgemVybyBvciBtb3JlIGNvbG9yIGNvbXBvbmVudHMgb2YgdGhlIGlucHV0IGltYWdlIHdpdGggYSBjb25zdGFudCB2YWx1ZVxuICAgICAgICAgICAgLmRlY2xhcmUoJ2ZpbGxDb21wb25lbnRzJywgZmlsbENvbXBvbmVudHMpXG5cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIHNyYyBjb21wb25lbnQgb2Ygc3JjIHRvIHplcm8gb3IgbW9yZSBjb2xvciBjb21wb25lbnRzIG9mIGEgY29weSBvZiBkZXN0XG4gICAgICAgICAgICAuZGVjbGFyZSgnY29weUNvbXBvbmVudHMnLCBjb3B5Q29tcG9uZW50cylcblxuICAgICAgICAgICAgLy8gZmluZCBtaW5pbXVtICYgbWF4aW11bSBwaXhlbCBpbnRlbnNpdHlcbiAgICAgICAgICAgIC5kZWNsYXJlKCdzY2FuTWluTWF4MkQnLCBzY2FuTWluTWF4MkQsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb2dyYW0udXNlc1Bpbmdwb25nUmVuZGVyaW5nKClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHBhcnRpYWwgZGVyaXZhdGl2ZXMgb2YgYW4gaW1hZ2VcbiAgICAgICAgICAgIC5kZWNsYXJlKCdzb2JlbERlcml2YXRpdmVzJywgc29iZWxEZXJpdmF0aXZlcylcbiAgICAgICAgO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzaGFkZXItZGVjbGFyYXRpb24uanNcbiAqIEVuY2Fwc3VsYXRlcyBhIHNoYWRlciBkZWNsYXJhdGlvblxuICovXG5cbmltcG9ydCB7IFNoYWRlclByZXByb2Nlc3NvciB9IGZyb20gJy4vc2hhZGVyLXByZXByb2Nlc3Nvcic7XG5pbXBvcnQgeyBGaWxlTm90Rm91bmRFcnJvciwgSWxsZWdhbEFyZ3VtZW50RXJyb3IsIElsbGVnYWxPcGVyYXRpb25FcnJvciwgUGFyc2VFcnJvciB9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5cbmNvbnN0IERFRkFVTFRfQVRUUklCVVRFUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHBvc2l0aW9uOiAnYV9wb3NpdGlvbicsXG4gICAgdGV4Q29vcmQ6ICdhX3RleENvb3JkJ1xufSk7XG5cbmNvbnN0IERFRkFVTFRfQVRUUklCVVRFU19MT0NBVElPTiA9IE9iamVjdC5mcmVlemUoe1xuICAgIHBvc2l0aW9uOiAwLCAvLyB1c2UgbG9jYXRpb24gMDsgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTF9BUEkvV2ViR0xfYmVzdF9wcmFjdGljZXNcbiAgICB0ZXhDb29yZDogMSxcbn0pO1xuXG5jb25zdCBERUZBVUxUX1ZFUlRFWF9TSEFERVJfUFJFRklYID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xucHJlY2lzaW9uIGhpZ2hwIGludDtcblxubGF5b3V0IChsb2NhdGlvbj0ke0RFRkFVTFRfQVRUUklCVVRFU19MT0NBVElPTi5wb3NpdGlvbn0pIGluIHZlYzIgJHtERUZBVUxUX0FUVFJJQlVURVMucG9zaXRpb259O1xubGF5b3V0IChsb2NhdGlvbj0ke0RFRkFVTFRfQVRUUklCVVRFU19MT0NBVElPTi50ZXhDb29yZH0pIGluIHZlYzIgJHtERUZBVUxUX0FUVFJJQlVURVMudGV4Q29vcmR9O1xub3V0IGhpZ2hwIHZlYzIgdGV4Q29vcmQ7XG51bmlmb3JtIGhpZ2hwIHZlYzIgdGV4U2l6ZTtcblxuI2RlZmluZSB2c2luaXQoKSBcXFxuZ2xfUG9zaXRpb24gPSB2ZWM0KCR7REVGQVVMVF9BVFRSSUJVVEVTLnBvc2l0aW9ufSwgMC4wZiwgMS4wZik7IFxcXG50ZXhDb29yZCA9ICR7REVGQVVMVF9BVFRSSUJVVEVTLnRleENvb3JkfTtcblxcblxcbmA7XG5cbmNvbnN0IERFRkFVTFRfVkVSVEVYX1NIQURFUiA9IGAjZGVmaW5lIHZzbWFpbigpIDtgO1xuXG5jb25zdCBERUZBVUxUX1ZFUlRFWF9TSEFERVJfU1VGRklYID0gYFxcblxcbnZvaWQgbWFpbigpIHsgdnNpbml0KCk7IHZzbWFpbigpOyB9XFxuYDtcblxuY29uc3QgREVGQVVMVF9GUkFHTUVOVF9TSEFERVJfUFJFRklYID0gYCN2ZXJzaW9uIDMwMCBlc1xuXG4jaWYgQEZTX1VTRV9DVVNUT01fUFJFQ0lTSU9OQCA9PSAwXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsgLy8gfmZsb2F0MTZcbnByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7IC8vIGludDMyXG4jZW5kaWZcblxuI2lmIEBGU19PVVRQVVRfVFlQRUAgPT0gMFxuI2RlZmluZSBPVVRfVFlQRSBtZWRpdW1wIHZlYzRcbiNlbGlmIEBGU19PVVRQVVRfVFlQRUAgPT0gMVxuI2RlZmluZSBPVVRfVFlQRSBtZWRpdW1wIGl2ZWM0XG4jZWxpZiBARlNfT1VUUFVUX1RZUEVAID09IDJcbiNkZWZpbmUgT1VUX1RZUEUgbWVkaXVtcCB1dmVjNFxuI2Vsc2VcbiNlcnJvciBVbmtub3duIEZTX09VVFBVVF9UWVBFXG4jZW5kaWZcblxub3V0IE9VVF9UWVBFIGNvbG9yO1xuaW4gaGlnaHAgdmVjMiB0ZXhDb29yZDtcbnVuaWZvcm0gaGlnaHAgdmVjMiB0ZXhTaXplO1xuXG5AaW5jbHVkZSBcImdsb2JhbC5nbHNsXCJcXG5cXG5gO1xuXG5jb25zdCBQUklWQVRFX1RPS0VOID0gU3ltYm9sKCk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU2hhZGVyRGVjbGFyYXRpb25GaWxlcGF0aE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7XCJmaWxlcGF0aFwifSB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZXBhdGhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdnNmaWxlcGF0aF1cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTaGFkZXJEZWNsYXJhdGlvblNvdXJjZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7XCJzb3VyY2VcIn0gdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2c3NvdXJjZV1cbiAqXG4gKiBAdHlwZWRlZiB7U2hhZGVyRGVjbGFyYXRpb25GaWxlcGF0aE9wdGlvbnMgfCBTaGFkZXJEZWNsYXJhdGlvblNvdXJjZU9wdGlvbnN9IFNoYWRlckRlY2xhcmF0aW9uT3B0aW9uc1xuICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NoYWRlci1wcmVwcm9jZXNzb3InKS5TaGFkZXJEZWZpbmVzfSBTaGFkZXJEZWZpbmVzICovXG5cbi8qKlxuICogU2hhZGVyIERlY2xhcmF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFkZXJEZWNsYXJhdGlvblxue1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTaGFkZXJEZWNsYXJhdGlvbk9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gcHJpdmF0ZVRva2VuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgcHJpdmF0ZVRva2VuKVxuICAgIHtcbiAgICAgICAgaWYocHJpdmF0ZVRva2VuICE9PSBQUklWQVRFX1RPS0VOKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcigpOyAvLyBwcml2YXRlIGNvbnN0cnVjdG9yIVxuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBvcmlnaW5hbCBzb3VyY2UgY29kZSBwcm92aWRlZCBieSB0aGUgdXNlciAoZnJhZ21lbnQgc2hhZGVyKSAqL1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSAoKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoKG9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGVwYXRoJzogcmV0dXJuIHJlcXVpcmUoJy4vc2hhZGVycy8nICsgb3B0aW9ucy5maWxlcGF0aCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnc291cmNlJzogICByZXR1cm4gb3B0aW9ucy5zb3VyY2U7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtuZXZlcn0gKi8gKCAnJyApO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gdmVydGV4IHNoYWRlciBzb3VyY2UgY29kZSAod2l0aG91dCBwcmVwcm9jZXNzaW5nKSAqL1xuICAgICAgICB0aGlzLl92c3NvdXJjZSA9ICgoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2gob3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsZXBhdGgnOiByZXR1cm4gb3B0aW9ucy52c2ZpbGVwYXRoID8gcmVxdWlyZSgnLi9zaGFkZXJzLycgKyBvcHRpb25zLnZzZmlsZXBhdGgpIDogREVGQVVMVF9WRVJURVhfU0hBREVSO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6ICAgcmV0dXJuIG9wdGlvbnMudnNzb3VyY2UgPyBvcHRpb25zLnZzc291cmNlIDogREVGQVVMVF9WRVJURVhfU0hBREVSO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7bmV2ZXJ9ICovICggJycgKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IHByZXByb2Nlc3NlZCBzb3VyY2UgY29kZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyICovXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gU2hhZGVyUHJlcHJvY2Vzc29yLnJ1bihERUZBVUxUX0ZSQUdNRU5UX1NIQURFUl9QUkVGSVggKyB0aGlzLl9zb3VyY2UpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBwcmVwcm9jZXNzZWQgc291cmNlIGNvZGUgb2YgdGhlIHZlcnRleCBzaGFkZXIgKi9cbiAgICAgICAgdGhpcy5fdmVydGV4U291cmNlID0gU2hhZGVyUHJlcHJvY2Vzc29yLnJ1bihERUZBVUxUX1ZFUlRFWF9TSEFERVJfUFJFRklYICsgdGhpcy5fdnNzb3VyY2UgKyBERUZBVUxUX1ZFUlRFWF9TSEFERVJfU1VGRklYKTtcblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gZmlsZXBhdGggb2YgdGhlIGZyYWdtZW50IHNoYWRlciAqL1xuICAgICAgICB0aGlzLl9maWxlcGF0aCA9IG9wdGlvbnMudHlwZSA9PT0gJ2ZpbGVwYXRoJyA/IG9wdGlvbnMuZmlsZXBhdGggOiAnPGluLW1lbW9yeT4nO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBmaWxlcGF0aCBvZiB0aGUgdmVydGV4IHNoYWRlciAqL1xuICAgICAgICB0aGlzLl92c2ZpbGVwYXRoID0gb3B0aW9ucy50eXBlID09PSAnZmlsZXBhdGgnICYmIG9wdGlvbnMudnNmaWxlcGF0aCA/IG9wdGlvbnMudnNmaWxlcGF0aCA6ICc8aW4tbWVtb3J5Pic7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gYW4gb3JkZXJlZCBsaXN0IG9mIHVuaWZvcm0gbmFtZXMgKi9cbiAgICAgICAgdGhpcy5fYXJndW1lbnRzID0gW107XG5cbiAgICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLHN0cmluZz59IGl0IG1hcHMgdW5pZm9ybSBuYW1lcyB0byB0aGVpciB0eXBlcyAqL1xuICAgICAgICB0aGlzLl91bmlmb3JtcyA9IHRoaXMuX2F1dG9kZXRlY3RVbmlmb3Jtcyh0aGlzLl9mcmFnbWVudFNvdXJjZSArICdcXG4nICsgdGhpcy5fdmVydGV4U291cmNlKTtcblxuICAgICAgICAvKiogQHR5cGUge1NoYWRlckRlZmluZXN9IGl0IG1hcHMgZXh0ZXJuYWxseSAjZGVmaW5lZCBjb25zdGFudHMgdG8gdGhlaXIgdmFsdWVzICovXG4gICAgICAgIHRoaXMuX2RlZmluZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTaGFkZXIgZGlyZWN0bHkgZnJvbSBhIEdMU0wgc291cmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBmcmFnbWVudCBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbdnNzb3VyY2VdIHZlcnRleCBzaGFkZXJcbiAgICAgKiBAcmV0dXJucyB7U2hhZGVyRGVjbGFyYXRpb259XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzb3VyY2UsIHZzc291cmNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhZGVyRGVjbGFyYXRpb24oeyB0eXBlOiAnc291cmNlJywgc291cmNlLCB2c3NvdXJjZSB9LCBQUklWQVRFX1RPS0VOKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgYSBTaGFkZXIgZnJvbSBhIGZpbGUgY29udGFpbmluZyBhIEdMU0wgc291cmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIHBhdGggdG8gLmdsc2wgZmlsZSByZWxhdGl2ZSB0byB0aGUgc2hhZGVycy8gZm9sZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2c2ZpbGVwYXRoXSBwYXRoIHRvIGEgLnZzLmdsc2wgZmlsZSByZWxhdGl2ZSB0byB0aGUgc2hhZGVycy8gZm9sZGVyXG4gICAgICogQHJldHVybnMge1NoYWRlckRlY2xhcmF0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbXBvcnQoZmlsZXBhdGgsIHZzZmlsZXBhdGggPSBudWxsKVxuICAgIHtcbiAgICAgICAgaWYoIVN0cmluZyhmaWxlcGF0aCkubWF0Y2goL15bYS16QS1aMC05X1xcLS9dK1xcLmdsc2wkLykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlsZU5vdEZvdW5kRXJyb3IoYENhbid0IGltcG9ydCBmcmFnbWVudCBzaGFkZXIgYXQgXCIke2ZpbGVwYXRofVwiYCk7XG4gICAgICAgIGVsc2UgaWYodnNmaWxlcGF0aCAhPSBudWxsICYmICFTdHJpbmcodnNmaWxlcGF0aCkubWF0Y2goL15bYS16QS1aMC05X1xcLS9dK1xcLnZzXFwuZ2xzbCQvKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBGaWxlTm90Rm91bmRFcnJvcihgQ2FuJ3QgaW1wb3J0IHZlcnRleCBzaGFkZXIgYXQgXCIke3ZzZmlsZXBhdGh9XCJgKTtcblxuICAgICAgICByZXR1cm4gbmV3IFNoYWRlckRlY2xhcmF0aW9uKHsgdHlwZTogJ2ZpbGVwYXRoJywgZmlsZXBhdGgsIHZzZmlsZXBhdGggfSwgUFJJVkFURV9UT0tFTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgbGlzdCAmIG9yZGVyIG9mIGFyZ3VtZW50cyB0byBiZVxuICAgICAqIHBhc3NlZCB0byB0aGUgc2hhZGVyXG4gICAgICogQHBhcmFtICB7Li4uc3RyaW5nfSBhcmdzIGFyZ3VtZW50IG5hbWVzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgd2l0aEFyZ3VtZW50cyguLi5hcmdzKVxuICAgIHtcbiAgICAgICAgLy8gdGhlIGxpc3Qgb2YgYXJndW1lbnRzIG1heSBiZSBkZWNsYXJlZCBvbmx5IG9uY2VcbiAgICAgICAgaWYodGhpcy5fYXJndW1lbnRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKGBSZWRlZmluaXRpb24gb2Ygc2hhZGVyIGFyZ3VtZW50c2ApO1xuXG4gICAgICAgIC8vIGdldCBhcmd1bWVudHNcbiAgICAgICAgdGhpcy5fYXJndW1lbnRzID0gYXJncy5tYXAoYXJnID0+IFN0cmluZyhhcmcpKTtcblxuICAgICAgICAvLyB2YWxpZGF0ZVxuICAgICAgICBmb3IoY29uc3QgYXJnbmFtZSBvZiB0aGlzLl9hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLl91bmlmb3Jtcy5oYXMoYXJnbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fdW5pZm9ybXMuaGFzKGFyZ25hbWUgKyAnWzBdJykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgQXJndW1lbnQgXCIke2FyZ25hbWV9XCIgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGluIHRoZSBzaGFkZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBzZXQgb2YgI2RlZmluZXMgdG8gYmUgcHJlcGVuZGVkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsbnVtYmVyPn0gZGVmaW5lcyBrZXktdmFsdWUgcGFpcnMgKGRlZmluZS1uYW1lOiBkZWZpbmUtdmFsdWUpXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgd2l0aERlZmluZXMoZGVmaW5lcylcbiAgICB7XG4gICAgICAgIC8vIHRoZSBsaXN0IG9mICNkZWZpbmVzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZVxuICAgICAgICBpZih0aGlzLl9kZWZpbmVzLnNpemUgPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihgUmVkZWZpbml0aW9uIG9mIGV4dGVybmFsbHkgZGVmaW5lZCBjb25zdGFudHMgb2YgYSBzaGFkZXJgKTtcblxuICAgICAgICAvLyBzdG9yZSBhbmQgd3JpdGUgdGhlICNkZWZpbmVzXG4gICAgICAgIGNvbnN0IGRlZnMgPSBbXSwga2V5cyA9IE9iamVjdC5rZXlzKGRlZmluZXMpO1xuICAgICAgICBmb3IoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKGRlZmluZXNba2V5XSk7IC8vIGZvcmNlIG51bWVyaWMgdmFsdWVzIChqdXN0IGluIGNhc2UpXG4gICAgICAgICAgICB0aGlzLl9kZWZpbmVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGRlZnMucHVzaChgI2RlZmluZSAke2tleX0gJHt2YWx1ZX1cXG5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc2hhZGVycyAmIHRoZSB1bmlmb3Jtc1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBERUZBVUxUX0ZSQUdNRU5UX1NIQURFUl9QUkVGSVggKyBkZWZzLmpvaW4oJycpICsgdGhpcy5fc291cmNlO1xuICAgICAgICBjb25zdCB2c3NvdXJjZSA9IERFRkFVTFRfVkVSVEVYX1NIQURFUl9QUkVGSVggKyBkZWZzLmpvaW4oJycpICsgdGhpcy5fdnNzb3VyY2UgKyBERUZBVUxUX1ZFUlRFWF9TSEFERVJfU1VGRklYO1xuICAgICAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IFNoYWRlclByZXByb2Nlc3Nvci5ydW4oc291cmNlLCB0aGlzLl9kZWZpbmVzKTtcbiAgICAgICAgdGhpcy5fdmVydGV4U291cmNlID0gU2hhZGVyUHJlcHJvY2Vzc29yLnJ1bih2c3NvdXJjZSwgdGhpcy5fZGVmaW5lcyk7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zID0gdGhpcy5fYXV0b2RldGVjdFVuaWZvcm1zKHRoaXMuX2ZyYWdtZW50U291cmNlICsgJ1xcbicgKyB0aGlzLl92ZXJ0ZXhTb3VyY2UpO1xuXG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgR0xTTCBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZyYWdtZW50U291cmNlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFnbWVudFNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIEdMU0wgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdmVydGV4U291cmNlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJ0ZXhTb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lcyBvZiB0aGUgdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMge3R5cGVvZiBERUZBVUxUX0FUVFJJQlVURVN9XG4gICAgICovXG4gICAgZ2V0IGF0dHJpYnV0ZXMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfQVRUUklCVVRFUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByZS1kZWZpbmVkIGxvY2F0aW9ucyBvZiB0aGUgdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMge3R5cGVvZiBERUZBVUxUX0FUVFJJQlVURVNfTE9DQVRJT059XG4gICAgICovXG4gICAgZ2V0IGxvY2F0aW9uT2ZBdHRyaWJ1dGVzKClcbiAgICB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0FUVFJJQlVURVNfTE9DQVRJT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmFtZXMgb2YgdGhlIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBTaGFkZXIsXG4gICAgICogY29ycmVzcG9uZGluZyB0byBHTFNMIHVuaWZvcm1zLCBpbiB0aGUgb3JkZXIgdGhleSB3aWxsIGJlIHBhc3NlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXQgYXJndW1lbnRzKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcmd1bWVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmFtZXMgb2YgdGhlIHVuaWZvcm1zIGRlY2xhcmVkIGluIHRoZSBzaGFkZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0IHVuaWZvcm1zKClcbiAgICB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3VuaWZvcm1zLmtleXMoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIEdMU0wgdHlwZSBvZiBhIHVuaWZvcm0gdmFyaWFibGUgZGVjbGFyZWQgaW4gdGhlIHNoYWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB1bmlmb3JtVHlwZShuYW1lKVxuICAgIHtcbiAgICAgICAgaWYoIXRoaXMuX3VuaWZvcm1zLmhhcyhuYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgVW5yZWNvZ25pemVkIHVuaWZvcm0gdmFyaWFibGU6IFwiJHtuYW1lfVwiYCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VuaWZvcm1zLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgYW4gZXh0ZXJuYWxseSBkZWZpbmVkIGNvbnN0YW50LCBpLmUuLCB2aWEgd2l0aERlZmluZXMoKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZGVmaW5lZENvbnN0YW50KG5hbWUpXG4gICAge1xuICAgICAgICBpZighdGhpcy5fZGVmaW5lcy5oYXMobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYFVucmVjb2duaXplZCBleHRlcm5hbGx5IGRlZmluZWQgY29uc3RhbnQ6IFwiJHtuYW1lfVwiYCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluZXMuZ2V0KG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIEdMU0wgc291cmNlIGFuZCBkZXRlY3RzIHRoZSB1bmlmb3JtIHZhcmlhYmxlcyxcbiAgICAgKiBhcyB3ZWxsIGFzIHRoZWlyIHR5cGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXByb2Nlc3NlZFNvdXJjZSBcbiAgICAgKiBAcmV0dXJucyB7TWFwPHN0cmluZyxzdHJpbmc+fSBzcGVjaWZpZXMgdGhlIHR5cGVzIG9mIGFsbCB1bmlmb3Jtc1xuICAgICAqL1xuICAgIF9hdXRvZGV0ZWN0VW5pZm9ybXMocHJlcHJvY2Vzc2VkU291cmNlKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc291cmNlV2l0aG91dENvbW1lbnRzID0gcHJlcHJvY2Vzc2VkU291cmNlOyAvLyBhc3N1bWUgd2UndmUgcHJlcHJvY2Vzc2VkIHRoZSBzb3VyY2UgYWxyZWFkeVxuICAgICAgICBjb25zdCByZWdleCA9IC9eXFxzKnVuaWZvcm1cXHMrKGhpZ2hwXFxzK3xtZWRpdW1wXFxzK3xsb3dwXFxzKyk/KFxcdyspXFxzKyhbXjtdKykvZ207XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUoKG1hdGNoID0gcmVnZXguZXhlYyhzb3VyY2VXaXRob3V0Q29tbWVudHMpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBtYXRjaFszXS5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKS5maWx0ZXIobmFtZSA9PiBuYW1lKTsgLy8gdHJpbSAmIHJlbW92ZSBlbXB0eSBuYW1lc1xuXG4gICAgICAgICAgICBmb3IoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGlmKG5hbWUuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpcyBpdCBhbiBhcnJheT9cbiAgICAgICAgICAgICAgICAgICAgaWYoIShtYXRjaCA9IG5hbWUubWF0Y2goLyhcXHcrKVxccypcXFtcXHMqKFxcZCspXFxzKlxcXSQvKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVW5zcGVjaWZpZWQgYXJyYXkgbGVuZ3RoIGZvciB1bmlmb3JtIFwiJHtuYW1lfVwiIGluIHRoZSBzaGFkZXJgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIGFycmF5IG5hbWUgJiBzaXplXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFsgYXJyYXksIHNpemUgXSA9IFsgbWF0Y2hbMV0sIE51bWJlcihtYXRjaFsyXSkgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB1bmlmb3Jtc1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2V0KGAke2FycmF5fVske2l9XWAsIHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgYSByZWd1bGFyIHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgaWYoIXVuaWZvcm1zLmhhcyhuYW1lKSB8fCB1bmlmb3Jtcy5nZXQobmFtZSkgPT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zZXQobmFtZSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoYFJlZGVmaW5pdGlvbiBvZiB1bmlmb3JtIFwiJHtuYW1lfVwiIGluIHRoZSBzaGFkZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5pZm9ybXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEltcG9ydCBhIFNoYWRlckRlY2xhcmF0aW9uIGZyb20gYSBHTFNMIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCByZWxhdGl2ZSB0byB0aGUgc2hhZGVycy8gZm9sZGVyIChhIC5nbHNsIGZpbGUpXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbdnNmaWxlcGF0aF0gb3B0aW9uYWwgdmVydGV4IHNoYWRlciAoYSAudnMuZ2xzbCBmaWxlKVxuICogQHJldHVybnMge1NoYWRlckRlY2xhcmF0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0U2hhZGVyKGZpbGVwYXRoLCB2c2ZpbGVwYXRoID0gbnVsbClcbntcbiAgICByZXR1cm4gU2hhZGVyRGVjbGFyYXRpb24uaW1wb3J0KGZpbGVwYXRoLCB2c2ZpbGVwYXRoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBTaGFkZXJEZWNsYXJhdGlvbiBmcm9tIGEgR0xTTCBzb3VyY2UgY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBmcmFnbWVudCBzaGFkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFt2c3NvdXJjZV0gb3B0aW9uYWwgdmVydGV4IHNoYWRlclxuICogQHJldHVybnMge1NoYWRlckRlY2xhcmF0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2hhZGVyKHNvdXJjZSwgdnNzb3VyY2UgPSBudWxsKVxue1xuICAgIHJldHVybiBTaGFkZXJEZWNsYXJhdGlvbi5jcmVhdGUoc291cmNlLCB2c3NvdXJjZSk7XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogc2hhZGVyLXByZXByb2Nlc3Nvci5qc1xuICogQ3VzdG9tIHByZXByb2Nlc3NvciBmb3Igc2hhZGVyc1xuICovXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgUGl4ZWxDb21wb25lbnQgfSBmcm9tICcuLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBGaWxlTm90Rm91bmRFcnJvciwgUGFyc2VFcnJvciB9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5cbi8vIEltcG9ydCBudW1lcmljIGdsb2JhbHNcbmNvbnN0IGdsb2JhbHMgPSByZXF1aXJlKCcuLi91dGlscy9nbG9iYWxzJyk7XG5jb25zdCBudW1lcmljR2xvYmFscyA9IE9iamVjdC5rZXlzKGdsb2JhbHMpLmZpbHRlcihrZXkgPT4gdHlwZW9mIGdsb2JhbHNba2V5XSA9PSAnbnVtYmVyJykucmVkdWNlKFxuICAgIChvYmosIGtleSkgPT4gKChvYmpba2V5XSA9IGdsb2JhbHNba2V5XSksIG9iaiksIHt9XG4pO1xuXG4vLyBDb25zdGFudHMgYWNjZXNzaWJsZSBieSBhbGwgc2hhZGVyc1xuY29uc3QgY29uc3RhbnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLy8gbnVtZXJpYyBnbG9iYWxzXG4gICAgLi4ubnVtZXJpY0dsb2JhbHMsXG5cbiAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAnRlNfVVNFX0NVU1RPTV9QUkVDSVNJT04nOiAwLCAvLyB1c2UgZGVmYXVsdCBwcmVjaXNpb24gc2V0dGluZ3NcbiAgICAnRlNfT1VUUFVUX1RZUEUnOiAwLCAvLyBub3JtYWxpemVkIFJHQkFcblxuICAgIC8vIGNvbG9yc1xuICAgICdQSVhFTENPTVBPTkVOVF9SRUQnOiBQaXhlbENvbXBvbmVudC5SRUQsXG4gICAgJ1BJWEVMQ09NUE9ORU5UX0dSRUVOJzogUGl4ZWxDb21wb25lbnQuR1JFRU4sXG4gICAgJ1BJWEVMQ09NUE9ORU5UX0JMVUUnOiBQaXhlbENvbXBvbmVudC5CTFVFLFxuICAgICdQSVhFTENPTVBPTkVOVF9BTFBIQSc6IFBpeGVsQ29tcG9uZW50LkFMUEhBLFxufSk7XG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnNcbmNvbnN0IGNvbW1lbnRzUmVnZXggPSBbIC9cXC9cXCooLnxcXHMpKj9cXCpcXC8vZyAsIC9cXC9cXC8uKiQvZ20gXTtcbmNvbnN0IGluY2x1ZGVSZWdleCA9IC9eXFxzKkBcXHMqaW5jbHVkZVxccytcIiguKj8pXCIvZ207XG5jb25zdCBjb25zdGFudFJlZ2V4ID0gL0AoXFx3KylAL2c7XG5jb25zdCB1bnJvbGxSZWdleCA9IFtcbiAgICAvQFxccyp1bnJvbGxcXHMrP2ZvclxccypcXChcXHMqKGludHwpXFxzKig/PGNvdW50ZXI+XFx3KylcXHMqPVxccyooLT9cXGQrfFxcdyspXFxzKjtcXHMqXFxrPGNvdW50ZXI+XFxzKig8PT8pXFxzKigtP1xcZCt8XFx3KylcXHMqO1xccypcXGs8Y291bnRlcj5cXHMqXFwrXFwrKClcXHMqXFwpXFxzKlxce1xccyooW1xcc1xcU10rPylcXHMqXFx9L2csXG4gICAgL0BcXHMqdW5yb2xsXFxzKz9mb3JcXHMqXFwoXFxzKihpbnR8KVxccyooPzxjb3VudGVyPlxcdyspXFxzKj1cXHMqKC0/XFxkK3xcXHcrKVxccyo7XFxzKlxcazxjb3VudGVyPlxccyooPD0/KVxccyooLT9cXGQrfFxcdyspXFxzKjtcXHMqXFxrPGNvdW50ZXI+XFxzKlxcKz1cXHMqKC0/XFxkKylcXHMqXFwpXFxzKlxce1xccyooW1xcc1xcU10rPylcXHMqXFx9L2csXG5dO1xuXG4vKiogQHR5cGVkZWYge01hcDxzdHJpbmcsbnVtYmVyPn0gU2hhZGVyRGVmaW5lcyAqL1xuXG4vKipcbiAqIEN1c3RvbSBwcmVwcm9jZXNzb3IgZm9yIHRoZSBzaGFkZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFkZXJQcmVwcm9jZXNzb3JcbntcbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBwcmVwcm9jZXNzb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBcbiAgICAgKiBAcGFyYW0ge1NoYWRlckRlZmluZXN9IFtkZWZpbmVzXVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHByZXByb2Nlc3NlZCBjb2RlXG4gICAgICovXG4gICAgc3RhdGljIHJ1bihjb2RlLCBkZWZpbmVzID0gbmV3IE1hcCgpKVxuICAgIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107IC8vIGNvbXBpbGUtdGltZSBlcnJvcnNcblxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcHJlcHJvY2Vzc29yIHdpbGwgcmVtb3ZlIGNvbW1lbnRzIGZyb20gR0xTTCBjb2RlLFxuICAgICAgICAvLyBpbmNsdWRlIHJlcXVlc3RlZCBHTFNMIGZpbGVzIGFuZCBpbXBvcnQgZ2xvYmFsIGNvbnN0YW50c1xuICAgICAgICAvLyBkZWZpbmVkIGZvciBhbGwgc2hhZGVycyAoc2VlIGFib3ZlKVxuICAgICAgICAvL1xuICAgICAgICByZXR1cm4gdW5yb2xsTG9vcHMoXG4gICAgICAgICAgICBTdHJpbmcoY29kZSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShjb21tZW50c1JlZ2V4WzBdLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShjb21tZW50c1JlZ2V4WzFdLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShpbmNsdWRlUmVnZXgsIChfLCBmaWxlbmFtZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IG5vIGN5Y2xlIGRldGVjdGlvbiBmb3IgQGluY2x1ZGVcbiAgICAgICAgICAgICAgICAgICAgU2hhZGVyUHJlcHJvY2Vzc29yLnJ1bihyZWFkZmlsZVN5bmMoZmlsZW5hbWUpLCBkZWZpbmVzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAucmVwbGFjZShjb25zdGFudFJlZ2V4LCAoXywgbmFtZSkgPT4gU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGEgZGVmaW5lZCBjb25zdGFudC4gSWYgbm90IHBvc3NpYmxlLCBmaW5kIGEgZ2xvYmFsIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZXMuaGFzKG5hbWUpID8gTnVtYmVyKGRlZmluZXMuZ2V0KG5hbWUpKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50c1tuYW1lXSAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKGNvbnN0YW50c1tuYW1lXSkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYFVuZGVmaW5lZCBjb25zdGFudDogJHtuYW1lfWApLCAwXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIGRlZmluZXNcbiAgICAgICAgKSArIChlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycy5tYXAobXNnID0+IGBcXG4jZXJyb3IgJHttc2d9XFxuYCkuam9pbignJykgOiAnJyk7XG4gICAgfVxufVxuXG4gLyoqXG4gKiBSZWFkcyBhIHNoYWRlciBmcm9tIHRoZSBzaGFkZXJzL2luY2x1ZGUvIGZvbGRlclxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZWFkZmlsZVN5bmMoZmlsZW5hbWUpXG57XG4gICAgaWYoU3RyaW5nKGZpbGVuYW1lKS5tYXRjaCgvXlthLXpBLVowLTlfLV0rXFwuZ2xzbCQvKSlcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vc2hhZGVycy9pbmNsdWRlLycgKyBmaWxlbmFtZSk7XG5cbiAgICB0aHJvdyBuZXcgRmlsZU5vdEZvdW5kRXJyb3IoYFNoYWRlciBwcmVwcm9jZXNzb3I6IGNhbid0IHJlYWQgZmlsZSBcIiR7ZmlsZW5hbWV9XCJgKTtcbn1cblxuLyoqXG4gKiBVbnJvbGwgZm9yIGxvb3BzIGluIG91ciBvd24gcHJlcHJvY2Vzc29yXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHBhcmFtIHtTaGFkZXJEZWZpbmVzfSBkZWZpbmVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB1bnJvbGxMb29wcyhjb2RlLCBkZWZpbmVzKVxue1xuICAgIC8vXG4gICAgLy8gQ3VycmVudGx5LCBvbmx5IGludGVnZXIgZm9yIGxvb3BzIHdpdGggcG9zaXRpdmUgc3RlcCB2YWx1ZXNcbiAgICAvLyBjYW4gYmUgdW5yb2xsZWQuIChUT0RPOiBuZWdhdGl2ZSBzdGVwIHZhbHVlcz8pXG4gICAgLy9cbiAgICAvLyBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGN1cmx5IGJyYWNlc1xuICAgIC8vIGluc2lkZSB1bnJvbGxlZCBsb29wcy4gWW91IG1heSBkZWZpbmUgbWFjcm9zIHRvIGdldCBhcm91bmRcbiAgICAvLyB0aGlzLCBidXQgZG8geW91IGFjdHVhbGx5IG5lZWQgdG8gdW5yb2xsIHN1Y2ggbG9vcHM/XG4gICAgLy9cbiAgICAvLyBMb29wcyB0aGF0IGRvbid0IGZpdCB0aGUgc3VwcG9ydGVkIHBhdHRlcm4gd2lsbCBjcmFzaFxuICAgIC8vIHRoZSBwcmVwcm9jZXNzb3IgaWYgeW91IHRyeSB0byB1bnJvbGwgdGhlbS5cbiAgICAvL1xuICAgIGNvbnN0IGZuID0gdW5yb2xsLmJpbmQoZGVmaW5lcyk7IC8vIENSQVpZIVxuICAgIGNvbnN0IG4gPSB1bnJvbGxSZWdleC5sZW5ndGg7XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHVucm9sbFJlZ2V4W2ldLCBmbik7XG5cbiAgICByZXR1cm4gY29kZTtcbn1cblxuLyoqXG4gKiBVbnJvbGwgYSBsb29wIHBhdHRlcm4gKHJlZ2V4cClcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCB0aGUgbWF0Y2hlZCBmb3IgbG9vcFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb3VudGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGVwXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9vcGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHVucm9sbGVkIGxvb3BcbiAqL1xuZnVuY3Rpb24gdW5yb2xsKG1hdGNoLCB0eXBlLCBjb3VudGVyLCBzdGFydCwgY21wLCBlbmQsIHN0ZXAsIGxvb3Bjb2RlKVxue1xuICAgIGNvbnN0IGRlZmluZXMgPSAvKiogQHR5cGUge1NoYWRlckRlZmluZXN9ICovICggdGhpcyApO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhlIGxvb3AgbGltaXRzIGFyZSBudW1lcmljIGNvbnN0YW50cyBvciAjZGVmaW5lZCBudW1iZXJzIGZyb20gdGhlIG91dHNpZGVcbiAgICBjb25zdCBoYXNTdGFydCA9IE51bWJlci5pc0Zpbml0ZSgrc3RhcnQpIHx8IGRlZmluZXMuaGFzKHN0YXJ0KTtcbiAgICBjb25zdCBoYXNFbmQgPSBOdW1iZXIuaXNGaW5pdGUoK2VuZCkgfHwgZGVmaW5lcy5oYXMoZW5kKTtcbiAgICBpZighaGFzU3RhcnQgfHwgIWhhc0VuZCkge1xuICAgICAgICBpZihkZWZpbmVzLnNpemUgPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYENhbid0IHVucm9sbCBsb29wOiB1bmtub3duIGxpbWl0cyAoc3RhcnQ9JHtzdGFydH0sIGVuZD0ke2VuZH0pLiBDb2RlOlxcblxcbiR7bWF0Y2h9YCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDsgLy8gZG9uJ3QgdW5yb2xsIG5vdywgYmVjYXVzZSBkZWZpbmVzIGlzIGVtcHR5IC0gbWF5YmUgd2UnbGwgc3VjY2VlZCBpbiB0aGUgbmV4dCBwYXNzXG4gICAgfVxuXG4gICAgLy8gcGFyc2UgYW5kIHZhbGlkYXRlIGxpbWl0cyAmIHN0ZXBcbiAgICBsZXQgaXN0YXJ0ID0gZGVmaW5lcy5oYXMoc3RhcnQpID8gZGVmaW5lcy5nZXQoc3RhcnQpIDogcGFyc2VJbnQoc3RhcnQpO1xuICAgIGxldCBpZW5kID0gZGVmaW5lcy5oYXMoZW5kKSA/IGRlZmluZXMuZ2V0KGVuZCkgOiBwYXJzZUludChlbmQpO1xuICAgIGxldCBpc3RlcCA9IChzdGVwLmxlbmd0aCA9PSAwKSA/IDEgOiBwYXJzZUludChzdGVwKTtcbiAgICBVdGlscy5hc3NlcnQoaXN0YXJ0IDw9IGllbmQgJiYgaXN0ZXAgPiAwKTtcblxuICAgIC8qXG4gICAgLy8gZGVidWdcbiAgICBjb25zb2xlLmxvZyhgRW5jb250cmVpIFwiJHttYXRjaH1cImApO1xuICAgIGNvbnNvbGUubG9nKGB0eXBlPVwiJHt0eXBlfVwiYCk7XG4gICAgY29uc29sZS5sb2coYGNvdW50ZXI9XCIke2NvdW50ZXJ9XCJgKTtcbiAgICBjb25zb2xlLmxvZyhgc3RhcnQ9XCIke3N0YXJ0fVwiYCk7XG4gICAgY29uc29sZS5sb2coYGNtcD1cIiR7Y21wfVwiYCk7XG4gICAgY29uc29sZS5sb2coYGVuZD1cIiR7ZW5kfVwiYCk7XG4gICAgY29uc29sZS5sb2coYHN0ZXA9XCIke3N0ZXB9XCJgKTtcbiAgICBjb25zb2xlLmxvZyhgbG9vcGNvZGU9XCIke2xvb3Bjb2RlfVwiYClcbiAgICBjb25zb2xlLmxvZygnRGVmaW5lczonLCBkZWZpbmVzKTtcbiAgICAqL1xuXG4gICAgLy8gY29udGludWUgc3RhdGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUgdW5yb2xsZWQgbG9vcHNcbiAgICAvLyBhbmQgd2lsbCBnZW5lcmF0ZSBhIGNvbXBpbGVyIGVycm9yLiBVc2luZyBicmVhayBpcyBvay5cbiAgICBjb25zdCBoYXNCcmVhayA9IChsb29wY29kZS5tYXRjaCgvXFxiYnJlYWtcXHMqOy8pICE9PSBudWxsKTtcblxuICAgIC8vIGNyZWF0ZSBhIG5ldyBzY29wZVxuICAgIGxldCB1bnJvbGxlZENvZGUgPSBoYXNCcmVhayA/ICdzd2l0Y2goMSkgeyBkZWZhdWx0OlxcbicgOiAne1xcbic7XG5cbiAgICAvLyBkZWNsYXJlIGNvdW50ZXJcbiAgICB1bnJvbGxlZENvZGUgKz0gYCR7dHlwZX0gJHtjb3VudGVyfTtcXG5gO1xuXG4gICAgLy8gdW5yb2xsIGxvb3BcbiAgICBpZW5kICs9IChjbXAgPT0gJzw9JykgPyAxIDogMDtcbiAgICBmb3IobGV0IGkgPSBpc3RhcnQ7IGkgPCBpZW5kOyBpICs9IGlzdGVwKVxuICAgICAgICB1bnJvbGxlZENvZGUgKz0gYHtcXG4ke2NvdW50ZXJ9ID0gJHtpfTtcXG4ke2xvb3Bjb2RlfVxcbn1cXG5gO1xuXG4gICAgLy8gY2xvc2Ugc2NvcGVcbiAgICB1bnJvbGxlZENvZGUgKz0gJ31cXG4nO1xuICAgIC8vY29uc29sZS5sb2coJ1Vucm9sbGVkIGNvZGU6XFxuXFxuJyArIHVucm9sbGVkQ29kZSk7XG5cbiAgICAvLyBkb25lIVxuICAgIHJldHVybiB1bnJvbGxlZENvZGU7XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogY29udm9sdXRpb24uanNcbiAqIENvbnZvbHV0aW9uIHNoYWRlciBnZW5lcmF0b3JzXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlU2hhZGVyIH0gZnJvbSAnLi4vLi4vc2hhZGVyLWRlY2xhcmF0aW9uJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgSWxsZWdhbEFyZ3VtZW50RXJyb3IgfSBmcm9tICcuLi8uLi8uLi91dGlscy9lcnJvcnMnO1xuXG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDJEIGNvbnZvbHV0aW9uIHdpdGggYSBzcXVhcmUga2VybmVsXG4gKiBAcGFyYW0ge251bWJlcltdfSBrZXJuZWwgY29udm9sdXRpb24ga2VybmVsXG4gKiBAcGFyYW0ge251bWJlcn0gW25vcm1hbGl6YXRpb25Db25zdGFudF0gd2lsbCBiZSBtdWx0aXBsaWVkIGJ5IGFsbCBrZXJuZWwgZW50cmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29udjJEKGtlcm5lbCwgbm9ybWFsaXphdGlvbkNvbnN0YW50ID0gMS4wKVxue1xuICAgIGNvbnN0IGtlcm5lbDMyID0gbmV3IEZsb2F0MzJBcnJheShrZXJuZWwubWFwKHggPT4gKCt4KSAqICgrbm9ybWFsaXphdGlvbkNvbnN0YW50KSkpO1xuICAgIGNvbnN0IGtTaXplID0gTWF0aC5zcXJ0KGtlcm5lbDMyLmxlbmd0aCkgfCAwO1xuICAgIGNvbnN0IE4gPSBrU2l6ZSA+PiAxOyAvLyBpZGl2IDJcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYoa1NpemUgPCAxIHx8IGtTaXplICUgMiA9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IHBlcmZvcm0gYSAyRCBjb252b2x1dGlvbiB3aXRoIGFuIGludmFsaWQga1NpemUgb2YgJHtrU2l6ZX1gKTtcbiAgICBlbHNlIGlmKGtTaXplICoga1NpemUgIT0ga2VybmVsMzIubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYEludmFsaWQgMkQgY29udm9sdXRpb24ga2VybmVsIG9mICR7a2VybmVsMzIubGVuZ3RofSBlbGVtZW50cyAoZXhwZWN0ZWQ6IHNxdWFyZSlgKTtcblxuICAgIC8vIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgcGl4ZWwgZnVuY3Rpb25cbiAgICBjb25zdCBwaXhlbEF0T2Zmc2V0ID0gKE4gPD0gNykgPyAncGl4ZWxBdFNob3J0T2Zmc2V0JyA6ICdwaXhlbEF0TG9uZ09mZnNldCc7XG5cbiAgICAvLyBjb2RlIGdlbmVyYXRvclxuICAgIGNvbnN0IGZvcmVhY2hLZXJuZWxFbGVtZW50ID0gZm4gPT4gVXRpbHMuY2FydGVzaWFuKFV0aWxzLnN5bW1ldHJpY1JhbmdlKE4pLCBVdGlscy5zeW1tZXRyaWNSYW5nZShOKSkubWFwKFxuICAgICAgICBjdXIgPT4gZm4oXG4gICAgICAgICAgICBrZXJuZWwzMlsoY3VyWzBdICsgTikgKiBrU2l6ZSArIChjdXJbMV0gKyBOKV0sXG4gICAgICAgICAgICBjdXJbMF0sIGN1clsxXVxuICAgICAgICApXG4gICAgKS5qb2luKCdcXG4nKTtcblxuICAgIGNvbnN0IGdlbmVyYXRlQ29kZSA9IChrLCBkeSwgZHgpID0+IGBcbiAgICAgICAgcmVzdWx0ICs9ICR7cGl4ZWxBdE9mZnNldH0oaW1hZ2UsIGl2ZWMyKCR7KC1keCkgfCAwfSwgJHsoLWR5KSB8IDB9KSkgKiBmbG9hdCgkeytrfSk7XG4gICAgYDtcblxuICAgIC8vIHNoYWRlclxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcblxuICAgIHZvaWQgbWFpbigpXG4gICAge1xuICAgICAgICBmbG9hdCBhbHBoYSA9IHRocmVhZFBpeGVsKGltYWdlKS5hO1xuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wZik7XG5cbiAgICAgICAgJHtmb3JlYWNoS2VybmVsRWxlbWVudChnZW5lcmF0ZUNvZGUpfVxuXG4gICAgICAgIGNvbG9yID0gdmVjNChyZXN1bHQucmdiLCBhbHBoYSk7XG4gICAgfVxuICAgIGA7XG5cbiAgICAvLyBkb25lIVxuICAgIHJldHVybiBjcmVhdGVTaGFkZXIoc291cmNlKS53aXRoQXJndW1lbnRzKCdpbWFnZScpO1xufVxuXG5cblxuXG4vKipcbiAqIEdlbmVyYXRlIGEgMUQgY29udm9sdXRpb24gZnVuY3Rpb24gb24gdGhlIHgtYXhpc1xuICogQHBhcmFtIHtudW1iZXJbXX0ga2VybmVsIGNvbnZvbHV0aW9uIGtlcm5lbFxuICogQHBhcmFtIHtudW1iZXJ9IFtub3JtYWxpemF0aW9uQ29uc3RhbnRdIHdpbGwgYmUgbXVsdGlwbGllZCBieSBhbGwga2VybmVsIGVudHJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZYKGtlcm5lbCwgbm9ybWFsaXphdGlvbkNvbnN0YW50ID0gMS4wKVxue1xuICAgIHJldHVybiBjb252MUQoJ3gnLCBrZXJuZWwsIG5vcm1hbGl6YXRpb25Db25zdGFudCk7XG59XG5cblxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSAxRCBjb252b2x1dGlvbiBmdW5jdGlvbiBvbiB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge251bWJlcltdfSBrZXJuZWwgY29udm9sdXRpb24ga2VybmVsXG4gKiBAcGFyYW0ge251bWJlcn0gW25vcm1hbGl6YXRpb25Db25zdGFudF0gd2lsbCBiZSBtdWx0aXBsaWVkIGJ5IGFsbCBrZXJuZWwgZW50cmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29udlkoa2VybmVsLCBub3JtYWxpemF0aW9uQ29uc3RhbnQgPSAxLjApXG57XG4gICAgcmV0dXJuIGNvbnYxRCgneScsIGtlcm5lbCwgbm9ybWFsaXphdGlvbkNvbnN0YW50KTtcbn1cblxuXG5cblxuLyoqXG4gKiAxRCBjb252b2x1dGlvbiBmdW5jdGlvbiBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIGVpdGhlciBcInhcIiBvciBcInlcIlxuICogQHBhcmFtIHtudW1iZXJbXX0ga2VybmVsIGNvbnZvbHV0aW9uIGtlcm5lbFxuICogQHBhcmFtIHtudW1iZXJ9IFtub3JtYWxpemF0aW9uQ29uc3RhbnRdIHdpbGwgYmUgbXVsdGlwbGllZCBieSBhbGwga2VybmVsIGVudHJpZXNcbiAqL1xuZnVuY3Rpb24gY29udjFEKGF4aXMsIGtlcm5lbCwgbm9ybWFsaXphdGlvbkNvbnN0YW50ID0gMS4wKVxue1xuICAgIGNvbnN0IGtlcm5lbDMyID0gbmV3IEZsb2F0MzJBcnJheShrZXJuZWwubWFwKHggPT4gKCt4KSAqICgrbm9ybWFsaXphdGlvbkNvbnN0YW50KSkpO1xuICAgIGNvbnN0IGtTaXplID0ga2VybmVsMzIubGVuZ3RoO1xuICAgIGNvbnN0IE4gPSBrU2l6ZSA+PiAxOyAvLyBpZGl2IDJcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYoa1NpemUgPCAxIHx8IGtTaXplICUgMiA9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IHBlcmZvcm0gYSAxRCBjb252b2x1dGlvbiB3aXRoIGFuIGludmFsaWQga1NpemUgb2YgJHtrU2l6ZX1gKTtcbiAgICBlbHNlIGlmKGF4aXMgIT0gJ3gnICYmIGF4aXMgIT0gJ3knKVxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IHBlcmZvcm0gMUQgY29udm9sdXRpb246IGludmFsaWQgYXhpcyBcIiR7YXhpc31cImApOyAvLyB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW5cblxuICAgIC8vIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgcGl4ZWwgZnVuY3Rpb25cbiAgICBjb25zdCBwaXhlbEF0T2Zmc2V0ID0gKE4gPD0gNykgPyAncGl4ZWxBdFNob3J0T2Zmc2V0JyA6ICdwaXhlbEF0TG9uZ09mZnNldCc7XG5cbiAgICAvLyBjb2RlIGdlbmVyYXRvclxuICAgIGNvbnN0IGZvcmVhY2hLZXJuZWxFbGVtZW50ID0gZm4gPT4gVXRpbHMuc3ltbWV0cmljUmFuZ2UoTikucmVkdWNlKFxuICAgICAgICAoYWNjLCBjdXIpID0+IGFjYyArIGZuKGtlcm5lbDMyW2N1ciArIE5dLCBjdXIpLFxuICAgICcnKTtcbiAgICBjb25zdCBnZW5lcmF0ZUNvZGUgPSAoaywgaSkgPT4gKChheGlzID09ICd4JykgPyBgXG4gICAgICAgIHBpeGVsICs9ICR7cGl4ZWxBdE9mZnNldH0oaW1hZ2UsIGl2ZWMyKCR7KC1pKSB8IDB9LCAwKSkgKiBmbG9hdCgkeytrfSk7XG4gICAgYCA6IGBcbiAgICAgICAgcGl4ZWwgKz0gJHtwaXhlbEF0T2Zmc2V0fShpbWFnZSwgaXZlYzIoMCwgJHsoLWkpIHwgMH0pKSAqIGZsb2F0KCR7K2t9KTtcbiAgICBgKTtcblxuICAgIC8vIHNoYWRlclxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcblxuICAgIHZvaWQgbWFpbigpXG4gICAge1xuICAgICAgICBmbG9hdCBhbHBoYSA9IHRocmVhZFBpeGVsKGltYWdlKS5hO1xuICAgICAgICB2ZWM0IHBpeGVsID0gdmVjNCgwLjBmKTtcblxuICAgICAgICAke2ZvcmVhY2hLZXJuZWxFbGVtZW50KGdlbmVyYXRlQ29kZSl9XG5cbiAgICAgICAgY29sb3IgPSB2ZWM0KHBpeGVsLnJnYiwgYWxwaGEpO1xuICAgIH1cbiAgICBgO1xuXG4gICAgLy8gZG9uZSFcbiAgICByZXR1cm4gY3JlYXRlU2hhZGVyKHNvdXJjZSkud2l0aEFyZ3VtZW50cygnaW1hZ2UnKTtcbn0iLCJ2YXIgbWFwID0ge1xuXHRcIi4vY29sb3JzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2NvbG9ycy5nbHNsXCIsXG5cdFwiLi9maWx0ZXJzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2ZpbHRlcnMuZ2xzbFwiLFxuXHRcIi4vZml4ZWQtcG9pbnQuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvZml4ZWQtcG9pbnQuZ2xzbFwiLFxuXHRcIi4vZmxvYXQxNi5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9mbG9hdDE2Lmdsc2xcIixcblx0XCIuL2dsb2JhbC5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9nbG9iYWwuZ2xzbFwiLFxuXHRcIi4vaW50MzIuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvaW50MzIuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnQtZGVzY3JpcHRvcnMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUva2V5cG9pbnQtZGVzY3JpcHRvcnMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnQtbWF0Y2hlcy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9rZXlwb2ludC1tYXRjaGVzLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9rZXlwb2ludHMuZ2xzbFwiLFxuXHRcIi4vbWF0aC5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9tYXRoLmdsc2xcIixcblx0XCIuL3B5cmFtaWRzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL3B5cmFtaWRzLmdsc2xcIixcblx0XCIuL3F1aWNrc2VsZWN0Lmlnbm9yZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9xdWlja3NlbGVjdC5pZ25vcmUuZ2xzbFwiLFxuXHRcIi4vc3VicGl4ZWwuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvc3VicGl4ZWwuZ2xzbFwiXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlIHN5bmMgcmVjdXJzaXZlIF5cXFxcLlxcXFwvLiokXCI7IiwidmFyIG1hcCA9IHtcblx0XCIuL2ZpbHRlcnMvY29udm9sdXRpb25cIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL2NvbnZvbHV0aW9uLmpzXCIsXG5cdFwiLi9maWx0ZXJzL2NvbnZvbHV0aW9uLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvZmlsdGVycy9jb252b2x1dGlvbi5qc1wiLFxuXHRcIi4vZmlsdGVycy9jb252b2x1dGlvbjFkLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL2NvbnZvbHV0aW9uMWQuZ2xzbFwiLFxuXHRcIi4vZmlsdGVycy9jb252b2x1dGlvbjJkLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL2NvbnZvbHV0aW9uMmQuZ2xzbFwiLFxuXHRcIi4vZmlsdGVycy9mYXN0LW1lZGlhbi5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvZmlsdGVycy9mYXN0LW1lZGlhbi5nbHNsXCIsXG5cdFwiLi9maWx0ZXJzL25pZ2h0dmlzaW9uLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL25pZ2h0dmlzaW9uLmdsc2xcIixcblx0XCIuL2ZpbHRlcnMvbm9ybWFsaXplLWltYWdlLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL25vcm1hbGl6ZS1pbWFnZS5nbHNsXCIsXG5cdFwiLi9maWx0ZXJzL3JnYjJncmV5Lmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9maWx0ZXJzL3JnYjJncmV5Lmdsc2xcIixcblx0XCIuL2luY2x1ZGUvY29sb3JzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2NvbG9ycy5nbHNsXCIsXG5cdFwiLi9pbmNsdWRlL2ZpbHRlcnMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvZmlsdGVycy5nbHNsXCIsXG5cdFwiLi9pbmNsdWRlL2ZpeGVkLXBvaW50Lmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2ZpeGVkLXBvaW50Lmdsc2xcIixcblx0XCIuL2luY2x1ZGUvZmxvYXQxNi5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9mbG9hdDE2Lmdsc2xcIixcblx0XCIuL2luY2x1ZGUvZ2xvYmFsLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2dsb2JhbC5nbHNsXCIsXG5cdFwiLi9pbmNsdWRlL2ludDMyLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2ludDMyLmdsc2xcIixcblx0XCIuL2luY2x1ZGUva2V5cG9pbnQtZGVzY3JpcHRvcnMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUva2V5cG9pbnQtZGVzY3JpcHRvcnMuZ2xzbFwiLFxuXHRcIi4vaW5jbHVkZS9rZXlwb2ludC1tYXRjaGVzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9pbmNsdWRlL2tleXBvaW50LW1hdGNoZXMuZ2xzbFwiLFxuXHRcIi4vaW5jbHVkZS9rZXlwb2ludHMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUva2V5cG9pbnRzLmdsc2xcIixcblx0XCIuL2luY2x1ZGUvbWF0aC5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvaW5jbHVkZS9tYXRoLmdsc2xcIixcblx0XCIuL2luY2x1ZGUvcHlyYW1pZHMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvcHlyYW1pZHMuZ2xzbFwiLFxuXHRcIi4vaW5jbHVkZS9xdWlja3NlbGVjdC5pZ25vcmUuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvcXVpY2tzZWxlY3QuaWdub3JlLmdsc2xcIixcblx0XCIuL2luY2x1ZGUvc3VicGl4ZWwuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2luY2x1ZGUvc3VicGl4ZWwuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2FsbG9jYXRlLWRlc2NyaXB0b3JzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvYWxsb2NhdGUtZGVzY3JpcHRvcnMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2FsbG9jYXRlLWV4dHJhLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvYWxsb2NhdGUtZXh0cmEuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2FwcGx5LWhvbW9ncmFwaHkuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9hcHBseS1ob21vZ3JhcGh5Lmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9iZi1rbm4uZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9iZi1rbm4uZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2JyaXNrLmlnbm9yZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2JyaXNrLmlnbm9yZS5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvY2xpcC1ib3JkZXIuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9jbGlwLWJvcmRlci5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvY2xpcC5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2NsaXAuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2Rpc2NhcmQtZGVzY3JpcHRvcnMuaWdub3JlLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZGlzY2FyZC1kZXNjcmlwdG9ycy5pZ25vcmUuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2Rpc3RhbmNlLWZpbHRlci5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2Rpc3RhbmNlLWZpbHRlci5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvZW5jb2RlLWtleXBvaW50LWxvbmctb2Zmc2V0cy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2VuY29kZS1rZXlwb2ludC1sb25nLW9mZnNldHMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2VuY29kZS1rZXlwb2ludC1vZmZzZXRzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZW5jb2RlLWtleXBvaW50LW9mZnNldHMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2VuY29kZS1rZXlwb2ludC1wb3NpdGlvbnMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnQtcG9zaXRpb25zLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnQtcHJvcGVydGllcy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2VuY29kZS1rZXlwb2ludC1wcm9wZXJ0aWVzLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9lbmNvZGUta2V5cG9pbnRzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZW5jb2RlLWtleXBvaW50cy5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvZW5jb2RlLW51bGwta2V5cG9pbnRzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZW5jb2RlLW51bGwta2V5cG9pbnRzLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9mYXN0Lmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvZmFzdC5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvZmFzdC52cy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2Zhc3QudnMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2hhbW1pbmctZGlzdGFuY2UtZmlsdGVyLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvaGFtbWluZy1kaXN0YW5jZS1maWx0ZXIuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2hhcnJpcy1jdXRvZmYuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9oYXJyaXMtY3V0b2ZmLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9oYXJyaXMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9oYXJyaXMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2tubi1pbml0Lmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMva25uLWluaXQuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2tubi10cmFuc2Zlci5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2tubi10cmFuc2Zlci5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvbGFwbGFjaWFuLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvbGFwbGFjaWFuLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9say5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2xrLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9sb29rdXAtb2YtbG9jYXRpb25zLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvbG9va3VwLW9mLWxvY2F0aW9ucy5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvbG9va3VwLW9mLWxvY2F0aW9ucy52cy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL2xvb2t1cC1vZi1sb2NhdGlvbnMudnMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL2xzaC1rbm4uZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9sc2gta25uLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9taXgta2V5cG9pbnRzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvbWl4LWtleXBvaW50cy5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvbmNjLmlnbm9yZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL25jYy5pZ25vcmUuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL25vbm1heC1zY2FsZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL25vbm1heC1zY2FsZS5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvbm9ubWF4LXNwYWNlLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvbm9ubWF4LXNwYWNlLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9ub25tYXgtc3VwcHJlc3Npb24uZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9ub25tYXgtc3VwcHJlc3Npb24uZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL29yYi1kZXNjcmlwdG9yLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvb3JiLWRlc2NyaXB0b3IuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL29yYi1vcmllbnRhdGlvbi5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL29yYi1vcmllbnRhdGlvbi5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvcmVmaW5lLXNjYWxlLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvcmVmaW5lLXNjYWxlLmdsc2xcIixcblx0XCIuL2tleXBvaW50cy9zY29yZS1maW5kbWF4Lmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvc2NvcmUtZmluZG1heC5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvc2h1ZmZsZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL3NodWZmbGUuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL3NvcnQta2V5cG9pbnRzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvc29ydC1rZXlwb2ludHMuZ2xzbFwiLFxuXHRcIi4va2V5cG9pbnRzL3N1YnBpeGVsLXJlZmluZW1lbnQuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy9zdWJwaXhlbC1yZWZpbmVtZW50Lmdsc2xcIixcblx0XCIuL2tleXBvaW50cy90cmFuc2Zlci1mbG93Lmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy9rZXlwb2ludHMvdHJhbnNmZXItZmxvdy5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvdHJhbnNmZXItb3JpZW50YXRpb24uZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy90cmFuc2Zlci1vcmllbnRhdGlvbi5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvdHJhbnNmZXItdG8tZXh0cmEuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL2tleXBvaW50cy90cmFuc2Zlci10by1leHRyYS5nbHNsXCIsXG5cdFwiLi9rZXlwb2ludHMvdXBsb2FkLWtleXBvaW50cy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMva2V5cG9pbnRzL3VwbG9hZC1rZXlwb2ludHMuZ2xzbFwiLFxuXHRcIi4vcHlyYW1pZHMvZG93bnNhbXBsZTIuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3B5cmFtaWRzL2Rvd25zYW1wbGUyLmdsc2xcIixcblx0XCIuL3B5cmFtaWRzL2Rvd25zYW1wbGUzLmlnbm9yZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvcHlyYW1pZHMvZG93bnNhbXBsZTMuaWdub3JlLmdsc2xcIixcblx0XCIuL3B5cmFtaWRzL3Vwc2FtcGxlMi5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvcHlyYW1pZHMvdXBzYW1wbGUyLmdsc2xcIixcblx0XCIuL3B5cmFtaWRzL3Vwc2FtcGxlMy5pZ25vcmUuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3B5cmFtaWRzL3Vwc2FtcGxlMy5pZ25vcmUuZ2xzbFwiLFxuXHRcIi4vdHJhbnNmb3Jtcy9hZGRpdGl2ZS1taXguZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3RyYW5zZm9ybXMvYWRkaXRpdmUtbWl4Lmdsc2xcIixcblx0XCIuL3RyYW5zZm9ybXMvcmVzaXplLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy90cmFuc2Zvcm1zL3Jlc2l6ZS5nbHNsXCIsXG5cdFwiLi90cmFuc2Zvcm1zL3dhcnAtcGVyc3BlY3RpdmUuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3RyYW5zZm9ybXMvd2FycC1wZXJzcGVjdGl2ZS5nbHNsXCIsXG5cdFwiLi91dGlscy9jb3B5LWNvbXBvbmVudHMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3V0aWxzL2NvcHktY29tcG9uZW50cy5nbHNsXCIsXG5cdFwiLi91dGlscy9jb3B5LXJhc3Rlci5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvY29weS1yYXN0ZXIuZ2xzbFwiLFxuXHRcIi4vdXRpbHMvY29weS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvY29weS5nbHNsXCIsXG5cdFwiLi91dGlscy9jcm9wLmlnbm9yZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvY3JvcC5pZ25vcmUuZ2xzbFwiLFxuXHRcIi4vdXRpbHMvZmlsbC1jb21wb25lbnRzLmdsc2xcIjogXCIuL25vZGVfbW9kdWxlcy9zcGVlZHktdmlzaW9uL3NyYy9ncHUvc2hhZGVycy91dGlscy9maWxsLWNvbXBvbmVudHMuZ2xzbFwiLFxuXHRcIi4vdXRpbHMvZmlsbC5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvZmlsbC5nbHNsXCIsXG5cdFwiLi91dGlscy9mbGlwLXkudnMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3V0aWxzL2ZsaXAteS52cy5nbHNsXCIsXG5cdFwiLi91dGlscy9zY2FuLW1pbm1heDFkLmlnbm9yZS5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvc2Nhbi1taW5tYXgxZC5pZ25vcmUuZ2xzbFwiLFxuXHRcIi4vdXRpbHMvc2Nhbi1taW5tYXgyZC5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvc2Nhbi1taW5tYXgyZC5nbHNsXCIsXG5cdFwiLi91dGlscy9zb2JlbC1kZXJpdmF0aXZlcy5nbHNsXCI6IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMvdXRpbHMvc29iZWwtZGVyaXZhdGl2ZXMuZ2xzbFwiLFxuXHRcIi4vdXRpbHMvc29iZWwtZGVyaXZhdGl2ZXMudnMuZ2xzbFwiOiBcIi4vbm9kZV9tb2R1bGVzL3NwZWVkeS12aXNpb24vc3JjL2dwdS9zaGFkZXJzL3V0aWxzL3NvYmVsLWRlcml2YXRpdmVzLnZzLmdsc2xcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NoYWRlcnMgc3luYyByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKiRcIjsiLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzcGVlZHktZGVzY3JpcHRvcmRiLmpzXG4gKiBBIGRhdGFiYXNlIG9mIGJpbmFyeSBkZXNjcmlwdG9ycyBpbiB2aWRlbyBtZW1vcnlcbiAqL1xuXG5pbXBvcnQgeyBTcGVlZHlUZXh0dXJlIH0gZnJvbSAnLi9zcGVlZHktdGV4dHVyZSc7XG5pbXBvcnQgeyBTcGVlZHlOYW1lc3BhY2UgfSBmcm9tICcuLi9jb3JlL3NwZWVkeS1uYW1lc3BhY2UnO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBOb3RTdXBwb3J0ZWRFcnJvciB9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5cbi8vXG4vLyBBIGRhdGFiYXNlIG9mIGJpbmFyeSBkZXNjcmlwdG9ycyBpcyBhIHRleHR1cmUgdGhhdCBzdG9yZXNcbi8vIGEgc2V0IG9mIChkZXNjcmlwdG9yOiB1aW50OF90W10pIGVudHJpZXMuXG4vL1xuXG4vKiogQHR5cGUge251bWJlcn0gd2UgdXNlIFJHQkE4IHRleHR1cmVzIHRvIHN0b3JlIHRoZSBkZXNjcmlwdG9ycyAqL1xuY29uc3QgREVTQ1JJUFRPUkRCX0JZVEVTUEVSUElYRUwgPSA0O1xuXG4vKiogQHR5cGUge251bWJlcn0gdGV4dHVyZSBzaXplIGdvZXMgdXAgdG8gMTYgTUIgKi9cbmNvbnN0IERFU0NSSVBUT1JEQl9NQVhMT0cyU1RSSURFID0gMTE7IC8vIDIwNDh4MjA0OCBSR0JBOCB0ZXh0dXJlcyBhcmUgZ3VhcmFudGVlZCB0byBiZSBhdmFpbGFibGUgaW4gV2ViR0wyICh3aGVyZSBpcyB0aGUgc291cmNlIG9mIHRoaXM/KVxuXG4vKipcbiAqIFV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgYSBkYXRhYmFzZSBvZiBiaW5hcnkgZGVzY3JpcHRvcnMgaW4gdmlkZW8gbWVtb3J5XG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlEZXNjcmlwdG9yREIgZXh0ZW5kcyBTcGVlZHlOYW1lc3BhY2VcbntcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkYXRhYmFzZSBvZiBiaW5hcnkgZGVzY3JpcHRvcnNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVRleHR1cmV9IHRleHR1cmUgb3V0cHV0IHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gZGVzY3JpcHRvcnMgYmluYXJ5IGRlc2NyaXB0b3JzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc2NyaXB0b3JTaXplIGluIGJ5dGVzLCBhIG11bHRpcGxlIG9mIDRcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5VGV4dHVyZX0gdGV4dHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUodGV4dHVyZSwgZGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JTaXplKVxuICAgIHtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KGRlc2NyaXB0b3JTaXplICUgREVTQ1JJUFRPUkRCX0JZVEVTUEVSUElYRUwgPT0gMCwgYEludmFsaWQgZGVzY3JpcHRvclNpemU6ICR7ZGVzY3JpcHRvclNpemV9YCk7XG5cbiAgICAgICAgY29uc3QgbnVtYmVyT2ZEZXNjcmlwdG9ycyA9IGRlc2NyaXB0b3JzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGl4ZWxzUGVyRGVzY3JpcHRvciA9IGRlc2NyaXB0b3JTaXplIC8gREVTQ1JJUFRPUkRCX0JZVEVTUEVSUElYRUw7XG5cbiAgICAgICAgLy8gZmluZCBhbiBhcHByb3ByaWF0ZSB0ZXh0dXJlIHNpemVcbiAgICAgICAgY29uc3QgbiA9IE1hdGgubG9nMihwaXhlbHNQZXJEZXNjcmlwdG9yICogTWF0aC5tYXgobnVtYmVyT2ZEZXNjcmlwdG9ycywgMSkpIC8gMjtcbiAgICAgICAgY29uc3QgbG9nMnN0cmlkZSA9IE1hdGgubWluKERFU0NSSVBUT1JEQl9NQVhMT0cyU1RSSURFLCBNYXRoLmNlaWwobikpO1xuXG4gICAgICAgIC8vIHNldHVwIHRleHR1cmUgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBzdHJpZGUgPSAxIDw8IGxvZzJzdHJpZGU7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gc3RyaWRlLCBoZWlnaHQgPSBzdHJpZGU7IC8vIHdlIHVzZSBwb3dlcnMtb2YtdHdvXG5cbiAgICAgICAgLy8gYXJlIHdlIHdpdGhpbiBzdG9yYWdlIGNhcGFjaXR5P1xuICAgICAgICBjb25zdCBjYXBhY2l0eSA9ICh3aWR0aCAqIGhlaWdodCkgLyBwaXhlbHNQZXJEZXNjcmlwdG9yO1xuICAgICAgICBpZihudW1iZXJPZkRlc2NyaXB0b3JzID4gY2FwYWNpdHkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoYFRoZSBjYXBhY2l0eSBvZiB0aGUgZGVzY3JpcHRvckRCICgke2NhcGFjaXR5fSBmb3IgJHtkZXNjcmlwdG9yU2l6ZSAqIDh9LWJpdCBkZXNjcmlwdG9ycykgaGFzIGJlZW4gZXhjZWVkZWRgKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGV4dHVyZSBkYXRhXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIERFU0NSSVBUT1JEQl9CWVRFU1BFUlBJWEVMKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVzY3JpcHRvcnM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGkgKiBkZXNjcmlwdG9yU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpXTtcblxuICAgICAgICAgICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICAgICAgICAgIFV0aWxzLmFzc2VydChkZXNjcmlwdG9yLmJ5dGVMZW5ndGggPT09IGRlc2NyaXB0b3JTaXplKTtcbiAgICAgICAgICAgIFV0aWxzLmFzc2VydChieXRlT2Zmc2V0ICsgZGVzY3JpcHRvclNpemUgPD0gZGF0YS5ieXRlTGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gd3JpdGUgZGF0YVxuICAgICAgICAgICAgZGF0YS5zZXQoZGVzY3JpcHRvciwgYnl0ZU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2cgZGF0YSBmb3IgZnVydGhlciBzdHVkeVxuICAgICAgICBjb25zdCBNRUdBQllURSA9IDEwNDg1NzY7XG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IG51bWJlck9mRGVzY3JpcHRvcnMgKiBkZXNjcmlwdG9yU2l6ZTtcbiAgICAgICAgVXRpbHMubG9nKFxuICAgICAgICAgICAgYENyZWF0aW5nIGEgJHt3aWR0aH14JHtoZWlnaHR9IGRhdGFiYXNlIG9mICR7bnVtYmVyT2ZEZXNjcmlwdG9yc30gYCArXG4gICAgICAgICAgICBgJHtkZXNjcmlwdG9yU2l6ZSAqIDh9LWJpdCBkZXNjcmlwdG9ycyBgICtcbiAgICAgICAgICAgIGAodG90YWwgc2l6ZTogJHsodG90YWxTaXplIC8gTUVHQUJZVEUpLnRvRml4ZWQoMil9IE1CKWBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGxvYWQgdG8gdGhlIHRleHR1cmVcbiAgICAgICAgdGV4dHVyZS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRleHR1cmUudXBsb2FkKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogc3BlZWR5LWdsLmpzXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBXZWJHTCBSZW5kZXJpbmcgQ29udGV4dFxuICovXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL3V0aWxzL29ic2VydmFibGUnO1xuaW1wb3J0IHsgU3BlZWR5UHJvbWlzZSB9IGZyb20gJy4uL2NvcmUvc3BlZWR5LXByb21pc2UnO1xuaW1wb3J0IHsgTm90U3VwcG9ydGVkRXJyb3IsIElsbGVnYWxBcmd1bWVudEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcblxuLyoqIEB0eXBlZGVmIHsnZGVmYXVsdCcgfCAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJ30gUG93ZXJQcmVmZXJlbmNlICovXG5cbi8vIENvbnN0YW50c1xuY29uc3QgU0lOR0xFVE9OX0tFWSA9IFN5bWJvbCgpO1xuY29uc3QgREVGQVVMVF9QT1dFUl9QUkVGRVJFTkNFID0gJ2RlZmF1bHQnO1xuXG4vL1xuLy8gV2UgdXNlIGEgc21hbGwgY2FudmFzIHRvIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlXG4vLyBvZiBjcmVhdGVJbWFnZUJpdG1hcCgpIG9uIEZpcmVmb3guXG4vL1xuLy8gQSBsYXJnZSBjYW52YXMgKDIwNDh4MjA0OCkgY2F1c2VzIGEgRlBTIGRyb3AsIGV2ZW5cbi8vIGlmIHdlIG9ubHkgZXh0cmFjdCBhIHNtYWxsIHJlZ2lvbiBvZiBpdCAodGhpcyBpc1xuLy8gdW5saWtlIENocm9tZSwgd2hpY2ggaXMgZmFzdCkuXG4vL1xuLy8gTm90ZTogd2UgYXV0b21hdGljYWxseSBpbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGVcbi8vIGNhbnZhcyAoYXMgbmVlZGVkKSB3aGVuIHJlbmRlcmluZyB0byBpdC5cbi8vXG5jb25zdCBDQU5WQVNfV0lEVEggPSAxNiwgQ0FOVkFTX0hFSUdIVCA9IDE2O1xuXG4vKiogQHR5cGUge1NwZWVkeUdMfSBTaW5nbGV0b24gKi9cbmxldCBpbnN0YW5jZSA9IG51bGw7XG5cbi8qKiBAdHlwZSB7UG93ZXJQcmVmZXJlbmNlfSBwb3dlciBwcmVmZXJlbmNlICovXG5sZXQgcG93ZXJQcmVmZXJlbmNlID0gREVGQVVMVF9QT1dFUl9QUkVGRVJFTkNFO1xuXG5cblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBXZWJHTCBSZW5kZXJpbmcgQ29udGV4dFxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5R0wgZXh0ZW5kcyBPYnNlcnZhYmxlXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0ga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihrZXkpXG4gICAge1xuICAgICAgICBVdGlscy5hc3NlcnQoa2V5ID09PSBTSU5HTEVUT05fS0VZKTtcbiAgICAgICAgc3VwZXIoKTtcblxuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSBpbnRlcm5hbCBmbGFnICovXG4gICAgICAgIHRoaXMuX3JlaW5pdGlhbGl6ZU9uQ29udGV4dExvc3MgPSB0cnVlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAqL1xuICAgICAgICB0aGlzLl9jYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXModGhpcy5fcmVpbml0aWFsaXplLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQgKi9cbiAgICAgICAgdGhpcy5fZ2wgPSBudWxsO1xuXG5cblxuICAgICAgICAvLyBjcmVhdGUgV2ViR0wyIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgIHRoaXMuX2dsID0gdGhpcy5fY3JlYXRlQ29udGV4dCh0aGlzLl9jYW52YXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBTaW5nbGV0b25cbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5R0x9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBpbnN0YW5jZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UgfHwgKGluc3RhbmNlID0gbmV3IFNwZWVkeUdMKFNJTkdMRVRPTl9LRVkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgV2ViR0wgUmVuZGVyaW5nIENvbnRleHRcbiAgICAgKiBCZSBjYXJlZnVsIG5vdCB0byBjYWNoZSB0aGlzLCBhcyB0aGUgV2ViR0wgUmVuZGVyaW5nIENvbnRleHQgbWF5IGJlIGxvc3QhXG4gICAgICogQHJldHVybnMge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gICAgZ2V0IGdsKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzXG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBjYW52YXMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBXZWJHTC1jYXBhYmxlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlaW5pdGlhbGl6ZSB0byBiZSBjYWxsZWQgaWYgd2UgZ2V0IGEgV2ViR0wgY29udGV4dCBsb3NzIGV2ZW50XG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIF9jcmVhdGVDYW52YXMocmVpbml0aWFsaXplKVxuICAgIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gVXRpbHMuY3JlYXRlQ2FudmFzKENBTlZBU19XSURUSCwgQ0FOVkFTX0hFSUdIVCk7XG5cbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBldiA9PiB7XG4gICAgICAgICAgICBVdGlscy53YXJuaW5nKGBMb3N0IFdlYkdMMiBjb250ZXh0YCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlaW5pdGlhbGl6ZSwgMCk7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgLypjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBldiA9PiB7XG4gICAgICAgICAgICBVdGlscy53YXJuaW5nKGBSZXN0b3JlZCBXZWJHTDIgY29udGV4dGApO1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZmFsc2UpOyovXG5cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBXZWJHTDIgUmVuZGVyaW5nIENvbnRleHRcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICAgKiBAcmV0dXJucyB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICBfY3JlYXRlQ29udGV4dChjYW52YXMpXG4gICAge1xuICAgICAgICBVdGlscy5sb2coYENyZWF0aW5nIGEgJHtwb3dlclByZWZlcmVuY2V9IFdlYkdMMiByZW5kZXJpbmcgY29udGV4dC4uLmApO1xuXG4gICAgICAgIC8vIGRvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBXZWJHTDI/XG4gICAgICAgIGlmKHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcihgVGhpcyBhcHBsaWNhdGlvbiByZXF1aXJlcyBXZWJHTDIuIFBsZWFzZSB1c2UgYSBkaWZmZXJlbnQgYnJvd3Nlci5gKTtcblxuICAgICAgICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywge1xuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBwb3dlclByZWZlcmVuY2U6IHBvd2VyUHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLCAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9XZWJHTF9iZXN0X3ByYWN0aWNlcyNhdm9pZF9hbHBoYWZhbHNlX3doaWNoX2Nhbl9iZV9leHBlbnNpdmVcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgICAgIGRlc3luY2hyb25pemVkOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZighZ2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoYENhbid0IGNyZWF0ZSBhIFdlYkdMMiBSZW5kZXJpbmcgQ29udGV4dC4gVHJ5IGEgZGlmZmVyZW50IGJyb3dzZXIhYCk7XG5cbiAgICAgICAgcmV0dXJuIGdsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlaW5pdGlhbGl6ZSBXZWJHTFxuICAgICAqL1xuICAgIF9yZWluaXRpYWxpemUoKVxuICAgIHtcbiAgICAgICAgLy8gZGlzYWJsZSByZWluaXRpYWxpemF0aW9uP1xuICAgICAgICBpZighdGhpcy5fcmVpbml0aWFsaXplT25Db250ZXh0TG9zcylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyB3YXJuaW5nXG4gICAgICAgIFV0aWxzLndhcm5pbmcoYFJlaW5pdGlhbGl6aW5nIFdlYkdMMi4uLmApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgY2FudmFzXG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHRoaXMuX3JlaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IGNvbnRleHRcbiAgICAgICAgdGhpcy5fZ2wgPSB0aGlzLl9jcmVhdGVDb250ZXh0KHRoaXMuX2NhbnZhcyk7XG5cbiAgICAgICAgLy8gbm90aWZ5IG9ic2VydmVyczogd2UgaGF2ZSBhIG5ldyBjb250ZXh0IVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlY3JlYXRlIGFsbCB0ZXh0dXJlcy4uLlxuICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb3NlIHRoZSBXZWJHTCBjb250ZXh0LiBUaGlzIGlzIHVzZWQgdG8gbWFudWFsbHlcbiAgICAgKiBmcmVlIHJlc291cmNlcywgYW5kIGFsc28gZm9yIHB1cnBvc2VzIG9mIHRlc3RpbmdcbiAgICAgKiBAcmV0dXJucyB7V0VCR0xfbG9zZV9jb250ZXh0fVxuICAgICAqL1xuICAgIGxvc2VDb250ZXh0KClcbiAgICB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG5cbiAgICAgICAgLy8gbm90aGluZyB0byBkbz9cbiAgICAgICAgaWYoZ2wuaXNDb250ZXh0TG9zdCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGFwcHJvcHJpYXRlIGV4dGVuc2lvblxuICAgICAgICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgICAgICBpZighZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCdXRUJHTF9sb3NlX2NvbnRleHQgZXh0ZW5zaW9uIGlzIHVuYXZhaWxhYmxlJyk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSByZWluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuX3JlaW5pdGlhbGl6ZU9uQ29udGV4dExvc3MgPSBmYWxzZTtcblxuICAgICAgICAvLyBsb3NlIGNvbnRleHRcbiAgICAgICAgZXh0Lmxvc2VDb250ZXh0KCk7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb3NlICYgcmVzdG9yZSB0aGUgV2ViR0wgY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kc1RvUmVzdG9yZV1cbiAgICAgKiBAcmV0dXJuIHtTcGVlZHlQcm9taXNlPFdFQkdMX2xvc2VfY29udGV4dD59IHJlc29sdmVzIGFzIHNvb24gYXMgdGhlIGNvbnRleHQgaXMgcmVzdG9yZWRcbiAgICAgKi9cbiAgICBsb3NlQW5kUmVzdG9yZUNvbnRleHQoc2Vjb25kc1RvUmVzdG9yZSA9IDEpXG4gICAge1xuICAgICAgICBjb25zdCBtcyA9IE1hdGgubWF4KHNlY29uZHNUb1Jlc3RvcmUsIDApICogMTAwMDtcbiAgICAgICAgY29uc3QgZXh0ID0gdGhpcy5sb3NlQ29udGV4dCgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vZXh0LnJlc3RvcmVDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVpbml0aWFsaXplT25Db250ZXh0TG9zcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVpbml0aWFsaXplKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKGV4dCksIDApOyAvLyBuZXh0IGZyYW1lXG4gICAgICAgICAgICB9LCBtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvd2VyIHByZWZlcmVuY2UgZm9yIHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICogQHJldHVybnMge1Bvd2VyUHJlZmVyZW5jZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHBvd2VyUHJlZmVyZW5jZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gcG93ZXJQcmVmZXJlbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvd2VyIHByZWZlcmVuY2UgZm9yIHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtQb3dlclByZWZlcmVuY2V9IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHNldCBwb3dlclByZWZlcmVuY2UodmFsdWUpXG4gICAge1xuICAgICAgICAvLyB2YWxpZGF0ZVxuICAgICAgICBpZighKHZhbHVlID09PSAnZGVmYXVsdCcgfHwgdmFsdWUgPT09ICdsb3ctcG93ZXInIHx8IHZhbHVlID09PSAnaGlnaC1wZXJmb3JtYW5jZScpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBJbnZhbGlkIHBvd2VyUHJlZmVyZW5jZTogXCIke3ZhbHVlfVwiYCk7XG5cbiAgICAgICAgLy8gdGhlIHBvd2VyIHByZWZlcmVuY2Ugc2hvdWxkIGJlIHNldCBiZWZvcmUgd2UgY3JlYXRlIHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICAgIGlmKGluc3RhbmNlID09IG51bGwgfHwgcG93ZXJQcmVmZXJlbmNlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgcG93ZXJQcmVmZXJlbmNlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIHJlY3JlYXRlIHRoZSBjb250ZXh0IGlmIGl0IGFscmVhZHkgZXhpc3RzLiBFeHBlcmltZW50YWwuXG4gICAgICAgICAgICBpZihpbnN0YW5jZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmxvc2VBbmRSZXN0b3JlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufSIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIHNwZWVkeS1ncHUuanNcbiAqIEdQVS1hY2NlbGVyYXRlZCByb3V0aW5lcyBmb3IgQ29tcHV0ZXIgVmlzaW9uXG4gKi9cblxuaW1wb3J0IHsgU3BlZWR5R0wgfSBmcm9tICcuL3NwZWVkeS1nbCc7XG5pbXBvcnQgeyBTcGVlZHlUZXh0dXJlIH0gZnJvbSAnLi9zcGVlZHktdGV4dHVyZSc7XG5pbXBvcnQgeyBTcGVlZHlQcm9ncmFtQ2VudGVyIH0gZnJvbSAnLi9zcGVlZHktcHJvZ3JhbS1jZW50ZXInO1xuaW1wb3J0IHsgU3BlZWR5VGV4dHVyZVBvb2wgfSBmcm9tICcuL3NwZWVkeS10ZXh0dXJlLXBvb2wnO1xuaW1wb3J0IHsgU3BlZWR5VGV4dHVyZVVwbG9hZGVyIH0gZnJvbSAnLi9zcGVlZHktdGV4dHVyZS11cGxvYWRlcic7XG5pbXBvcnQgeyBTcGVlZHlNZWRpYVNvdXJjZSB9IGZyb20gJy4uL2NvcmUvc3BlZWR5LW1lZGlhLXNvdXJjZSc7XG5pbXBvcnQgeyBTcGVlZHlQcm9taXNlIH0gZnJvbSAnLi4vY29yZS9zcGVlZHktcHJvbWlzZSc7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi91dGlscy9vYnNlcnZhYmxlJztcblxuXG4vKipcbiAqIEdQVS1hY2NlbGVyYXRlZCByb3V0aW5lcyBmb3IgQ29tcHV0ZXIgVmlzaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVlZHlHUFUgZXh0ZW5kcyBPYnNlcnZhYmxlXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5R0x9IGNhY2hlZCByZWZlcmVuY2UgKi9cbiAgICAgICAgdGhpcy5fc3BlZWR5R0wgPSBTcGVlZHlHTC5pbnN0YW5jZTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVByb2dyYW1DZW50ZXJ9IEdQVS1iYXNlZCBwcm9ncmFtcyAqL1xuICAgICAgICB0aGlzLl9wcm9ncmFtcyA9IG5ldyBTcGVlZHlQcm9ncmFtQ2VudGVyKHRoaXMpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5VGV4dHVyZVBvb2x9IHRleHR1cmUgcG9vbCAqL1xuICAgICAgICB0aGlzLl90ZXh0dXJlUG9vbCA9IG5ldyBTcGVlZHlUZXh0dXJlUG9vbCh0aGlzKTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVRleHR1cmVVcGxvYWRlcn0gdGV4dHVyZSB1cGxvYWRlciAqL1xuICAgICAgICB0aGlzLl90ZXh0dXJlVXBsb2FkZXIgPSBuZXcgU3BlZWR5VGV4dHVyZVVwbG9hZGVyKHRoaXMpO1xuXG5cblxuICAgICAgICAvLyByZWNyZWF0ZSB0aGUgc3RhdGUgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuX3NwZWVkeUdMLnN1YnNjcmliZSh0aGlzLl9yZXNldCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjZXNzIHBvaW50IHRvIGFsbCBHUFUgcHJvZ3JhbXNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvZ3JhbUNlbnRlcn1cbiAgICAgKi9cbiAgICBnZXQgcHJvZ3JhbXMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJHTCBSZW5kZXJpbmcgQ29udGV4dFxuICAgICAqIEJlIGNhcmVmdWwgbm90IHRvIGNhY2hlIHRoaXMsIGFzIHRoZSBXZWJHTCBSZW5kZXJpbmcgQ29udGV4dCBtYXkgYmUgbG9zdCFcbiAgICAgKiBAcmV0dXJucyB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICBnZXQgZ2woKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwZWVkeUdMLmdsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNhbnZhc1xuICAgICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgY2FudmFzKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcGVlZHlHTC5jYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGV4dHVyZSBwb29sXG4gICAgICogQHJldHVybnMge1NwZWVkeVRleHR1cmVQb29sfVxuICAgICAqL1xuICAgIGdldCB0ZXh0dXJlUG9vbCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVBvb2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHRleHR1cmUgdG8gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7U3BlZWR5VGV4dHVyZX0gdGV4dHVyZVxuICAgICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gcmV0dXJuZWQgZm9yIGNvbnZlbmllbmNlXG4gICAgICovXG4gICAgcmVuZGVyVG9DYW52YXModGV4dHVyZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dHVyZS53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgICAgIC8vIGRvIHdlIG5lZWQgdG8gcmVzaXplIHRoZSBjYW52YXM/XG4gICAgICAgIGlmKHdpZHRoID4gY2FudmFzLndpZHRoIHx8IGhlaWdodCA+IGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIFV0aWxzLndhcm5pbmcoYFJlc2l6aW5nIHRoZSBjYW52YXMgdG8gJHt3aWR0aH0geCAke2hlaWdodH1gKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbmRlclxuICAgICAgICB0aGlzLnByb2dyYW1zLnV0aWxzLnJlbmRlclRvQ2FudmFzLm91dHB1dHMod2lkdGgsIGhlaWdodCwgbnVsbCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMudXRpbHMucmVuZGVyVG9DYW52YXModGV4dHVyZSk7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYW4gaW1hZ2UgdG8gdGhlIEdQVVxuICAgICAqIEBwYXJhbSB7U3BlZWR5TWVkaWFTb3VyY2V9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7U3BlZWR5VGV4dHVyZX0gb3V0cHV0VGV4dHVyZVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlUZXh0dXJlfSBvdXRwdXRUZXh0dXJlXG4gICAgICovXG4gICAgdXBsb2FkKHNvdXJjZSwgb3V0cHV0VGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlVXBsb2FkZXIudXBsb2FkKHNvdXJjZSwgb3V0cHV0VGV4dHVyZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgcmVzb3VyY2VzXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgcmVsZWFzZSgpXG4gICAge1xuICAgICAgICBVdGlscy5hc3NlcnQoIXRoaXMuaXNSZWxlYXNlZCgpKTtcblxuICAgICAgICAvLyByZWxlYXNlIGludGVybmFsIGNvbXBvbmVudHNcbiAgICAgICAgdGhpcy5fcHJvZ3JhbXMgPSB0aGlzLl9wcm9ncmFtcy5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVQb29sID0gdGhpcy5fdGV4dHVyZVBvb2wucmVsZWFzZSgpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlVXBsb2FkZXIgPSB0aGlzLl90ZXh0dXJlVXBsb2FkZXIucmVsZWFzZSgpO1xuXG4gICAgICAgIC8vIHVuc3Vic2NyaWJlXG4gICAgICAgIHRoaXMuX3NwZWVkeUdMLnVuc3Vic2NyaWJlKHRoaXMuX3Jlc2V0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFzIHRoaXMgU3BlZWR5R1BVIGJlZW4gcmVsZWFzZWQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWxlYXNlZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbXMgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb3NlICYgcmVzdG9yZSB0aGUgV2ViR0wgY29udGV4dCAodXNlZnVsIGZvciB0ZXN0aW5nIHB1cnBvc2VzKVxuICAgICAqIEByZXR1cm4ge1NwZWVkeVByb21pc2U8dm9pZD59IHJlc29sdmVzIGFzIHNvb24gYXMgdGhlIGNvbnRleHQgaXMgcmVzdG9yZWRcbiAgICAgKi9cbiAgICBsb3NlQW5kUmVzdG9yZVdlYkdMQ29udGV4dCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BlZWR5R0wubG9zZUFuZFJlc3RvcmVDb250ZXh0KCkudGhlbigoKSA9PiB2b2lkKDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgaW50ZXJuYWwgc3RhdGVcbiAgICAgKiAoY2FsbGVkIG9uIGNvbnRleHQgcmVzZXQpXG4gICAgICovXG4gICAgX3Jlc2V0KClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuaXNSZWxlYXNlZCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX3Byb2dyYW1zID0gbmV3IFNwZWVkeVByb2dyYW1DZW50ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVQb29sID0gbmV3IFNwZWVkeVRleHR1cmVQb29sKHRoaXMpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlVXBsb2FkZXIgPSBuZXcgU3BlZWR5VGV4dHVyZVVwbG9hZGVyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX25vdGlmeSgpO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzcGVlZHktbHNoLmpzXG4gKiBHUFUtYmFzZWQgTFNIIHRhYmxlcyBmb3IgZmFzdCBtYXRjaGluZyBvZiBiaW5hcnkgZGVzY3JpcHRvcnNcbiAqL1xuXG5pbXBvcnQgeyBTcGVlZHlUZXh0dXJlLCBTcGVlZHlEcmF3YWJsZVRleHR1cmUgfSBmcm9tICcuL3NwZWVkeS10ZXh0dXJlJztcbmltcG9ydCB7IFNwZWVkeURlc2NyaXB0b3JEQiB9IGZyb20gJy4vc3BlZWR5LWRlc2NyaXB0b3JkYic7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IE1BVENIX01BWF9JTkRFWCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbHMnO1xuXG4vKlxuICogICAgICAgICAgICAgIEFMRSdTIEdQVS1CQVNFRCBMU0ggRk9SIEFQUFJPWElNQVRFIEtOTiBNQVRDSElOR1xuICogICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIEhlcmUgaXMgbXkgdmFyaWFudCBvZiBMb2NhbGl0eSBTZW5zaXRpdmUgSGFzaGluZyBmb3IgR1BVLWJhc2VkIEtOTiBtYXRjaGluZyFcbiAqIEluZGljZXMgb2Yga2V5cG9pbnQgZGVzY3JpcHRvcnMgYXJlIHN0b3JlZCBpbiBzZXZlcmFsIHRhYmxlcywgZWFjaCB3aXRoIG1hbnlcbiAqIGJ1Y2tldHMgb2YgZml4ZWQgY2FwYWNpdHkuIEluIGEgbnV0c2hlbGwsIEkgY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgb2YgZml4ZWRcbiAqIHNpemUgdG8gbWF0Y2ggdGhlIGtleXBvaW50cy5cbiAqXG4gKiBCdWNrZXRzIGluIHZpZGVvIG1lbW9yeSBtYXkgZ2V0IGZ1bGwuIFdvdWxkbid0IGl0IGJlIGNvb2wgaWYgd2UgY291bGQgdXNlIGFcbiAqIHByb2JhYmlsaXN0aWMgYXBwcm9hY2ggdG8gbGV0IHVzIHdvcmsgd2l0aGluIHRoZWlyIHN0b3JhZ2UgY2FwYWNpdHk/XG4gKlxuICogTGV0IHRoZXJlIGJlIG4gYnVja2V0cyBpbiBhIHRhYmxlLCBlYWNoIHdpdGggc3RvcmFnZSBjYXBhY2l0eSBjIChob2xkaW5nXG4gKiB1cCB0byBjIGVsZW1lbnRzKS4gQnVja2V0cyBhcmUgbnVtYmVyZWQgZnJvbSAwIHRvIG4tMS5cbiAqXG4gKiBXZSBwaWNrIHVuaWZvcm1seSBhIHJhbmRvbSBidWNrZXQgdG8gc3RvcmUgYSBuZXcgZWxlbWVudCBpbiB0aGUgdGFibGUuIExldFxuICogWCBiZSB0aGUgY2hvc2VuIGJ1Y2tldC4gVGhlIHByb2JhYmlsaXR5IHRoYXQgd2UnbGwgc3RvcmUgdGhlIG5ldyBlbGVtZW50IGluXG4gKiBhbnkgcGFydGljdWxhciBidWNrZXQgayBpczpcbiAqXG4gKiBQKFggPSBrKSA9IDEvbiAgIChrID0gMCwgMSwgMiwgLi4uIG4tMSlcbiAqXG4gKiBPbiBhdmVyYWdlLCBlYWNoIG5ldyBlbGVtZW50IHN0b3JlZCBpbiB0aGUgdGFibGUgaW5zZXJ0cyAxL24gb2YgYW4gZWxlbWVudFxuICogaW4gZWFjaCBidWNrZXQuIElmIHdlIGFkZCBtIG5ldyBlbGVtZW50cyB0byB0aGUgdGFibGUsIGVhY2ggYnVja2V0IHJlY2VpdmVzXG4gKiBtL24gZWxlbWVudHMsIG9uIGF2ZXJhZ2UoKikuXG4gKlxuICogKCopIGZvciBhbGwgaywgZGVmaW5lIHRoZSBJayByYW5kb20gdmFyaWFibGUgYXMgMSBpZiBYID0gayBhbmQgMCBvdGhlcndpc2UuXG4gKiAgICAgSXQgZm9sbG93cyB0aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBvZiBJaywgRShJayksIGlzIDEvbiBmb3IgYWxsIGsuIEluXG4gKiAgICAgYWRkaXRpb24sIHRoZSBleHBlY3RlZCB2YWx1ZSBvZiAobSBJaykgaXMgbSAqIEUoaWspID0gbS9uLlxuICpcbiAqIE5vdyBsZXQgWWkgYmUgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbnNlcnRlZCBpbiBidWNrZXQgaSBpbiBtIGFkZGl0aW9ucyB0b1xuICogdGhlIHRhYmxlLiBXZSBtb2RlbCBZaSBhcyBQb2lzc29uKG0vbiksIHNpbmNlIG9uIGF2ZXJhZ2UsIG0gYWRkaXRpb25zIHRvXG4gKiB0aGUgdGFibGUgcmVzdWx0IGluIG0vbiBuZXcgZWxlbWVudHMgYmVpbmcgaW5zZXJ0ZWQgaW4gYnVja2V0IGkuIEJ1Y2tldHNcbiAqIGFyZSBwaWNrZWQgaW5kZXBlbmRlbnRseS4gSGVuY2UsIGZvciBhbGwgaSwgdGhlIHByb2JhYmlsaXR5IHRoYXQgd2UgaW5zZXJ0XG4gKiBxIGVsZW1lbnRzIGluIGJ1Y2tldCBpIGluIG0gYWRkaXRpb25zIHRvIHRoZSB0YWJsZSBpczpcbiAqXG4gKiBQKFlpID0gcSkgPSAobS9uKV5xICogZXhwKC1tL24pIC8gcSEgICAocSA9IDAsIDEsIDIuLi4pXG4gKlxuICogR2l2ZW4gdGhhdCBlYWNoIGJ1Y2tldCBoYXMgc3RvcmFnZSBjYXBhY2l0eSBjLCB3ZSByZXF1aXJlIFlpIDw9IGMgd2l0aCBhXG4gKiBoaWdoIHByb2JhYmlsaXR5IHAgKHNheSwgcCA9IDAuOTkpLiBUaGlzIG1lYW5zIHRoYXQsIGluIG0gYWRkaXRpb25zLCB3ZVxuICogZG9uJ3Qgd2FudCB0byBleGNlZWQgdGhlIGNhcGFjaXR5IGMgd2l0aCBoaWdoIHByb2JhYmlsaXR5LiBTbywgbGV0IHVzIGZpbmRcbiAqIGEgKGxhcmdlKSB2YWx1ZSBvZiBtIHN1Y2ggdGhhdDpcbiAqXG4gKiBQKFlpIDw9IGMpID49IHBcbiAqXG4gKiBTb3VuZHMgZ29vZCEgV2UgY2FuIGZpbmQgdGhlIGxhcmdlc3QgbWF0Y2hpbmcgbSB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEkgZG9uJ3QgdGhpbmsgd2UgbmVlZCB0byBlbmZvcmNlIGEgaGlnaCBwcm9iYWJpbGl0eSB0aGF0IEFMTCBidWNrZXRzIHN0YXlcbiAqIHdpdGhpbiB0aGVpciBjYXBhY2l0eSAtIG4gaXMgbGFyZ2UsIHdlIG5lZWQgdG8gdXNlIHRoZSBhdmFpbGFibGUgc3BhY2UsIGFuZFxuICogd2UgaGF2ZSBtdWx0aXBsZSB0YWJsZXMgYW55d2F5LlxuICpcbiAqIEluIHByYWN0aWNlLCB0aGUgYXNzdW1wdGlvbiB0aGF0IGJ1Y2tldHMgYXJlIHBpY2tlZCB1bmlmb3JtbHkgZG9lc24ndCBob2xkOlxuICoga2V5cG9pbnRzIHRoYXQgYXJlIG5lYXJieSB0ZW5kIHRvIGhhdmUgc2ltaWxhciBkZXNjcmlwdG9ycyBhbmQgYnVja2V0cyBhcmVcbiAqIHBpY2tlZCBhY2NvcmRpbmcgdG8gdGhvc2UgZGVzY3JpcHRvcnMuIFN0aWxsLCB0aGlzIG1vZGVsIHdvcmtzIHdlbGwgZW5vdWdoXG4gKiBpbiBwcmFjdGljZSBhbmQgaXQgaXMgc2ltcGxlISBUaGF0J3Mgd2hhdCBJIGxpa2UgYWJvdXQgaXQhXG4gKlxuICogLi4uIG5vdywgaG93IEkgYWN0dWFsbHkgZG8gdGhlIG1hdGNoaW5nIGlzIHRoZSB0aGVtZSBvZiB0aGUgbmV4dCBlcGlzb2RlIVxuICovXG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBEZWZhdWx0IG51bWJlciBvZiB0YWJsZXMgaW4gYSBMU0ggZGF0YSBzdHJ1Y3R1cmUgKi9cbmV4cG9ydCBjb25zdCBMU0hfREVGQVVMVF9OVU1CRVJfT0ZfVEFCTEVTID0gODtcblxuLyoqIEB0eXBlIHtudW1iZXJ9IERlZmF1bHQgbnVtYmVyIG9mIGJpdHMgb2YgYSBoYXNoICovXG5leHBvcnQgY29uc3QgTFNIX0RFRkFVTFRfSEFTSF9TSVpFID0gMTU7XG5cbi8qKiBAdHlwZSB7bnVtYmVyW119IEFjY2VwdGFibGUgbnVtYmVyIG9mIHRhYmxlcyBmb3IgYSBMU0ggZGF0YSBzdHJ1Y3R1cmUgKi9cbmV4cG9ydCBjb25zdCBMU0hfQUNDRVBUQUJMRV9OVU1CRVJfT0ZfVEFCTEVTID0gWzQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyXTtcblxuLyoqIEB0eXBlIHtudW1iZXJbXX0gQWNjZXB0YWJsZSB2YWx1ZXMgZm9yIGhhc2hTaXplLCBpbiBiaXRzICovXG5leHBvcnQgY29uc3QgTFNIX0FDQ0VQVEFCTEVfSEFTSF9TSVpFUyA9IFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMF07XG5cbi8qKiBAdHlwZSB7bnVtYmVyW119IEFjY2VwdGFibGUgc2l6ZXMgZm9yIGtleXBvaW50IGRlc2NyaXB0b3JzLCBpbiBieXRlcyAqL1xuZXhwb3J0IGNvbnN0IExTSF9BQ0NFUFRBQkxFX0RFU0NSSVBUT1JfU0laRVMgPSBbMzIsNjRdO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExTSFByb2ZpbGUgTFNIIHByb2ZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIHByb2ZpbGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYXBhY2l0eSBtYXhpbXVtIG51bWJlciBvZiBrZXlwb2ludHMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIHN1Y2ggYSB0YWJsZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhhc2hTaXplIG51bWJlciBvZiBiaXRzIGluIGEga2V5cG9pbnQgZGVzY3JpcHRvciBoYXNoIChhdCBtb3N0IDE2KVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRhYmxlQ291bnQgbnVtYmVyIG9mIHRhYmxlcywgcHJlZmVyYWJseSBhIHBvd2VyIG9mIDIgKGF0IG1vc3QgMTYpXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVja2V0Q2FwYWNpdHkgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBvZiBhIGJ1Y2tldCBvZiBhIHRhYmxlXG4gKi9cblxuLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLG51bWJlcik6TFNIUHJvZmlsZVtdfG51bGx9IGdlbmVyYXRlIExTSCBwcm9maWxlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBjYXBhY2l0eSAqL1xuY29uc3QgZ2VuZXJhdGVMU0hQcm9maWxlcyA9ICh0LGgscCkgPT4gIUxTSF9BQ0NFUFRBQkxFX0hBU0hfU0laRVMuaW5jbHVkZXMoaCkgfHwgIUxTSF9BQ0NFUFRBQkxFX05VTUJFUl9PRl9UQUJMRVMuaW5jbHVkZXModCkgPyBudWxsIDogW1xuICAgIHtcbiAgICAgICAgbmFtZTogJ3gtc21hbGwnLFxuICAgICAgICBidWNrZXRDYXBhY2l0eTogMSxcbiAgICAgICAgdGFibGVDb3VudDogdCxcbiAgICAgICAgaGFzaFNpemU6IGgsXG4gICAgICAgIGNhcGFjaXR5OiBmaW5kVGFibGVDYXBhY2l0eShoLCAxLCBwKSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3NtYWxsJyxcbiAgICAgICAgYnVja2V0Q2FwYWNpdHk6IDIsXG4gICAgICAgIHRhYmxlQ291bnQ6IHQsXG4gICAgICAgIGhhc2hTaXplOiBoLFxuICAgICAgICBjYXBhY2l0eTogZmluZFRhYmxlQ2FwYWNpdHkoaCwgMiwgcCksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdzbWFsbC1wbHVzJyxcbiAgICAgICAgYnVja2V0Q2FwYWNpdHk6IDMsXG4gICAgICAgIHRhYmxlQ291bnQ6IHQsXG4gICAgICAgIGhhc2hTaXplOiBoLFxuICAgICAgICBjYXBhY2l0eTogZmluZFRhYmxlQ2FwYWNpdHkoaCwgMywgcCksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdtZWRpdW0nLFxuICAgICAgICBidWNrZXRDYXBhY2l0eTogNCxcbiAgICAgICAgdGFibGVDb3VudDogdCxcbiAgICAgICAgaGFzaFNpemU6IGgsXG4gICAgICAgIGNhcGFjaXR5OiBmaW5kVGFibGVDYXBhY2l0eShoLCA0LCBwKSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ21lZGl1bS1wbHVzJyxcbiAgICAgICAgYnVja2V0Q2FwYWNpdHk6IDUsXG4gICAgICAgIHRhYmxlQ291bnQ6IHQsXG4gICAgICAgIGhhc2hTaXplOiBoLFxuICAgICAgICBjYXBhY2l0eTogZmluZFRhYmxlQ2FwYWNpdHkoaCwgNSwgcCksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdsYXJnZScsXG4gICAgICAgIGJ1Y2tldENhcGFjaXR5OiA2LFxuICAgICAgICB0YWJsZUNvdW50OiB0LFxuICAgICAgICBoYXNoU2l6ZTogaCxcbiAgICAgICAgY2FwYWNpdHk6IGZpbmRUYWJsZUNhcGFjaXR5KGgsIDYsIHApLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAneC1sYXJnZScsXG4gICAgICAgIGJ1Y2tldENhcGFjaXR5OiA4LFxuICAgICAgICB0YWJsZUNvdW50OiB0LFxuICAgICAgICBoYXNoU2l6ZTogaCxcbiAgICAgICAgY2FwYWNpdHk6IGZpbmRUYWJsZUNhcGFjaXR5KGgsIDgsIHApLFxuICAgIH0sXG5dO1xuXG4vL1xuLy8gTFNIIGhhc2ggc2VxdWVuY2VzOiByYW5kb20gYml0cyBpbiBpbmNyZWFzaW5nIG9yZGVyXG4vLyBXZSBnZW5lcmF0ZSBhIGZldyBzZXF1ZW5jZXMgKG9uZSBmb3IgZWFjaCB0YWJsZSkgc3VwcG9ydGluZyB1cCB0byAxNiBoYXNoIGJpdHNcbi8vIFdlIHBhZCBlYWNoIHNlcXVlbmNlIHdpdGggaW52YWxpZCB2YWx1ZXMgYXQgdGhlIGVuZCAtIHdlIHdhbnQgdG8gcGljayBhbnkgYml0IHdpdGggZXF1YWwgcHJvYmFiaWxpdHlcbi8vXG5cbi8qKiBAdHlwZWRlZiB7VWludDMyQXJyYXl9IEJpdFNlcXVlbmNlcyBmbGF0dGVuZWQgYXJyYXkgb2YgTFNIX1NFUVVFTkNFX0NPVU5UIHNlcXVlbmNlcyBvZiBMU0hfU0VRVUVOQ0VfTUFYTEVOIGVsZW1lbnRzIGVhY2ggLSBlYWNoIGVudHJ5IHJlcHJlc2VudHMgYSBiaXQgaW5kZXggKi9cbi8qKiBAdHlwZWRlZiB7T2JqZWN0PG51bWJlcixCaXRTZXF1ZW5jZXM+fSBCaXRTZXF1ZW5jZXNJbmRleGVkQnlEZXNjcmlwdG9yU2l6ZSAqL1xuLyoqIEB0eXBlZGVmIHtPYmplY3Q8bnVtYmVyLEJpdFNlcXVlbmNlc0luZGV4ZWRCeURlc2NyaXB0b3JTaXplPn0gTFNIU2VxdWVuY2VzICovXG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBvZiBhIHNlcXVlbmNlICovXG5leHBvcnQgY29uc3QgTFNIX1NFUVVFTkNFX01BWExFTiA9IE1hdGgubWF4KC4uLkxTSF9BQ0NFUFRBQkxFX0hBU0hfU0laRVMpO1xuXG4vKiogQHR5cGUge251bWJlcn0gbnVtYmVyIG9mIHNlcXVlbmNlcyBpbiBhIEJpdFNlcXVlbmNlcyBvYmplY3QgKi9cbmV4cG9ydCBjb25zdCBMU0hfU0VRVUVOQ0VfQ09VTlQgPSBNYXRoLm1heCguLi5MU0hfQUNDRVBUQUJMRV9OVU1CRVJfT0ZfVEFCTEVTKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbihCaXRTZXF1ZW5jZXMpOiBCaXRTZXF1ZW5jZXN9IFNvcnQgc3Vic2VxdWVuY2VzIG9mIHJhbmRvbSBiaXRzIGluIGFzY2VuZGluZyBvcmRlciAqL1xuY29uc3QgcGFydGl0aW9uZWRTb3J0ID0gc2VxID0+IChVdGlscy5yYW5nZShMU0hfU0VRVUVOQ0VfQ09VTlQpXG4gICAgLmZvckVhY2goaSA9PiBzZXEuc3ViYXJyYXkoaSAqIExTSF9TRVFVRU5DRV9NQVhMRU4sIChpKzEpICogTFNIX1NFUVVFTkNFX01BWExFTikuc29ydCgpKSxcbnNlcSk7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBCaXRTZXF1ZW5jZXMpOiBCaXRTZXF1ZW5jZXN9IFNldCB0aGUgbGFzdCBwIGVudHJpZXMgb2YgdGhlIGlucHV0IHN1YnNlcXVlbmNlcyB0byBhbiBpbnZhbGlkIHZhbHVlICovXG5jb25zdCBwYWRTZXF1ZW5jZXMgPSAocCwgc2VxKSA9PiAoVXRpbHMucmFuZ2UoTFNIX1NFUVVFTkNFX0NPVU5UKVxuICAgIC5mb3JFYWNoKGkgPT4gc2VxLnN1YmFycmF5KChpKzEpICogTFNIX1NFUVVFTkNFX01BWExFTiAtIHAsIChpKzEpICogTFNIX1NFUVVFTkNFX01BWExFTikuZmlsbCgweEJBRENBRkUpKSxcbnNlcSk7XG5cbi8qKiBAdHlwZSB7TFNIU2VxdWVuY2VzfSB0aGUgYml0cyB3ZSBwaWNrIHRvIGZvcm0gdGhlIGhhc2hlcywgbGFpZCBvdXQgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBpbmRleGVkIGJ5IGRlc2NyaXB0b3JTaXplIGFuZCBoYXNoU2l6ZSAqL1xuY29uc3QgTFNIX1NFUVVFTkNFUyA9IChmID0+IExTSF9BQ0NFUFRBQkxFX0hBU0hfU0laRVMucmVkdWNlKChwLG8pID0+ICgocFtvXT1mKG8pKSwgcCksIHt9KSkoaCA9PiAoe1xuICAgIC8vIGZvciAyNTYtYml0IGRlc2NyaXB0b3JzXG4gICAgMzI6IHBhcnRpdGlvbmVkU29ydChwYWRTZXF1ZW5jZXMoTFNIX1NFUVVFTkNFX01BWExFTiAtIGgsIG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgIC4uLihVdGlscy5zaHVmZmxlKFV0aWxzLnJhbmdlKDI1NikpKSxcbiAgICAgICAgLi4uKFV0aWxzLnNodWZmbGUoVXRpbHMucmFuZ2UoMjU2KSkpLFxuICAgICAgICAuLi4oVXRpbHMuc2h1ZmZsZShVdGlscy5yYW5nZSgyNTYpKSksXG4gICAgXS5zbGljZSgwLCBMU0hfU0VRVUVOQ0VfQ09VTlQgKiBMU0hfU0VRVUVOQ0VfTUFYTEVOKSkpKSxcblxuICAgIC8vIGZvciA1MTItYml0IGRlc2NyaXB0b3JzXG4gICAgNjQ6IHBhcnRpdGlvbmVkU29ydChwYWRTZXF1ZW5jZXMoTFNIX1NFUVVFTkNFX01BWExFTiAtIGgsIG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgIC4uLihVdGlscy5zaHVmZmxlKFV0aWxzLnJhbmdlKDUxMikpKSxcbiAgICAgICAgLi4uKFV0aWxzLnNodWZmbGUoVXRpbHMucmFuZ2UoNTEyKSkpLFxuICAgIF0uc2xpY2UoMCwgTFNIX1NFUVVFTkNFX0NPVU5UICogTFNIX1NFUVVFTkNFX01BWExFTikpKSksXG59KSk7XG5cbi8vXG4vLyBNaXNjXG4vL1xuXG4vKiogQHR5cGUge251bWJlcn0gd2UgdXNlIFJHQkE4IHRleHR1cmVzICgzMiBiaXRzIHBlciBwaXhlbCkgYXMgc3RvcmFnZSAqL1xuY29uc3QgTFNIX0JZVEVTUEVSUElYRUwgPSA0O1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6IG51bWJlcn0gbmV4dCBwb3dlciBvZiAyICovXG5jb25zdCBuZXh0UG90ID0geCA9PiB4ID4gMSA/IDEgPDwgTWF0aC5jZWlsKE1hdGgubG9nMih4KSkgOiAxO1xuXG5cblxuLyoqXG4gKiBHUFUtYmFzZWQgTFNIIHRhYmxlcyBmb3IgZmFzdCBtYXRjaGluZyBvZiBiaW5hcnkgZGVzY3JpcHRvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeUxTSFxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTcGVlZHlUZXh0dXJlfSBsc2hUYWJsZXMgdGV4dHVyZSB0byBiZSB1c2VkIGFzIHRoZSBzZXQgb2YgTFNIIHRhYmxlc1xuICAgICAqIEBwYXJhbSB7U3BlZWR5VGV4dHVyZX0gZGVzY3JpcHRvckRCIHRleHR1cmUgdG8gYmUgdXNlZCBhcyB0aGUgZGVzY3JpcHRvciBkYXRhYmFzZVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBkZXNjcmlwdG9ycyB0aGUgYmluYXJ5IGRlc2NyaXB0b3JzIHlvdSdsbCBzdG9yZSAobWFrZSBzdXJlIHlvdSBkb24ndCByZXBlYXQgdGhlbSwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBqdXN0IHdhc3RlIHNwYWNlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFibGVDb3VudF0gbnVtYmVyIG9mIExTSCB0YWJsZXMsIHByZWZlcmFibHkgYSBwb3dlciBvZiB0d29cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hhc2hTaXplXSBudW1iZXIgb2YgYml0cyBvZiBhIGhhc2ggb2YgYSBkZXNjcmlwdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9iYWJpbGl0eV0gcHJvYmFiaWxpdHkgb2Ygbm8gZGlzY2FyZCBldmVudHMgaGFwcGVuaW5nIGluIHRoZSB0aGVvcmV0aWNhbCBtb2RlbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxzaFRhYmxlcywgZGVzY3JpcHRvckRCLCBkZXNjcmlwdG9ycywgdGFibGVDb3VudCA9IExTSF9ERUZBVUxUX05VTUJFUl9PRl9UQUJMRVMsIGhhc2hTaXplID0gTFNIX0RFRkFVTFRfSEFTSF9TSVpFLCBwcm9iYWJpbGl0eSA9IDAuOTUpXG4gICAge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yQ291bnQgPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JTaXplID0gZGVzY3JpcHRvckNvdW50ID4gMCA/IGRlc2NyaXB0b3JzWzBdLmJ5dGVMZW5ndGggOiAwO1xuICAgICAgICBjb25zdCBsc2hQcm9maWxlcyA9IGdlbmVyYXRlTFNIUHJvZmlsZXModGFibGVDb3VudCwgaGFzaFNpemUsIHByb2JhYmlsaXR5KTtcblxuICAgICAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgICAgICBVdGlscy5hc3NlcnQoZGVzY3JpcHRvckNvdW50ID4gMCwgYENhbid0IGJ1aWxkIExTSCB0YWJsZXMgd2l0aG91dCBkZXNjcmlwdG9ycyFgKTtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KExTSF9BQ0NFUFRBQkxFX0RFU0NSSVBUT1JfU0laRVMuaW5jbHVkZXMoZGVzY3JpcHRvclNpemUpLCBgQ2FuJ3QgYnVpbGQgTFNIIHRhYmxlczogdW5hY2NlcHRhYmxlIGRlc2NyaXB0b3Igc2l6ZSBvZiAke2Rlc2NyaXB0b3JTaXplfSBieXRlc2ApO1xuICAgICAgICBVdGlscy5hc3NlcnQoZGVzY3JpcHRvcnMuZmluZEluZGV4KGQgPT4gZC5ieXRlTGVuZ3RoICE9PSBkZXNjcmlwdG9yU2l6ZSkgPCAwLCBgQ2FuJ3QgYnVpbGQgTFNIIHRhYmxlczogaW5jb3JyZWN0bHkgc2l6ZWQgZGVzY3JpcHRvcnMuIEV4cGVjdGVkICR7ZGVzY3JpcHRvclNpemV9IGJ5dGVzIGZvciBlYWNoYCk7XG4gICAgICAgIFV0aWxzLmFzc2VydChkZXNjcmlwdG9yQ291bnQgPCBNQVRDSF9NQVhfSU5ERVgsIGBDYW4ndCBidWlsZCBMU0ggdGFibGVzOiB0b28gbWFueSBkZXNjcmlwdG9ycyAoJHtkZXNjcmlwdG9ycy5sZW5ndGh9KWApO1xuICAgICAgICBVdGlscy5hc3NlcnQobHNoUHJvZmlsZXMgIT0gbnVsbCwgYENhbid0IGJ1aWxkIExTSCB0YWJsZXM6IHVuYWNjZXB0YWJsZSBudW1iZXIgb2YgdGFibGVzICgke3RhYmxlQ291bnR9KSB4IGhhc2ggc2l6ZSAoJHtoYXNoU2l6ZX0pYCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtMU0hQcm9maWxlfSBMU0ggcHJvZmlsZSAqL1xuICAgICAgICB0aGlzLl9wcm9maWxlID0gbHNoUHJvZmlsZXMuZmluZChwcm9maWxlID0+IGRlc2NyaXB0b3JDb3VudCA8PSBwcm9maWxlLmNhcGFjaXR5KSB8fCBsc2hQcm9maWxlc1tsc2hQcm9maWxlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gZGVzY3JpcHRvciBzaXplLCBpbiBieXRlcyAqL1xuICAgICAgICB0aGlzLl9kZXNjcmlwdG9yU2l6ZSA9IGRlc2NyaXB0b3JTaXplO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgb2YgZGVzY3JpcHRvcnMgKi9cbiAgICAgICAgdGhpcy5fZGVzY3JpcHRvckNvdW50ID0gZGVzY3JpcHRvckNvdW50O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Qml0U2VxdWVuY2VzfSBiaXQgc2VxdWVuY2VzICovXG4gICAgICAgIHRoaXMuX3NlcXVlbmNlcyA9IHRoaXMuX3BpY2tTZXF1ZW5jZXModGhpcy5fZGVzY3JpcHRvclNpemUpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5VGV4dHVyZX0gTFNIIHRhYmxlcyBzdG9yaW5nIGluZGljZXMgb2YgZGVzY3JpcHRvcnMgKi9cbiAgICAgICAgdGhpcy5fdGFibGVzID0gdGhpcy5fY3JlYXRlU3RhdGljVGFibGVzKGxzaFRhYmxlcywgdGhpcy5fc2VxdWVuY2VzLCBkZXNjcmlwdG9ycywgZGVzY3JpcHRvclNpemUpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5VGV4dHVyZX0gYSBzdG9yYWdlIG9mIGRlc2NyaXB0b3JzICovXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0b3JEQiA9IFNwZWVkeURlc2NyaXB0b3JEQi5jcmVhdGUoZGVzY3JpcHRvckRCLCBkZXNjcmlwdG9ycywgZGVzY3JpcHRvclNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0b3Igc2l6ZSwgaW4gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkZXNjcmlwdG9yU2l6ZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRvclNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGRlc2NyaXB0b3JzIHN0b3JlZCBpbiB0aGlzIExTSCBkYXRhIHN0cnVjdHVyZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0b3JDb3VudCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRvckNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExTSCBiaXQgc2VxdWVuY2VzXG4gICAgICogQHJldHVybnMge0JpdFNlcXVlbmNlc31cbiAgICAgKi9cbiAgICBnZXQgc2VxdWVuY2VzKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXF1ZW5jZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGJpdHMgdGhhdCBtYWtlIGEgaGFzaFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhhc2hTaXplKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9maWxlLmhhc2hTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGRlc2NyaXB0b3JzIHRoYXQgY2FuIGJlIHN0b3JlZCBpbiBhIGJ1Y2tldCBvZiBhIHRhYmxlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgYnVja2V0Q2FwYWNpdHkoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2ZpbGUuYnVja2V0Q2FwYWNpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgYnVja2V0cyBwZXIgdGFibGUgZG8gd2UgaGF2ZT9cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBidWNrZXRzUGVyVGFibGUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDEgPDwgdGhpcy5fcHJvZmlsZS5oYXNoU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgTFNIIHRhYmxlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRhYmxlQ291bnQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2ZpbGUudGFibGVDb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIG9uZSBMU0ggdGFibGUsIGluIGJ5dGVzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGFibGVTaXplKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNQZXJUYWJsZSAqIHRoaXMuYnVja2V0Q2FwYWNpdHkgKiBMU0hfQllURVNQRVJQSVhFTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIGFsbCBMU0ggdGFibGVzIGNvbWJpbmVkLCBpbiBieXRlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRvdGFsU2l6ZSgpXG4gICAge1xuICAgICAgICAvLyBhY3R1YWxseSwgdGhlIHRvdGFsIG1lbW9yeSBpbiBWUkFNIG1heSBiZSBhIGJpdCBsYXJnZXIgdGhhblxuICAgICAgICAvLyB0aGlzIHZhbHVlLCBkZXBlbmRpbmcgb24gdGhlIGFjdHVhbCBzaXplIG9mIHRoZSB0ZXh0dXJlXG4gICAgICAgIHJldHVybiB0aGlzLnRhYmxlQ291bnQgKiB0aGlzLnRhYmxlU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMU0ggdGFibGVzIHRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCB0YWJsZXMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhYmxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgZGVzY3JpcHRvcnNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCBkZXNjcmlwdG9yREIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0b3JEQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaWNrIHRoZSBhcHByb3ByaWF0ZSBMU0ggc2VxdWVuY2VzIGZvciBhIHBhcnRpY3VsYXIgZGVzY3JpcHRvciBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc2NyaXB0b3JTaXplIGluIGJ5dGVzXG4gICAgICogQHJldHVybnMge0JpdFNlcXVlbmNlc31cbiAgICAgKi9cbiAgICBfcGlja1NlcXVlbmNlcyhkZXNjcmlwdG9yU2l6ZSlcbiAgICB7XG4gICAgICAgIFV0aWxzLmFzc2VydChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTFNIX1NFUVVFTkNFUywgdGhpcy5oYXNoU2l6ZSkpO1xuICAgICAgICBVdGlscy5hc3NlcnQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKExTSF9TRVFVRU5DRVNbdGhpcy5oYXNoU2l6ZV0sIGRlc2NyaXB0b3JTaXplKSk7XG5cbiAgICAgICAgcmV0dXJuIExTSF9TRVFVRU5DRVNbdGhpcy5oYXNoU2l6ZV1bZGVzY3JpcHRvclNpemVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBMU0ggdGFibGVzXG4gICAgICogQHBhcmFtIHtTcGVlZHlUZXh0dXJlfSB0ZXh0dXJlIG91dHB1dCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtCaXRTZXF1ZW5jZXN9IHNlcXVlbmNlcyBiaXQgc2VxdWVuY2VzXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5W119IGRlc2NyaXB0b3JzIG5vbi1lbXB0eSBhcnJheSBvZiBiaW5hcnkgZGVzY3JpcHRvcnMsIEFMTCBIQVZJTkcgVEhFIFNBTUUgU0laRVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXNjcmlwdG9yU2l6ZSBpbiBieXRlc1xuICAgICAqIEByZXR1cm5zIHtTcGVlZHlUZXh0dXJlfSB0ZXh0dXJlXG4gICAgICovXG4gICAgX2NyZWF0ZVN0YXRpY1RhYmxlcyh0ZXh0dXJlLCBzZXF1ZW5jZXMsIGRlc2NyaXB0b3JzLCBkZXNjcmlwdG9yU2l6ZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IEVORF9PRl9MSVNUID0gMHhGRkZGRkZGRjtcbiAgICAgICAgY29uc3QgcHJvZmlsZU5hbWUgPSB0aGlzLl9wcm9maWxlLm5hbWU7XG4gICAgICAgIGNvbnN0IHRhYmxlQ2FwYWNpdHkgPSB0aGlzLl9wcm9maWxlLmNhcGFjaXR5O1xuICAgICAgICBjb25zdCB0YWJsZUNvdW50ID0gdGhpcy50YWJsZUNvdW50O1xuICAgICAgICBjb25zdCBidWNrZXRzUGVyVGFibGUgPSB0aGlzLmJ1Y2tldHNQZXJUYWJsZTtcbiAgICAgICAgY29uc3QgYnVja2V0U2l6ZSA9IHRoaXMuYnVja2V0Q2FwYWNpdHkgKiBMU0hfQllURVNQRVJQSVhFTDtcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSB0aGlzLmhhc2hTaXplO1xuICAgICAgICBjb25zdCBudW1iZXJPZlBpeGVscyA9IHRoaXMudGFibGVDb3VudCAqIHRoaXMuYnVja2V0c1BlclRhYmxlICogdGhpcy5idWNrZXRDYXBhY2l0eTsgLy8gd2F0Y2ggZm9yIG92ZXJmbG93P1xuICAgICAgICBjb25zdCB0ZXh0dXJlV2lkdGggPSBNYXRoLm1pbihuZXh0UG90KE1hdGguc3FydChudW1iZXJPZlBpeGVscykpLCA0MDk2KTsgLy8gNDA5NiBpcyBjb21wYXRpYmxlIHdpdGggbW9zdCBkZXZpY2VzIGFjY29yZGluZyB0byBNRE5cbiAgICAgICAgY29uc3QgdGV4dHVyZUhlaWdodCA9IE1hdGguY2VpbChudW1iZXJPZlBpeGVscyAvIHRleHR1cmVXaWR0aCk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mRGVzY3JpcHRvcnMgPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICAgICAgVXRpbHMuYXNzZXJ0KGhhc2hTaXplIDw9IExTSF9TRVFVRU5DRV9NQVhMRU4pO1xuICAgICAgICBVdGlscy5hc3NlcnQodGFibGVDb3VudCA8PSBMU0hfU0VRVUVOQ0VfQ09VTlQpO1xuICAgICAgICBVdGlscy5hc3NlcnQobnVtYmVyT2ZQaXhlbHMgPD0gdGV4dHVyZVdpZHRoICogdGV4dHVyZUhlaWdodCk7XG5cbiAgICAgICAgLy8gbG9nXG4gICAgICAgIGNvbnN0IE1FR0FCWVRFID0gMTA0ODU3NjtcbiAgICAgICAgVXRpbHMubG9nKFxuICAgICAgICAgICAgYEJ1aWxkaW5nICR7dGFibGVDb3VudH0gJHtwcm9maWxlTmFtZX0gTFNIIHRhYmxlcyB3aXRoICR7bnVtYmVyT2ZEZXNjcmlwdG9yc30gYCArXG4gICAgICAgICAgICBgJHtkZXNjcmlwdG9yU2l6ZSAqIDh9LWJpdCBkZXNjcmlwdG9ycyBlYWNoIGFuZCBoYXNoU2l6ZSA9ICR7aGFzaFNpemV9IGJpdHMgYCArXG4gICAgICAgICAgICBgKCR7dGV4dHVyZVdpZHRofXgke3RleHR1cmVIZWlnaHR9LCB3aXRoICR7KHRoaXMudGFibGVTaXplIC8gTUVHQUJZVEUpLnRvRml4ZWQoMil9IGAgK1xuICAgICAgICAgICAgYE1CIHBlciB0YWJsZSBhbmQgdG90YWwgc2l6ZSA9ICR7KHRoaXMudG90YWxTaXplIC8gTUVHQUJZVEUpLnRvRml4ZWQoMil9IE1CKSwgYFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHdhcm4gdGhlIHVzZXIgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGRlc2NyaXB0b3JzXG4gICAgICAgIGlmKG51bWJlck9mRGVzY3JpcHRvcnMgPiB0YWJsZUNhcGFjaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBleGNlZWRpbmdQZXJjZW50YWdlID0gMTAwICogbnVtYmVyT2ZEZXNjcmlwdG9ycyAvIHRhYmxlQ2FwYWNpdHk7XG4gICAgICAgICAgICBVdGlscy53YXJuaW5nKGBUaGVyZSBhcmUgdG9vIG1hbnkgZGVzY3JpcHRvcnMgKCR7bnVtYmVyT2ZEZXNjcmlwdG9yc30pIGZvciBhICR7cHJvZmlsZU5hbWV9IExTSCB0YWJsZS4gVGhhdCdzICR7ZXhjZWVkaW5nUGVyY2VudGFnZS50b0ZpeGVkKDIpfSUgb2YgaXRzIHRoZW9yZXRpY2FsIGNhcGFjaXR5LiBDb25zaWRlciBpbmNyZWFzaW5nIHRoZSBoYXNoU2l6ZSAoY3VycmVudGx5IHNldCB0byAke2hhc2hTaXplfSkgb3IgcmVkdWNpbmcgdGhlIG51bWJlciBvZiBkZXNjcmlwdG9ycyB0byBhdm9pZCBkZWdyYWRhdGlvbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBlbXB0eSBMU0ggdGFibGVzXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0ZXh0dXJlV2lkdGggKiB0ZXh0dXJlSGVpZ2h0ICogTFNIX0JZVEVTUEVSUElYRUwpO1xuICAgICAgICBjb25zdCBieXRlcyA9IChuZXcgVWludDhBcnJheShidWZmZXIpKS5maWxsKDB4RkYpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cbiAgICAgICAgLy8gc2h1ZmZsZSB0aGUgZGVzY3JpcHRvcnMuLi5cbiAgICAgICAgLy8gaXQgc2VlbXMgbGlrZSBhIGdvb2QgaWRlYSB0byBoYW5kbGUgY29sbGlzaW9ucyBvZiBzaW1pbGFyIGRlc2NyaXB0b3JzLFxuICAgICAgICAvLyB3aGljaCBtYXkgYmUgbG9jYXRlZCBuZXh0IHRvIGVhY2ggb3RoZXIgaW4gdGhlIGFycmF5XG4gICAgICAgIGNvbnN0IHBlcm11dGF0aW9uID0gVXRpbHMuc2h1ZmZsZShVdGlscy5yYW5nZShudW1iZXJPZkRlc2NyaXB0b3JzKSk7XG5cbiAgICAgICAgLy8gZm9yIGVhY2ggZGVzY3JpcHRvclxuICAgICAgICAvLyBkbyBldmVyeXRoaW5nIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IVxuICAgICAgICBjb25zdCBudW1iZXJPZkRpc2NhcmRlZERlc2NyaXB0b3JzUGVyVGFibGUgPSAobmV3IEFycmF5KHRhYmxlQ291bnQpKS5maWxsKDApO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZXNjcmlwdG9yczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9ySW5kZXggPSBwZXJtdXRhdGlvbltpXTsgLy9pO1xuICAgICAgICAgICAgY29uc3QgaGFzaGVzID0gdGhpcy5faGFzaENvZGVzKGRlc2NyaXB0b3JzW2Rlc2NyaXB0b3JJbmRleF0sIHNlcXVlbmNlcyk7XG5cbiAgICAgICAgICAgIC8vIGZvciBlYWNoIHRhYmxlXG4gICAgICAgICAgICBmb3IobGV0IHRhYmxlID0gMDsgdGFibGUgPCB0YWJsZUNvdW50OyB0YWJsZSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBoYXNoICYgbWVtb3J5IGFkZHJlc3Nlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZXNbdGFibGVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQnl0ZU9mZnNldCA9IHRhYmxlICogYnVja2V0c1BlclRhYmxlICogYnVja2V0U2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWNrZXRCeXRlT2Zmc2V0ID0gdGFibGVCeXRlT2Zmc2V0ICsgaGFzaCAqIGJ1Y2tldFNpemU7XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBFTkRfT0ZfTElTVDtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGVudHJ5Qnl0ZU9mZnNldCA9IDA7IGVudHJ5Qnl0ZU9mZnNldCA8IGJ1Y2tldFNpemU7IGVudHJ5Qnl0ZU9mZnNldCArPSBMU0hfQllURVNQRVJQSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYnVja2V0Qnl0ZU9mZnNldCArIGVudHJ5Qnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBkYXRhLmdldFVpbnQzMihieXRlT2Zmc2V0LCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGtleXBvaW50XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ID09IEVORF9PRl9MSVNUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldFVpbnQzMihieXRlT2Zmc2V0LCBkZXNjcmlwdG9ySW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBub3RlOiBpZiB0aGUgYnVja2V0IGlzIGZ1bGwsIHdlIGp1c3QgZGlzY2FyZCB0aGUgZW50cnkgOlxcXG4gICAgICAgICAgICAgICAgLy8gd2UgZ2l2ZSB0aGlzIGV2ZW50IGEgcHJvYmFiaWxpc3RpYyB0cmVhdG1lbnQgKHNlZSBhYm92ZSksXG4gICAgICAgICAgICAgICAgLy8gc28gaXQgaGFwcGVucyB3aXRoIGxvdyBwcm9iYWJpbGl0eVxuICAgICAgICAgICAgICAgIGlmKGluZGV4ICE9IEVORF9PRl9MSVNUKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkRpc2NhcmRlZERlc2NyaXB0b3JzUGVyVGFibGVbdGFibGVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2cgZGF0YSBmb3IgZnVydGhlciBzdHVkeVxuICAgICAgICBjb25zdCBudW1iZXJPZkRpc2NhcmRlZERlc2NyaXB0b3JzID0gbnVtYmVyT2ZEaXNjYXJkZWREZXNjcmlwdG9yc1BlclRhYmxlLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBudW1iZXJPZkRpc2NhcmRlZERlc2NyaXB0b3JzUGVyVGFibGUubWFwKGQgPT4gMTAwICogZCAvIG51bWJlck9mRGVzY3JpcHRvcnMpO1xuICAgICAgICBVdGlscy5sb2coXG4gICAgICAgICAgICBgV2hlbiBidWlsZGluZyAke3RhYmxlQ291bnR9ICR7cHJvZmlsZU5hbWV9IExTSCB0YWJsZXMgd2l0aCAke251bWJlck9mRGVzY3JpcHRvcnN9IGAgK1xuICAgICAgICAgICAgYCR7ZGVzY3JpcHRvclNpemUgKiA4fS1iaXQgZGVzY3JpcHRvcnMgZWFjaCBhbmQgaGFzaFNpemUgPSAke2hhc2hTaXplfSBiaXRzLCBgICtcbiAgICAgICAgICAgIGBJIGdvdCB0aGUgZm9sbG93aW5nIGRpc2NhcmQgcHJvZmlsZTogYCArIHByb2ZpbGUubWFwKHggPT4geC50b0ZpeGVkKDIpICsgJyUnKS5qb2luKCcsICcpICsgYC4gYCArXG4gICAgICAgICAgICBgQXZlcmFnZTogJHsoMTAwICogbnVtYmVyT2ZEaXNjYXJkZWREZXNjcmlwdG9ycyAvICh0YWJsZUNvdW50ICogbnVtYmVyT2ZEZXNjcmlwdG9ycykpLnRvRml4ZWQoMil9JS4gYCArXG4gICAgICAgICAgICBgTWluaW11bTogJHtNYXRoLm1pbiguLi5wcm9maWxlKS50b0ZpeGVkKDIpfSUuIGAgK1xuICAgICAgICAgICAgYFRhYmxlIGNhcGFjaXR5OiAke3RhYmxlQ2FwYWNpdHl9LmBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGxvYWQgdGhlIExTSCB0YWJsZXMgdG8gdGhlIEdQVVxuICAgICAgICB0ZXh0dXJlLnJlc2l6ZSh0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHQpO1xuICAgICAgICB0ZXh0dXJlLnVwbG9hZChieXRlcyk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2sgYml0cyBmcm9tIGEgYmluYXJ5IGRlc2NyaXB0b3JcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgYSBzaW5nbGUgZGVzY3JpcHRvclxuICAgICAqIEBwYXJhbSB7Qml0U2VxdWVuY2VzfSBzZXF1ZW5jZXMgZmxhdHRlbmVkIGFycmF5IG9mIHRhYmxlQ291bnQgc2VxdWVuY2VzIG9mIExTSF9TRVFVRU5DRV9NQVhMRU4gZWxlbWVudHMgZWFjaFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gaGFzaCBjb2RlIGZvciBlYWNoIHRhYmxlXG4gICAgICovXG4gICAgX2hhc2hDb2RlcyhkZXNjcmlwdG9yLCBzZXF1ZW5jZXMpXG4gICAge1xuICAgICAgICBjb25zdCB0YWJsZUNvdW50ID0gdGhpcy50YWJsZUNvdW50O1xuICAgICAgICBjb25zdCBoYXNoU2l6ZSA9IHRoaXMuaGFzaFNpemU7XG4gICAgICAgIGNvbnN0IGJ1Y2tldHNQZXJUYWJsZSA9IHRoaXMuYnVja2V0c1BlclRhYmxlO1xuICAgICAgICBjb25zdCBoYXNoZXMgPSBuZXcgQXJyYXkodGFibGVDb3VudCk7XG4gICAgICAgIC8vY29uc3QgZGVzY3JpcHRvclNpemUgPSBkZXNjcmlwdG9yLmxlbmd0aDtcblxuICAgICAgICAvLyBqdXN0IHRvIGJlIHN1cmUuLi5cbiAgICAgICAgVXRpbHMuYXNzZXJ0KFxuICAgICAgICAgICAgaGFzaFNpemUgPD0gTFNIX1NFUVVFTkNFX01BWExFTiAmJlxuICAgICAgICAgICAgc2VxdWVuY2VzLmxlbmd0aCA+PSBMU0hfU0VRVUVOQ0VfTUFYTEVOICogdGFibGVDb3VudFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGZvciBlYWNoIHRhYmxlXG4gICAgICAgIGZvcihsZXQgdGFibGUgPSAwOyB0YWJsZSA8IHRhYmxlQ291bnQ7IHRhYmxlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IExTSF9TRVFVRU5DRV9NQVhMRU4gKiB0YWJsZTtcblxuICAgICAgICAgICAgLy8gcGljayBiaXRzIFsgc2VxdWVuY2VzW29mZnNldF0gLi4gc2VxdWVuY2VzW29mZnNldCArIGhhc2hTaXplLTFdIF1cbiAgICAgICAgICAgIGxldCBoYXNoID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoYXNoU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJpdCA9IHNlcXVlbmNlc1tvZmZzZXQgKyBpXTtcbiAgICAgICAgICAgICAgICBsZXQgYiA9IGJpdCA+Pj4gMztcbiAgICAgICAgICAgICAgICBsZXQgbSA9IDEgPDwgKGJpdCAmIDcpO1xuXG4gICAgICAgICAgICAgICAgLy9VdGlscy5hc3NlcnQoYiA8IGRlc2NyaXB0b3JTaXplKTtcbiAgICAgICAgICAgICAgICBoYXNoID0gKGhhc2ggPDwgMSkgfCAoKGRlc2NyaXB0b3JbYl0gJiBtKSAhPSAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFsaWRhdGUgJiBzdG9yZVxuICAgICAgICAgICAgVXRpbHMuYXNzZXJ0KGhhc2ggPj0gMCAmJiBoYXNoIDwgYnVja2V0c1BlclRhYmxlKTtcbiAgICAgICAgICAgIGhhc2hlc1t0YWJsZV0gPSBoYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIGhhc2hlcztcbiAgICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZSBQKFggPD0gayksIHdoZXJlIFggfiBQb2lzc29uKGxhbWJkYSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYW1iZGEgcG9zaXRpdmUgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gayBub24tbmVnYXRpdmUgaW50ZWdlclxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY3VtdWxhdGl2ZVBvaXNzb24obGFtYmRhLCBrKVxue1xuICAgIGNvbnN0IGV4cCA9IE1hdGguZXhwKC1sYW1iZGEpO1xuICAgIGxldCBzdW0gPSAxLCBmYXQgPSAxLCBwb3cgPSAxO1xuXG4gICAgLy8gayBzaG91bGQgYmUgc21hbGwhISFcbiAgICBmb3IobGV0IGkgPSAxOyBpIDw9IGs7IGkrKylcbiAgICAgICAgc3VtICs9IChwb3cgKj0gbGFtYmRhKSAvIChmYXQgKj0gaSk7XG5cbiAgICByZXR1cm4gc3VtICogZXhwO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGtleXBvaW50IGRlc2NyaXB0b3JzIHRoYXQgYSB0YWJsZSBjYW4gaG9sZFxuICogQHBhcmFtIHtudW1iZXJ9IGhhc2hTaXplIHBvc2l0aXZlIGludGVnZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBidWNrZXRDYXBhY2l0eSBwb3NpdGl2ZSBpbnRlZ2VyXG4gKiBAcGFyYW0ge251bWJlcn0gW3Byb2JhYmlsaXR5XSBwcm9iYWJpbGl0eSBvZiBubyBkaXNjYXJkIGV2ZW50cyBoYXBwZW5pbmcgaW4gdGhlIHRoZW9yZXRpY2FsIG1vZGVsXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG9wdGltYWwgdGFibGUgY2FwYWNpdHlcbiAqL1xuZnVuY3Rpb24gZmluZFRhYmxlQ2FwYWNpdHkoaGFzaFNpemUsIGJ1Y2tldENhcGFjaXR5LCBwcm9iYWJpbGl0eSA9IDAuOTkpXG57XG4gICAgY29uc3QgbiA9IDEgPDwgaGFzaFNpemUgLy8gbnVtYmVyIG9mIGJ1Y2tldHNcbiAgICBjb25zdCBjID0gYnVja2V0Q2FwYWNpdHk7XG4gICAgY29uc3QgcCA9IHByb2JhYmlsaXR5O1xuXG4gICAgbGV0IGwgPSAxLCByID0gbiAqIGM7IC8vIHdhdGNoIGZvciBvdmVyZmxvdyFcbiAgICBsZXQgbSA9IDAsIHBtID0gMDtcblxuICAgIC8vIGJpbmFyeSBzZWFyY2hcbiAgICB3aGlsZShsIDwgcikge1xuICAgICAgICBtID0gTWF0aC5mbG9vcigobCArIHIpIC8gMik7XG4gICAgICAgIHBtID0gY3VtdWxhdGl2ZVBvaXNzb24obSAvIG4sIGMpO1xuXG4gICAgICAgIGlmKHBtID4gcCkgLy9pZigxLXBtIDwgMS1wKVxuICAgICAgICAgICAgbCA9IG0gKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByID0gbTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cbiIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIHNwZWVkeS1wcm9ncmFtLWNlbnRlci5qc1xuICogQW4gYWNjZXNzIHBvaW50IHRvIGFsbCBwcm9ncmFtcyB0aGF0IHJ1biBvbiB0aGUgR1BVXG4gKi9cblxuaW1wb3J0IHsgU3BlZWR5R1BVIH0gZnJvbSAnLi9zcGVlZHktZ3B1JztcbmltcG9ydCB7IFNwZWVkeVByb2dyYW1Hcm91cFV0aWxzIH0gZnJvbSAnLi9wcm9ncmFtcy91dGlscyc7XG5pbXBvcnQgeyBTcGVlZHlQcm9ncmFtR3JvdXBGaWx0ZXJzIH0gZnJvbSAnLi9wcm9ncmFtcy9maWx0ZXJzJztcbmltcG9ydCB7IFNwZWVkeVByb2dyYW1Hcm91cEtleXBvaW50cyB9IGZyb20gJy4vcHJvZ3JhbXMva2V5cG9pbnRzJztcbmltcG9ydCB7IFNwZWVkeVByb2dyYW1Hcm91cFB5cmFtaWRzIH0gZnJvbSAnLi9wcm9ncmFtcy9weXJhbWlkcyc7XG5pbXBvcnQgeyBTcGVlZHlQcm9ncmFtR3JvdXBUcmFuc2Zvcm1zIH0gZnJvbSAnLi9wcm9ncmFtcy90cmFuc2Zvcm1zJztcbmltcG9ydCB7IFNwZWVkeVByb2dyYW1Hcm91cCB9IGZyb20gJy4vc3BlZWR5LXByb2dyYW0tZ3JvdXAnO1xuXG4vKipcbiAqIEFuIGFjY2VzcyBwb2ludCB0byBhbGwgcHJvZ3JhbXMgdGhhdCBydW4gb24gdGhlIENQVVxuICogQWxsIHByb2dyYW0gZ3JvdXBzIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhpcyBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5UHJvZ3JhbUNlbnRlclxue1xuICAgIC8qKlxuICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTcGVlZHlHUFV9IGdwdSByZWZlcmVuY2UgdG8gU3BlZWR5R1BVXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3B1KVxuICAgIHtcbiAgICAgICAgLy8gTm90ZTogd2UgaW5zdGFudGlhdGUgdGhlIHByb2dyYW0gZ3JvdXBzIGxhemlseVxuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5R1BVfSByZWZlcmVuY2UgdG8gU3BlZWR5R1BVICovXG4gICAgICAgIHRoaXMuX2dwdSA9IGdwdTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVByb2dyYW1Hcm91cEZpbHRlcnN9IGltYWdlIGZpbHRlcnMgKi9cbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlQcm9ncmFtR3JvdXBUcmFuc2Zvcm1zfSBnZW9tZXRyaWMgdHJhbnNmb3JtYXRpb25zICovXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybXMgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5UHJvZ3JhbUdyb3VwUHlyYW1pZHN9IHB5cmFtaWRzICYgc2NhbGUtc3BhY2UgKi9cbiAgICAgICAgdGhpcy5fcHlyYW1pZHMgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5UHJvZ3JhbUdyb3VwS2V5cG9pbnRzfSBrZXlwb2ludCByb3V0aW5lcyAqL1xuICAgICAgICB0aGlzLl9rZXlwb2ludHMgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5UHJvZ3JhbUdyb3VwVXRpbHN9IHV0aWxpdHkgcHJvZ3JhbXMgKi9cbiAgICAgICAgdGhpcy5fdXRpbHMgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltYWdlIGZpbHRlcnMgJiBjb252b2x1dGlvbnNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvZ3JhbUdyb3VwRmlsdGVyc31cbiAgICAgKi9cbiAgICBnZXQgZmlsdGVycygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycyB8fCAodGhpcy5fZmlsdGVycyA9IG5ldyBTcGVlZHlQcm9ncmFtR3JvdXBGaWx0ZXJzKHRoaXMuX2dwdSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlb21ldHJpYyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvZ3JhbUdyb3VwVHJhbnNmb3Jtc31cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNmb3JtcygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtcyB8fCAodGhpcy5fdHJhbnNmb3JtcyA9IG5ldyBTcGVlZHlQcm9ncmFtR3JvdXBUcmFuc2Zvcm1zKHRoaXMuX2dwdSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltYWdlIHB5cmFtaWRzICYgc2NhbGUtc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvZ3JhbUdyb3VwUHlyYW1pZHN9XG4gICAgICovXG4gICAgZ2V0IHB5cmFtaWRzKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9weXJhbWlkcyB8fCAodGhpcy5fcHlyYW1pZHMgPSBuZXcgU3BlZWR5UHJvZ3JhbUdyb3VwUHlyYW1pZHModGhpcy5fZ3B1KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5cG9pbnQgZGV0ZWN0aW9uICYgZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvZ3JhbUdyb3VwS2V5cG9pbnRzfVxuICAgICAqL1xuICAgIGdldCBrZXlwb2ludHMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXBvaW50cyB8fCAodGhpcy5fa2V5cG9pbnRzID0gbmV3IFNwZWVkeVByb2dyYW1Hcm91cEtleXBvaW50cyh0aGlzLl9ncHUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHByb2dyYW1zXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb2dyYW1Hcm91cFV0aWxzfVxuICAgICAqL1xuICAgIGdldCB1dGlscygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXRpbHMgfHwgKHRoaXMuX3V0aWxzID0gbmV3IFNwZWVkeVByb2dyYW1Hcm91cFV0aWxzKHRoaXMuX2dwdSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgYWxsIHByb2dyYW1zIGZyb20gYWxsIGdyb3Vwcy4gWW91J2xsXG4gICAgICogbm8gbG9uZ2VyIGJlIGFibGUgdG8gdXNlIGFueSBvZiB0aGVtLlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHJlbGVhc2UoKVxuICAgIHtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywga2V5KSAmJiB0aGlzW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgIGlmKGdyb3VwIGluc3RhbmNlb2YgU3BlZWR5UHJvZ3JhbUdyb3VwKVxuICAgICAgICAgICAgICAgICAgICBncm91cC5yZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogc3BlZWR5LXByb2dyYW0tZ3JvdXAuanNcbiAqIEFuIGFic3RyYWN0IGdyb3VwIG9mIHByb2dyYW1zIHRoYXQgcnVuIG9uIHRoZSBHUFVcbiAqL1xuXG5pbXBvcnQgeyBTaGFkZXJEZWNsYXJhdGlvbiB9IGZyb20gJy4vc2hhZGVyLWRlY2xhcmF0aW9uJztcbmltcG9ydCB7IFNwZWVkeVByb2dyYW0gfSBmcm9tICcuL3NwZWVkeS1wcm9ncmFtJztcbmltcG9ydCB7IFNwZWVkeUdQVSB9IGZyb20gJy4vc3BlZWR5LWdwdSc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NwZWVkeS1wcm9ncmFtJykuU3BlZWR5UHJvZ3JhbU9wdGlvbnN9IFNwZWVkeVByb2dyYW1PcHRpb25zICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU3BlZWR5UHJvZ3JhbUhlbHBlcnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogU3BlZWR5UHJvZ3JhbU9wdGlvbnN9IHVzZXNQaW5ncG9uZ1JlbmRlcmluZ1xuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBTcGVlZHlQcm9ncmFtT3B0aW9uc30gcmVuZGVyc1RvQ2FudmFzXG4qL1xuXG4vKiogQGNvbnN0IHtTcGVlZHlQcm9ncmFtSGVscGVyc30gUHJvZ3JhbSBzZXR0aW5ncyBnZW5lcmF0b3IgKi9cbmNvbnN0IFBST0dSQU1fSEVMUEVSUyA9IE9iamVjdC5mcmVlemUoe1xuXG4gICAgLyoqXG4gICAgICogUGluZ3BvbmcgUmVuZGVyaW5nOiB0aGUgb3V0cHV0IHRleHR1cmUgb2YgYVxuICAgICAqIHByb2dyYW0gY2Fubm90IGJlIHVzZWQgYXMgYW4gaW5wdXQgdG8gaXRzZWxmLlxuICAgICAqIFRoaXMgaXMgYSBjb252ZW5pZW50IGhlbHBlciBpbiB0aGVzZSBzaXR1YXRpb25zXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb2dyYW1PcHRpb25zfVxuICAgICAqL1xuICAgIHVzZXNQaW5ncG9uZ1JlbmRlcmluZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpbmdwb25nOiB0cnVlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0byBjYW52YXNcbiAgICAgKiBVc2UgaXQgd2hlbiB3ZSdyZSBzdXBwb3NlZCB0byBzZWUgdGhlIHRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvZ3JhbU9wdGlvbnN9XG4gICAgICovXG4gICAgcmVuZGVyc1RvQ2FudmFzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVuZGVyVG9UZXh0dXJlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG5cbn0pO1xuXG5cbi8qKlxuICogU3BlZWR5UHJvZ3JhbUdyb3VwXG4gKiBBIHNlbWFudGljYWxseSBjb3JyZWxhdGVkIGdyb3VwXG4gKiBvZiBwcm9ncmFtcyB0aGF0IHJ1biBvbiB0aGUgR1BVXG4gKiBAYWJzdHJhY3RcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVByb2dyYW1Hcm91cFxue1xuICAgIC8qKlxuICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7U3BlZWR5R1BVfSBncHVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihncHUpXG4gICAge1xuICAgICAgICAvKiogQHR5cGUge1NwZWVkeUdQVX0gR1BVLWFjY2VsZXJhdGVkIHJvdXRpbmVzICovXG4gICAgICAgIHRoaXMuX2dwdSA9IGdwdTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVByb2dyYW1bXX0gdGhlIGxpc3Qgb2YgYWxsIHByb2dyYW1zIHRoYXQgYmVsb25nIHRvIHRoaXMgZ3JvdXAgKi9cbiAgICAgICAgdGhpcy5fcHJvZ3JhbXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNsYXJlIGEgcHJvZ3JhbVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9ncmFtIG5hbWVcbiAgICAgKiBAcGFyYW0ge1NoYWRlckRlY2xhcmF0aW9ufSBzaGFkZXJkZWNsIFNoYWRlciBkZWNsYXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3BlZWR5UHJvZ3JhbU9wdGlvbnN9IFtvcHRpb25zXSBQcm9ncmFtIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgZGVjbGFyZShuYW1lLCBzaGFkZXJkZWNsLCBvcHRpb25zID0ge30pXG4gICAge1xuICAgICAgICAvLyBsYXp5IGluc3RhbnRpYXRpb24gb2Yga2VybmVsc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoeSBjYXN0IGEgc3ltYm9sIHRvIHN5bWJvbD9cbiAgICAgICAgICAgICAgICAvLyBTdXBwcmVzcyBlcnJvciBUUzkwMDU6IERlY2xhcmF0aW9uIGVtaXQgZm9yIHRoaXMgZmlsZSByZXF1aXJlcyB1c2luZyBwcml2YXRlIG5hbWUgJ2tleScuXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtzeW1ib2x9ICovICggU3ltYm9sKG5hbWUpICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXNba2V5XSB8fCAodGhpc1trZXldID0gdGhpcy5fY3JlYXRlUHJvZ3JhbShzaGFkZXJkZWNsLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lYXQgaGVscGVycyB0byBiZSB1c2VkIHdoZW4gZGVjbGFyaW5nIHByb2dyYW1zXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb2dyYW1IZWxwZXJzfVxuICAgICAqL1xuICAgIGdldCBwcm9ncmFtKClcbiAgICB7XG4gICAgICAgIHJldHVybiBQUk9HUkFNX0hFTFBFUlM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgYWxsIHByb2dyYW1zIGZyb20gdGhpcyBncm91cFxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHJlbGVhc2UoKVxuICAgIHtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3Byb2dyYW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbXNbaV0ucmVsZWFzZSgpO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwYXduIGEgU3BlZWR5UHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7U2hhZGVyRGVjbGFyYXRpb259IHNoYWRlcmRlY2wgU2hhZGVyIGRlY2xhcmF0aW9uXG4gICAgICogQHBhcmFtIHtTcGVlZHlQcm9ncmFtT3B0aW9uc30gW29wdGlvbnNdIFByb2dyYW0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvZ3JhbX1cbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvZ3JhbShzaGFkZXJkZWNsLCBvcHRpb25zID0ge30pXG4gICAge1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gbmV3IFNwZWVkeVByb2dyYW0odGhpcy5fZ3B1LmdsLCBzaGFkZXJkZWNsLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbXMucHVzaChwcm9ncmFtKTtcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxufSIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIHNwZWVkeS1wcm9ncmFtLmpzXG4gKiBTcGVlZHlQcm9ncmFtIGNsYXNzXG4gKi9cblxuaW1wb3J0IHsgU3BlZWR5VGV4dHVyZSwgU3BlZWR5RHJhd2FibGVUZXh0dXJlIH0gZnJvbSAnLi9zcGVlZHktdGV4dHVyZSc7XG5pbXBvcnQgeyBTcGVlZHlQcm9taXNlIH0gZnJvbSAnLi4vY29yZS9zcGVlZHktcHJvbWlzZSc7XG5pbXBvcnQgeyBTaGFkZXJEZWNsYXJhdGlvbiB9IGZyb20gJy4vc2hhZGVyLWRlY2xhcmF0aW9uJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgTm90U3VwcG9ydGVkRXJyb3IsIElsbGVnYWxBcmd1bWVudEVycm9yLCBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IsIEdMRXJyb3IgfSBmcm9tICcuLi91dGlscy9lcnJvcnMnO1xuXG4vKiogQGNvbnN0IHtPYmplY3Q8c3RyaW5nLHN0cmluZz59IE1hcCB1bmlmb3JtIHR5cGUgdG8gYSBnbCBmdW5jdGlvbiAqL1xuY29uc3QgVU5JRk9STV9TRVRURVJTID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgJ3NhbXBsZXIyRCc6ICd1bmlmb3JtMWknLFxuICAgICdpc2FtcGxlcjJEJzondW5pZm9ybTFpJyxcbiAgICAndXNhbXBsZXIyRCc6J3VuaWZvcm0xaScsXG4gICAgJ2Zsb2F0JzogICAgICd1bmlmb3JtMWYnLFxuICAgICdpbnQnOiAgICAgICAndW5pZm9ybTFpJyxcbiAgICAndWludCc6ICAgICAgJ3VuaWZvcm0xdWknLFxuICAgICdib29sJzogICAgICAndW5pZm9ybTFpJyxcbiAgICAndmVjMic6ICAgICAgJ3VuaWZvcm0yZicsXG4gICAgJ3ZlYzMnOiAgICAgICd1bmlmb3JtM2YnLFxuICAgICd2ZWM0JzogICAgICAndW5pZm9ybTRmJyxcbiAgICAnaXZlYzInOiAgICAgJ3VuaWZvcm0yaScsXG4gICAgJ2l2ZWMzJzogICAgICd1bmlmb3JtM2knLFxuICAgICdpdmVjNCc6ICAgICAndW5pZm9ybTRpJyxcbiAgICAndXZlYzInOiAgICAgJ3VuaWZvcm0ydWknLFxuICAgICd1dmVjMyc6ICAgICAndW5pZm9ybTN1aScsXG4gICAgJ3V2ZWM0JzogICAgICd1bmlmb3JtNHVpJyxcbiAgICAnYnZlYzInOiAgICAgJ3VuaWZvcm0yaScsXG4gICAgJ2J2ZWMzJzogICAgICd1bmlmb3JtM2knLFxuICAgICdidmVjNCc6ICAgICAndW5pZm9ybTRpJyxcbiAgICAnbWF0Mic6ICAgICAgJ3VuaWZvcm1NYXRyaXgyZnYnLFxuICAgICdtYXQzJzogICAgICAndW5pZm9ybU1hdHJpeDNmdicsXG4gICAgJ21hdDQnOiAgICAgICd1bmlmb3JtTWF0cml4NGZ2Jyxcbn0pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNwZWVkeVByb2dyYW1PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZW5kZXJUb1RleHR1cmVdIHJlbmRlciByZXN1bHRzIHRvIGEgdGV4dHVyZT9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Bpbmdwb25nXSBhbHRlcm5hdGUgb3V0cHV0IHRleHR1cmUgYmV0d2VlbiBjYWxsc1xuICovXG5cbi8qKiBAdHlwZWRlZiB7bnVtYmVyfG51bWJlcltdfGJvb2xlYW58Ym9vbGVhbltdfFNwZWVkeVRleHR1cmV9IFNwZWVkeVByb2dyYW1Vbmlmb3JtVmFsdWUgKi9cblxuLyoqXG4gKiBBIFNwZWVkeVByb2dyYW0gaXMgYSBGdW5jdGlvbiB0aGF0XG4gKiBydW5zIEdQVS1hY2NlbGVyYXRlZCBHTFNMIGNvZGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVByb2dyYW0gZXh0ZW5kcyBGdW5jdGlvblxue1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3BlZWR5UHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgV2ViR0wgY29udGV4dFxuICAgICAqIEBwYXJhbSB7U2hhZGVyRGVjbGFyYXRpb259IHNoYWRlcmRlY2wgU2hhZGVyIGRlY2xhcmF0aW9uXG4gICAgICogQHBhcmFtIHtTcGVlZHlQcm9ncmFtT3B0aW9uc30gW29wdGlvbnNdIHVzZXIgb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdsLCBzaGFkZXJkZWNsLCBvcHRpb25zID0geyB9KVxuICAgIHtcbiAgICAgICAgc3VwZXIoJy4uLmFyZ3MnLCAncmV0dXJuIHRoaXMuX3NlbGYuX2NhbGwoLi4uYXJncyknKTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeVByb2dyYW19IHRoaXMgZnVuY3Rpb24gYm91bmQgdG8gdGhpcyBmdW5jdGlvbiEgKi9cbiAgICAgICAgdGhpcy5fc2VsZiA9IHRoaXMuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9zZWxmLl9pbml0KGdsLCBzaGFkZXJkZWNsLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgU3BlZWR5UHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgV2ViR0wgY29udGV4dFxuICAgICAqIEBwYXJhbSB7U2hhZGVyRGVjbGFyYXRpb259IHNoYWRlcmRlY2wgU2hhZGVyIGRlY2xhcmF0aW9uXG4gICAgICogQHBhcmFtIHtTcGVlZHlQcm9ncmFtT3B0aW9uc30gb3B0aW9ucyB1c2VyIG9wdGlvbnNcbiAgICAgKi9cbiAgICBfaW5pdChnbCwgc2hhZGVyZGVjbCwgb3B0aW9ucylcbiAgICB7XG4gICAgICAgIC8vIG5vdCBhIHZhbGlkIGNvbnRleHQ/XG4gICAgICAgIGlmKGdsLmlzQ29udGV4dExvc3QoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoYENhbid0IGluaXRpYWxpemUgU3BlZWR5UHJvZ3JhbTogbG9zdCBjb250ZXh0YCk7XG5cbiAgICAgICAgLy8gb3B0aW9ucyBvYmplY3RcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICByZW5kZXJUb1RleHR1cmU6IHRydWUsXG4gICAgICAgICAgICBwaW5ncG9uZzogZmFsc2UsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG5cblxuICAgICAgICAvKiogQHR5cGUge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9ICovXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFByb2dyYW19IHZlcnRleCBzaGFkZXIgKyBmcmFnbWVudCBzaGFkZXIgKi9cbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IFNwZWVkeVByb2dyYW0uX2NvbXBpbGUoZ2wsIHNoYWRlcmRlY2wudmVydGV4U291cmNlLCBzaGFkZXJkZWNsLmZyYWdtZW50U291cmNlKTtcblxuICAgICAgICAvKiogQHR5cGUge1Byb2dyYW1HZW9tZXRyeX0gdGhpcyBpcyBhIHF1YWQgKi9cbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgUHJvZ3JhbUdlb21ldHJ5KGdsLCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogc2hhZGVyZGVjbC5sb2NhdGlvbk9mQXR0cmlidXRlcy5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleENvb3JkOiBzaGFkZXJkZWNsLmxvY2F0aW9uT2ZBdHRyaWJ1dGVzLnRleENvb3JkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nW119IG5hbWVzIG9mIHRoZSBhcmd1bWVudHMgb2YgdGhlIFNwZWVkeVByb2dyYW0gKi9cbiAgICAgICAgdGhpcy5fYXJnbmFtZXMgPSBzaGFkZXJkZWNsLmFyZ3VtZW50cztcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW5bXX0gdGVsbHMgd2hldGhlciB0aGUgaS10aCBhcmd1bWVudCBvZiB0aGUgU3BlZWR5UHJvZ3JhbSBpcyBhbiBhcnJheSBvciBub3QgKi9cbiAgICAgICAgdGhpcy5fYXJnSXNBcnJheSA9IChuZXcgQXJyYXkodGhpcy5fYXJnbmFtZXMubGVuZ3RoKSkuZmlsbChmYWxzZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtVQk9IZWxwZXJ9IFVCTyBoZWxwZXIgKGxhenkgaW5zdGFudGlhdGlvbikgKi9cbiAgICAgICAgdGhpcy5fdWJvID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IHNob3VsZCB3ZSByZW5kZXIgdG8gYSB0ZXh0dXJlPyBJZiBmYWxzZSwgd2UgcmVuZGVyIHRvIHRoZSBjYW52YXMgKi9cbiAgICAgICAgdGhpcy5fcmVuZGVyVG9UZXh0dXJlID0gQm9vbGVhbihvcHRpb25zLnJlbmRlclRvVGV4dHVyZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBvdXRwdXQgKi9cbiAgICAgICAgdGhpcy5fd2lkdGggPSAxO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBoZWlnaHQgb2YgdGhlIG91dHB1dCAqL1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSAxO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5RHJhd2FibGVUZXh0dXJlW119IG91dHB1dCB0ZXh0dXJlKHMpICovXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSAobmV3IEFycmF5KG9wdGlvbnMucGluZ3BvbmcgPyAyIDogMSkpLmZpbGwobnVsbCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IHVzZWQgZm9yIHBpbmdwb25nIHJlbmRlcmluZyAqL1xuICAgICAgICB0aGlzLl90ZXh0dXJlSW5kZXggPSAwO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZyxVbmlmb3JtVmFyaWFibGU+fSB1bmlmb3JtIHZhcmlhYmxlcyAqL1xuICAgICAgICB0aGlzLl91bmlmb3JtID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U2hhZGVyRGVjbGFyYXRpb259IHNoYWRlciBkZWNsYXJhdGlvbiAqL1xuICAgICAgICB0aGlzLl9zaGFkZXJkZWNsID0gc2hhZGVyZGVjbDtcblxuXG4gICAgICAgIC8vIGF1dG9kZXRlY3QgdW5pZm9ybXNcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcbiAgICAgICAgZm9yKGNvbnN0IG5hbWUgb2Ygc2hhZGVyZGVjbC51bmlmb3Jtcykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHNoYWRlcmRlY2wudW5pZm9ybVR5cGUobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3VuaWZvcm0uc2V0KG5hbWUsIG5ldyBVbmlmb3JtVmFyaWFibGUodHlwZSwgbG9jYXRpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hdGNoIGFyZ3VtZW50cyAmIHVuaWZvcm1zXG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLl9hcmduYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYXJnbmFtZSA9IHRoaXMuX2FyZ25hbWVzW2pdO1xuICAgICAgICAgICAgaWYoIXRoaXMuX3VuaWZvcm0uaGFzKGFyZ25hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXJnSXNBcnJheVtqXSA9IHRoaXMuX3VuaWZvcm0uaGFzKGFyZ25hbWUgKyAnWzBdJyk7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX2FyZ0lzQXJyYXlbal0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoYEV4cGVjdGVkIHVuaWZvcm0gXCIke2FyZ25hbWV9XCIsIGFzIGRlY2xhcmVkIGluIHRoZSBhcmd1bWVudCBsaXN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIFNwZWVkeVByb2dyYW1cbiAgICAgKiBAcGFyYW0gIHsuLi5TcGVlZHlQcm9ncmFtVW5pZm9ybVZhbHVlfSBhcmdzXG4gICAgICogQHJldHVybnMge1NwZWVkeURyYXdhYmxlVGV4dHVyZX1cbiAgICAgKi9cbiAgICBfY2FsbCguLi5hcmdzKVxuICAgIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgY29uc3QgYXJnbmFtZXMgPSB0aGlzLl9hcmduYW1lcztcblxuICAgICAgICAvLyBtYXRjaGluZyBhcmd1bWVudHM/XG4gICAgICAgIGlmKGFyZ3MubGVuZ3RoICE9IGFyZ25hbWVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgQ2FuJ3QgcnVuIHNoYWRlcjogaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgKGV4cGVjdGVkICR7YXJnbmFtZXMubGVuZ3RofSwgZ290ICR7YXJncy5sZW5ndGh9KWApO1xuXG4gICAgICAgIC8vIGNhbid0IHVzZSB0aGUgb3V0cHV0IHRleHR1cmUgYXMgYW4gaW5wdXRcbiAgICAgICAgY29uc3QgZmxhdEFyZ3MgPSBVdGlscy5mbGF0dGVuKGFyZ3MpO1xuICAgICAgICBmb3IobGV0IGogPSBmbGF0QXJncy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYoZmxhdEFyZ3Nbal0gPT09IHRoaXMuX3RleHR1cmVbdGhpcy5fdGV4dHVyZUluZGV4XSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoYENhbid0IHJ1biBzaGFkZXI6IGRvbid0IHVzZSBpdHMgb3V0cHV0IHRleHR1cmUgYXMgYW4gaW5wdXQgdG8gaXRzZWxmLiBDb25zaWRlciB1c2luZyBwaW5ncG9uZyByZW5kZXJpbmchYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb250ZXh0IGxvc3M/XG4gICAgICAgIGlmKGdsLmlzQ29udGV4dExvc3QoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlW3RoaXMuX3RleHR1cmVJbmRleF07XG5cbiAgICAgICAgLy8gdXNlIHByb2dyYW1cbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcblxuICAgICAgICAvLyBiaW5kIHRoZSBWQU9cbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHRoaXMuX2dlb21ldHJ5LnZhbyk7XG5cbiAgICAgICAgLy8gc2VsZWN0IHRoZSByZW5kZXIgdGFyZ2V0XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlW3RoaXMuX3RleHR1cmVJbmRleF07XG4gICAgICAgIGNvbnN0IGZibyA9IHRoaXMuX3JlbmRlclRvVGV4dHVyZSA/IHRleHR1cmUuZ2xGYm8gOiBudWxsO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0ZXhTaXplIHVuaWZvcm0gKGF2YWlsYWJsZSBpbiBhbGwgZnJhZ21lbnQgc2hhZGVycylcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCwgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBjb25zdCB0ZXhTaXplID0gdGhpcy5fdW5pZm9ybS5nZXQoJ3RleFNpemUnKTtcbiAgICAgICAgdGV4U2l6ZS5zZXRWYWx1ZShnbCwgWyB3aWR0aCwgaGVpZ2h0IF0pO1xuICAgICAgICAvL2dsLnVuaWZvcm0yZih0ZXhTaXplLmxvY2F0aW9uLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBzZXQgdW5pZm9ybXNbaV0gdG8gYXJnc1tpXVxuICAgICAgICBmb3IobGV0IGkgPSAwLCB0ZXhObyA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhcmduYW1lID0gYXJnbmFtZXNbaV07XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLl9hcmdJc0FycmF5W2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5pZm9ybSB2YXJpYWJsZSBtYXRjaGVzIGFyZ3VtZW50IG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlmb3JtID0gdGhpcy5fdW5pZm9ybS5nZXQoYXJnbmFtZSk7XG4gICAgICAgICAgICAgICAgdGV4Tm8gPSB1bmlmb3JtLnNldFZhbHVlKGdsLCBhcmdzW2ldLCB0ZXhObyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1bmlmb3JtIGFycmF5IG1hdGNoZXMgYXJndW1lbnQgbmFtZVxuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLl91bmlmb3JtLmhhcyhgJHthcmduYW1lfVske2FycmF5Lmxlbmd0aH1dYCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IHJ1biBzaGFkZXI6IHRvbyBmZXcgZWxlbWVudHMgaW4gdGhlIFwiJHthcmduYW1lfVwiIGFycmF5YCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDAsIHVuaWZvcm0gPSB1bmRlZmluZWQ7ICh1bmlmb3JtID0gdGhpcy5fdW5pZm9ybS5nZXQoYCR7YXJnbmFtZX1bJHtqfV1gKSkgIT09IHVuZGVmaW5lZDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4Tm8gPSB1bmlmb3JtLnNldFZhbHVlKGdsLCBhcnJheVtqXSwgdGV4Tm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgQ2FuJ3QgcnVuIHNoYWRlcjogZXhwZWN0ZWQgYW4gYXJyYXkgZm9yIFwiJHthcmduYW1lfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgVW5pZm9ybSBCdWZmZXIgT2JqZWN0cyAoaWYgYW55KVxuICAgICAgICBpZih0aGlzLl91Ym8gIT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl91Ym8udXBkYXRlKCk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgRkJPXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcblxuICAgICAgICAvLyBkcmF3IGNhbGxcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTsgLy8gbW9kZSwgb2Zmc2V0LCBjb3VudFxuXG4gICAgICAgIC8vIHVuYmluZCB0aGUgRkJPXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgLy8gdW5iaW5kIHRoZSBWQU9cbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuXG4gICAgICAgIC8vIHdlJ3ZlIGp1c3QgY2hhbmdlZCB0aGUgdGV4dHVyZSEgZGlzY2FyZCB0aGUgcHlyYW1pZCwgaWYgYW55XG4gICAgICAgIGlmKHRleHR1cmUgIT0gbnVsbClcbiAgICAgICAgICAgIHRleHR1cmUuZGlzY2FyZE1pcG1hcHMoKTtcblxuICAgICAgICAvLyBwaW5nLXBvbmcgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuX3Bpbmdwb25nKCk7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBvdXRwdXQgdGV4dHVyZShzKSBhbmQgaXRzICh0aGVpcikgc2hhcGUocylcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggbmV3IHdpZHRoLCBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IG5ldyBoZWlnaHQsIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSAgey4uLlNwZWVkeURyYXdhYmxlVGV4dHVyZXxudWxsfSB0ZXh0dXJlIG91dHB1dCB0ZXh0dXJlKHMpXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb2dyYW19IHRoaXNcbiAgICAgKi9cbiAgICBvdXRwdXRzKHdpZHRoLCBoZWlnaHQsIC4uLnRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLl9zZXRPdXRwdXRUZXh0dXJlKC4uLnRleHR1cmUpO1xuICAgICAgICB0aGlzLl9zZXRPdXRwdXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpemUgb2YgdGhlIG91dHB1dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBuZXcgd2lkdGgsIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgbmV3IGhlaWdodCwgaW4gcGl4ZWxzXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb2dyYW19IHRoaXNcbiAgICAgKi9cbiAgICBfc2V0T3V0cHV0U2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgb3V0cHV0IHNpemVcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aCB8IDA7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodCB8IDA7XG5cbiAgICAgICAgLy8gcmVzaXplIHRoZSBvdXRwdXQgdGV4dHVyZShzKVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGV4dHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYodGhpcy5fdGV4dHVyZVtpXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVbaV0ucmVzaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBwcm92aWRlZCB0ZXh0dXJlKHMpIGFzIG91dHB1dFxuICAgICAqIEBwYXJhbSB7Li4uU3BlZWR5RHJhd2FibGVUZXh0dXJlfSB0ZXh0dXJlIHNldCB0byBudWxsIHRvIHVzZSB0aGUgaW50ZXJuYWwgdGV4dHVyZShzKVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9ncmFtfSB0aGlzXG4gICAgICovXG4gICAgX3NldE91dHB1dFRleHR1cmUoLi4udGV4dHVyZSlcbiAgICB7XG4gICAgICAgIFV0aWxzLmFzc2VydCh0ZXh0dXJlLmxlbmd0aCA9PT0gdGhpcy5fdGV4dHVyZS5sZW5ndGgsIGBJbmNvcnJlY3QgbnVtYmVyIG9mIHRleHR1cmVzIChleHBlY3RlZCAke3RoaXMuX3RleHR1cmUubGVuZ3RofSlgKTtcblxuICAgICAgICAvLyB1cGRhdGUgb3V0cHV0IHRleHR1cmUocylcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3RleHR1cmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlW2ldID0gdGV4dHVyZVtpXTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZUluZGV4ID0gMDtcblxuICAgICAgICAvLyBkb25lIVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgaW50ZXJuYWwgdGV4dHVyZXNcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfVxuICAgICAqL1xuICAgIGNsZWFyKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlW3RoaXMuX3RleHR1cmVJbmRleF07XG5cbiAgICAgICAgLy8gY2xlYXIgaW50ZXJuYWwgdGV4dHVyZXNcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3RleHR1cmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlW2ldLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gcGluZy1wb25nIHJlbmRlcmluZ1xuICAgICAgICB0aGlzLl9waW5ncG9uZygpO1xuXG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBkYXRhIHVzaW5nIGEgVW5pZm9ybSBCdWZmZXIgT2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrTmFtZSB1bmlmb3JtIGJsb2NrIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9ncmFtfSB0aGlzXG4gICAgICovXG4gICAgc2V0VUJPKGJsb2NrTmFtZSwgZGF0YSlcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuX3VibyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3VibyA9IG5ldyBVQk9IZWxwZXIodGhpcy5fZ2wsIHRoaXMuX3Byb2dyYW0pO1xuXG4gICAgICAgIHRoaXMuX3Viby5zZXQoYmxvY2tOYW1lLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNwZWVkeVByb2dyYW1cbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICByZWxlYXNlKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG5cbiAgICAgICAgLy8gUmVsZWFzZSBVQk9zIChpZiBhbnkpXG4gICAgICAgIGlmKHRoaXMuX3VibyAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fdWJvID0gdGhpcy5fdWJvLnJlbGVhc2UoKTtcblxuICAgICAgICAvLyBVbmxpbmsgdGV4dHVyZXNcbiAgICAgICAgdGhpcy5fdGV4dHVyZS5maWxsKG51bGwpO1xuXG4gICAgICAgIC8vIFJlbGVhc2UgZ2VvbWV0cnlcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeS5yZWxlYXNlKCk7XG5cbiAgICAgICAgLy8gUmVsZWFzZSBwcm9ncmFtXG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5fcHJvZ3JhbSk7XG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSBudWxsO1xuXG4gICAgICAgIC8vIE5lZWQgdG8gZGVsZXRlIHRoZSBzaGFkZXJzIGFzIHdlbGw/IEluIHNlYyA1LjE0LjkgUHJvZ3JhbXMgYW5kIHNoYWRlcnNcbiAgICAgICAgLy8gb2YgdGhlIFdlYkdMIDEuMCBzcGVjLCBpdCBpcyBtZW50aW9uZWQgdGhhdCB0aGUgdW5kZXJseWluZyBHTCBvYmplY3RcbiAgICAgICAgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIG1hcmtlZCBmb3IgZGVsZXRpb24gd2hlbiB0aGUgSlMgb2JqZWN0IGlzXG4gICAgICAgIC8vIGRlc3Ryb3llZCAoaS5lLiwgZ2FyYmFnZSBjb2xsZWN0ZWQpXG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjb25zdGFudCAjZGVmaW5lZCBpbiB0aGUgc2hhZGVyIGRlY2xhcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGRlZmluZWRDb25zdGFudChuYW1lKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRlcmRlY2wuZGVmaW5lZENvbnN0YW50KG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgZm9yIHBpbmdwb25nIHJlbmRlcmluZzogYWx0ZXJuYXRlc1xuICAgICAqIHRoZSB0ZXh0dXJlIGluZGV4IGZyb20gMCB0byAxIGFuZCB2aWNlLXZlcnNhXG4gICAgICovXG4gICAgX3Bpbmdwb25nKClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuX3RleHR1cmUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVJbmRleCA9IDEgLSB0aGlzLl90ZXh0dXJlSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGlsZSBhbmQgbGluayBHTFNMIHNoYWRlcnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnRleFNoYWRlclNvdXJjZSBHTFNMIGNvZGUgb2YgdGhlIHZlcnRleCBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJhZ21lbnRTaGFkZXJTb3VyY2UgR0xTTCBjb2RlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAgICAgKiBAcmV0dXJucyB7V2ViR0xQcm9ncmFtfVxuICAgICAqL1xuICAgIHN0YXRpYyBfY29tcGlsZShnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcblxuICAgICAgICAvLyBjb21waWxlIHZlcnRleCBzaGFkZXJcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU291cmNlKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcblxuICAgICAgICAvLyBjb21waWxlIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG5cbiAgICAgICAgLy8gbGluayBwcm9ncmFtXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgICAgLy8gcmV0dXJuIG9uIHN1Y2Nlc3NcbiAgICAgICAgaWYoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAgICAgICAgICByZXR1cm4gcHJvZ3JhbTtcblxuICAgICAgICAvLyBkaXNwbGF5IGFuIGVycm9yXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtcbiAgICAgICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpLFxuICAgICAgICAgICAgZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpLFxuICAgICAgICAgICAgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSksXG4gICAgICAgIF07XG5cbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG5cbiAgICAgICAgLy8gZGlzcGxheSBlcnJvclxuICAgICAgICBjb25zdCBzcGFjZXMgPSBpID0+IE1hdGgubWF4KDAsIDIgLSBNYXRoLmZsb29yKE1hdGgubG9nMTAoaSkpKTtcbiAgICAgICAgY29uc3QgY29sID0gayA9PiBuZXcgQXJyYXkoc3BhY2VzKGspKS5maWxsKCcgJykuam9pbignJykgKyBrICsgJy4gJztcbiAgICAgICAgY29uc3Qgc291cmNlID0gZXJyb3JzWzBdID8gZnJhZ21lbnRTaGFkZXJTb3VyY2UgOiB2ZXJ0ZXhTaGFkZXJTb3VyY2U7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFNvdXJjZSA9IHNvdXJjZS5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgIC5tYXAoKGxpbmUsIG5vKSA9PiBjb2woMStubykgKyBsaW5lKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIHRocm93IG5ldyBHTEVycm9yKFxuICAgICAgICAgICAgYFxcblxcbi0tLS0tLS0tLS0gRVJST1IgLS0tLS0tLS0tLVxcblxcbmAgK1xuICAgICAgICAgICAgZXJyb3JzLmZpbHRlcihlcnIgPT4gZXJyKS5qb2luKCdcXG4nKSArXG4gICAgICAgICAgICBgXFxuXFxuLS0tLS0tLS0tLSBTT1VSQ0UgQ09ERSAtLS0tLS0tLS0tXFxuXFxuYCArXG4gICAgICAgICAgICBmb3JtYXR0ZWRTb3VyY2UgKyAnXFxuJ1xuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cblxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIRUxQRVJTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuXG5cblxuXG4vKipcbiAqIENvbmZpZ3VyZSBhbmQgc3RvcmUgdGhlIFZBTyBhbmQgdGhlIFZCT3NcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB7TG9jYXRpb25PZkF0dHJpYnV0ZXN9IGxvY2F0aW9uXG4gKiBAcmV0dXJucyB7UHJvZ3JhbUdlb21ldHJ5fVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExvY2F0aW9uT2ZBdHRyaWJ1dGVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXhDb29yZFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJ1ZmZlck9mQXR0cmlidXRlc1xuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gcG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7V2ViR0xCdWZmZXJ9IHRleENvb3JkXG4gKi9cbmZ1bmN0aW9uIFByb2dyYW1HZW9tZXRyeShnbCwgbG9jYXRpb24pXG57XG4gICAgLyoqIEB0eXBlIHtXZWJHTFZlcnRleEFycmF5T2JqZWN0fSBWZXJ0ZXggQXJyYXkgT2JqZWN0ICovXG4gICAgdGhpcy52YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuXG4gICAgLyoqIEB0eXBlIHtCdWZmZXJPZkF0dHJpYnV0ZXN9IFZlcnRleCBCdWZmZXIgT2JqZWN0cyAqL1xuICAgIHRoaXMudmJvID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHBvc2l0aW9uOiBnbC5jcmVhdGVCdWZmZXIoKSxcbiAgICAgICAgdGV4Q29vcmQ6IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgfSk7XG5cbiAgICAvKiogQHR5cGUge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9ICovXG4gICAgdGhpcy5fZ2wgPSBnbDtcblxuXG5cbiAgICAvLyBiaW5kIHRoZSBWQU9cbiAgICBnbC5iaW5kVmVydGV4QXJyYXkodGhpcy52YW8pO1xuXG4gICAgLy8gc2V0IHRoZSBwb3NpdGlvbiBhdHRyaWJ1dGVcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52Ym8ucG9zaXRpb24pO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgLy8gY2xpcCBjb29yZGluYXRlcyAoQ0NXKVxuICAgICAgICAtMSwgLTEsXG4gICAgICAgIDEsIC0xLFxuICAgICAgICAtMSwgMSxcblxuICAgICAgICAtMSwgMSxcbiAgICAgICAgMSwgLTEsXG4gICAgICAgIDEsIDEsXG4gICAgXSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbi5wb3NpdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbi5wb3NpdGlvbiwgLy8gYXR0cmlidXRlIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiwgICAgICAgICAgICAgICAgLy8gMiBjb21wb25lbnRzIHBlciB2ZXJ0ZXggKHgseSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5GTE9BVCwgICAgICAgICAvLyB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsICAgICAgICAgICAgLy8gZG9uJ3Qgbm9ybWFsaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBzdHJpZGUgKHRpZ2h0bHkgcGFja2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApOyAgICAgICAgICAgICAgIC8vIG9mZnNldFxuXG4gICAgLy8gc2V0IHRoZSB0ZXhDb29yZCBhdHRyaWJ1dGVcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52Ym8udGV4Q29vcmQpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgLy8gdGV4dHVyZSBjb29yZGluYXRlcyAoQ0NXKVxuICAgICAgICAwLCAwLFxuICAgICAgICAxLCAwLFxuICAgICAgICAwLCAxLFxuXG4gICAgICAgIDAsIDEsXG4gICAgICAgIDEsIDAsXG4gICAgICAgIDEsIDEsXG4gICAgXSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbi50ZXhDb29yZCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbi50ZXhDb29yZCwgLy8gYXR0cmlidXRlIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiwgICAgICAgICAgICAgICAgLy8gMiBjb21wb25lbnRzIHBlciB2ZXJ0ZXggKHgseSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5GTE9BVCwgICAgICAgICAvLyB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsICAgICAgICAgICAgLy8gZG9uJ3Qgbm9ybWFsaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBzdHJpZGUgKHRpZ2h0bHkgcGFja2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApOyAgICAgICAgICAgICAgIC8vIG9mZnNldFxuXG4gICAgLy8gdW5iaW5kXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcblxuICAgIC8vIGRvbmUhXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUodGhpcyk7XG59XG5cbi8qKlxuICogUmVsZWFzZXMgdGhlIGludGVybmFsIHJlc291cmNlc1xuICogQHJldHVybnMge251bGx9XG4gKi9cblByb2dyYW1HZW9tZXRyeS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKClcbntcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuXG4gICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkodGhpcy52YW8pO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZiby5wb3NpdGlvbik7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmJvLnRleENvb3JkKTtcblxuICAgIHJldHVybiBudWxsO1xufVxuXG5cblxuXG5cbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBzdG9yaW5nIGRhdGEgaW4gR0xTTCB1bmlmb3JtIHZhcmlhYmxlc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7V2ViR0xVbmlmb3JtTG9jYXRpb259IGxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIFVuaWZvcm1WYXJpYWJsZSh0eXBlLCBsb2NhdGlvbilcbntcbiAgICAvKiogQHR5cGUge3N0cmluZ30gR0xTTCBkYXRhIHR5cGUgKi9cbiAgICB0aGlzLnR5cGUgPSBTdHJpbmcodHlwZSk7XG4gICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChVTklGT1JNX1NFVFRFUlMsIHRoaXMudHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlOiAke3RoaXMudHlwZX1gKTtcblxuICAgIC8qKiBAdHlwZSB7V2ViR0xVbmlmb3JtTG9jYXRpb259IHVuaWZvcm0gbG9jYXRpb24gaW4gYSBXZWJHTCBwcm9ncmFtICovXG4gICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9IHNldHRlciBmdW5jdGlvbiAqL1xuICAgIHRoaXMuc2V0dGVyID0gVU5JRk9STV9TRVRURVJTW3RoaXMudHlwZV07XG4gICAgY29uc3QgbiA9IE51bWJlcigodGhpcy5zZXR0ZXIubWF0Y2goL151bmlmb3JtKE1hdHJpeCk/KFxcZCkvKSlbMl0pIHwgMDtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBpcyB0aGUgdW5pZm9ybSBhIHNjYWxhciAoMCksIGEgdmVjdG9yICgxKSBvciBhIG1hdHJpeCAoMik/ICovXG4gICAgdGhpcy5kaW0gPSB0aGlzLnR5cGUuc3RhcnRzV2l0aCgnbWF0JykgPyAyIDogKCh0aGlzLnR5cGUuaW5kZXhPZigndmVjJykgPj0gMCkgPyAxIDogMCk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gcmVxdWlyZWQgbnVtYmVyIG9mIHNjYWxhcnMgKi9cbiAgICB0aGlzLmxlbmd0aCA9ICh0aGlzLmRpbSA9PSAyKSA/IG4gKiBuIDogbjtcblxuICAgIC8qKiBAdHlwZSB7U3BlZWR5UHJvZ3JhbVVuaWZvcm1WYWx1ZXxudWxsfSBjYWNoZWQgdmFsdWUgKi9cbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG59XG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBhIHVuaWZvcm0gdmFyaWFibGVcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB7U3BlZWR5UHJvZ3JhbVVuaWZvcm1WYWx1ZX0gdmFsdWUgdXNlIGNvbHVtbi1tYWpvciBmb3JtYXQgZm9yIG1hdHJpY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gW3RleE5vXSBjdXJyZW50IHRleHR1cmUgaW5kZXhcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG5ldyB0ZXh0dXJlIGluZGV4XG4gKi9cblVuaWZvcm1WYXJpYWJsZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbihnbCwgdmFsdWUsIHRleE5vID0gLTEpXG57XG4gICAgY29uc3Qgc2V0VmFsdWUgPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyAoIGdsW3RoaXMuc2V0dGVyXSApO1xuXG4gICAgLy8gY2hlY2sgdW5pZm9ybSB0eXBlXG4gICAgaWYodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0aGlzLnR5cGUuZW5kc1dpdGgoJ3NhbXBsZXIyRCcpKSB7XG4gICAgICAgIC8vIHNldCB0ZXh0dXJlXG4gICAgICAgIGlmKHRleE5vID49IGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKGBDYW4ndCBhY3RpdmF0ZSB0ZXh0dXJlIHVuaXQgJHt0ZXhOb306IG1heCBpcyAke2dsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTfWApO1xuICAgICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKGBDYW4ndCBwYXNzIGFycmF5cyBvZiB0ZXh0dXJlcyB0byBzaGFkZXJzYCk7XG4gICAgICAgIGVsc2UgaWYodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgQ2FuJ3QgcnVuIHNoYWRlcjogY2Fubm90IHVzZSAke3ZhbHVlfSBhcyBhbiBpbnB1dCB0ZXh0dXJlYCk7XG4gICAgICAgIGVsc2UgaWYodGV4Tm8gPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBNaXNzaW5nIHRleE5vYCk7XG5cbiAgICAgICAgY29uc3QgdGV4ID0gdmFsdWU7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXhObyk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleC5nbFRleHR1cmUpO1xuICAgICAgICBnbC51bmlmb3JtMWkodGhpcy5sb2NhdGlvbiwgdGV4Tm8pO1xuXG4gICAgICAgIHRleE5vKys7XG4gICAgfVxuICAgIGVsc2UgaWYodmFsdWUgPT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIC8vIGRvIG5vdCB1cGRhdGUgdGhlIHVuaWZvcm0gaWYgaXQgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgdm9pZCgwKTtcbiAgICB9XG4gICAgZWxzZSBpZih0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIC8vIHNldCBzY2FsYXIgdmFsdWVcbiAgICAgICAgc2V0VmFsdWUuY2FsbChnbCwgdGhpcy5sb2NhdGlvbiwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIHNldCB2ZWN0b3Igb3IgbWF0cml4XG4gICAgICAgIGlmKHZhbHVlLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZGltID09IDIpXG4gICAgICAgICAgICAgICAgc2V0VmFsdWUuY2FsbChnbCwgdGhpcy5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTsgLy8gbWF0cml4XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2V0VmFsdWUuY2FsbChnbCwgdGhpcy5sb2NhdGlvbiwgLi4udmFsdWUpOyAvLyB2ZWN0b3JcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYENhbid0IHJ1biBzaGFkZXI6IGluY29ycmVjdCBudW1iZXIgb2YgdmFsdWVzIGZvciAke3RoaXMudHlwZX06IFwiJHt2YWx1ZX1cImApO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgQ2FuJ3QgcnVuIHNoYWRlcjogdW5yZWNvZ25pemVkIGFyZ3VtZW50IFwiJHt2YWx1ZX1cImApO1xuXG4gICAgLy8gY2FjaGUgdGhlIHZhbHVlXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIGRvbmVcbiAgICByZXR1cm4gdGV4Tm87XG59XG5cblxuXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVUJPU3R1ZmZcbiAqIEBwcm9wZXJ0eSB7V2ViR0xCdWZmZXJ9IGJ1ZmZlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrQmluZGluZ0luZGV4IFwiZ2xvYmFsXCIgYmluZGluZyBpbmRleFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrSW5kZXggVUJPIFwibG9jYXRpb25cIiBpbiB0aGUgcHJvZ3JhbVxuICogQHByb3BlcnR5IHtBcnJheUJ1ZmZlclZpZXd8bnVsbH0gZGF0YSB1c2VyLWRhdGFcbiAqL1xuXG4vKipcbiAqIEEgaGVscGVyIGNsYXNzIGZvciBoYW5kbGluZyBVbmlmb3JtIEJ1ZmZlciBPYmplY3RzIChVQk9zKVxuICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbFxuICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW1cbiAqL1xuZnVuY3Rpb24gVUJPSGVscGVyKGdsLCBwcm9ncmFtKVxue1xuICAgIC8qKiBAdHlwZSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gKi9cbiAgICB0aGlzLl9nbCA9IGdsO1xuXG4gICAgLyoqIEB0eXBlIHtXZWJHTFByb2dyYW19ICovXG4gICAgdGhpcy5fcHJvZ3JhbSA9IHByb2dyYW07XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gYXV0by1pbmNyZW1lbnQgY291bnRlciAqL1xuICAgIHRoaXMuX25leHRJbmRleCA9IDA7XG5cbiAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsVUJPU3R1ZmY+fSBVQk8gZGljdGlvbmFyeSBpbmRleGVkIGJ5IHVuaWZvcm0gYmxvY2sgbmFtZXMgKi9cbiAgICB0aGlzLl91Ym8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFNldCBVbmlmb3JtIEJ1ZmZlciBPYmplY3QgZGF0YVxuICogKHRoZSBidWZmZXIgd2lsbCBiZSB1cGxvYWRlZCB3aGVuIHRoZSBwcm9ncmFtIGlzIGV4ZWN1dGVkKVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdW5pZm9ybSBibG9jayBuYW1lXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YVxuICovXG5VQk9IZWxwZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpXG57XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcblxuICAgIC8vIGNyZWF0ZSBVQk8gZW50cnlcbiAgICBpZih0aGlzLl91Ym9bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl91Ym9bbmFtZV0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IGdsLmNyZWF0ZUJ1ZmZlcigpLFxuICAgICAgICAgICAgYmxvY2tCaW5kaW5nSW5kZXg6IHRoaXMuX25leHRJbmRleCsrLFxuICAgICAgICAgICAgYmxvY2tJbmRleDogLTEsXG4gICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZ2V0IFVCTyBlbnRyeSBmb3IgdGhlIGdpdmVuIGJsb2NrIG5hbWVcbiAgICBjb25zdCB1Ym8gPSB0aGlzLl91Ym9bbmFtZV07XG5cbiAgICAvLyByZWFkIGJsb2NrIGluZGV4ICYgYXNzaWduIGJpbmRpbmcgcG9pbnRcbiAgICBpZih1Ym8uYmxvY2tJbmRleCA8IDApIHtcbiAgICAgICAgY29uc3QgYmxvY2tJbmRleCA9IGdsLmdldFVuaWZvcm1CbG9ja0luZGV4KHRoaXMuX3Byb2dyYW0sIG5hbWUpOyAvLyBHTHVpbnRcbiAgICAgICAgZ2wudW5pZm9ybUJsb2NrQmluZGluZyh0aGlzLl9wcm9ncmFtLCBibG9ja0luZGV4LCB1Ym8uYmxvY2tCaW5kaW5nSW5kZXgpO1xuICAgICAgICB1Ym8uYmxvY2tJbmRleCA9IGJsb2NrSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgdGhlIGRhdGEgLSB3ZSdsbCB1cGxvYWQgaXQgbGF0ZXJcbiAgICB1Ym8uZGF0YSA9IGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlIFVCTyBkYXRhXG4gKiBDYWxsZWQgd2hlbiB3ZSdyZSB1c2luZyB0aGUgYXBwcm9wcmlhdGUgV2ViR0xQcm9ncmFtXG4gKi9cblVCT0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG5cbiAgICBmb3IoY29uc3QgbmFtZSBpbiB0aGlzLl91Ym8pIHtcbiAgICAgICAgY29uc3QgdWJvID0gdGhpcy5fdWJvW25hbWVdO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIHViby5idWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLlVOSUZPUk1fQlVGRkVSLCB1Ym8uZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIHViby5ibG9ja0JpbmRpbmdJbmRleCwgdWJvLmJ1ZmZlcik7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIG51bGwpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZWxlYXNlIGFsbG9jYXRlZCBidWZmZXJzXG4gKiBAcmV0dXJucyB7bnVsbH1cbiAqL1xuVUJPSGVscGVyLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKVxue1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG5cbiAgICBmb3IoY29uc3QgbmFtZSBpbiB0aGlzLl91Ym8pIHtcbiAgICAgICAgY29uc3QgdWJvID0gdGhpcy5fdWJvW25hbWVdO1xuXG4gICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih1Ym8uYnVmZmVyKTtcbiAgICAgICAgdWJvLmRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuIiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogc3BlZWR5LXRleHR1cmUtcG9vbC5qc1xuICogVGV4dHVyZSBwb29sXG4gKi9cblxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBTcGVlZHlHUFUgfSBmcm9tICcuL3NwZWVkeS1ncHUnO1xuaW1wb3J0IHsgU3BlZWR5RHJhd2FibGVUZXh0dXJlIH0gZnJvbSAnLi9zcGVlZHktdGV4dHVyZSc7XG5pbXBvcnQgeyBPdXRPZk1lbW9yeUVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcblxuLy8gQ29uc3RhbnRzXG5jb25zdCBERUZBVUxUX0NBUEFDSVRZID0gMTAyNDtcbmNvbnN0IEJVQ0tFVCA9IFN5bWJvbCgnQnVja2V0Jyk7XG5cblxuLypcblxuPT09IEhldXJpc3RpY3MgdG8gZmlndXJlIG91dCB0aGUgY2FwYWNpdHkgb2YgYSB0ZXh0dXJlIHBvb2wgPT09XG5cbjEuIERlY2lkZSB0aGUgbWF4aW11bSBhbW91bnQgb2YgVlJBTSB5b3UnZCBsaWtlIHRvIHVzZSBpbiBhIHBvb2wgKHNheSwgNjQgTUIpLlxuXG4yLiBGaWd1cmUgb3V0IHRoZSBhdmVyYWdlIHRleHR1cmUgc2l6ZSBpbiB5b3VyIGFwcGxpY2F0aW9uIChzYXksIDY0MHgzNjAgcGl4ZWxzKS5cblxuMy4gRmlndXJlIG91dCB0aGUgYXZlcmFnZSB0ZXh0dXJlIHNpemUgaW4gYnl0ZXMgKHNheSwgOTIxNjAwIGJ5dGVzKS4gRWFjaCBwaXhlbFxuICAgdXNlcyA0IGJ5dGVzIChSR0JBIGZvcm1hdCkuXG5cbjQuIERpdmlkZSB0aGUgbWF4aW11bSBhbW91bnQgb2YgVlJBTSBieSB0aGUgYXZlcmFnZSB0ZXh0dXJlIHNpemUgaW4gYnl0ZXNcbiAgIChzYXksIDcyKS4gVGhhdCdzIHRoZSBjYXBhY2l0eSBvZiB0aGUgcG9vbC5cblxuTm90ZSB0aGF0IHRleHR1cmVzIGFyZSBhbGxvY2F0ZWQgbGF6aWx5LCBzbyBWUkFNIHVzYWdlIGlzIGtlcHQgdG8gYSBtaW5pbXVtLlxuXG5BZGFwdGVkIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTF9BUEkvV2ViR0xfYmVzdF9wcmFjdGljZXNcblxuKi9cblxuXG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcn0gVGV4dHVyZUJ1Y2tldEluZGV4IGluZGV4IG9mIGEgYnVja2V0IGluIGEgcG9vbFxuICovXG5cblxuXG4vKipcbiAqIEEgYnVja2V0XG4gKi9cbmNsYXNzIFRleHR1cmVCdWNrZXRcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfSB0ZXh0dXJlIG1hbmFnZWQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7VGV4dHVyZUJ1Y2tldEluZGV4fSBpbmRleCBpbmRleCBvZiB0aGlzIGJ1Y2tldFxuICAgICAqIEBwYXJhbSB7VGV4dHVyZUJ1Y2tldEluZGV4fSBuZXh0IGluZGV4IG9mIHRoZSBuZXh0IGJ1Y2tldFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHR1cmUsIGluZGV4LCBuZXh0KVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IG1hbmFnZWQgdGV4dHVyZSAqL1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7VGV4dHVyZUJ1Y2tldEluZGV4fSBpbmRleCBvZiB0aGlzIGJ1Y2tldCAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtUZXh0dXJlQnVja2V0SW5kZXh9IGluZGV4IG9mIHRoZSBuZXh0IGJ1Y2tldCAqL1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdGV4dHVyZSBpcyBhdmFpbGFibGUgb3Igbm90ICovXG4gICAgICAgIHRoaXMuZnJlZSA9IHRydWU7XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBUZXh0dXJlIHBvb2xcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWVkeVRleHR1cmVQb29sXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjYXBhY2l0eV0gbnVtYmVyIG9mIHRleHR1cmVzIGluIHRoZSBwb29sXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3B1LCBjYXBhY2l0eSA9IERFRkFVTFRfQ0FQQUNJVFkpXG4gICAge1xuICAgICAgICBVdGlscy5hc3NlcnQoY2FwYWNpdHkgPiAwKTtcblxuICAgICAgICAvKiogQHR5cGUge1RleHR1cmVCdWNrZXRbXX0gYnVja2V0cyAqL1xuICAgICAgICB0aGlzLl9idWNrZXQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjYXBhY2l0eSB9LCAoXywgaSkgPT4gbmV3IFRleHR1cmVCdWNrZXQobnVsbCwgaSwgaSAtIDEpKTtcblxuICAgICAgICAvKiogQHR5cGUge1RleHR1cmVCdWNrZXRJbmRleH0gaW5kZXggb2YgYW4gYXZhaWxhYmxlIGJ1Y2tldCAqL1xuICAgICAgICB0aGlzLl9oZWFkID0gY2FwYWNpdHkgLSAxO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5R1BVfSBHUFUgaW5zdGFuY2UgKi9cbiAgICAgICAgdGhpcy5fZ3B1ID0gZ3B1O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHRleHR1cmUgZnJvbSB0aGUgcG9vbFxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9XG4gICAgICovXG4gICAgYWxsb2NhdGUoKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5faGVhZCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZNZW1vcnlFcnJvcihgRXhoYXVzdGVkIHBvb2wgKGNhcGFjaXR5OiAke3RoaXMuX2J1Y2tldC5sZW5ndGh9KWApO1xuXG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IHRoaXMuX2J1Y2tldFt0aGlzLl9oZWFkXTtcbiAgICAgICAgYnVja2V0LmZyZWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGJ1Y2tldC5uZXh0O1xuXG4gICAgICAgIGlmKGJ1Y2tldC50ZXh0dXJlID09IG51bGwpIC8vIGxhenkgaW5zdGFudGlhdGlvblxuICAgICAgICAgICAgYnVja2V0LnRleHR1cmUgPSBTcGVlZHlUZXh0dXJlUG9vbC5fY3JlYXRlTWFuYWdlZFRleHR1cmUodGhpcy5fZ3B1LmdsLCBidWNrZXQpO1xuXG4gICAgICAgIHJldHVybiBidWNrZXQudGV4dHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXQgYSB0ZXh0dXJlIGJhY2sgaW4gdGhlIHBvb2xcbiAgICAgKiBAcGFyYW0ge1NwZWVkeURyYXdhYmxlVGV4dHVyZX0gdGV4dHVyZVxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGZyZWUodGV4dHVyZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IHRleHR1cmVbQlVDS0VUXTtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KGJ1Y2tldCAhPT0gdW5kZWZpbmVkICYmICFidWNrZXQuZnJlZSwgYFVubWFuYWdlZCB0ZXh0dXJlIG9yIGRvdWJsZSBmcmVlYCk7XG5cbiAgICAgICAgYnVja2V0Lm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBidWNrZXQuZnJlZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBidWNrZXQuaW5kZXg7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgdGV4dHVyZSBwb29sXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgcmVsZWFzZSgpXG4gICAge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZih0aGlzLl9idWNrZXRbaV0udGV4dHVyZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuX2J1Y2tldFtpXS50ZXh0dXJlID0gdGhpcy5fYnVja2V0W2ldLnRleHR1cmUucmVsZWFzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGV4dHVyZSB3aXRoIGEgcmVmZXJlbmNlIHRvIGEgYnVja2V0XG4gICAgICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqIEBwYXJhbSB7VGV4dHVyZUJ1Y2tldH0gYnVja2V0XG4gICAgICogQHJldHVybnMge1NwZWVkeURyYXdhYmxlVGV4dHVyZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgX2NyZWF0ZU1hbmFnZWRUZXh0dXJlKGdsLCBidWNrZXQpXG4gICAge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFNwZWVkeURyYXdhYmxlVGV4dHVyZShnbCwgMSwgMSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGV4dHVyZSwgQlVDS0VULCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogYnVja2V0XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBzcGVlZHktdGV4dHVyZS1yZWFkZXIuanNcbiAqIFJlYWRzIGRhdGEgZnJvbSB0ZXh0dXJlc1xuICovXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgU2V0dGluZ3MgfSBmcm9tICcuLi9jb3JlL3NldHRpbmdzJztcbmltcG9ydCB7IFNwZWVkeUdQVSB9IGZyb20gJy4vc3BlZWR5LWdwdSc7XG5pbXBvcnQgeyBTcGVlZHlQcm9taXNlIH0gZnJvbSAnLi4vY29yZS9zcGVlZHktcHJvbWlzZSc7XG5pbXBvcnQgeyBTcGVlZHlEcmF3YWJsZVRleHR1cmUgfSBmcm9tICcuL3NwZWVkeS10ZXh0dXJlJztcbmltcG9ydCB7IGFzYXAgfSBmcm9tICcuLi91dGlscy9hc2FwJztcbmltcG9ydCB7IElsbGVnYWxPcGVyYXRpb25FcnJvciwgVGltZW91dEVycm9yLCBHTEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcblxuLyoqIEB0eXBlIHtudW1iZXJ9IG51bWJlciBvZiBQQk9zOyB1c2VkIHRvIGdldCBhIHBlcmZvcm1hbmNlIGJvb3N0IGluIGdsLnJlYWRQaXhlbHMoKSAqL1xuY29uc3QgREVGQVVMVF9OVU1CRVJfT0ZfQlVGRkVSUyA9IDI7XG5cbi8qKiBAdHlwZSB7KGZuOiBGdW5jdGlvbiwgLi4uYXJnczogYW55W10pID0+IG51bWJlcn0gUnVuIGZ1bmN0aW9uIGZuIG9uIHRoZSBcIm5leHQgZnJhbWVcIiAqL1xuY29uc3QgcnVuT25OZXh0RnJhbWUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdGaXJlZm94JykgP1xuICAgICgoZm4sIC4uLmFyZ3MpID0+IHNldFRpbWVvdXQoZm4sIDEwLCAuLi5hcmdzKSkgOiAvLyBSQUYgcHJvZHVjZXMgYSB3YXJuaW5nIG9uIEZpcmVmb3hcbiAgICAoKGZuLCAuLi5hcmdzKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKSkpOyAvLyByZWR1Y2UgYmF0dGVyeSB1c2FnZVxuXG4vKipcbiAqIFJlYWRzIGRhdGEgZnJvbSB0ZXh0dXJlc1xuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5VGV4dHVyZVJlYWRlclxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtudW1iZXJPZkJ1ZmZlcnNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobnVtYmVyT2ZCdWZmZXJzID0gREVGQVVMVF9OVU1CRVJfT0ZfQlVGRkVSUylcbiAgICB7XG4gICAgICAgIFV0aWxzLmFzc2VydChudW1iZXJPZkJ1ZmZlcnMgPiAwKTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IGlzIHRoaXMgb2JqZWN0IGluaXRpYWxpemVkPyAqL1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7VWludDhBcnJheVtdfSBwaXhlbCBidWZmZXJzIGZvciBkYXRhIHRyYW5zZmVycyAoZWFjaCBzdG9yZXMgUkdCQSBkYXRhKSAqL1xuICAgICAgICB0aGlzLl9waXhlbEJ1ZmZlciA9IChuZXcgQXJyYXkobnVtYmVyT2ZCdWZmZXJzKSkuZmlsbChudWxsKS5tYXAoKCkgPT4gbmV3IFVpbnQ4QXJyYXkoMCkpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xCdWZmZXJbXX0gUGl4ZWwgQnVmZmVyIE9iamVjdHMgKFBCT3MpICovXG4gICAgICAgIHRoaXMuX3BibyA9IChuZXcgQXJyYXkobnVtYmVyT2ZCdWZmZXJzKSkuZmlsbChudWxsKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgdGhhdCB3aWxsIGJlIGNvbnN1bWVkIGluIHRoaXMgZnJhbWUgKi9cbiAgICAgICAgdGhpcy5fY29uc3VtZXJJbmRleCA9IDA7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIHRoYXQgd2lsbCBiZSBwcm9kdWNlZCBuZXh0ICovXG4gICAgICAgIHRoaXMuX3Byb2R1Y2VySW5kZXggPSBudW1iZXJPZkJ1ZmZlcnMgLSAxO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BlZWR5UHJvbWlzZTx2b2lkPltdfSBwcm9kdWNlci1jb25zdW1lciBwcm9taXNlcyAqL1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtYmVyT2ZCdWZmZXJzIH0sICgpID0+IFNwZWVkeVByb21pc2UucmVzb2x2ZSgpKTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW5bXX0gYXJlIHRoZSBjb250ZW50cyBvZiB0aGUgaXRoIGJ1ZmZlciBiZWluZyBwcm9kdWNlZD8gKi9cbiAgICAgICAgdGhpcy5fYnVzeSA9IChuZXcgQXJyYXkobnVtYmVyT2ZCdWZmZXJzKSkuZmlsbChmYWxzZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFuW119IGNhbiB0aGUgaXRoIGJ1ZmZlciBiZSBjb25zdW1lZD8gKi9cbiAgICAgICAgdGhpcy5fcmVhZHkgPSAobmV3IEFycmF5KG51bWJlck9mQnVmZmVycykpLmZpbGwodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3BlZWR5R1BVfSBncHVcbiAgICAgKi9cbiAgICBpbml0KGdwdSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2FsbG9jYXRlUEJPcyhncHUpO1xuICAgICAgICBncHUuc3Vic2NyaWJlKHRoaXMuX2FsbG9jYXRlUEJPcywgdGhpcywgZ3B1KTtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSByZXNvdXJjZXNcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgcmVsZWFzZShncHUpXG4gICAge1xuICAgICAgICBncHUudW5zdWJzY3JpYmUodGhpcy5fYWxsb2NhdGVQQk9zLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fZGVhbGxvY2F0ZVBCT3MoZ3B1KTtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHBpeGVscyBmcm9tIGEgdGV4dHVyZSwgc3luY2hyb25vdXNseS5cbiAgICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBhICh4LHksd2lkdGgsaGVpZ2h0KSBzdWItcmVjdGFuZ2xlLlxuICAgICAqIEBwYXJhbSB7U3BlZWR5RHJhd2FibGVUZXh0dXJlfSB0ZXh0dXJlIGEgdGV4dHVyZSB3aXRoIGEgRkJPXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF1cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gcGl4ZWxzIGluIHRoZSBSR0JBIGZvcm1hdFxuICAgICAqL1xuICAgIHJlYWRQaXhlbHNTeW5jKHRleHR1cmUsIHggPSAwLCB5ID0gMCwgd2lkdGggPSB0ZXh0dXJlLndpZHRoLCBoZWlnaHQgPSB0ZXh0dXJlLmhlaWdodClcbiAgICB7XG4gICAgICAgIFV0aWxzLmFzc2VydCh0aGlzLl9pbml0aWFsaXplZCk7XG5cbiAgICAgICAgY29uc3QgZ2wgPSB0ZXh0dXJlLmdsO1xuICAgICAgICBjb25zdCBmYm8gPSB0ZXh0dXJlLmdsRmJvO1xuXG4gICAgICAgIC8vIGNsYW1wIHZhbHVlc1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHdpZHRoLCB0ZXh0dXJlLndpZHRoKSk7XG4gICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGhlaWdodCwgdGV4dHVyZS5oZWlnaHQpKTtcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHgsIHRleHR1cmUud2lkdGggLSB3aWR0aCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeSwgdGV4dHVyZS5oZWlnaHQgLSBoZWlnaHQpKTtcblxuICAgICAgICAvLyBidWZmZXIgYWxsb2NhdGlvblxuICAgICAgICBjb25zdCBzaXplb2ZCdWZmZXIgPSB3aWR0aCAqIGhlaWdodCAqIDQ7IC8vIDQgYnl0ZXMgcGVyIHBpeGVsIChSR0JBKVxuICAgICAgICB0aGlzLl9yZWFsbG9jYXRlKHNpemVvZkJ1ZmZlcik7XG5cbiAgICAgICAgLy8gbG9zdCBjb250ZXh0P1xuICAgICAgICBpZihnbC5pc0NvbnRleHRMb3N0KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxCdWZmZXJbMF0uc3ViYXJyYXkoMCwgc2l6ZW9mQnVmZmVyKTtcblxuICAgICAgICAvLyByZWFkIHBpeGVsc1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5fcGl4ZWxCdWZmZXJbMF0pO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbEJ1ZmZlclswXS5zdWJhcnJheSgwLCBzaXplb2ZCdWZmZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWQgcGl4ZWxzIGZyb20gYSB0ZXh0dXJlLCBhc3luY2hyb25vdXNseSwgd2l0aCBQQk9zLlxuICAgICAqIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGEgKHgseSx3aWR0aCxoZWlnaHQpIHN1Yi1yZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtTcGVlZHlEcmF3YWJsZVRleHR1cmV9IHRleHR1cmUgYSB0ZXh0dXJlIHdpdGggYSBGQk9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3hdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5XSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUJ1ZmZlcmVkRG93bmxvYWRzXSBhY2NlbGVyYXRlIGRvd25sb2FkcyBieSByZXR1cm5pbmcgcGl4ZWxzIGZyb20gdGhlIHRleHR1cmUgb2YgdGhlIHByZXZpb3VzIGNhbGwgKHVzZWZ1bCBmb3Igc3RyZWFtaW5nKVxuICAgICAqIEByZXR1cm5zIHtTcGVlZHlQcm9taXNlPFVpbnQ4QXJyYXk+fSByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBwaXhlbHMgaW4gdGhlIFJHQkEgZm9ybWF0XG4gICAgICovXG4gICAgcmVhZFBpeGVsc0FzeW5jKHRleHR1cmUsIHggPSAwLCB5ID0gMCwgd2lkdGggPSB0ZXh0dXJlLndpZHRoLCBoZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCwgdXNlQnVmZmVyZWREb3dubG9hZHMgPSBmYWxzZSlcbiAgICB7XG4gICAgICAgIFV0aWxzLmFzc2VydCh0aGlzLl9pbml0aWFsaXplZCk7XG5cbiAgICAgICAgY29uc3QgZ2wgPSB0ZXh0dXJlLmdsO1xuICAgICAgICBjb25zdCBmYm8gPSB0ZXh0dXJlLmdsRmJvO1xuXG4gICAgICAgIC8vIGNsYW1wIHZhbHVlc1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHdpZHRoLCB0ZXh0dXJlLndpZHRoKSk7XG4gICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGhlaWdodCwgdGV4dHVyZS5oZWlnaHQpKTtcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHgsIHRleHR1cmUud2lkdGggLSB3aWR0aCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeSwgdGV4dHVyZS5oZWlnaHQgLSBoZWlnaHQpKTtcblxuICAgICAgICAvLyBidWZmZXIgYWxsb2NhdGlvblxuICAgICAgICBjb25zdCBzaXplb2ZCdWZmZXIgPSB3aWR0aCAqIGhlaWdodCAqIDQ7IC8vIDQgYnl0ZXMgcGVyIHBpeGVsIChSR0JBKVxuICAgICAgICB0aGlzLl9yZWFsbG9jYXRlKHNpemVvZkJ1ZmZlcik7XG5cbiAgICAgICAgLy8gbG9zdCBjb250ZXh0P1xuICAgICAgICBpZihnbC5pc0NvbnRleHRMb3N0KCkpXG4gICAgICAgICAgICByZXR1cm4gU3BlZWR5UHJvbWlzZS5yZXNvbHZlKHRoaXMuX3BpeGVsQnVmZmVyWzBdLnN1YmFycmF5KDAsIHNpemVvZkJ1ZmZlcikpO1xuXG4gICAgICAgIC8vIGRvIG5vdCBvcHRpbWl6ZT9cbiAgICAgICAgaWYoIXVzZUJ1ZmZlcmVkRG93bmxvYWRzKSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbEJ1ZmZlciA9IHRoaXMuX3BpeGVsQnVmZmVyWzBdLnN1YmFycmF5KDAsIHNpemVvZkJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gU3BlZWR5VGV4dHVyZVJlYWRlci5fcmVhZFBpeGVsc1ZpYVBCTyhnbCwgdGhpcy5fcGJvWzBdLCBwaXhlbEJ1ZmZlciwgZmJvLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KS50aGVuKCgpID0+XG4gICAgICAgICAgICAgICAgcGl4ZWxCdWZmZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWRlIGxhdGVuY3kgd2l0aCBhIFByb2R1Y2VyLUNvbnN1bWVyIG1lY2hhbmlzbVxuICAgICAgICBjb25zdCBudW1iZXJPZkJ1ZmZlcnMgPSB0aGlzLl9waXhlbEJ1ZmZlci5sZW5ndGg7XG5cbiAgICAgICAgLy8gR1BVIG5lZWRzIHRvIHByb2R1Y2UgZGF0YVxuICAgICAgICBjb25zdCBwcm9kdWNlckluZGV4ID0gdGhpcy5fcHJvZHVjZXJJbmRleDtcblxuICAgICAgICBpZighdGhpcy5fYnVzeVtwcm9kdWNlckluZGV4XSkge1xuICAgICAgICAgICAgY29uc3QgcGJvID0gdGhpcy5fcGJvW3Byb2R1Y2VySW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxCdWZmZXIgPSB0aGlzLl9waXhlbEJ1ZmZlcltwcm9kdWNlckluZGV4XS5zdWJhcnJheSgwLCBzaXplb2ZCdWZmZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9kdWNlckluZGV4ID0gKHByb2R1Y2VySW5kZXggKyAxKSAlIG51bWJlck9mQnVmZmVycztcblxuICAgICAgICAgICAgdGhpcy5fcmVhZHlbcHJvZHVjZXJJbmRleF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2J1c3lbcHJvZHVjZXJJbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgLy9jb25zb2xlLnRpbWUoXCJwcm9kdWNlIFwiK3Byb2R1Y2VySW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVtwcm9kdWNlckluZGV4XSA9IFNwZWVkeVRleHR1cmVSZWFkZXIuX3JlYWRQaXhlbHNWaWFQQk8oZ2wsIHBibywgcGl4ZWxCdWZmZXIsIGZibywgeCwgeSwgd2lkdGgsIGhlaWdodCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLnRpbWVFbmQoXCJwcm9kdWNlIFwiK3Byb2R1Y2VySW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1c3lbcHJvZHVjZXJJbmRleF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkeVtwcm9kdWNlckluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL2Vsc2UgY29uc29sZS5sb2coXCJza2lwXCIscHJvZHVjZXJJbmRleCk7XG4gICAgICAgIGVsc2UgLyogc2tpcCBmcmFtZSAqLyA7XG5cbiAgICAgICAgLy8gQ1BVIG5lZWRzIHRvIGNvbnN1bWUgZGF0YVxuICAgICAgICBjb25zdCBjb25zdW1lckluZGV4ID0gdGhpcy5fY29uc3VtZXJJbmRleDtcbiAgICAgICAgdGhpcy5fY29uc3VtZXJJbmRleCA9IChjb25zdW1lckluZGV4ICsgMSkgJSBudW1iZXJPZkJ1ZmZlcnM7XG5cbiAgICAgICAgaWYoIXRoaXMuX3JlYWR5W2NvbnN1bWVySW5kZXhdKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUudGltZShcImNvbnN1bWUgXCIrY29uc3VtZXJJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVtjb25zdW1lckluZGV4XS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUudGltZUVuZChcImNvbnN1bWUgXCIrY29uc3VtZXJJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZHlbY29uc3VtZXJJbmRleF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxCdWZmZXJbY29uc3VtZXJJbmRleF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOTyBXQUlUIFwiK2NvbnN1bWVySW5kZXgpO1xuICAgICAgICB0aGlzLl9yZWFkeVtjb25zdW1lckluZGV4XSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gU3BlZWR5UHJvbWlzZS5yZXNvbHZlKHRoaXMuX3BpeGVsQnVmZmVyW2NvbnN1bWVySW5kZXhdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFsbG9jYXRlIHRoZSBwaXhlbCBidWZmZXJzLCBzbyB0aGF0IHRoZXkgY2FuIGhvbGQgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBieXRlc1xuICAgICAqIElmIHRoZSBwaXhlbCBidWZmZXJzIGFscmVhZHkgaGF2ZSB0aGUgcmVxdWlyZWQgY2FwYWNpdHksIHRoZW4gbm90aGluZyBpcyBkb25lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgaW4gYnl0ZXNcbiAgICAgKi9cbiAgICBfcmVhbGxvY2F0ZShzaXplKVxuICAgIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byByZWFsbG9jYXRlXG4gICAgICAgIGlmKHNpemUgPD0gdGhpcy5fcGl4ZWxCdWZmZXJbMF0uYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyByZWFsbG9jYXRlXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9waXhlbEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICAvL25ld0J1ZmZlci5zZXQodGhpcy5fcGl4ZWxCdWZmZXJbaV0pOyAvLyBtYWtlIHRoaXMgb3B0aW9uYWw/XG4gICAgICAgICAgICB0aGlzLl9waXhlbEJ1ZmZlcltpXSA9IG5ld0J1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlIFBCT3NcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICovXG4gICAgX2FsbG9jYXRlUEJPcyhncHUpXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IGdwdS5nbDtcblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGJvLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5fcGJvW2ldID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVhbGxvY2F0ZSBQQk9zXG4gICAgICogQHBhcmFtIHtTcGVlZHlHUFV9IGdwdVxuICAgICAqL1xuICAgIF9kZWFsbG9jYXRlUEJPcyhncHUpXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IGdwdS5nbDtcblxuICAgICAgICBmb3IobGV0IGkgPSB0aGlzLl9wYm8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9wYm9baV0pO1xuICAgICAgICAgICAgdGhpcy5fcGJvW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWQgcGl4ZWxzIHRvIGEgVWludDhBcnJheSwgYXN5bmNocm9ub3VzbHksIHVzaW5nIGEgUGl4ZWwgQnVmZmVyIE9iamVjdCAoUEJPKVxuICAgICAqIEl0J3MgYXNzdW1lZCB0aGF0IHRoZSB0YXJnZXQgdGV4dHVyZSBpcyBpbiB0aGUgUkdCQTggZm9ybWF0XG4gICAgICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ9IHBib1xuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gb3V0cHV0QnVmZmVyIHdpdGggc2l6ZSA+PSB3aWR0aCAqIGhlaWdodCAqIDRcbiAgICAgKiBAcGFyYW0ge1dlYkdMRnJhbWVidWZmZXJ9IGZib1xuICAgICAqIEBwYXJhbSB7R0xpbnR9IHhcbiAgICAgKiBAcGFyYW0ge0dMaW50fSB5XG4gICAgICogQHBhcmFtIHtHTHNpemVpfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7R0xzaXplaX0gaGVpZ2h0XG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgc3RhdGljIF9yZWFkUGl4ZWxzVmlhUEJPKGdsLCBwYm8sIG91dHB1dEJ1ZmZlciwgZmJvLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgLypcblxuICAgICAgICBXaGVuIHRlc3RpbmcgU3BlZWR5IG9uIENocm9tZSAobW9iaWxlKSB1c2luZyBhYm91dDp0cmFjaW5nIHdpdGggdGhlXG4gICAgICAgIC0tZW5hYmxlLWdwdS1zZXJ2aWNlLXRyYWNpbmcgZmxhZywgSSBmb3VuZCB0aGF0IEEgTE9UIG9mIHRpbWUgaXMgc3BlbnRcbiAgICAgICAgaW4gVHJhY2VHTEFQSTo6Z2xNYXBCdWZmZXJSYW5nZSwgd2hpY2ggdGFrZXMgcGxhY2UganVzdCBhZnRlclxuICAgICAgICBHTEVTMkRlY29kZXJJbXBsOjpIYW5kbGVSZWFkUGl4ZWxzIGFuZCBHTEVTMkRlY29kZXJJbXBsOjpnbFJlYWRQaXhlbHMuXG5cbiAgICAgICAgVXNpbmcgbXVsdGlwbGUgUEJPcyBkb2Vzbid0IHNlZW0gdG8gaW1wYWN0IENocm9tZSB0b28gbXVjaC4gUGVyZm9ybWFuY2VcbiAgICAgICAgaXMgbXVjaCBiZXR0ZXIgb24gRmlyZWZveC4gVGhpcyBzdWdnZXN0cyB0aGVyZSBpcyByb29tIGZvciBpbXByb3ZlbWVudC5cbiAgICAgICAgSSBkbyBub3QgeWV0IHVuZGVyc3RhbmQgY2xlYXJseSB0aGUgY2F1c2UgZm9yIHRoaXMgbGFnIG9uIENocm9tZS4gSXRcbiAgICAgICAgbWF5IGJlIGEgQ1BVLUdQVSBzeW5jaHJvbml6YXRpb24gaXNzdWUuXG5cbiAgICAgICAgRURJVDogSSBoYXZlIGZvdW5kIHRoYXQgdXNpbmcgZ2wuZmx1c2goKSBhZ2dyZXNzaXZlbHkgZ3JlYXRseSBpbXByb3Zlc1xuICAgICAgICAgICAgICB0aGluZ3MuIFdlYkdMIGNvbW1hbmRzIHdpbGwgYmUgcHVzaGVkIGZyZXF1ZW50bHkhXG5cbiAgICAgICAgU2VlIGFsc286XG4gICAgICAgIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzL2xhdGVzdC8yLjAvIzMuNy4zIChCdWZmZXIgb2JqZWN0cylcbiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvbWFzdGVyL2RvY3MvZ3B1L2RlYnVnZ2luZ19ncHVfcmVsYXRlZF9jb2RlLm1kXG5cbiAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHdpZHRoICogaGVpZ2h0ICogNDtcblxuICAgICAgICAvLyB2YWxpZGF0ZSBvdXRwdXRCdWZmZXJcbiAgICAgICAgVXRpbHMuYXNzZXJ0KG91dHB1dEJ1ZmZlci5ieXRlTGVuZ3RoID49IHNpemUsIGBJbnZhbGlkIGJ1ZmZlciBzaXplYCk7XG5cbiAgICAgICAgLy8gcmVhZCBwaXhlbHMgaW50byB0aGUgUEJPXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuUElYRUxfUEFDS19CVUZGRVIsIHBibyk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuUElYRUxfUEFDS19CVUZGRVIsIHNpemUsIGdsLkRZTkFNSUNfUkVBRCk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgICAgICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCAwKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5QSVhFTF9QQUNLX0JVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgZmVuY2VcbiAgICAgICAgY29uc3Qgc3luYyA9IGdsLmZlbmNlU3luYyhnbC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwgMCk7XG4gICAgICAgIGdsLmZsdXNoKCk7IC8vIG1ha2Ugc3VyZSB0aGUgc3luYyBjb21tYW5kIGlzIHJlYWRcblxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgY29tbWFuZHMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSBHUFVcbiAgICAgICAgcmV0dXJuIG5ldyBTcGVlZHlQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBXZWJHTDIgc3BlYyBzZWMgMy43LjE0IFN5bmMgb2JqZWN0cyxcbiAgICAgICAgICAgIC8vIFwic3luYyBvYmplY3RzIG1heSBvbmx5IHRyYW5zaXRpb24gdG8gdGhlIHNpZ25hbGVkIHN0YXRlXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSB1c2VyIGFnZW50J3MgZXZlbnQgbG9vcCBpcyBub3QgZXhlY3V0aW5nIGEgdGFza1wiXG4gICAgICAgICAgICAvLyBpbiBvdGhlciB3b3JkcywgaXQgd29uJ3QgYmUgc2lnbmFsZWQgaW4gdGhlIHNhbWUgZnJhbWVcbiAgICAgICAgICAgIGlmKFNldHRpbmdzLmdwdVBvbGxpbmdNb2RlICE9ICdhc2FwJylcbiAgICAgICAgICAgICAgICBydW5Pbk5leHRGcmFtZShTcGVlZHlUZXh0dXJlUmVhZGVyLl9jbGllbnRXYWl0QXN5bmMsIGdsLCBzeW5jLCAwLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFzYXAoU3BlZWR5VGV4dHVyZVJlYWRlci5fY2xpZW50V2FpdEFzeW5jLCBnbCwgc3luYywgMCwgcmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuUElYRUxfUEFDS19CVUZGRVIsIHBibyk7XG4gICAgICAgICAgICBnbC5nZXRCdWZmZXJTdWJEYXRhKGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCAwLCBvdXRwdXRCdWZmZXIpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5QSVhFTF9QQUNLX0JVRkZFUiwgbnVsbCk7XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKGBDYW4ndCBnZXRCdWZmZXJTdWJEYXRhQXN5bmMoKTogZXJyb3IgaW4gY2xpZW50V2FpdEFzeW5jKClgLCBlcnIpO1xuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVN5bmMoc3luYyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciBhIHN5bmMgb2JqZWN0IHRvIGJlY29tZSBzaWduYWxlZFxuICAgICAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICAgKiBAcGFyYW0ge1dlYkdMU3luY30gc3luY1xuICAgICAqIEBwYXJhbSB7R0xiaXRmaWVsZH0gZmxhZ3MgbWF5IGJlIGdsLlNZTkNfRkxVU0hfQ09NTUFORFNfQklUIG9yIDBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb2xsSW50ZXJ2YWxdIGluIG1pbGxpc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVtYWluaW5nQXR0ZW1wdHNdIGZvciB0aW1lb3V0XG4gICAgICovXG4gICAgc3RhdGljIF9jbGllbnRXYWl0QXN5bmMoZ2wsIHN5bmMsIGZsYWdzLCByZXNvbHZlLCByZWplY3QsIHBvbGxJbnRlcnZhbCA9IDEwLCByZW1haW5pbmdBdHRlbXB0cyA9IDEwMDApXG4gICAge1xuICAgICAgICAoZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGdsLmNsaWVudFdhaXRTeW5jKHN5bmMsIGZsYWdzLCAwKTtcblxuICAgICAgICAgICAgaWYocmVtYWluaW5nQXR0ZW1wdHMtLSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUaW1lb3V0RXJyb3IoYEdQVSBwb2xsaW5nIHRpbWVvdXRgLCBHTEVycm9yLmZyb20oZ2wpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHN0YXR1cyA9PT0gZ2wuQ09ORElUSU9OX1NBVElTRklFRCB8fCBzdGF0dXMgPT09IGdsLkFMUkVBRFlfU0lHTkFMRUQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL3NldFRpbWVvdXQocG9sbCwgcG9sbEludGVydmFsKTtcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5ncHVQb2xsaW5nTW9kZSAhPSAnYXNhcCcpXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShwb2xsKTsgLy8gUkFGIGlzIGEgcmF0aGVyIHVudXN1YWwgd2F5IHRvIGRvIHBvbGxpbmcgYXQgfjYwIGZwcy4gRG9lcyBpdCByZWR1Y2UgQ1BVIHVzYWdlP1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYXNhcChwb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogc3BlZWR5LXRleHR1cmUtdXBsb2FkZXIuanNcbiAqIEEgdXRpbGl0eSB0aGF0IGhlbHBzIHVwbG9hZGluZyBkYXRhIHRvIHRleHR1cmVzXG4gKi9cblxuaW1wb3J0IHsgU3BlZWR5R1BVIH0gZnJvbSAnLi9zcGVlZHktZ3B1JztcbmltcG9ydCB7IFNwZWVkeVRleHR1cmUgfSBmcm9tICcuL3NwZWVkeS10ZXh0dXJlJztcbmltcG9ydCB7IFNwZWVkeU1lZGlhU291cmNlIH0gZnJvbSAnLi4vY29yZS9zcGVlZHktbWVkaWEtc291cmNlJztcblxuLyoqXG4gKiBBIHV0aWxpdHkgdGhhdCBoZWxwcyB1cGxvYWRpbmcgZGF0YSB0byB0ZXh0dXJlc1xuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5VGV4dHVyZVVwbG9hZGVyXG57XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUdQVX0gZ3B1XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3B1KVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHtTcGVlZHlHUFV9IEdQVSBpbnN0YW5jZSAqL1xuICAgICAgICB0aGlzLl9ncHUgPSBncHU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBsb2FkIGFuIGltYWdlIHRvIHRoZSBHUFVcbiAgICAgKiBAcGFyYW0ge1NwZWVkeU1lZGlhU291cmNlfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge1NwZWVkeVRleHR1cmV9IG91dHB1dFRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5VGV4dHVyZX0gb3V0cHV0IHRleHR1cmVcbiAgICAgKi9cbiAgICB1cGxvYWQoc291cmNlLCBvdXRwdXRUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHNvdXJjZS5kYXRhO1xuXG4gICAgICAgIC8vIGJ1Z2ZpeDogaWYgdGhlIG1lZGlhIGlzIGEgdmlkZW8sIHdlIGNhbid0IHJlYWxseVxuICAgICAgICAvLyB1cGxvYWQgaXQgdG8gdGhlIEdQVSB1bmxlc3MgaXQncyByZWFkeVxuICAgICAgICAvL2lmKGRhdGEuY29uc3RydWN0b3IubmFtZSA9PSAnSFRNTFZpZGVvRWxlbWVudCcpIHtcbiAgICAgICAgaWYoZGF0YSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmKGRhdGEucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG1heSBoYXBwZW4gd2hlbiB0aGUgdmlkZW8gbG9vcHMgKEZpcmVmb3gpXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBwcmV2aW91c2x5IHVwbG9hZGVkIHRleHR1cmVcbiAgICAgICAgICAgICAgICAvL1V0aWxzLndhcm5pbmcoYFRyeWluZyB0byBwcm9jZXNzIGEgdmlkZW8gdGhhdCBpc24ndCByZWFkeSB5ZXRgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0VGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwbG9hZCB0byB0aGUgb3V0cHV0IHRleHR1cmVcbiAgICAgICAgcmV0dXJuIG91dHB1dFRleHR1cmUudXBsb2FkKGRhdGEsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgdGV4dHVyZSB1cGxvYWRlclxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHJlbGVhc2UoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIHNwZWVkeS10ZXh0dXJlLmpzXG4gKiBBIHdyYXBwZXIgYXJvdW5kIFdlYkdMVGV4dHVyZVxuICovXG5cbmltcG9ydCB7IFNwZWVkeUdQVSB9IGZyb20gJy4vc3BlZWR5LWdwdSc7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IElsbGVnYWxPcGVyYXRpb25FcnJvciwgSWxsZWdhbEFyZ3VtZW50RXJyb3IsIE5vdFN1cHBvcnRlZEVycm9yLCBHTEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCB7IE1BWF9URVhUVVJFX0xFTkdUSCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbHMnO1xuXG4vKipcbiAqIEdldCBhIGJ1ZmZlciBmaWxsZWQgd2l0aCB6ZXJvc1xuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgbnVtYmVyIG9mIGJ5dGVzXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuLypcbmNvbnN0IHplcm9zID0gKGZ1bmN0aW9uKCkge1xuICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0KTtcblxuICAgIHJldHVybiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIGlmKHNpemUgPiBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheSgwLCBzaXplKTtcbiAgICB9XG59KSgpO1xuKi9cblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIFdlYkdMVGV4dHVyZVxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5VGV4dHVyZVxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB0ZXh0dXJlIHdpZHRoIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgdGV4dHVyZSBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmb3JtYXRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcm5hbEZvcm1hdF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFUeXBlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZmlsdGVyXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd3JhcF1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0ID0gZ2wuUkdCQSwgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBOCwgZGF0YVR5cGUgPSBnbC5VTlNJR05FRF9CWVRFLCBmaWx0ZXIgPSBnbC5ORUFSRVNULCB3cmFwID0gZ2wuTUlSUk9SRURfUkVQRUFUKVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSByZW5kZXJpbmcgY29udGV4dCAqL1xuICAgICAgICB0aGlzLl9nbCA9IGdsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgdGV4dHVyZSAqL1xuICAgICAgICB0aGlzLl93aWR0aCA9IE1hdGgubWF4KDEsIHdpZHRoIHwgMCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IGhlaWdodCBvZiB0aGUgdGV4dHVyZSAqL1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLm1heCgxLCBoZWlnaHQgfCAwKTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IGhhdmUgd2UgZ2VuZXJhdGVkIG1pcG1hcHMgZm9yIHRoaXMgdGV4dHVyZT8gKi9cbiAgICAgICAgdGhpcy5faGFzTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSB0ZXh0dXJlIGZvcm1hdCAqL1xuICAgICAgICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IGludGVybmFsIGZvcm1hdCAodXN1YWxseSBhIHNpemVkIGZvcm1hdCkgKi9cbiAgICAgICAgdGhpcy5faW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gZGF0YSB0eXBlICovXG4gICAgICAgIHRoaXMuX2RhdGFUeXBlID0gZGF0YVR5cGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IHRleHR1cmUgZmlsdGVyaW5nIChtaW4gJiBtYWcpICovXG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IGZpbHRlcjtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gdGV4dHVyZSB3cmFwcGluZyAqL1xuICAgICAgICB0aGlzLl93cmFwID0gd3JhcDtcblxuICAgICAgICAvKiogQHR5cGUge1dlYkdMVGV4dHVyZX0gaW50ZXJuYWwgdGV4dHVyZSBvYmplY3QgKi9cbiAgICAgICAgdGhpcy5fZ2xUZXh0dXJlID0gU3BlZWR5VGV4dHVyZS5fY3JlYXRlVGV4dHVyZSh0aGlzLl9nbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fZm9ybWF0LCB0aGlzLl9pbnRlcm5hbEZvcm1hdCwgdGhpcy5fZGF0YVR5cGUsIHRoaXMuX2ZpbHRlciwgdGhpcy5fd3JhcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgdGhlIHRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICByZWxlYXNlKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG5cbiAgICAgICAgLy8gYWxyZWFkeSByZWxlYXNlZD9cbiAgICAgICAgaWYodGhpcy5fZ2xUZXh0dXJlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKGBUaGUgU3BlZWR5VGV4dHVyZSBoYXMgYWxyZWFkeSBiZWVuIHJlbGVhc2VkYCk7XG5cbiAgICAgICAgLy8gcmVsZWFzZSByZXNvdXJjZXNcbiAgICAgICAgdGhpcy5kaXNjYXJkTWlwbWFwcygpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRoaXMuX2dsVGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2dsVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5faGVpZ2h0ID0gMDtcblxuICAgICAgICAvLyBkb25lIVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgcGl4ZWwgZGF0YSB0byB0aGUgdGV4dHVyZS4gVGhlIHRleHR1cmUgd2lsbCBiZSByZXNpemVkIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge1RleEltYWdlU291cmNlfSBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gaW4gcGl4ZWxzXG4gICAgICogQHJldHVybiB7U3BlZWR5VGV4dHVyZX0gdGhpc1xuICAgICAqL1xuICAgIHVwbG9hZChwaXhlbHMsIHdpZHRoID0gdGhpcy5fd2lkdGgsIGhlaWdodCA9IHRoaXMuX2hlaWdodClcbiAgICB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgIFV0aWxzLmFzc2VydCh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCk7XG5cbiAgICAgICAgdGhpcy5kaXNjYXJkTWlwbWFwcygpO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2ludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTg7XG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IGdsLlJHQkE7XG4gICAgICAgIHRoaXMuX2RhdGFUeXBlID0gZ2wuVU5TSUdORURfQllURTtcblxuICAgICAgICBTcGVlZHlUZXh0dXJlLl91cGxvYWQoZ2wsIHRoaXMuX2dsVGV4dHVyZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgcGl4ZWxzLCAwLCB0aGlzLl9mb3JtYXQsIHRoaXMuX2ludGVybmFsRm9ybWF0LCB0aGlzLl9kYXRhVHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSB0ZXh0dXJlXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgY2xlYXIoKVxuICAgIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcblxuICAgICAgICAvLyBjb250ZXh0IGxvc3M/XG4gICAgICAgIGlmKGdsLmlzQ29udGV4dExvc3QoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIGNsZWFyIHRleHR1cmUgZGF0YVxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9nbFRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX2ludGVybmFsRm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCAwLCB0aGlzLl9mb3JtYXQsIHRoaXMuX2RhdGFUeXBlLCBudWxsKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgICAgICAgLy8gbm8gbWlwbWFwc1xuICAgICAgICB0aGlzLmRpc2NhcmRNaXBtYXBzKCk7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoaXMgdGV4dHVyZS4gSXRzIGNvbnRlbnQgd2lsbCBiZSBsb3N0IVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBuZXcgd2lkdGgsIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgbmV3IGhlaWdodCwgaW4gcGl4ZWxzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcmVzaXplP1xuICAgICAgICBpZih0aGlzLl93aWR0aCA9PT0gd2lkdGggJiYgdGhpcy5faGVpZ2h0ID09PSBoZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyB2YWxpZGF0ZSBzaXplXG4gICAgICAgIHdpZHRoIHw9IDA7IGhlaWdodCB8PSAwO1xuICAgICAgICBpZih3aWR0aCA+IE1BWF9URVhUVVJFX0xFTkdUSCB8fCBoZWlnaHQgPiBNQVhfVEVYVFVSRV9MRU5HVEgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoYE1heGltdW0gdGV4dHVyZSBzaXplIGV4Y2VlZGVkLiBVc2luZyAke3dpZHRofSB4ICR7aGVpZ2h0fSwgZXhwZWN0ZWQgdXAgdG8gJHtNQVhfVEVYVFVSRV9MRU5HVEh9IHggJHtNQVhfVEVYVFVSRV9MRU5HVEh9LmApO1xuICAgICAgICBlbHNlIGlmKHdpZHRoIDwgMSB8fCBoZWlnaHQgPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBJbnZhbGlkIHRleHR1cmUgc2l6ZTogJHt3aWR0aH0geCAke2hlaWdodH1gKTtcblxuICAgICAgICAvLyBjb250ZXh0IGxvc3M/XG4gICAgICAgIGlmKGdsLmlzQ29udGV4dExvc3QoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyByZXNpemVcbiAgICAgICAgLy8gTm90ZTogdGhpcyBpcyBmYXN0IG9uIENocm9tZSwgYnV0IHNlZW1zIHNsb3cgb24gRmlyZWZveFxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9nbFRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX2ludGVybmFsRm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCAwLCB0aGlzLl9mb3JtYXQsIHRoaXMuX2RhdGFUeXBlLCBudWxsKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgICAgICAgLy8gbm8gbWlwbWFwc1xuICAgICAgICB0aGlzLmRpc2NhcmRNaXBtYXBzKCk7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgbWlwbWFwXG4gICAgICogQHBhcmFtIHtTcGVlZHlEcmF3YWJsZVRleHR1cmVbXX0gW21pcG1hcF0gY3VzdG9tIHRleHR1cmUgZm9yIGVhY2ggbWlwIGxldmVsXG4gICAgICogQHJldHVybnMge1NwZWVkeVRleHR1cmV9IHRoaXNcbiAgICAgKi9cbiAgICBnZW5lcmF0ZU1pcG1hcHMobWlwbWFwID0gW10pXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgaWYodGhpcy5faGFzTWlwbWFwcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIGxldCB0aGUgaGFyZHdhcmUgY29tcHV0ZSB0aGUgYWxsIGxldmVscyBvZiB0aGUgcHlyYW1pZCwgdXAgdG8gMXgxXG4gICAgICAgIC8vIHdlIGFsc28gc3BlY2lmeSB0aGUgVEVYVFVSRV9NSU5fRklMVEVSIHRvIGJlIHVzZWQgZnJvbSBub3cgb25cbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2xUZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUik7XG4gICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuICAgICAgICAvLyBhY2NlcHQgY3VzdG9tIHRleHR1cmVzXG4gICAgICAgIGlmKG1pcG1hcC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBleHBlY3RlZCBudW1iZXIgb2YgbWlwbWFwIGxldmVscyBhY2NvcmRpbmcgdG8gdGhlIE9wZW5HTCBFUyAzLjAgc3BlYyAoc2VjIDMuOC4xMC40KVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IG51bU1pcG1hcHMgPSAxICsgTWF0aC5mbG9vcihNYXRoLmxvZzIoTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpKTtcbiAgICAgICAgICAgIFV0aWxzLmFzc2VydChtaXBtYXAubGVuZ3RoIDw9IG51bU1pcG1hcHMpO1xuXG4gICAgICAgICAgICAvLyB2ZXJpZnkgdGhlIGRpbWVuc2lvbnMgb2YgZWFjaCBsZXZlbFxuICAgICAgICAgICAgZm9yKGxldCBsZXZlbCA9IDE7IGxldmVsIDwgbWlwbWFwLmxlbmd0aDsgbGV2ZWwrKykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBtYXgoMSwgZmxvb3Ioc2l6ZSAvIDJebG9kKSksIGluIGFjY29yZGFuY2UgdG9cbiAgICAgICAgICAgICAgICAvLyB0aGUgT3BlbkdMIEVTIDMuMCBzcGVjIHNlYyAzLjguMTAuNCAoTWlwbWFwcGluZylcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gTWF0aC5tYXgoMSwgd2lkdGggPj4+IGxldmVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gTWF0aC5tYXgoMSwgaGVpZ2h0ID4+PiBsZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAvLyB2ZXJpZnkgdGhlIGRpbWVuc2lvbnMgb2YgdGhpcyBsZXZlbFxuICAgICAgICAgICAgICAgIFV0aWxzLmFzc2VydChtaXBtYXBbbGV2ZWxdLndpZHRoID09PSB3ICYmIG1pcG1hcFtsZXZlbF0uaGVpZ2h0ID09PSBoKTtcblxuICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gbWlwbWFwXG4gICAgICAgICAgICAgICAgbWlwbWFwW2xldmVsXS5jb3B5VG8odGhpcywgbGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgdGhpcy5faGFzTWlwbWFwcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHByZXZpb3VzbHkgZ2VuZXJhdGVkIG1pcG1hcCwgaWYgYW55XG4gICAgICovXG4gICAgZGlzY2FyZE1pcG1hcHMoKVxuICAgIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcblxuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmKCF0aGlzLl9oYXNNaXBtYXBzKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBtaW4gZmlsdGVyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX2dsVGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9maWx0ZXIpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuICAgICAgICAvLyBkb25lIVxuICAgICAgICB0aGlzLl9oYXNNaXBtYXBzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGlzIHRleHR1cmUgaGF2ZSBhIG1pcG1hcD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNNaXBtYXBzKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNaXBtYXBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhcyB0aGlzIHRleHR1cmUgYmVlbiByZWxlYXNlZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlbGVhc2VkKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbFRleHR1cmUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgV2ViR0xUZXh0dXJlXG4gICAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgZ2xUZXh0dXJlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbFRleHR1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLCBpbiBwaXhlbHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZSwgaW4gcGl4ZWxzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYkdMIENvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICBnZXQgZ2woKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYkdMIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZvcm1hdCB1c3VhbGx5IGdsLlJHQkFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgdXN1YWxseSBnbC5SR0JBOFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhVHlwZSB1c3VhbGx5IGdsLlVOU0lHTkVEX0JZVEVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlsdGVyIHVzdWFsbHkgZ2wuTkVBUkVTVCBvciBnbC5MSU5FQVJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd3JhcCBnbC5SRVBFQVQsIGdsLk1JUlJPUkVEX1JFUEVBVCBvciBnbC5DTEFNUF9UT19FREdFXG4gICAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgX2NyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgaW50ZXJuYWxGb3JtYXQsIGRhdGFUeXBlLCBmaWx0ZXIsIHdyYXApXG4gICAge1xuICAgICAgICBVdGlscy5hc3NlcnQod2lkdGggPiAwICYmIGhlaWdodCA+IDApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSAmIGJpbmQgdGV4dHVyZVxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICAvLyBzZXR1cFxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB3cmFwKTtcbiAgICAgICAgLy9nbC50ZXhTdG9yYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMSwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIGRhdGFUeXBlLCBudWxsKTtcblxuICAgICAgICAvLyB1bmJpbmQgJiByZXR1cm5cbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgcGl4ZWwgZGF0YSB0byBhIFdlYkdMIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge0dMc2l6ZWl9IHdpZHRoIHRleHR1cmUgd2lkdGhcbiAgICAgKiBAcGFyYW0ge0dMc2l6ZWl9IGhlaWdodCB0ZXh0dXJlIGhlaWdodFxuICAgICAqIEBwYXJhbSB7VGV4SW1hZ2VTb3VyY2V9IHBpeGVsc1xuICAgICAqIEBwYXJhbSB7R0xpbnR9IGxvZCBtaXBtYXAgbGV2ZWwtb2YtZGV0YWlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZvcm1hdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcm5hbEZvcm1hdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhVHlwZVxuICAgICAqIEByZXR1cm5zIHtXZWJHTFRleHR1cmV9IHRleHR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3VwbG9hZChnbCwgdGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgcGl4ZWxzLCBsb2QsIGZvcm1hdCwgaW50ZXJuYWxGb3JtYXQsIGRhdGFUeXBlKVxuICAgIHtcbiAgICAgICAgLy8gUHJlZmVyIGNhbGxpbmcgX3VwbG9hZCgpIGJlZm9yZSBnbC51c2VQcm9ncmFtKCkgdG8gYXZvaWQgdGhlXG4gICAgICAgIC8vIG5lZWRsZXNzIHN3aXRjaGluZyBvZiBHTCBwcm9ncmFtcyBpbnRlcm5hbGx5LiBTZWUgYWxzbzpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9XZWJHTF9iZXN0X3ByYWN0aWNlc1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICAvKlxuICAgICAgICAvLyBzbG93ZXIgdGhhbiB0ZXhJbWFnZTJELCB1bmxpa2UgdGhlIHNwZWM/XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgICAgIC8vIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgIGxvZCwgICAgICAgICAgICAgICAvLyBtaXAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAwLCAgICAgICAgICAgICAgICAgLy8geC1vZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAwLCAgICAgICAgICAgICAgICAgLy8geS1vZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCwgICAgICAgICAgICAgLy8gdGV4dHVyZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgICAgICAgICAgICAvLyB0ZXh0dXJlIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgIGdsLlJHQkEsICAgICAgICAgICAvLyBzb3VyY2UgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVU5TSUdORURfQllURSwgIC8vIHNvdXJjZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzKTsgICAgICAgICAgIC8vIHNvdXJjZSBkYXRhXG4gICAgICAgICovXG5cbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAgICAgICAgLy8gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgbG9kLCAgICAgICAgICAgICAgICAgIC8vIG1pcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0LCAgICAgICAvLyBpbnRlcm5hbCBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCwgICAgICAgICAgICAgICAgLy8gdGV4dHVyZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgICAgICAgICAgICAgICAvLyB0ZXh0dXJlIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgIDAsICAgICAgICAgICAgICAgICAgICAvLyBib3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQsICAgICAgICAgICAgICAgLy8gc291cmNlIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlLCAgICAgICAgICAgICAvLyBzb3VyY2UgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgIHBpeGVscyk7ICAgICAgICAgICAgICAvLyBzb3VyY2UgZGF0YVxuXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBTcGVlZHlUZXh0dXJlIHdpdGggYSBmcmFtZWJ1ZmZlclxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5RHJhd2FibGVUZXh0dXJlIGV4dGVuZHMgU3BlZWR5VGV4dHVyZVxue1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB0ZXh0dXJlIHdpZHRoIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgdGV4dHVyZSBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmb3JtYXRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcm5hbEZvcm1hdF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFUeXBlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZmlsdGVyXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd3JhcF1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0ID0gdW5kZWZpbmVkLCBpbnRlcm5hbEZvcm1hdCA9IHVuZGVmaW5lZCwgZGF0YVR5cGUgPSB1bmRlZmluZWQsIGZpbHRlciA9IHVuZGVmaW5lZCwgd3JhcCA9IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIHN1cGVyKGdsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIGludGVybmFsRm9ybWF0LCBkYXRhVHlwZSwgZmlsdGVyLCB3cmFwKTtcblxuICAgICAgICAvKiogQHR5cGUge1dlYkdMRnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyICovXG4gICAgICAgIHRoaXMuX2dsRmJvID0gU3BlZWR5RHJhd2FibGVUZXh0dXJlLl9jcmVhdGVGcmFtZWJ1ZmZlcihnbCwgdGhpcy5fZ2xUZXh0dXJlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlcyB0aGUgdGV4dHVyZVxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHJlbGVhc2UoKVxuICAgIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcblxuICAgICAgICAvLyBhbHJlYWR5IHJlbGVhc2VkP1xuICAgICAgICBpZih0aGlzLl9nbEZibyA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihgVGhlIFNwZWVkeURyYXdhYmxlVGV4dHVyZSBoYXMgYWxyZWFkeSBiZWVuIHJlbGVhc2VkYCk7XG5cbiAgICAgICAgLy8gcmVsZWFzZSB0aGUgZnJhbWVidWZmZXJcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZ2xGYm8pO1xuICAgICAgICB0aGlzLl9nbEZibyA9IG51bGw7XG5cbiAgICAgICAgLy8gcmVsZWFzZSB0aGUgU3BlZWR5VGV4dHVyZVxuICAgICAgICByZXR1cm4gc3VwZXIucmVsZWFzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBXZWJHTEZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybnMge1dlYkdMRnJhbWVidWZmZXJ9XG4gICAgICovXG4gICAgZ2V0IGdsRmJvKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbEZibztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoaXMgdGV4dHVyZSBpbnRvIGFub3RoZXJcbiAgICAgKiAoeW91IG1heSBoYXZlIHRvIGRpc2NhcmQgdGhlIG1pcG1hcHMgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uKVxuICAgICAqIEBwYXJhbSB7U3BlZWR5VGV4dHVyZX0gdGV4dHVyZSB0YXJnZXQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG9kXSBsZXZlbC1vZi1kZXRhaWwgb2YgdGhlIHRhcmdldCB0ZXh0dXJlXG4gICAgICovXG4gICAgY29weVRvKHRleHR1cmUsIGxvZCA9IDApXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuXG4gICAgICAgIC8vIGNvbnRleHQgbG9zcz9cbiAgICAgICAgaWYoZ2wuaXNDb250ZXh0TG9zdCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgdGV4dHVyZSBzaXplIGFzIG1heCgxLCBmbG9vcihzaXplIC8gMl5sb2QpKSxcbiAgICAgICAgLy8gaW4gYWNjb3JkYW5jZSB0byB0aGUgT3BlbkdMIEVTIDMuMCBzcGVjIHNlYyAzLjguMTAuNFxuICAgICAgICAvLyAoTWlwbWFwcGluZylcbiAgICAgICAgY29uc3QgcG90ID0gMSA8PCAobG9kIHw9IDApO1xuICAgICAgICBjb25zdCBleHBlY3RlZFdpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0ZXh0dXJlLndpZHRoIC8gcG90KSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkSGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0ZXh0dXJlLmhlaWdodCAvIHBvdCkpO1xuXG4gICAgICAgIC8vIHZhbGlkYXRlXG4gICAgICAgIFV0aWxzLmFzc2VydCh0aGlzLl93aWR0aCA9PT0gZXhwZWN0ZWRXaWR0aCAmJiB0aGlzLl9oZWlnaHQgPT09IGV4cGVjdGVkSGVpZ2h0KTtcblxuICAgICAgICAvLyBjb3B5IHRvIHRleHR1cmVcbiAgICAgICAgU3BlZWR5RHJhd2FibGVUZXh0dXJlLl9jb3B5VG9UZXh0dXJlKGdsLCB0aGlzLl9nbEZibywgdGV4dHVyZS5nbFRleHR1cmUsIDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIGxvZCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZXNpemUgdGhpcyB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIG5ldyB3aWR0aCwgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBuZXcgaGVpZ2h0LCBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVzZXJ2ZUNvbnRlbnRdIHNob3VsZCB3ZSBwcmVzZXJ2ZSB0aGUgY29udGVudCBvZiB0aGUgdGV4dHVyZT8gRVhQRU5TSVZFIVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIC8qcmVzaXplKHdpZHRoLCBoZWlnaHQsIHByZXNlcnZlQ29udGVudCA9IGZhbHNlKVxuICAgIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcblxuICAgICAgICAvLyBubyBuZWVkIHRvIHByZXNlcnZlIHRoZSBjb250ZW50P1xuICAgICAgICBpZighcHJlc2VydmVDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBubyBuZWVkIHRvIHJlc2l6ZT9cbiAgICAgICAgaWYodGhpcy5fd2lkdGggPT09IHdpZHRoICYmIHRoaXMuX2hlaWdodCA9PT0gaGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgc2l6ZVxuICAgICAgICB3aWR0aCB8PSAwOyBoZWlnaHQgfD0gMDtcbiAgICAgICAgVXRpbHMuYXNzZXJ0KHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKTtcblxuICAgICAgICAvLyBjb250ZXh0IGxvc3M/XG4gICAgICAgIGlmKGdsLmlzQ29udGV4dExvc3QoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIGFsbG9jYXRlIG5ldyB0ZXh0dXJlXG4gICAgICAgIGNvbnN0IG5ld1RleHR1cmUgPSBTcGVlZHlUZXh0dXJlLl9jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBuZXcgdGV4dHVyZSB3aXRoIHplcm9zIHRvIGF2b2lkIGFcbiAgICAgICAgLy8gd2FybmluZyB3aGVuIGNhbGxpbmcgY29weVRleFN1YkltYWdlMkQoKSBvbiBGaXJlZm94XG4gICAgICAgIC8vIHRoaXMgbWF5IG5vdCBiZSB2ZXJ5IGVmZmljaWVudD9cbiAgICAgICAgU3BlZWR5VGV4dHVyZS5fdXBsb2FkKGdsLCBuZXdUZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCB6ZXJvcyh3aWR0aCAqIGhlaWdodCAqIDQpKTsgLy8gUkdCQTogNCBieXRlcyBwZXIgcGl4ZWxcblxuICAgICAgICAvLyBjb3B5IHRoZSBvbGQgdGV4dHVyZSB0byB0aGUgbmV3IG9uZVxuICAgICAgICBjb25zdCBvbGRXaWR0aCA9IHRoaXMuX3dpZHRoLCBvbGRIZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIFNwZWVkeURyYXdhYmxlVGV4dHVyZS5fY29weVRvVGV4dHVyZShnbCwgdGhpcy5fZ2xGYm8sIG5ld1RleHR1cmUsIDAsIDAsIE1hdGgubWluKHdpZHRoLCBvbGRXaWR0aCksIE1hdGgubWluKGhlaWdodCwgb2xkSGVpZ2h0KSwgMCk7XG5cbiAgICAgICAgLy8gYmluZCBGQk9cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9nbEZibyk7XG5cbiAgICAgICAgLy8gaW52YWxpZGF0ZSBvbGQgZGF0YSAoaXMgdGhpcyBuZWVkZWQ/KVxuICAgICAgICBnbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIFtnbC5DT0xPUl9BVFRBQ0hNRU5UMF0pO1xuXG4gICAgICAgIC8vIGF0dGFjaCB0aGUgbmV3IHRleHR1cmUgdG8gdGhlIGV4aXN0aW5nIGZyYW1lYnVmZmVyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCAgICAgICAgIC8vIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgICAvLyBjb2xvciBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgICAgICAgICAgLy8gdGV4IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUZXh0dXJlLCAgICAgICAgICAgICAvLyB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApOyAgICAgICAgICAgICAgICAgICAgIC8vIG1pcG1hcCBsZXZlbFxuXG4gICAgICAgIC8vIHVuYmluZCBGQk9cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICAvLyByZWxlYXNlIHRoZSBvbGQgdGV4dHVyZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRoaXMuX2dsVGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2dsVGV4dHVyZSA9IG5ld1RleHR1cmU7XG5cbiAgICAgICAgLy8gdXBkYXRlIGRpbWVuc2lvbnMgJiBkaXNjYXJkIG1pcG1hcHNcbiAgICAgICAgdGhpcy5kaXNjYXJkTWlwbWFwcygpO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgdGV4dHVyZVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGNsZWFyKClcbiAgICB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdoZW4gd2UgcGFzcyBudWxsIHRvIHRleEltYWdlMkQoKSwgaXQgc2VlbXMgdGhhdCBGaXJlZm94XG4gICAgICAgIC8vIGRvZXNuJ3QgY2xlYXIgdGhlIHRleHR1cmUuIEluc3RlYWQsIGl0IGRpc3BsYXlzIHRoaXMgd2FybmluZzpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gXCJXZWJHTCB3YXJuaW5nOiBkcmF3QXJyYXlzSW5zdGFuY2VkOlxuICAgICAgICAvLyAgVGV4IGltYWdlIFRFWFRVUkVfMkQgbGV2ZWwgMCBpcyBpbmN1cnJpbmcgbGF6eSBpbml0aWFsaXphdGlvbi5cIlxuICAgICAgICAvL1xuICAgICAgICAvLyBIZXJlIGlzIGEgd29ya2Fyb3VuZDpcbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJUb0NvbG9yKDAsIDAsIDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSB0ZXh0dXJlIHRvIGEgY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciByZWQgY29tcG9uZW50LCBhIHZhbHVlIGluIFswLDFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGcgZ3JlZW4gY29tcG9uZW50LCBhIHZhbHVlIGluIFswLDFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgYmx1ZSBjb21wb25lbnQsIGEgdmFsdWUgaW4gWzAsMV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYSBhbHBoYSBjb21wb25lbnQsIGEgdmFsdWUgaW4gWzAsMV1cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBjbGVhclRvQ29sb3IociwgZywgYiwgYSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG5cbiAgICAgICAgLy8gY29udGV4dCBsb3NzP1xuICAgICAgICBpZihnbC5pc0NvbnRleHRMb3N0KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBjbGFtcCBwYXJhbWV0ZXJzXG4gICAgICAgIHIgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKCtyLCAxLjApKTtcbiAgICAgICAgZyA9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oK2csIDEuMCkpO1xuICAgICAgICBiID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigrYiwgMS4wKSk7XG4gICAgICAgIGEgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKCthLCAxLjApKTtcblxuICAgICAgICAvLyBkaXNjYXJkIG1pcG1hcHMsIGlmIGFueVxuICAgICAgICB0aGlzLmRpc2NhcmRNaXBtYXBzKCk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHRleHR1cmVcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9nbEZibyk7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICAvLyBkb25lIVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBGQk8gYXNzb2NpYXRlZCB3aXRoIGFuIGV4aXN0aW5nIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7V2ViR0xGcmFtZWJ1ZmZlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX2NyZWF0ZUZyYW1lYnVmZmVyKGdsLCB0ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgY29uc3QgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgICAgICAvLyBzZXR1cCBmcmFtZWJ1ZmZlclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCAgICAgICAgIC8vIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgICAvLyBjb2xvciBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgICAgICAgICAgLy8gdGV4IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLCAgICAgICAgICAgICAgICAvLyB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApOyAgICAgICAgICAgICAgICAgICAgIC8vIG1pcG1hcCBsZXZlbFxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBlcnJvcnNcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG4gICAgICAgIGlmKHN0YXR1cyAhPSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSAoKCkgPT4gKChbXG4gICAgICAgICAgICAgICAgJ0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEJyxcbiAgICAgICAgICAgICAgICAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJyxcbiAgICAgICAgICAgICAgICAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TJyxcbiAgICAgICAgICAgICAgICAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQnLFxuICAgICAgICAgICAgICAgICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01VTFRJU0FNUExFJ1xuICAgICAgICAgICAgXS5maWx0ZXIoZXJyID0+IGdsW2Vycl0gPT09IHN0YXR1cykpWzBdIHx8ICd1bmtub3duIGVycm9yJykpKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR0xFcnJvcihgQ2FuJ3QgY3JlYXRlIGZyYW1lYnVmZmVyOiAke2Vycm9yfSAoJHtzdGF0dXN9KWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5iaW5kICYgcmV0dXJuXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBmYm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBkYXRhIGZyb20gYSBmcmFtZWJ1ZmZlciB0byBhIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAgICogQHBhcmFtIHtXZWJHTEZyYW1lYnVmZmVyfSBmYm8gd2UnbGwgcmVhZCB0aGUgZGF0YSBmcm9tIHRoaXNcbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZSBkZXN0aW5hdGlvbiB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtHTGludH0geCB4cG9zICh3aGVyZSB0byBzdGFydCBjb3B5aW5nKVxuICAgICAqIEBwYXJhbSB7R0xpbnR9IHkgeXBvcyAod2hlcmUgdG8gc3RhcnQgY29weWluZylcbiAgICAgKiBAcGFyYW0ge0dMc2l6ZWl9IHdpZHRoIHdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtHTHNpemVpfSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtHTGludH0gW2xvZF0gbWlwbWFwIGxldmVsLW9mLWRldGFpbFxuICAgICAqIEByZXR1cm5zIHtXZWJHTFRleHR1cmV9IHRleHR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvcHlUb1RleHR1cmUoZ2wsIGZibywgdGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbG9kID0gMClcbiAgICB7XG4gICAgICAgIC8vZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG5cbiAgICAgICAgZ2wuY29weVRleFN1YkltYWdlMkQoXG4gICAgICAgICAgICBnbC5URVhUVVJFXzJELCAvLyB0YXJnZXRcbiAgICAgICAgICAgIGxvZCwgLy8gbWlwbWFwIGxldmVsXG4gICAgICAgICAgICAwLCAvLyB4b2Zmc2V0XG4gICAgICAgICAgICAwLCAvLyB5b2Zmc2V0XG4gICAgICAgICAgICB4LCAvLyB4cG9zICh3aGVyZSB0byBzdGFydCBjb3B5aW5nKVxuICAgICAgICAgICAgeSwgLy8geXBvcyAod2hlcmUgdG8gc3RhcnQgY29weWluZylcbiAgICAgICAgICAgIHdpZHRoLCAvLyB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgaGVpZ2h0IC8vIGhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgICAgICApO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKFxuICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgLy8gdGFyZ2V0XG4gICAgICAgICAgICBsb2QsIC8vIG1pcG1hcCBsZXZlbFxuICAgICAgICAgICAgZ2wuUkdCQSwgLy8gaW50ZXJuYWwgZm9ybWF0XG4gICAgICAgICAgICB4LCAvLyB4cG9zICh3aGVyZSB0byBzdGFydCBjb3B5aW5nKVxuICAgICAgICAgICAgeSwgLy8geXBvcyAod2hlcmUgdG8gc3RhcnQgY29weWluZylcbiAgICAgICAgICAgIHdpZHRoLCAvLyB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgaGVpZ2h0LCAvLyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAgICAgICAgICAgIDAgLy8gYm9yZGVyXG4gICAgICAgICk7XG4gICAgICAgICovXG5cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxufSIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIGFzYXAuanNcbiAqIFNjaGVkdWxlIGEgZnVuY3Rpb24gdG8gcnVuIFwiYXMgc29vbiBhcyBwb3NzaWJsZVwiXG4gKi9cblxuLyoqIGNhbGxiYWNrcyAqL1xuY29uc3QgY2FsbGJhY2tzID0gLyoqIEB0eXBlIHtGdW5jdGlvbltdfSAqLyAoIFtdICk7XG5cbi8qKiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFja3MgKi9cbmNvbnN0IGFyZ3MgPSAvKiogQHR5cGUge2FueVtdW119ICovICggW10gKTtcblxuLyoqIGFzYXAga2V5ICovXG5jb25zdCBBU0FQX0tFWSA9ICdhc2FwJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigxKTtcblxuLy8gUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnQgPT4ge1xuICAgIGlmKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IEFTQVBfS0VZKVxuICAgICAgICByZXR1cm47XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZihjYWxsYmFja3MubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybjtcblxuICAgIGNvbnN0IGZuID0gY2FsbGJhY2tzLnBvcCgpO1xuICAgIGNvbnN0IGFyZ0FycmF5ID0gYXJncy5wb3AoKTtcbiAgICBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ0FycmF5KTtcbn0sIHRydWUpO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgZnVuY3Rpb24gdG8gcnVuIFwiYXMgc29vbiBhcyBwb3NzaWJsZVwiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gcGFyYW1zIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzYXAoZm4sIC4uLnBhcmFtcylcbntcbiAgICBjYWxsYmFja3MudW5zaGlmdChmbik7XG4gICAgYXJncy51bnNoaWZ0KHBhcmFtcyk7XG4gICAgd2luZG93LnBvc3RNZXNzYWdlKEFTQVBfS0VZLCAnKicpO1xufSIsIi8qXG4gKiBzcGVlZHktdmlzaW9uLmpzXG4gKiBHUFUtYWNjZWxlcmF0ZWQgQ29tcHV0ZXIgVmlzaW9uIGZvciBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIEFsZXhhbmRyZSBNYXJ0aW5zIDxhbGVtYXJ0ZihhdClnbWFpbC5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIGVycm9ycy5qc1xuICogRXJyb3IgY2xhc3Nlc1xuICovXG5cbi8qKiBAdHlwZWRlZiB7U3BlZWR5RXJyb3J8RXJyb3J8bnVsbH0gU3BlZWR5RXJyb3JDYXVzZSAqL1xuXG4vKipcbiAqIEdlbmVyaWMgZXJyb3IgY2xhc3MgZm9yIFNwZWVkeVxuICovXG5leHBvcnQgY2xhc3MgU3BlZWR5RXJyb3IgZXh0ZW5kcyBFcnJvclxue1xuICAgIC8qKlxuICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgbWVzc2FnZSB0ZXh0XG4gICAgICogQHBhcmFtIHtTcGVlZHlFcnJvckNhdXNlfSBbY2F1c2VdIGNhdXNlIG9mIHRoZSBlcnJvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBjYXVzZSA/IGNhdXNlLnRvU3RyaW5nKCkgOiAnW3NwZWVkeS12aXNpb24uanNdJ1xuICAgICAgICBdLmpvaW4oJ1xcbi0+ICcpKTtcblxuICAgICAgICAvKiogQHR5cGUge1NwZWVkeUVycm9yQ2F1c2V9IGNhdXNlIG9mIHRoZSBlcnJvciAqL1xuICAgICAgICB0aGlzLl9jYXVzZSA9IGNhdXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVycm9yIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGVycm9yIG5hbWUgKGlnbm9yZWQpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IF8gaWdub3JlZFxuICAgICAqL1xuICAgIHNldCBuYW1lKF8pXG4gICAge1xuICAgICAgICB2b2lkKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2F1c2Ugb2YgdGhlIGVycm9yLiBBdmFpbGFibGUgaWZcbiAgICAgKiBpdCBoYXMgYmVlbiBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybnMge1NwZWVkeUVycm9yQ2F1c2V9XG4gICAgICovXG4gICAgZ2V0IGNhdXNlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXVzZTtcbiAgICB9XG59XG5cbi8qKlxuICogVW5zdXBwb3J0ZWQgb3BlcmF0aW9uIGVycm9yXG4gKiBUaGUgcmVxdWVzdGVkIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBVbnN1cHBvcnRlZCBvcGVyYXRpb24uICR7bWVzc2FnZX1gLCBjYXVzZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIE5vdCBpbXBsZW1lbnRlZCBlcnJvclxuICogVGhlIGNhbGxlZCBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RJbXBsZW1lbnRlZEVycm9yIGV4dGVuZHMgU3BlZWR5RXJyb3JcbntcbiAgICAvKipcbiAgICAgKiBDbGFzcyBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gYWRkaXRpb25hbCB0ZXh0XG4gICAgICogQHBhcmFtIHtTcGVlZHlFcnJvckNhdXNlfSBbY2F1c2VdIGNhdXNlIG9mIHRoZSBlcnJvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnJywgY2F1c2UgPSBudWxsKVxuICAgIHtcbiAgICAgICAgc3VwZXIoYE1ldGhvZCBub3QgaW1wbGVtZW50ZWQuICR7bWVzc2FnZX1gLCBjYXVzZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFdlYkdMIGVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBHTEVycm9yIGV4dGVuZHMgU3BlZWR5RXJyb3JcbntcbiAgICAvKipcbiAgICAgKiBDbGFzcyBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gYWRkaXRpb25hbCB0ZXh0XG4gICAgICogQHBhcmFtIHtTcGVlZHlFcnJvckNhdXNlfSBbY2F1c2VdIGNhdXNlIG9mIHRoZSBlcnJvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnJywgY2F1c2UgPSBudWxsKVxuICAgIHtcbiAgICAgICAgc3VwZXIoYFdlYkdMIGVycm9yLiAke21lc3NhZ2V9YCwgY2F1c2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBlcnJvciBvYmplY3QgZGVzY3JpYmluZyB0aGUgbGF0ZXN0IFdlYkdMIGVycm9yXG4gICAgICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqIEByZXR1cm5zIHtHTEVycm9yfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKGdsKVxuICAgIHtcbiAgICAgICAgY29uc3QgcmVjb2duaXplZEVycm9ycyA9IFtcbiAgICAgICAgICAgICdOT19FUlJPUicsXG4gICAgICAgICAgICAnSU5WQUxJRF9FTlVNJyxcbiAgICAgICAgICAgICdJTlZBTElEX1ZBTFVFJyxcbiAgICAgICAgICAgICdJTlZBTElEX09QRVJBVElPTicsXG4gICAgICAgICAgICAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nLFxuICAgICAgICAgICAgJ09VVF9PRl9NRU1PUlknLFxuICAgICAgICAgICAgJ0NPTlRFWFRfTE9TVF9XRUJHTCcsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgZ2xFcnJvciA9IGdsLmdldEVycm9yKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZWNvZ25pemVkRXJyb3JzLmZpbmQoZXJyb3IgPT4gZ2xbZXJyb3JdID09IGdsRXJyb3IpIHx8ICdVbmtub3duJztcbiAgICAgICAgcmV0dXJuIG5ldyBHTEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBYnN0cmFjdE1ldGhvZEVycm9yXG4gKiBUaHJvd24gd2hlbiBvbmUgdHJpZXMgdG8gY2FsbCBhbiBhYnN0cmFjdCBtZXRob2RcbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0TWV0aG9kRXJyb3IgZXh0ZW5kcyBTcGVlZHlFcnJvclxue1xuICAgIC8qKlxuICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSBhZGRpdGlvbmFsIHRleHRcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUVycm9yQ2F1c2V9IFtjYXVzZV0gY2F1c2Ugb2YgdGhlIGVycm9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9ICcnLCBjYXVzZSA9IG51bGwpXG4gICAge1xuICAgICAgICBzdXBlcihgQ2FuJ3QgY2FsbCBhYnN0cmFjdCBtZXRob2QuICR7bWVzc2FnZX1gLCBjYXVzZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIElsbGVnYWwgYXJndW1lbnQgZXJyb3JcbiAqIEEgbWV0aG9kIGhhcyByZWNlaXZlZCBvbmUgb3IgbW9yZSBpbGxlZ2FsIGFyZ3VtZW50c1xuICovXG5leHBvcnQgY2xhc3MgSWxsZWdhbEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBTcGVlZHlFcnJvclxue1xuICAgIC8qKlxuICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSBhZGRpdGlvbmFsIHRleHRcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUVycm9yQ2F1c2V9IFtjYXVzZV0gY2F1c2Ugb2YgdGhlIGVycm9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9ICcnLCBjYXVzZSA9IG51bGwpXG4gICAge1xuICAgICAgICBzdXBlcihgSWxsZWdhbCBhcmd1bWVudC4gJHttZXNzYWdlfWAsIGNhdXNlKTtcbiAgICB9XG59XG5cbi8qKlxuICogSWxsZWdhbCBvcGVyYXRpb24gZXJyb3JcbiAqIFRoZSBtZXRob2QgYXJndW1lbnRzIGFyZSB2YWxpZCwgYnV0IHRoZSBtZXRob2QgY2FuJ3RcbiAqIGJlIGNhbGxlZCBkdWUgdG8gdGhlIGN1cnJlbnQgdGhlIHN0YXRlIG9mIHRoZSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIElsbGVnYWxPcGVyYXRpb25FcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBJbGxlZ2FsIG9wZXJhdGlvbi4gJHttZXNzYWdlfWAsIGNhdXNlKTtcbiAgICB9XG59XG5cbi8qKlxuICogT3V0IG9mIG1lbW9yeVxuICovXG5leHBvcnQgY2xhc3MgT3V0T2ZNZW1vcnlFcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBPdXQgb2YgbWVtb3J5LiAke21lc3NhZ2V9YCwgY2F1c2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBGaWxlIG5vdCBmb3VuZCBlcnJvclxuICovXG5leHBvcnQgY2xhc3MgRmlsZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBTcGVlZHlFcnJvclxue1xuICAgIC8qKlxuICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSBhZGRpdGlvbmFsIHRleHRcbiAgICAgKiBAcGFyYW0ge1NwZWVkeUVycm9yQ2F1c2V9IFtjYXVzZV0gY2F1c2Ugb2YgdGhlIGVycm9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9ICcnLCBjYXVzZSA9IG51bGwpXG4gICAge1xuICAgICAgICBzdXBlcihgRmlsZSBub3QgZm91bmQuICR7bWVzc2FnZX1gLCBjYXVzZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRpbWVvdXQgZXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBUaW1lb3V0IGVycm9yLiAke21lc3NhZ2V9YCwgY2F1c2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBlcnJvclxuICovXG5leHBvcnQgY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBQYXJzZSBlcnJvci4gJHttZXNzYWdlfWAsIGNhdXNlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQXNzZXJ0aW9uIGVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBBc3NlcnRpb24gZmFpbGVkLiAke21lc3NhZ2V9YCwgY2F1c2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBY2Nlc3MgZGVuaWVkXG4gKi9cbmV4cG9ydCBjbGFzcyBBY2Nlc3NEZW5pZWRFcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBBY2Nlc3MgZGVuaWVkLiAke21lc3NhZ2V9YCwgY2F1c2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBXZWJBc3NlbWJseSBlcnJvclxuICovXG5leHBvcnQgY2xhc3MgV2ViQXNzZW1ibHlFcnJvciBleHRlbmRzIFNwZWVkeUVycm9yXG57XG4gICAgLyoqXG4gICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGFkZGl0aW9uYWwgdGV4dFxuICAgICAqIEBwYXJhbSB7U3BlZWR5RXJyb3JDYXVzZX0gW2NhdXNlXSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNhdXNlID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKGBXZWJBc3NlbWJseSBlcnJvci4gJHttZXNzYWdlfWAsIGNhdXNlKTtcbiAgICB9XG59IiwiLypcbiAqIHNwZWVkeS12aXNpb24uanNcbiAqIEdQVS1hY2NlbGVyYXRlZCBDb21wdXRlciBWaXNpb24gZm9yIEphdmFTY3JpcHRcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgQWxleGFuZHJlIE1hcnRpbnMgPGFsZW1hcnRmKGF0KWdtYWlsLmNvbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogZ2xvYmFscy5qc1xuICogR2xvYmFsIGNvbnN0YW50c1xuICovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJTUFHRSBQWVJBTUlEUyAmIFNDQUxFLVNQQUNFXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKiogQHR5cGUge251bWJlcn0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGxldmVscyBpbiBhIHB5cmFtaWQsIGNvbnNpZGVyaW5nIGEgc2NhbGUgZmFjdG9yIG9mIDJ4IGJldHdlZW4gbGV2ZWxzICovXG5leHBvcnQgY29uc3QgUFlSQU1JRF9NQVhfTEVWRUxTID0gODtcblxuLyoqIEB0eXBlIHtudW1iZXJ9IFRoZSBiYXNlLTIgbG9nYXJpdGhtIG9mIFBZUkFNSURfTUFYX1NDQUxFICovXG5leHBvcnQgY29uc3QgTE9HMl9QWVJBTUlEX01BWF9TQ0FMRSA9IDA7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBUaGUgbWF4aW11bSBzdXBwb3J0ZWQgc2NhbGUgZm9yIGEgcHlyYW1pZCBsZXZlbCAqL1xuZXhwb3J0IGNvbnN0IFBZUkFNSURfTUFYX1NDQUxFID0gMSA8PCBMT0cyX1BZUkFNSURfTUFYX1NDQUxFO1xuXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZJWEVELVBPSU5UIE1BVEhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBIb3cgbWFueSBiaXRzIGRvIHdlIHVzZSB0byBzdG9yZSBmcmFjdGlvbmFsIGRhdGE/ICovXG5leHBvcnQgY29uc3QgRklYX0JJVFMgPSAzOyAvLyBzdGVwIHNpemU6IDAuMTI1ID0gMS8yXkZJWF9CSVRTXG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBGaXhlZC1wb2ludCByZXNvbHV0aW9uICovXG5leHBvcnQgY29uc3QgRklYX1JFU09MVVRJT04gPSAxIDw8IEZJWF9CSVRTOyAvLyBmbG9hdCgyXihGSVhfQklUUykpXG5cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVEVYVFVSRSBMSU1JVFNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBNYXhpbXVtIHRleHR1cmUgbGVuZ3RoICh3aWR0aCwgaGVpZ2h0KSAqL1xuZXhwb3J0IGNvbnN0IE1BWF9URVhUVVJFX0xFTkdUSCA9ICgxIDw8ICgxNiAtIEZJWF9CSVRTKSkgLSAxOyAvLyBtdXN0IGJlIDJebiAtIDEgZHVlIHRvIGtleXBvaW50IGVuY29kaW5nXG5cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gS0VZUE9JTlRTXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKiogQHR5cGUge251bWJlcn0gU2l6ZSBvZiBhIGtleXBvaW50IGhlYWRlciwgaW4gYnl0ZXMgKG11c3QgYmUgZGl2aXNpYmxlIGJ5IDQpICovXG5leHBvcnQgY29uc3QgTUlOX0tFWVBPSU5UX1NJWkUgPSA4O1xuXG4vKiogQHR5cGUge251bWJlcn0gTWluaW11bSBsZW5ndGggb2YgYSBrZXlwb2ludCBlbmNvZGVyLCBpbiBwaXhlbHMgKGVuY29kZXMgYXQgbGVhc3QgMSBrZXlwb2ludCkgKi9cbmV4cG9ydCBjb25zdCBNSU5fRU5DT0RFUl9MRU5HVEggPSAyOyAvLyBjYXBhY2l0eSBjb21wdXRhdGlvbnMgYXJlIGJhc2VkIG9uIHRoaXMgLy8gTWF0aC5jZWlsKE1hdGguc3FydChNSU5fS0VZUE9JTlRfU0laRSAvIDQpKTtcblxuLyoqIEB0eXBlIHtudW1iZXJ9IE1heGltdW0gbnVtYmVyIG9mIGtleXBvaW50cyB3ZSBjYW4gZW5jb2RlICh0aGUgYWN0dWFsIGxlbmd0aCBvZiB0aGUgZW5jb2RlciBtYXkgdmFyeSkgKi9cbmV4cG9ydCBjb25zdCBNQVhfRU5DT0RFUl9DQVBBQ0lUWSA9IDgxOTI7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBEZWZhdWx0IGNhcGFjaXR5IG9mIGEga2V5cG9pbnQgZW5jb2RlciAoNjR4NjQgdGV4dHVyZSB3aXRoIDIgcGl4ZWxzIHBlciBrZXlwb2ludCkgKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VOQ09ERVJfQ0FQQUNJVFkgPSAyMDQ4O1xuXG4vKiogQHR5cGUge251bWJlcn0gbG9nMiBvZiBNQVhfREVTQ1JJUFRPUl9TSVpFICovXG5leHBvcnQgY29uc3QgTE9HMl9NQVhfREVTQ1JJUFRPUl9TSVpFID0gNjtcblxuLyoqIEB0eXBlIHtudW1iZXJ9IG1heGltdW0gc2l6ZSBvZiBhIGtleXBvaW50IGRlc2NyaXB0b3IsIGluIGJ5dGVzICovXG5leHBvcnQgY29uc3QgTUFYX0RFU0NSSVBUT1JfU0laRSA9IDEgPDwgTE9HMl9NQVhfREVTQ1JJUFRPUl9TSVpFO1xuXG4vKiogQHR5cGUge251bWJlcn0gSG93IG1hbnkgYml0cyB3aWxsIHdlIHVzZSB3aGVuIGVuY29kaW5nIHRoZSBpbmRleCBvZiBhIGtleXBvaW50IG1hdGNoPyAqL1xuZXhwb3J0IGNvbnN0IE1BVENIX0lOREVYX0JJVFMgPSAzMiAtIChMT0cyX01BWF9ERVNDUklQVE9SX1NJWkUgKyAzKTsgLy8gMzIgLSBsb2cyKE1BWF9ERVNDUklQVE9SX1NJWkUgKiA4KVxuXG4vKiogQHR5cGUge251bWJlcn0gQml0d2lzZSBtYXNrIHRvIGV4dHJhY3QgYSBrZXlwb2ludCBpbmRleCBmcm9tIGFuIGVuY29kZWQgbWF0Y2ggKi9cbmV4cG9ydCBjb25zdCBNQVRDSF9JTkRFWF9NQVNLID0gKDEgPDwgTUFUQ0hfSU5ERVhfQklUUykgLSAxO1xuXG4vKiogQHR5cGUge251bWJlcn0gTWF4aW11bSBzaXplIG9mIHRoZSBkYXRhYmFzZSBvZiBrZXlwb2ludHMgZm9yIG1hdGNoaW5nICovXG5leHBvcnQgY29uc3QgTUFUQ0hfTUFYX0lOREVYID0gKDEgPDwgTUFUQ0hfSU5ERVhfQklUUykgLSAxO1xuXG4vKiogQHR5cGUge251bWJlcn0gVGhlIG1heGltdW0gZGlzdGFuY2UgdGhhdCBjYW4gYmUgc3RvcmVkIGluIGEgbWF0Y2ggKi9cbmV4cG9ydCBjb25zdCBNQVRDSF9NQVhfRElTVEFOQ0UgPSAoMSA8PCAoMzIgLSBNQVRDSF9JTkRFWF9CSVRTKSkgLSAxO1xuXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE1JU0Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKiBAdHlwZSB7Ym9vbGVhbn0gQXJlIHdlIGluIGEgbGl0dGxlLWVuZGlhbiBtYWNoaW5lPyAqL1xuZXhwb3J0IGNvbnN0IExJVFRMRV9FTkRJQU4gPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDB4Q0FGRSA9PT0gKG5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMHhGRSwgMHhDQV0pLmJ1ZmZlcikpWzBdO1xufSkoKTsiLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBvYnNlcnZhYmxlLmpzXG4gKiBPYnNlcnZlciBkZXNpZ24gcGF0dGVyblxuICovXG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIE9ic2VydmVyIGRlc2lnbiBwYXR0ZXJuXG4gKiBAYWJzdHJhY3RcbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmFibGVcbntcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIC8qKiBAdHlwZSB7RnVuY3Rpb25bXX0gc3Vic2NyaWJlcnMgLyBjYWxsYmFja3MgKi9cbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgICAvKiogQHR5cGUge29iamVjdFtdfSBcInRoaXNcIiBwb2ludGVycyAqL1xuICAgICAgICB0aGlzLl90aGlzcHRyID0gW107XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnlbXT59IGZ1bmN0aW9uIGFyZ3VtZW50cyAqL1xuICAgICAgICB0aGlzLl9hcmdzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHN1YnNjcmliZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc3B0cl0gXCJ0aGlzXCIgcG9pbnRlciB0byBiZSB1c2VkIHdoZW4gaW52b2tpbmcgdGhlIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3MgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoZm4sIHRoaXNwdHIsIC4uLmFyZ3MpXG4gICAge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycy5wdXNoKGZuKTtcbiAgICAgICAgdGhpcy5fdGhpc3B0ci5wdXNoKHRoaXNwdHIpO1xuICAgICAgICB0aGlzLl9hcmdzLnB1c2goYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBwcmV2aW91c2x5IGFkZGVkIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt0aGlzcHRyXSBcInRoaXNcIiBwb2ludGVyXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUoZm4sIHRoaXNwdHIpXG4gICAge1xuICAgICAgICBmb3IobGV0IGogPSB0aGlzLl9zdWJzY3JpYmVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYodGhpcy5fc3Vic2NyaWJlcnNbal0gPT09IGZuICYmIHRoaXMuX3RoaXNwdHJbal0gPT09IHRoaXNwdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVycy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhpc3B0ci5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXJncy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgYWxsIHN1YnNjcmliZXJzIGFib3V0IGEgc3RhdGUgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9ub3RpZnkoKVxuICAgIHtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3N1YnNjcmliZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbaV0uY2FsbCh0aGlzLl90aGlzcHRyW2ldLCAuLi4odGhpcy5fYXJnc1tpXSkpO1xuICAgIH1cbn0iLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiB0eXBlcy5qc1xuICogVHlwZXMgJiBmb3JtYXRzXG4gKi9cblxuLyoqXG4gKiBNZWRpYSB0eXBlc1xuICogQGVudW0ge1N5bWJvbH1cbiAqL1xuZXhwb3J0IGNvbnN0IE1lZGlhVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEltYWdlOiBTeW1ib2woJ0ltYWdlJyksXG4gICAgVmlkZW86IFN5bWJvbCgnVmlkZW8nKSxcbiAgICBDYW52YXM6IFN5bWJvbCgnQ2FudmFzJyksXG4gICAgQml0bWFwOiBTeW1ib2woJ0JpdG1hcCcpLFxufSk7XG5cbi8qKlxuICogSW1hZ2UgZm9ybWF0c1xuICogQGVudW0ge1N5bWJvbH1cbiAqL1xuZXhwb3J0IGNvbnN0IEltYWdlRm9ybWF0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgUkdCQTogU3ltYm9sKCdSR0JBJyksXG4gICAgR1JFWTogU3ltYm9sKCdHUkVZJyksXG59KTtcblxuLyoqXG4gKiBQaXhlbCBjb21wb25lbnQgKGJpdHdpc2UgZmxhZ3MpXG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBQaXhlbENvbXBvbmVudFxuICovXG5leHBvcnQgY29uc3QgUGl4ZWxDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBSRUQ6ICAgMSxcbiAgICBHUkVFTjogMixcbiAgICBCTFVFOiAgNCxcbiAgICBBTFBIQTogOCxcbiAgICBBTEw6ICAgMTUgLy8gPSBSRUQgfCBHUkVFTiB8IEJMVUUgfCBBTFBIQVxufSk7XG5cbi8qKlxuICogQ29tcG9uZW50IElEIHV0aWxpdHlcbiAqL1xuZXhwb3J0IGNvbnN0IENvbG9yQ29tcG9uZW50SWQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBbUGl4ZWxDb21wb25lbnQuUkVEXTogICAwLFxuICAgIFtQaXhlbENvbXBvbmVudC5HUkVFTl06IDEsXG4gICAgW1BpeGVsQ29tcG9uZW50LkJMVUVdOiAgMixcbiAgICBbUGl4ZWxDb21wb25lbnQuQUxQSEFdOiAzXG59KTsiLCIvKlxuICogc3BlZWR5LXZpc2lvbi5qc1xuICogR1BVLWFjY2VsZXJhdGVkIENvbXB1dGVyIFZpc2lvbiBmb3IgSmF2YVNjcmlwdFxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBBbGV4YW5kcmUgTWFydGlucyA8YWxlbWFydGYoYXQpZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiB1dGlscy5qc1xuICogR2VuZXJpYyB1dGlsaXRpZXNcbiAqL1xuXG5pbXBvcnQgeyBJbGxlZ2FsQXJndW1lbnRFcnJvciwgUGFyc2VFcnJvciwgQXNzZXJ0aW9uRXJyb3IsIEFjY2Vzc0RlbmllZEVycm9yLCBOb3RTdXBwb3J0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzJ1xuaW1wb3J0IHsgU3BlZWR5UHJvbWlzZSB9IGZyb20gJy4uL2NvcmUvc3BlZWR5LXByb21pc2UnO1xuXG4vKipcbiAqIEdlbmVyaWMgdXRpbGl0aWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBVdGlsc1xue1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHdhcm5pbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBtZXNzYWdlIHRleHRcbiAgICAgKiBAcGFyYW0gIHsuLi5zdHJpbmd9IGFyZ3Mgb3B0aW9uYWwgdGV4dFxuICAgICAqL1xuICAgIHN0YXRpYyB3YXJuaW5nKHRleHQsIC4uLmFyZ3MpXG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tzcGVlZHktdmlzaW9uXScsIHRleHQsIC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgbWVzc2FnZSB0ZXh0XG4gICAgICogQHBhcmFtICB7Li4uc3RyaW5nfSBhcmdzIG9wdGlvbmFsIHRleHRcbiAgICAgKi9cbiAgICBzdGF0aWMgbG9nKHRleHQsIC4uLmFyZ3MpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZygnW3NwZWVkeS12aXNpb25dJywgdGV4dCwgLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzZXJ0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBleHByIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAdGhyb3dzIHtBc3NlcnRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXNzZXJ0KGV4cHIsIHRleHQgPSAnJylcbiAgICB7XG4gICAgICAgIGlmKCFleHByKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKHRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWVzIG9mIHRoZSBhcmd1bWVudHMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1biBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgc3RhdGljIGZ1bmN0aW9uQXJndW1lbnRzKGZ1bilcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBmdW4udG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgcmVnZXggPSBjb2RlLnN0YXJ0c1dpdGgoJ2Z1bmN0aW9uJykgPyAnZnVuY3Rpb25cXFxccy4qXFxcXCgoW14pXSopXFxcXCknIDpcbiAgICAgICAgICAgICAgICAgICAgIChjb2RlLnN0YXJ0c1dpdGgoJygnKSA/ICdcXFxcKChbXildKilcXFxcKS4qPT4nIDogJyhbXj1dKykuKj0+Jyk7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbmV3IFJlZ0V4cChyZWdleCkuZXhlYyhjb2RlKTtcblxuICAgICAgICBpZihtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IG1hdGNoWzFdLnJlcGxhY2UoL1xcL1xcKi4qP1xcKlxcLy9nLCAnJyk7IC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3Muc3BsaXQoJywnKS5tYXAoYXJnbmFtZSA9PlxuICAgICAgICAgICAgICAgIGFyZ25hbWUucmVwbGFjZSgvPS4qJC8sICcnKS50cmltKCkgLy8gcmVtb3ZlIGRlZmF1bHQgcGFyYW1zICYgdHJpbVxuICAgICAgICAgICAgKS5maWx0ZXIoYXJnbmFtZSA9PlxuICAgICAgICAgICAgICAgIGFyZ25hbWUgLy8gaGFuZGxlIHRyYWlsaW5nIGNvbW1hc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgQ2FuJ3QgZGV0ZWN0IGZ1bmN0aW9uIGFyZ3VtZW50cyBvZiAke2NvZGV9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBmcm9tIGFuIG9iamVjdCxcbiAgICAgKiB0cmF2ZXJzaW5nIGl0cyBlbnRpcmUgcHJvdG90eXBlIGNoYWluXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiBcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBbGxQcm9wZXJ0eURlc2NyaXB0b3JzKG9iailcbiAgICB7XG4gICAgICAgIGlmKG9iaikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi4oVXRpbHMuZ2V0QWxsUHJvcGVydHlEZXNjcmlwdG9ycyhwcm90bykpLFxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iailcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEhUTUxDYW52YXNFbGVtZW50IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBpbiBwaXhlbHNcbiAgICAgKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgd2l0aFxuICAgICAqIEdhdXNzaWFuIGRpc3RyaWJ1dGlvbiAobXUsIHNpZ21hKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdSBtZWFuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ21hIHN0YW5kYXJkIGRldmlhdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHJhbmRvbSBudW1iZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2F1c3NpYW5Ob2lzZShtdSA9IDAsIHNpZ21hID0gMSlcbiAgICB7XG4gICAgICAgIC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgY29uc3QgVFdPX1BJID0gMi4wICogTWF0aC5QSTtcbiAgICAgICAgXG4gICAgICAgIGxldCBhLCBiID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgZG8geyBhID0gTWF0aC5yYW5kb20oKTsgfSB3aGlsZShhIDw9IE51bWJlci5FUFNJTE9OKTtcbiAgICAgICAgbGV0IHogPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhhKSkgKiBNYXRoLnNpbihUV09fUEkgKiBiKTtcblxuICAgICAgICByZXR1cm4geiAqIHNpZ21hICsgbXU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSAxRCBnYXVzc2lhbiBrZXJuZWwgd2l0aCBjdXN0b20gc2lnbWFcbiAgICAgKiBUaXA6IHVzZSBrZXJuZWxTaXplID49ICg1ICogc2lnbWEpLCBrZXJuZWxTaXplIG9kZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdtYSBnYXVzc2lhbiBzaWdtYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba2VybmVsU2l6ZV0ga2VybmVsIHNpemUsIG9kZCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3JtYWxpemVkXSBub3JtYWxpemUgZW50cmllcyBzbyB0aGF0IHRoZWlyIHN1bSBpcyAxXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqL1xuICAgIHN0YXRpYyBnYXVzc2lhbktlcm5lbChzaWdtYSwga2VybmVsU2l6ZSA9IDAsIG5vcm1hbGl6ZWQgPSB0cnVlKVxuICAgIHtcbiAgICAgICAgLypcbiAgICAgICAgICogTGV0IEcoeCkgYmUgYSBHYXVzc2lhbiBmdW5jdGlvbiBjZW50ZXJlZCBhdCAwIHdpdGggZml4ZWQgc2lnbWE6XG4gICAgICAgICAqXG4gICAgICAgICAqIEcoeCkgPSAoMSAvIChzaWdtYSAqIHNxcnQoMiAqIHBpKSkpICogZXhwKC0oeCAvIChzcXJ0KDIpICogc2lnbWEpKV4yKVxuICAgICAgICAgKiBcbiAgICAgICAgICogSW4gYWRkaXRpb24sIGxldCBmKHApIGJlIGEga2VybmVsIHZhbHVlIGF0IHBpeGVsIHAsIC1rLzIgPD0gcCA8PSBrLzI6XG4gICAgICAgICAqIFxuICAgICAgICAgKiBmKHApID0gXFxpbnRfe3AgLSAwLjV9XntwICsgMC41fSBHKHgpIGR4IChpbnRlZ3JhdGUgYXJvdW5kIHApXG4gICAgICAgICAqICAgICAgPSBcXGludF97MH1ee3AgKyAwLjV9IEcoeCkgZHggLSBcXGludF97MH1ee3AgLSAwLjV9IEcoeCkgZHhcbiAgICAgICAgICogXG4gICAgICAgICAqIFNldHRpbmcgYSBjb25zdGFudCBjIDo9IHNxcnQoMikgKiBzaWdtYSwgaXQgZm9sbG93cyB0aGF0OlxuICAgICAgICAgKiBcbiAgICAgICAgICogZihwKSA9ICgxIC8gMmMpICogKGVyZigocCArIDAuNSkgLyBjKSAtIGVyZigocCAtIDAuNSkgLyBjKSlcbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gZGVmYXVsdCBrZXJuZWwgc2l6ZVxuICAgICAgICBpZihrZXJuZWxTaXplID09IDApIHtcbiAgICAgICAgICAgIGtlcm5lbFNpemUgPSBNYXRoLmNlaWwoNS4wICogc2lnbWEpIHwgMDtcbiAgICAgICAgICAgIGtlcm5lbFNpemUgKz0gMSAtIChrZXJuZWxTaXplICUgMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgICAgICBrZXJuZWxTaXplIHw9IDA7XG4gICAgICAgIGlmKGtlcm5lbFNpemUgPCAxIHx8IGtlcm5lbFNpemUgJSAyID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXJyb3IoYEludmFsaWQga2VybmVsIHNpemUgZ2l2ZW4gdG8gZ2F1c3NpYW5LZXJuZWw6ICR7a2VybmVsU2l6ZX0geCAxYCk7XG4gICAgICAgIGVsc2UgaWYoc2lnbWEgPD0gMC4wKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBJbnZhbGlkIHNpZ21hIGdpdmVuIHRvIGdhdXNzaWFuS2VybmVsOiAke3NpZ21hfWApO1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIGVyZih4KSA9IC1lcmYoLXgpIGNhbiBiZSBhcHByb3hpbWF0ZWQgbnVtZXJpY2FsbHkuIFNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24jTnVtZXJpY2FsX2FwcHJveGltYXRpb25zXG4gICAgICAgIGNvbnN0IGtlcm5lbCA9IG5ldyBBcnJheShrZXJuZWxTaXplKTtcblxuICAgICAgICAvLyBzZXQgY29uc3RhbnRzXG4gICAgICAgIGNvbnN0IE4gID0gIGtlcm5lbFNpemUgPj4gMTsgLy8gaW50ZWdlciAoZmxvb3IsIGRpdiAyKVxuICAgICAgICBjb25zdCBjICA9ICAoK3NpZ21hKSAqIDEuNDE0MjEzNTYyMzczMDk1MTsgLy8gc2lnbWEgKiBzcXJ0KDIpXG4gICAgICAgIGNvbnN0IG0gID0gIDAuMzI3NTkxMTtcbiAgICAgICAgY29uc3QgYTEgPSAgMC4yNTQ4Mjk1OTI7XG4gICAgICAgIGNvbnN0IGEyID0gLTAuMjg0NDk2NzM2O1xuICAgICAgICBjb25zdCBhMyA9ICAxLjQyMTQxMzc0MTtcbiAgICAgICAgY29uc3QgYTQgPSAtMS40NTMxNTIwMjc7XG4gICAgICAgIGNvbnN0IGE1ID0gIDEuMDYxNDA1NDI5O1xuXG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIGtlcm5lbFxuICAgICAgICBsZXQgc3VtID0gMC4wO1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwga2VybmVsU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICBsZXQgeGEgPSAoaiAtIE4gKyAwLjUpIC8gYztcbiAgICAgICAgICAgIGxldCB4YiA9IChqIC0gTiAtIDAuNSkgLyBjO1xuICAgICAgICAgICAgbGV0IHNhID0gMS4wLCBzYiA9IDEuMDtcblxuICAgICAgICAgICAgaWYoeGEgPCAwLjApIHsgc2EgPSAtMS4wOyB4YSA9IC14YTsgfVxuICAgICAgICAgICAgaWYoeGIgPCAwLjApIHsgc2IgPSAtMS4wOyB4YiA9IC14YjsgfVxuXG4gICAgICAgICAgICBjb25zdCB0YSA9IDEuMCAvICgxLjAgKyBtICogeGEpO1xuICAgICAgICAgICAgY29uc3QgdGIgPSAxLjAgLyAoMS4wICsgbSAqIHhiKTtcbiAgICAgICAgICAgIGNvbnN0IHBhID0gKCgoKGE1ICogdGEgKyBhNCkgKiB0YSArIGEzKSAqIHRhICsgYTIpICogdGEgKyBhMSkgKiB0YTtcbiAgICAgICAgICAgIGNvbnN0IHBiID0gKCgoKGE1ICogdGIgKyBhNCkgKiB0YiArIGEzKSAqIHRiICsgYTIpICogdGIgKyBhMSkgKiB0YjtcbiAgICAgICAgICAgIGNvbnN0IHlhID0gMS4wIC0gcGEgKiBNYXRoLmV4cCgteGEgKiB4YSk7XG4gICAgICAgICAgICBjb25zdCB5YiA9IDEuMCAtIHBiICogTWF0aC5leHAoLXhiICogeGIpO1xuXG4gICAgICAgICAgICBjb25zdCBlcmZhID0gc2EgKiB5YTtcbiAgICAgICAgICAgIGNvbnN0IGVyZmIgPSBzYiAqIHliO1xuICAgICAgICAgICAgY29uc3QgZnAgPSAoZXJmYSAtIGVyZmIpIC8gKDIuMCAqIGMpO1xuXG4gICAgICAgICAgICBrZXJuZWxbal0gPSBmcDtcbiAgICAgICAgICAgIHN1bSArPSBmcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUga2VybmVsXG4gICAgICAgIGlmKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBrZXJuZWxTaXplOyBqKyspXG4gICAgICAgICAgICAgICAga2VybmVsW2pdIC89IHN1bTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIHJldHVybiBrZXJuZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSAyRCBrZXJuZWwgaW4gY29sdW1uLW1ham9yIGZvcm1hdCB1c2luZyB0d28gc2VwYXJhYmxlIDFEIGtlcm5lbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBrYSAxRCBrZXJuZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBba2JdXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqL1xuICAgIHN0YXRpYyBrZXJuZWwyZChrYSwga2IgPSBrYSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGtzaXplID0ga2EubGVuZ3RoO1xuICAgICAgICBVdGlscy5hc3NlcnQoa2EubGVuZ3RoID09IGthLmxlbmd0aCk7XG4gICAgICAgIFV0aWxzLmFzc2VydChrc2l6ZSA+PSAxICYmIGtzaXplICUgMiA9PSAxKTtcblxuICAgICAgICAvLyBjb21wdXRlIHRoZSBvdXRlciBwcm9kdWN0IGthIHgga2JcbiAgICAgICAgbGV0IGtlcm5lbDJkID0gbmV3IEFycmF5KGtzaXplICoga3NpemUpLCBrID0gMDtcbiAgICAgICAgZm9yKGxldCBjb2wgPSAwOyBjb2wgPCBrc2l6ZTsgY29sKyspIHtcbiAgICAgICAgICAgIGZvcihsZXQgcm93ID0gMDsgcm93IDwga3NpemU7IHJvdysrKVxuICAgICAgICAgICAgICAgIGtlcm5lbDJkW2srK10gPSBrYVtyb3ddICoga2JbY29sXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXJuZWwyZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXJ0ZXNpYW4gcHJvZHVjdCBhIHggYjogWyBbYWksIGJqXSBmb3IgYWxsIGksIGogXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBiXG4gICAgICogQHJldHVybnMge0FycmF5PFtudW1iZXIsbnVtYmVyXT59XG4gICAgICovXG4gICAgc3RhdGljIGNhcnRlc2lhbihhLCBiKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5hLm1hcChhID0+IGIubWFwKGIgPT4gW2EsIGJdKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN5bW1ldHJpYyByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBbIC1uLCAuLi4sIG4gXVxuICAgICAqL1xuICAgIHN0YXRpYyBzeW1tZXRyaWNSYW5nZShuKVxuICAgIHtcbiAgICAgICAgaWYoKG4gfD0gMCkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEVycm9yKGBFeHBlY3RlZCBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIGFzIGlucHV0YCk7XG5cbiAgICAgICAgcmV0dXJuIFsuLi4oQXJyYXkoMipuICsgMSkua2V5cygpKV0ubWFwKHggPT4geCAtIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIFswLCBuKSByYW5nZSBvZiBpbnRlZ2Vyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIHBvc2l0aXZlIGludGVnZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFsgMCwgMSwgLi4uLCBuLTEgXVxuICAgICAqL1xuICAgIHN0YXRpYyByYW5nZShuKVxuICAgIHtcbiAgICAgICAgaWYoKG4gfD0gMCkgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFcnJvcihgRXhwZWN0ZWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGFzIGlucHV0YCk7XG5cbiAgICAgICAgcmV0dXJuIFsuLi4oQXJyYXkobikua2V5cygpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2h1ZmZsZSBpbi1wbGFjZVxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHtUW119IGFyclxuICAgICAqIEByZXR1cm5zIHtUW119IGFyclxuICAgICAqL1xuICAgIHN0YXRpYyBzaHVmZmxlKGFycilcbiAgICB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG0gPSBsZW4gLSAxO1xuXG4gICAgICAgIC8vIEZpc2hlci1ZYXR0ZXNcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaiA9IGkgKyAoKE1hdGgucmFuZG9tKCkgKiAobGVuIC0gaSkpIHwgMCk7IC8vIGkgPD0gaiA8IGFyci5sZW5ndGhcblxuICAgICAgICAgICAgaWYoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gYXJyW2pdO1xuICAgICAgICAgICAgICAgIGFycltqXSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW4gYW4gYXJyYXkgKDEgbGV2ZWwgb25seSlcbiAgICAgKiBAdGVtcGxhdGUgVVxuICAgICAqIEBwYXJhbSB7VVtdfSBhcnJheVxuICAgICAqIEByZXR1cm5zIHtVW119XG4gICAgICovXG4gICAgc3RhdGljIGZsYXR0ZW4oYXJyYXkpXG4gICAge1xuICAgICAgICAvL3JldHVybiBhcnJheS5mbGF0KCk7XG4gICAgICAgIC8vcmV0dXJuIGFycmF5LnJlZHVjZSgoYXJyLCB2YWwpID0+IGFyci5jb25jYXQodmFsKSwgW10pO1xuXG4gICAgICAgIGNvbnN0IGZsYXQgPSBbXTtcblxuICAgICAgICBmb3IobGV0IGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDAsIG0gPSBlbnRyeS5sZW5ndGg7IGogPCBtOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGZsYXQucHVzaChlbnRyeVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZmxhdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGF0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIDE2LWJpdCBmbG9hdCBmcm9tIGFcbiAgICAgKiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1aW50MTZcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNvZGVGbG9hdDE2KHVpbnQxNilcbiAgICB7XG4gICAgICAgIC8vIGRlY29kZSBhY2NvcmRpbmcgdG8gc2VjIDIuMS4yXG4gICAgICAgIC8vIDE2LUJpdCBGbG9hdGluZyBQb2ludCBOdW1iZXJzXG4gICAgICAgIC8vIG9mIHRoZSBPcGVuR0wgRVMgMyBzcGVjXG4gICAgICAgIGNvbnN0IHMgPSAodWludDE2ICYgMHhGRkZGKSA+PiAxNTsgLy8gc2lnbiBiaXRcbiAgICAgICAgY29uc3QgZSA9ICh1aW50MTYgJiAweDdGRkYpID4+IDEwOyAvLyBleHBvbmVudFxuICAgICAgICBjb25zdCBtID0gKHVpbnQxNiAmIDB4M0ZGKTsgLy8gbWFudGlzc2FcbiAgICAgICAgY29uc3Qgc2lnbiA9IDEgLSAyICogczsgLy8gKC0xKV5zXG5cbiAgICAgICAgaWYoZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG0gPT0gMCA/IHNpZ24gKiAwLjAgOiBzaWduICogbSAqIDUuOTYwNDY0NDc3NTM5MDYzZS04OyAvLyB6ZXJvIC8gc3Vibm9ybWFsXG4gICAgICAgIGVsc2UgaWYoZSA9PSAzMSlcbiAgICAgICAgICAgIHJldHVybiBtID09IDAgPyBzaWduICogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5hTjtcblxuICAgICAgICBjb25zdCBmID0gZSA+PSAxNSA/ICgxIDw8IChlLTE1KSkgOiAxLjAgLyAoMSA8PCAoMTUtZSkpOyAvLyAyXihlLTE1KVxuICAgICAgICByZXR1cm4gc2lnbiAqIGYgKiAoMS4wICsgbSAqIDAuMDAwOTc2NTYyNSk7IC8vIG5vcm1hbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgYXJvdW5kIGdldFVzZXJNZWRpYSgpXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbUNvbnN0cmFpbnRzfSBbY29uc3RyYWludHNdIHdpbGwgYmUgcGFzc2VkIHRvIGdldFVzZXJNZWRpYSgpXG4gICAgICogQHJldHVybnMge1NwZWVkeVByb21pc2U8SFRNTFZpZGVvRWxlbWVudD59XG4gICAgICovXG4gICAgc3RhdGljIHJlcXVlc3RDYW1lcmFTdHJlYW0oY29uc3RyYWludHMgPSB7IGF1ZGlvOiBmYWxzZSwgdmlkZW86IHRydWUgfSlcbiAgICB7XG4gICAgICAgIFV0aWxzLmxvZygnQWNjZXNzaW5nIHRoZSB3ZWJjYW0uLi4nKTtcblxuICAgICAgICBpZighbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyB8fCAhbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoJ1Vuc3VwcG9ydGVkIGJyb3dzZXI6IG5vIG1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoKScpO1xuXG4gICAgICAgIHJldHVybiBuZXcgU3BlZWR5UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICB2aWRlby5vbmxvYWRlZG1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZyhgVGhlIGNhbWVyYSBpcyBvbiEgUmVzb2x1dGlvbjogJHt2aWRlby52aWRlb1dpZHRofSB4ICR7dmlkZW8udmlkZW9IZWlnaHR9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmlkZW8pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWNjZXNzRGVuaWVkRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBQbGVhc2UgZ2l2ZSBhY2Nlc3MgdG8gdGhlIGNhbWVyYSBhbmQgcmVsb2FkIHRoZSBwYWdlYCxcbiAgICAgICAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNpZiAhZGVmaW5lZChLRVJORUxfU0laRSkgfHwgIWRlZmluZWQoQVhJUykgfHwgKEFYSVMgIT0gMCAmJiBBWElTICE9IDEpXFxuI2Vycm9yIFVuZGVmaW5lZCBLRVJORUxfU0laRSAvIEFYSVNcXG4jZW5kaWZcXG51bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG51bmlmb3JtIGZsb2F0IGtlcm5lbFtAS0VSTkVMX1NJWkVAXTtcXG5jb25zdCBpdmVjMiBheGlzID0gaXZlYzIoMS1BWElTLCBBWElTKTtcXG4jZGVmaW5lIFMoeCxrKSByZXN1bHQgKz0gcGl4ZWxBdFNob3J0T2Zmc2V0KGltYWdlLCBpdmVjMigoeCksKHgpKSAqIGF4aXMpICoga2VybmVsW2tdXFxudm9pZCBtYWluKClcXG57XFxudmVjNCByZXN1bHQgPSB2ZWM0KDAuMGYpO1xcbiNpZiBLRVJORUxfU0laRSA9PSAzXFxuUygtMSwgMik7XFxuUyggMCwgMSk7XFxuUyggMSwgMCk7XFxuI2VsaWYgS0VSTkVMX1NJWkUgPT0gNVxcblMoLTIsIDQpO1xcblMoLTEsIDMpO1xcblMoIDAsIDIpO1xcblMoIDEsIDEpO1xcblMoIDIsIDApO1xcbiNlbGlmIEtFUk5FTF9TSVpFID09IDdcXG5TKC0zLCA2KTtcXG5TKC0yLCA1KTtcXG5TKC0xLCA0KTtcXG5TKCAwLCAzKTtcXG5TKCAxLCAyKTtcXG5TKCAyLCAxKTtcXG5TKCAzLCAwKTtcXG4jZWxpZiBLRVJORUxfU0laRSA9PSA5XFxuUygtNCwgOCk7XFxuUygtMywgNyk7XFxuUygtMiwgNik7XFxuUygtMSwgNSk7XFxuUyggMCwgNCk7XFxuUyggMSwgMyk7XFxuUyggMiwgMik7XFxuUyggMywgMSk7XFxuUyggNCwgMCk7XFxuI2VsaWYgS0VSTkVMX1NJWkUgPT0gMTFcXG5TKC01LCAxMCk7XFxuUygtNCwgOSk7XFxuUygtMywgOCk7XFxuUygtMiwgNyk7XFxuUygtMSwgNik7XFxuUyggMCwgNSk7XFxuUyggMSwgNCk7XFxuUyggMiwgMyk7XFxuUyggMywgMik7XFxuUyggNCwgMSk7XFxuUyggNSwgMCk7XFxuI2VsaWYgS0VSTkVMX1NJWkUgPT0gMTNcXG5TKC02LCAxMik7XFxuUygtNSwgMTEpO1xcblMoLTQsIDEwKTtcXG5TKC0zLCA5KTtcXG5TKC0yLCA4KTtcXG5TKC0xLCA3KTtcXG5TKCAwLCA2KTtcXG5TKCAxLCA1KTtcXG5TKCAyLCA0KTtcXG5TKCAzLCAzKTtcXG5TKCA0LCAyKTtcXG5TKCA1LCAxKTtcXG5TKCA2LCAwKTtcXG4jZWxpZiBLRVJORUxfU0laRSA9PSAxNVxcblMoLTcsIDE0KTtcXG5TKC02LCAxMyk7XFxuUygtNSwgMTIpO1xcblMoLTQsIDExKTtcXG5TKC0zLCAxMCk7XFxuUygtMiwgOSk7XFxuUygtMSwgOCk7XFxuUyggMCwgNyk7XFxuUyggMSwgNik7XFxuUyggMiwgNSk7XFxuUyggMywgNCk7XFxuUyggNCwgMyk7XFxuUyggNSwgMik7XFxuUyggNiwgMSk7XFxuUyggNywgMCk7XFxuI2Vsc2VcXG4jZXJyb3IgSW52YWxpZCBwYXJhbWV0ZXJzXFxuI2VuZGlmXFxuY29sb3IgPSB2ZWM0KHJlc3VsdC5yZ2IsIDEuMGYpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWZuZGVmIEtFUk5FTF9TSVpFX1NRVUFSRURcXG4jZGVmaW5lIE11c3QgZGVmaW5lIEtFUk5FTF9TSVpFX1NRVUFSRURcXG4jZW5kaWZcXG51bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG51bmlmb3JtIGZsb2F0IGtlcm5lbFtAS0VSTkVMX1NJWkVfU1FVQVJFREBdO1xcbiNkZWZpbmUgUyh4LHksaykgcmVzdWx0ICs9IHBpeGVsQXRTaG9ydE9mZnNldChpbWFnZSwgaXZlYzIoKHgpLCh5KSkpICoga2VybmVsW2tdXFxudm9pZCBtYWluKClcXG57XFxudmVjNCByZXN1bHQgPSB2ZWM0KDAuMGYpO1xcbiNpZiBLRVJORUxfU0laRV9TUVVBUkVEID09IDlcXG5TKC0xLC0xLCA4KTtcXG5TKC0xLCAwLCA3KTtcXG5TKC0xLCAxLCA2KTtcXG5TKCAwLC0xLCA1KTtcXG5TKCAwLCAwLCA0KTtcXG5TKCAwLCAxLCAzKTtcXG5TKCAxLC0xLCAyKTtcXG5TKCAxLCAwLCAxKTtcXG5TKCAxLCAxLCAwKTtcXG4jZWxpZiBLRVJORUxfU0laRV9TUVVBUkVEID09IDI1XFxuUygtMiwtMiwgMjQpO1xcblMoLTIsLTEsIDIzKTtcXG5TKC0yLCAwLCAyMik7XFxuUygtMiwgMSwgMjEpO1xcblMoLTIsIDIsIDIwKTtcXG5TKC0xLC0yLCAxOSk7XFxuUygtMSwtMSwgMTgpO1xcblMoLTEsIDAsIDE3KTtcXG5TKC0xLCAxLCAxNik7XFxuUygtMSwgMiwgMTUpO1xcblMoIDAsLTIsIDE0KTtcXG5TKCAwLC0xLCAxMyk7XFxuUyggMCwgMCwgMTIpO1xcblMoIDAsIDEsIDExKTtcXG5TKCAwLCAyLCAxMCk7XFxuUyggMSwtMiwgOSk7XFxuUyggMSwtMSwgOCk7XFxuUyggMSwgMCwgNyk7XFxuUyggMSwgMSwgNik7XFxuUyggMSwgMiwgNSk7XFxuUyggMiwtMiwgNCk7XFxuUyggMiwtMSwgMyk7XFxuUyggMiwgMCwgMik7XFxuUyggMiwgMSwgMSk7XFxuUyggMiwgMiwgMCk7XFxuI2VsaWYgS0VSTkVMX1NJWkVfU1FVQVJFRCA9PSA0OVxcblMoLTMsLTMsIDQ4KTtcXG5TKC0zLC0yLCA0Nyk7XFxuUygtMywtMSwgNDYpO1xcblMoLTMsIDAsIDQ1KTtcXG5TKC0zLCAxLCA0NCk7XFxuUygtMywgMiwgNDMpO1xcblMoLTMsIDMsIDQyKTtcXG5TKC0yLC0zLCA0MSk7XFxuUygtMiwtMiwgNDApO1xcblMoLTIsLTEsIDM5KTtcXG5TKC0yLCAwLCAzOCk7XFxuUygtMiwgMSwgMzcpO1xcblMoLTIsIDIsIDM2KTtcXG5TKC0yLCAzLCAzNSk7XFxuUygtMSwtMywgMzQpO1xcblMoLTEsLTIsIDMzKTtcXG5TKC0xLC0xLCAzMik7XFxuUygtMSwgMCwgMzEpO1xcblMoLTEsIDEsIDMwKTtcXG5TKC0xLCAyLCAyOSk7XFxuUygtMSwgMywgMjgpO1xcblMoIDAsLTMsIDI3KTtcXG5TKCAwLC0yLCAyNik7XFxuUyggMCwtMSwgMjUpO1xcblMoIDAsIDAsIDI0KTtcXG5TKCAwLCAxLCAyMyk7XFxuUyggMCwgMiwgMjIpO1xcblMoIDAsIDMsIDIxKTtcXG5TKCAxLC0zLCAyMCk7XFxuUyggMSwtMiwgMTkpO1xcblMoIDEsLTEsIDE4KTtcXG5TKCAxLCAwLCAxNyk7XFxuUyggMSwgMSwgMTYpO1xcblMoIDEsIDIsIDE1KTtcXG5TKCAxLCAzLCAxNCk7XFxuUyggMiwtMywgMTMpO1xcblMoIDIsLTIsIDEyKTtcXG5TKCAyLC0xLCAxMSk7XFxuUyggMiwgMCwgMTApO1xcblMoIDIsIDEsIDkpO1xcblMoIDIsIDIsIDgpO1xcblMoIDIsIDMsIDcpO1xcblMoIDMsLTMsIDYpO1xcblMoIDMsLTIsIDUpO1xcblMoIDMsLTEsIDQpO1xcblMoIDMsIDAsIDMpO1xcblMoIDMsIDEsIDIpO1xcblMoIDMsIDIsIDEpO1xcblMoIDMsIDMsIDApO1xcbiNlbHNlXFxuI2Vycm9yIEludmFsaWQgS0VSTkVMX1NJWkVfU1FVQVJFRFxcbiNlbmRpZlxcbmNvbG9yID0gdmVjNChyZXN1bHQucmdiLCAxLjBmKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuI2RlZmluZSBYKGksaikgdCA9IHZlYzIobWluKHBbaV0sIHBbal0pLCBtYXgocFtpXSwgcFtqXSkpOyBwW2ldID0gdC54OyBwW2pdID0gdC55O1xcbiNkZWZpbmUgUyhpLHgseSkgcFtpXSA9IHBpeGVsQXRTaG9ydE9mZnNldChpbWFnZSwgaXZlYzIoKHgpLCh5KSkpLmdcXG52b2lkIG1haW4oKVxcbntcXG5mbG9hdCBtZWRpYW47XFxudmVjMiB0O1xcbiNpZiAhZGVmaW5lZChLRVJORUxfU0laRSlcXG4jZXJyb3IgTXVzdCBkZWZpbmUgS0VSTkVMX1NJWkVcXG4jZWxpZiBLRVJORUxfU0laRSA9PSAzXFxuZmxvYXQgcFs5XTtcXG5TKDAsLTEsLTEpO1xcblMoMSwgMCwtMSk7XFxuUygyLCAxLC0xKTtcXG5TKDMsLTEsIDApO1xcblMoNCwgMCwgMCk7XFxuUyg1LCAxLCAwKTtcXG5TKDYsLTEsIDEpO1xcblMoNywgMCwgMSk7XFxuUyg4LCAxLCAxKTtcXG5YKDEsMik7WCg0LDUpO1goNyw4KTtYKDAsMSk7WCgzLDQpO1goNiw3KTtYKDEsMik7WCg0LDUpO1goNyw4KTtYKDAsMyk7WCg1LDgpO1goNCw3KTtYKDMsNik7WCgxLDQpO1goMiw1KTtYKDQsNyk7WCg0LDIpO1goNiw0KTtYKDQsMik7XFxubWVkaWFuID0gcFs0XTtcXG4jZWxpZiBLRVJORUxfU0laRSA9PSA1XFxuZmxvYXQgcFsyNV07XFxuUyggMCwtMiwtMik7XFxuUyggMSwtMSwtMik7XFxuUyggMiwgMCwtMik7XFxuUyggMywgMSwtMik7XFxuUyggNCwgMiwtMik7XFxuUyggNSwtMiwtMSk7XFxuUyggNiwtMSwtMSk7XFxuUyggNywgMCwtMSk7XFxuUyggOCwgMSwtMSk7XFxuUyggOSwgMiwtMSk7XFxuUygxMCwtMiwgMCk7XFxuUygxMSwtMSwgMCk7XFxuUygxMiwgMCwgMCk7XFxuUygxMywgMSwgMCk7XFxuUygxNCwgMiwgMCk7XFxuUygxNSwtMiwgMSk7XFxuUygxNiwtMSwgMSk7XFxuUygxNywgMCwgMSk7XFxuUygxOCwgMSwgMSk7XFxuUygxOSwgMiwgMSk7XFxuUygyMCwtMiwgMik7XFxuUygyMSwtMSwgMik7XFxuUygyMiwgMCwgMik7XFxuUygyMywgMSwgMik7XFxuUygyNCwgMiwgMik7XFxuWCgwLDEpO1goMyw0KTtYKDIsNCk7WCgyLDMpO1goNiw3KTtYKDUsNyk7WCg1LDYpO1goOSwxMCk7WCg4LDEwKTtYKDgsOSk7WCgxMiwxMyk7WCgxMSwxMyk7WCgxMSwxMik7WCgxNSwxNik7WCgxNCwxNik7WCgxNCwxNSk7WCgxOCwxOSk7WCgxNywxOSk7WCgxNywxOCk7WCgyMSwyMik7WCgyMCwyMik7WCgyMCwyMSk7WCgyMywyNCk7WCgyLDUpO1goMyw2KTtYKDAsNik7WCgwLDMpO1goNCw3KTtYKDEsNyk7WCgxLDQpO1goMTEsMTQpO1goOCwxNCk7WCg4LDExKTtYKDEyLDE1KTtYKDksMTUpO1goOSwxMik7WCgxMywxNik7WCgxMCwxNik7WCgxMCwxMyk7WCgyMCwyMyk7WCgxNywyMyk7WCgxNywyMCk7WCgyMSwyNCk7WCgxOCwyNCk7WCgxOCwyMSk7WCgxOSwyMik7WCg4LDE3KTtYKDksMTgpO1goMCwxOCk7WCgwLDkpO1goMTAsMTkpO1goMSwxOSk7WCgxLDEwKTtYKDExLDIwKTtYKDIsMjApO1goMiwxMSk7WCgxMiwyMSk7WCgzLDIxKTtYKDMsMTIpO1goMTMsMjIpO1goNCwyMik7WCg0LDEzKTtYKDE0LDIzKTtYKDUsMjMpO1goNSwxNCk7WCgxNSwyNCk7WCg2LDI0KTtYKDYsMTUpO1goNywxNik7WCg3LDE5KTtYKDEzLDIxKTtYKDE1LDIzKTtYKDcsMTMpO1goNywxNSk7WCgxLDkpO1goMywxMSk7WCg1LDE3KTtYKDExLDE3KTtYKDksMTcpO1goNCwxMCk7WCg2LDEyKTtYKDcsMTQpO1goNCw2KTtYKDQsNyk7WCgxMiwxNCk7WCgxMCwxNCk7WCg2LDcpO1goMTAsMTIpO1goNiwxMCk7WCg2LDE3KTtYKDEyLDE3KTtYKDcsMTcpO1goNywxMCk7WCgxMiwxOCk7WCg3LDEyKTtYKDEwLDE4KTtYKDEyLDIwKTtYKDEwLDIwKTtYKDEwLDEyKTtcXG5tZWRpYW4gPSBwWzEyXTtcXG4jZWxpZiBLRVJORUxfU0laRSA9PSA3XFxuZmxvYXQgcFs0OV07XFxuUyggMCwtMywtMyk7XFxuUyggMSwtMiwtMyk7XFxuUyggMiwtMSwtMyk7XFxuUyggMywgMCwtMyk7XFxuUyggNCwgMSwtMyk7XFxuUyggNSwgMiwtMyk7XFxuUyggNiwgMywtMyk7XFxuUyggNywtMywtMik7XFxuUyggOCwtMiwtMik7XFxuUyggOSwtMSwtMik7XFxuUygxMCwgMCwtMik7XFxuUygxMSwgMSwtMik7XFxuUygxMiwgMiwtMik7XFxuUygxMywgMywtMik7XFxuUygxNCwtMywtMSk7XFxuUygxNSwtMiwtMSk7XFxuUygxNiwtMSwtMSk7XFxuUygxNywgMCwtMSk7XFxuUygxOCwgMSwtMSk7XFxuUygxOSwgMiwtMSk7XFxuUygyMCwgMywtMSk7XFxuUygyMSwtMywgMCk7XFxuUygyMiwtMiwgMCk7XFxuUygyMywtMSwgMCk7XFxuUygyNCwgMCwgMCk7XFxuUygyNSwgMSwgMCk7XFxuUygyNiwgMiwgMCk7XFxuUygyNywgMywgMCk7XFxuUygyOCwtMywgMSk7XFxuUygyOSwtMiwgMSk7XFxuUygzMCwtMSwgMSk7XFxuUygzMSwgMCwgMSk7XFxuUygzMiwgMSwgMSk7XFxuUygzMywgMiwgMSk7XFxuUygzNCwgMywgMSk7XFxuUygzNSwtMywgMik7XFxuUygzNiwtMiwgMik7XFxuUygzNywtMSwgMik7XFxuUygzOCwgMCwgMik7XFxuUygzOSwgMSwgMik7XFxuUyg0MCwgMiwgMik7XFxuUyg0MSwgMywgMik7XFxuUyg0MiwtMywgMyk7XFxuUyg0MywtMiwgMyk7XFxuUyg0NCwtMSwgMyk7XFxuUyg0NSwgMCwgMyk7XFxuUyg0NiwgMSwgMyk7XFxuUyg0NywgMiwgMyk7XFxuUyg0OCwgMywgMyk7XFxuWCgwLDEpO1goMiwzKTtYKDAsMik7WCgxLDMpO1goMSwyKTtYKDQsNSk7WCg2LDcpO1goNCw2KTtYKDUsNyk7WCg1LDYpO1goMCw0KTtYKDIsNik7WCgyLDQpO1goMSw1KTtYKDMsNyk7WCgzLDUpO1goMSwyKTtYKDMsNCk7WCg1LDYpO1goOCw5KTtYKDEwLDExKTtYKDgsMTApO1goOSwxMSk7WCg5LDEwKTtYKDEyLDEzKTtYKDE0LDE1KTtYKDEyLDE0KTtYKDEzLDE1KTtYKDEzLDE0KTtYKDgsMTIpO1goMTAsMTQpO1goMTAsMTIpO1goOSwxMyk7WCgxMSwxNSk7WCgxMSwxMyk7WCg5LDEwKTtYKDExLDEyKTtYKDEzLDE0KTtYKDAsOCk7WCg0LDEyKTtYKDQsOCk7WCgyLDEwKTtYKDYsMTQpO1goNiwxMCk7WCgyLDQpO1goNiw4KTtYKDEwLDEyKTtYKDEsOSk7WCg1LDEzKTtYKDUsOSk7WCgzLDExKTtYKDcsMTUpO1goNywxMSk7WCgzLDUpO1goNyw5KTtYKDExLDEzKTtYKDEsMik7WCgzLDQpO1goNSw2KTtYKDcsOCk7WCg5LDEwKTtYKDExLDEyKTtYKDEzLDE0KTtYKDE2LDE3KTtYKDE4LDE5KTtYKDE2LDE4KTtYKDE3LDE5KTtYKDE3LDE4KTtYKDIwLDIxKTtYKDIyLDIzKTtYKDIwLDIyKTtYKDIxLDIzKTtYKDIxLDIyKTtYKDE2LDIwKTtYKDE4LDIyKTtYKDE4LDIwKTtYKDE3LDIxKTtYKDE5LDIzKTtYKDE5LDIxKTtYKDE3LDE4KTtYKDE5LDIwKTtYKDIxLDIyKTtYKDI0LDI1KTtYKDI2LDI3KTtYKDI0LDI2KTtYKDI1LDI3KTtYKDI1LDI2KTtYKDI4LDI5KTtYKDMwLDMxKTtYKDI4LDMwKTtYKDI5LDMxKTtYKDI5LDMwKTtYKDI0LDI4KTtYKDI2LDMwKTtYKDI2LDI4KTtYKDI1LDI5KTtYKDI3LDMxKTtYKDI3LDI5KTtYKDI1LDI2KTtYKDI3LDI4KTtYKDI5LDMwKTtYKDE2LDI0KTtYKDIwLDI4KTtYKDIwLDI0KTtYKDE4LDI2KTtYKDIyLDMwKTtYKDIyLDI2KTtYKDE4LDIwKTtYKDIyLDI0KTtYKDI2LDI4KTtYKDE3LDI1KTtYKDIxLDI5KTtYKDIxLDI1KTtYKDE5LDI3KTtYKDIzLDMxKTtYKDIzLDI3KTtYKDE5LDIxKTtYKDIzLDI1KTtYKDI3LDI5KTtYKDE3LDE4KTtYKDE5LDIwKTtYKDIxLDIyKTtYKDIzLDI0KTtYKDI1LDI2KTtYKDI3LDI4KTtYKDI5LDMwKTtYKDAsMTYpO1goOCwyNCk7WCg4LDE2KTtYKDQsMjApO1goMTIsMjgpO1goMTIsMjApO1goNCw4KTtYKDEyLDE2KTtYKDIwLDI0KTtYKDIsMTgpO1goMTAsMjYpO1goMTAsMTgpO1goNiwyMik7WCgxNCwzMCk7WCgxNCwyMik7WCg2LDEwKTtYKDE0LDE4KTtYKDIyLDI2KTtYKDIsNCk7WCg2LDgpO1goMTAsMTIpO1goMTQsMTYpO1goMTgsMjApO1goMjIsMjQpO1goMjYsMjgpO1goMSwxNyk7WCg5LDI1KTtYKDksMTcpO1goNSwyMSk7WCgxMywyOSk7WCgxMywyMSk7WCg1LDkpO1goMTMsMTcpO1goMjEsMjUpO1goMywxOSk7WCgxMSwyNyk7WCgxMSwxOSk7WCg3LDIzKTtYKDE1LDMxKTtYKDE1LDIzKTtYKDcsMTEpO1goMTUsMTkpO1goMjMsMjcpO1goMyw1KTtYKDcsOSk7WCgxMSwxMyk7WCgxNSwxNyk7WCgxOSwyMSk7WCgyMywyNSk7WCgyNywyOSk7WCgxLDIpO1goMyw0KTtYKDUsNik7WCg3LDgpO1goOSwxMCk7WCgxMSwxMik7WCgxMywxNCk7WCgxNSwxNik7WCgxNywxOCk7WCgxOSwyMCk7WCgyMSwyMik7WCgyMywyNCk7WCgyNSwyNik7WCgyNywyOCk7WCgyOSwzMCk7WCgzMiwzMyk7WCgzNCwzNSk7WCgzMiwzNCk7WCgzMywzNSk7WCgzMywzNCk7WCgzNiwzNyk7WCgzOCwzOSk7WCgzNiwzOCk7WCgzNywzOSk7WCgzNywzOCk7WCgzMiwzNik7WCgzNCwzOCk7WCgzNCwzNik7WCgzMywzNyk7WCgzNSwzOSk7WCgzNSwzNyk7WCgzMywzNCk7WCgzNSwzNik7WCgzNywzOCk7WCg0MCw0MSk7WCg0Miw0Myk7WCg0MCw0Mik7WCg0MSw0Myk7WCg0MSw0Mik7WCg0NCw0NSk7WCg0Niw0Nyk7WCg0NCw0Nik7WCg0NSw0Nyk7WCg0NSw0Nik7WCg0MCw0NCk7WCg0Miw0Nik7WCg0Miw0NCk7WCg0MSw0NSk7WCg0Myw0Nyk7WCg0Myw0NSk7WCg0MSw0Mik7WCg0Myw0NCk7WCg0NSw0Nik7WCgzMiw0MCk7WCgzNiw0NCk7WCgzNiw0MCk7WCgzNCw0Mik7WCgzOCw0Nik7WCgzOCw0Mik7WCgzNCwzNik7WCgzOCw0MCk7WCg0Miw0NCk7WCgzMyw0MSk7WCgzNyw0NSk7WCgzNyw0MSk7WCgzNSw0Myk7WCgzOSw0Nyk7WCgzOSw0Myk7WCgzNSwzNyk7WCgzOSw0MSk7WCg0Myw0NSk7WCgzMywzNCk7WCgzNSwzNik7WCgzNywzOCk7WCgzOSw0MCk7WCg0MSw0Mik7WCg0Myw0NCk7WCg0NSw0Nik7WCgzMiw0OCk7WCg0MCw0OCk7WCgzNiw0MCk7WCg0NCw0OCk7WCgzOCw0Mik7WCgzNCwzNik7WCgzOCw0MCk7WCg0Miw0NCk7WCg0Niw0OCk7WCgzNyw0MSk7WCgzOSw0Myk7WCgzNSwzNyk7WCgzOSw0MSk7WCg0Myw0NSk7WCgzMywzNCk7WCgzNSwzNik7WCgzNywzOCk7WCgzOSw0MCk7WCg0MSw0Mik7WCg0Myw0NCk7WCg0NSw0Nik7WCg0Nyw0OCk7WCgwLDMyKTtYKDE2LDQ4KTtYKDE2LDMyKTtYKDgsNDApO1goMjQsNDApO1goOCwxNik7WCgyNCwzMik7WCg0MCw0OCk7WCg0LDM2KTtYKDIwLDM2KTtYKDEyLDQ0KTtYKDI4LDQ0KTtYKDEyLDIwKTtYKDI4LDM2KTtYKDQsOCk7WCgxMiwxNik7WCgyMCwyNCk7WCgyOCwzMik7WCgzNiw0MCk7WCg0NCw0OCk7WCgyLDM0KTtYKDE4LDM0KTtYKDEwLDQyKTtYKDI2LDQyKTtYKDEwLDE4KTtYKDI2LDM0KTtYKDYsMzgpO1goMjIsMzgpO1goMTQsNDYpO1goMzAsNDYpO1goMTQsMjIpO1goMzAsMzgpO1goNiwxMCk7WCgxNCwxOCk7WCgyMiwyNik7WCgzMCwzNCk7WCgzOCw0Mik7WCgyLDQpO1goNiw4KTtYKDEwLDEyKTtYKDE0LDE2KTtYKDE4LDIwKTtYKDIyLDI0KTtYKDI2LDI4KTtYKDMwLDMyKTtYKDM0LDM2KTtYKDM4LDQwKTtYKDQyLDQ0KTtYKDQ2LDQ4KTtYKDEsMzMpO1goMTcsMzMpO1goOSw0MSk7WCgyNSw0MSk7WCg5LDE3KTtYKDI1LDMzKTtYKDUsMzcpO1goMjEsMzcpO1goMTMsNDUpO1goMjksNDUpO1goMTMsMjEpO1goMjksMzcpO1goNSw5KTtYKDEzLDE3KTtYKDIxLDI1KTtYKDI5LDMzKTtYKDM3LDQxKTtYKDMsMzUpO1goMTksMzUpO1goMTEsNDMpO1goMjcsNDMpO1goMTEsMTkpO1goMjcsMzUpO1goNywzOSk7WCgyMywzOSk7WCgxNSw0Nyk7WCgzMSw0Nyk7WCgxNSwyMyk7WCgzMSwzOSk7WCg3LDExKTtYKDE1LDE5KTtYKDIzLDI3KTtYKDMxLDM1KTtYKDM5LDQzKTtYKDMsNSk7WCg3LDkpO1goMTEsMTMpO1goMTUsMTcpO1goMTksMjEpO1goMjMsMjUpO1goMjcsMjkpO1goMzEsMzMpO1goMzUsMzcpO1goMzksNDEpO1goNDMsNDUpO1goMSwyKTtYKDMsNCk7WCg1LDYpO1goNyw4KTtYKDksMTApO1goMTEsMTIpO1goMTMsMTQpO1goMTUsMTYpO1goMTcsMTgpO1goMTksMjApO1goMjEsMjIpO1goMjMsMjQpO1xcbm1lZGlhbiA9IHBbMjRdO1xcbiNlbHNlXFxuI2Vycm9yIFVuc3VwcG9ydGVkIGtlcm5lbCBzaXplXFxuI2VuZGlmXFxuY29sb3IgPSB2ZWM0KG1lZGlhbiwgbWVkaWFuLCBtZWRpYW4sIDEuMGYpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBpbGx1bWluYXRpb25NYXA7XFxudW5pZm9ybSBmbG9hdCBnYWluO1xcbnVuaWZvcm0gZmxvYXQgb2Zmc2V0O1xcbnVuaWZvcm0gZmxvYXQgZGVjYXk7XFxuI2lmbmRlZiBHUkVZU0NBTEVcXG4jZXJyb3IgTXVzdCBkZWZpbmUgR1JFWVNDQUxFXFxuI2VuZGlmXFxuI2lmIEdSRVlTQ0FMRSA9PSAwXFxuY29uc3QgbWF0MyByZ2IyeXV2ID0gbWF0MyhcXG4wLjI5OWYsIC0wLjE0NzEzZiwgMC42MTVmLFxcbjAuNTg3ZiwgLTAuMjg4ODZmLCAtMC41MTQ5OWYsXFxuMC4xMTRmLCAwLjQzNmYsIC0wLjEwMDAxZlxcbik7XFxuY29uc3QgbWF0MyB5dXYycmdiID0gbWF0MyhcXG4xLjBmLCAxLjBmLCAxLjBmLFxcbjAuMGYsIC0wLjM5NDY1ZiwgMi4wMzIxMWYsXFxuMS4xMzk4M2YsIC0wLjU4MDYwZiwgMC4wZlxcbik7XFxuI2VuZGlmXFxuY29uc3QgZmxvYXQgZXBzID0gMC4wMDAxZjtcXG5jb25zdCBmbG9hdCBzcXJ0MiA9IDEuNDE0MjEzNTYyMzczMDk1MWY7XFxuY29uc3QgZmxvYXQgbWFnaWMgPSAyMC4wZjtcXG5jb25zdCB2ZWMyIGNlbnRlciA9IHZlYzIoMC41Zik7XFxudm9pZCBtYWluKClcXG57XFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKGltYWdlKTtcXG52ZWM0IGltYXBQaXhlbCA9IHRocmVhZFBpeGVsKGlsbHVtaW5hdGlvbk1hcCk7XFxuZmxvYXQgbGFtYmRhID0gLXNxcnQyICogbG9nKG1heCgxLjBmIC0gZGVjYXksIGVwcykpO1xcbmZsb2F0IGRpc3QgPSBsZW5ndGgodGV4Q29vcmQgLSBjZW50ZXIpO1xcbmZsb2F0IHZnYWluID0gZ2FpbiAqIGV4cCgtbGFtYmRhICogZGlzdCk7XFxuZmxvYXQgbm9ybWFsaXplZEdhaW4gPSAyLjBmICogdmdhaW47XFxuZmxvYXQgbm9ybWFsaXplZE9mZnNldCA9IDIuMGYgKiBvZmZzZXQgLSAxLjBmO1xcbiNpZiBHUkVZU0NBTEUgIT0gMFxcbmZsb2F0IGx1bWEgPSAxLjAgLyAoMS4wICsgZXhwKC1ub3JtYWxpemVkR2FpbiAqIG1hZ2ljICogKHBpeGVsLmcgLSBpbWFwUGl4ZWwuZykpKTtcXG5sdW1hID0gY2xhbXAobHVtYSArIG5vcm1hbGl6ZWRPZmZzZXQsIDAuMGYsIDEuMGYpO1xcbmNvbG9yID0gdmVjNChsdW1hLCBsdW1hLCBsdW1hLCAxLjBmKTtcXG4jZWxzZVxcbnZlYzMgeXV2UGl4ZWwgPSByZ2IyeXV2ICogcGl4ZWwucmdiO1xcbnZlYzMgeXV2SW1hcFBpeGVsID0gcmdiMnl1diAqIGltYXBQaXhlbC5yZ2I7XFxuZmxvYXQgbHVtYSA9IDEuMCAvICgxLjAgKyBleHAoLW5vcm1hbGl6ZWRHYWluICogbWFnaWMgKiAoeXV2UGl4ZWwuciAtIHl1dkltYXBQaXhlbC5yKSkpO1xcbmx1bWEgKz0gbm9ybWFsaXplZE9mZnNldDtcXG52ZWMzIHJnYkNvcnJlY3RlZFBpeGVsID0geXV2MnJnYiAqIHZlYzMobHVtYSwgeXV2UGl4ZWwuZ2IpO1xcbnJnYkNvcnJlY3RlZFBpeGVsID0gY2xhbXAocmdiQ29ycmVjdGVkUGl4ZWwsIDAuMGYsIDEuMGYpO1xcbmNvbG9yID0gdmVjNChyZ2JDb3JyZWN0ZWRQaXhlbCwgMS4wZik7XFxuI2VuZGlmXFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNpZm5kZWYgR1JFWVNDQUxFXFxuI2Vycm9yIE11c3QgZGVmaW5lIEdSRVlTQ0FMRVxcbiNlbmRpZlxcbiNpZiBHUkVZU0NBTEUgIT0gMFxcbnVuaWZvcm0gc2FtcGxlcjJEIG1pbm1heDJkO1xcbiNlbHNlXFxudW5pZm9ybSBzYW1wbGVyMkQgbWlubWF4MmRSR0JbM107XFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCBtaW5WYWx1ZTtcXG51bmlmb3JtIGZsb2F0IG1heFZhbHVlO1xcbmNvbnN0IGZsb2F0IGVwcyA9IDEuMGYgLyAyNTUuMGY7XFxudm9pZCBtYWluKClcXG57XFxudmVjMiBtaW5tYXggPSBjbGFtcCh2ZWMyKG1pblZhbHVlLCBtYXhWYWx1ZSksIDAuMGYsIDI1NS4wZikgLyAyNTUuMGY7XFxudmVjNCBuZXdNaW4gPSB2ZWM0KG1pbm1heC54KTtcXG52ZWM0IG5ld1JhbmdlID0gdmVjNChtaW5tYXgueSAtIG1pbm1heC54KTtcXG52ZWM0IGFscGhhID0gdmVjNCgxLjBmLCBuZXdNaW4ueCwgbmV3UmFuZ2UueCwgMS4wZik7XFxuI2lmIEdSRVlTQ0FMRSAhPSAwXFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKG1pbm1heDJkKTtcXG5tYXQ0IGNoYW5uZWwgPSBtYXQ0KHBpeGVsLCBwaXhlbCwgcGl4ZWwsIGFscGhhKTtcXG4jZWxzZVxcbm1hdDQgY2hhbm5lbCA9IG1hdDQoXFxudGhyZWFkUGl4ZWwobWlubWF4MmRSR0JbMF0pLFxcbnRocmVhZFBpeGVsKG1pbm1heDJkUkdCWzFdKSxcXG50aHJlYWRQaXhlbChtaW5tYXgyZFJHQlsyXSksXFxuYWxwaGFcXG4pO1xcbiNlbmRpZlxcbnZlYzQgb2xkTWluID0gdmVjNChjaGFubmVsWzBdLmcsIGNoYW5uZWxbMV0uZywgY2hhbm5lbFsyXS5nLCBjaGFubmVsWzNdLmcpO1xcbnZlYzQgb2xkUmFuZ2UgPSBtYXgodmVjNChjaGFubmVsWzBdLmIsIGNoYW5uZWxbMV0uYiwgY2hhbm5lbFsyXS5iLCBjaGFubmVsWzNdLmIpLCBlcHMpO1xcbnZlYzQgb2xkSW50ZW5zaXR5ID0gdmVjNChjaGFubmVsWzBdLmEsIGNoYW5uZWxbMV0uYSwgY2hhbm5lbFsyXS5hLCBjaGFubmVsWzNdLmEpO1xcbnZlYzQgbmV3SW50ZW5zaXR5ID0gKG9sZEludGVuc2l0eSAtIG9sZE1pbikgKiBuZXdSYW5nZSAvIG9sZFJhbmdlICsgbmV3TWluO1xcbmNvbG9yID0gbmV3SW50ZW5zaXR5O1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJjb25zdCB2ZWM0IGdyZXkgPSB2ZWM0KDAuMjk5ZiwgMC41ODdmLCAwLjExNGYsIDAuMGYpO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGltYWdlO1xcbnZvaWQgbWFpbigpXFxue1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChpbWFnZSk7XFxuZmxvYXQgZyA9IGRvdChwaXhlbCwgZ3JleSk7XFxuY29sb3IgPSB2ZWM0KGcsIGcsIGcsIDEuMGYpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWZuZGVmIF9DT0xPUlNfR0xTTFxcbiNkZWZpbmUgX0NPTE9SU19HTFNMXFxuI2RlZmluZSBQSVhFTENPTVBPTkVOVF9SRUQgICBAUElYRUxDT01QT05FTlRfUkVEQFxcbiNkZWZpbmUgUElYRUxDT01QT05FTlRfR1JFRU4gQFBJWEVMQ09NUE9ORU5UX0dSRUVOQFxcbiNkZWZpbmUgUElYRUxDT01QT05FTlRfQkxVRSAgQFBJWEVMQ09NUE9ORU5UX0JMVUVAXFxuI2RlZmluZSBQSVhFTENPTVBPTkVOVF9BTFBIQSBAUElYRUxDT01QT05FTlRfQUxQSEFAXFxuI2VuZGlmXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2lmbmRlZiBfRklMVEVSU19HTFNMXFxuI2RlZmluZSBfRklMVEVSU19HTFNMXFxuZmxvYXQgbGFwbGFjaWFuKHNhbXBsZXIyRCBweXJhbWlkLCB2ZWMyIHBvc2l0aW9uLCBmbG9hdCBsb2QpXFxue1xcbmZsb2F0IHBvdCA9IGV4cDIobG9kKTtcXG5pdmVjMiBweXJCYXNlU2l6ZSA9IHRleHR1cmVTaXplKHB5cmFtaWQsIDApO1xcbmNvbnN0IHZlYzMgb25lcyA9IHZlYzMoMS4wZik7XFxuY29uc3QgbWF0MyBrZXJuZWwgPSBtYXQzKFxcbjAsLTEsIDAsXFxuLTEsIDQsLTEsXFxuMCwtMSwgMFxcbik7XFxuI2RlZmluZSBMUEMoeCx5KSBweXJTdWJwaXhlbEF0RXhPZmZzZXQocHlyYW1pZCwgcG9zaXRpb24sIGxvZCwgcG90LCBpdmVjMigoeCksKHkpKSwgcHlyQmFzZVNpemUpLmdcXG5tYXQzIG5laWdoYm9yaG9vZCA9IG1hdDMoXFxuMC4wZiwgTFBDKDAsLTEpLCAwLjBmLFxcbkxQQygtMSwwKSwgTFBDKDAsMCksIExQQygxLDApLFxcbjAuMGYsIExQQygwLDEpLCAwLjBmXFxuKTtcXG5tYXQzIG0gPSBtYXRyaXhDb21wTXVsdChuZWlnaGJvcmhvb2QsIGtlcm5lbCk7XFxucmV0dXJuIGRvdChvbmVzLCB2ZWMzKFxcbmRvdChtWzBdLCBvbmVzKSxcXG5kb3QobVsxXSwgb25lcyksXFxuZG90KG1bMl0sIG9uZXMpXFxuKSkgKiAoMS4wZiArIGxvZCk7XFxufVxcbiNlbmRpZlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNpZm5kZWYgX0ZJWEVEUE9JTlRfR0xTTFxcbiNkZWZpbmUgX0ZJWEVEUE9JTlRfR0xTTFxcbiNkZWZpbmUgZml4ZWRfdCBpbnRcXG4jZGVmaW5lIGZpeGVkMl90IGl2ZWMyXFxuY29uc3QgaW50IEZJWF9CSVRTID0gaW50KEBGSVhfQklUU0ApO1xcbmNvbnN0IGZsb2F0IEZJWF9SRVNPTFVUSU9OID0gZmxvYXQoQEZJWF9SRVNPTFVUSU9OQCk7XFxuI2RlZmluZSBpdG9maXgoeCkgZml4ZWRfdCgoeCkgPDwgRklYX0JJVFMpXFxuI2RlZmluZSBmaXh0b2koZikgaW50KCh4KSA+PiBGSVhfQklUUylcXG4jZGVmaW5lIGZ0b2ZpeCh4KSBmaXhlZF90KCh4KSAqIEZJWF9SRVNPTFVUSU9OICsgMC41ZilcXG4jZGVmaW5lIGZpeHRvZihmKSAoZmxvYXQoZikgLyBGSVhfUkVTT0xVVElPTilcXG4jZGVmaW5lIGl2ZWMydG9maXgoeCkgZml4ZWQyX3QoKHgpIDw8IEZJWF9CSVRTKVxcbiNkZWZpbmUgZml4dG9pdmVjMihmKSBpdmVjMigoZikgPj4gRklYX0JJVFMpXFxuI2RlZmluZSB2ZWMydG9maXgodikgZml4ZWQyX3QoKHYpICogRklYX1JFU09MVVRJT04gKyB2ZWMyKDAuNWYpKVxcbiNkZWZpbmUgZml4dG92ZWMyKGYpICh2ZWMyKGYpIC8gRklYX1JFU09MVVRJT04pXFxuI2VuZGlmXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2lmbmRlZiBfRkxPQVQxNl9HTFNMXFxuI2RlZmluZSBfRkxPQVQxNl9HTFNMXFxuI2RlZmluZSBlbmNvZGVGbG9hdDE2KGYpICh2ZWMyKHBhY2tmMTYoZikpIC8gMjU1LjBmKVxcbiNkZWZpbmUgZGVjb2RlRmxvYXQxNih2KSB1bnBhY2tmMTYodXZlYzIoKHYpICogMjU1LjBmKSlcXG4jZGVmaW5lIGVuY29kZVBhaXJPZkZsb2F0MTYoZikgdmVjNChlbmNvZGVGbG9hdDE2KChmKS54KSwgZW5jb2RlRmxvYXQxNigoZikueSkpXFxuI2RlZmluZSBkZWNvZGVQYWlyT2ZGbG9hdDE2KHYpIHZlYzIoZGVjb2RlRmxvYXQxNigodikucmcpLCBkZWNvZGVGbG9hdDE2KCh2KS5iYSkpXFxuI2RlZmluZSBlbmNvZGVOdWxsUGFpck9mRmxvYXQxNigpIHZlYzQoMS4wZilcXG4jZGVmaW5lIGlzTnVsbFBhaXJPZkZsb2F0MTYodikgYWxsKGVxdWFsKCh2KSwgZW5jb2RlTnVsbFBhaXJPZkZsb2F0MTYoKSkpXFxuI2RlZmluZSBlbmNvZGVEaXNjYXJkZWRQYWlyT2ZGbG9hdDE2KCkgdmVjNCgwLjBmLCAxLjBmLCAwLjBmLCAxLjBmKVxcbiNkZWZpbmUgaXNEaXNjYXJkZWRQYWlyT2ZGbG9hdDE2KHYpIGFsbChlcXVhbCgodiksIGVuY29kZURpc2NhcmRlZFBhaXJPZkZsb2F0MTYoKSkpXFxuI2RlZmluZSBlbmNvZGVGbG9hdDE2TmFOKCkgdmVjMigwLjVmLCAxLjBmKVxcbiNkZWZpbmUgaXNFbmNvZGVkRmxvYXQxNk5hTih2KSBhbGwoZXF1YWwoKHYpLCBlbmNvZGVGbG9hdDE2TmFOKCkpKVxcbnV2ZWMyIHBhY2tmMTYoIGZsb2F0IGYpXFxue1xcbnVpbnQgeSA9IHBhY2tIYWxmMngxNih2ZWMyKGYsIDAuMGYpKTtcXG5yZXR1cm4gdXZlYzIoeSwgeSA+PiA4dSkgJiAweEZGdTtcXG59XFxuZmxvYXQgdW5wYWNrZjE2KHV2ZWMyIHYpXFxue1xcbnYgJj0gMHhGRnU7XFxucmV0dXJuIHVucGFja0hhbGYyeDE2KHYueCB8ICh2LnkgPDwgOHUpKS54O1xcbn1cXG5ib29sIGlzRW5jb2RlZEZsb2F0MTZaZXJvKHZlYzIgdilcXG57XFxudXZlYzIgdyA9IHV2ZWMyKHYgKiAyNTUuMGYpO1xcbnJldHVybiAwdSA9PSB3LnggKyB3LnkgKiAoMHg4MHUgLSB3LnkpO1xcbn1cXG4jZW5kaWZcIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWZuZGVmIF9HTE9CQUxfR0xTTFxcbiNkZWZpbmUgX0dMT0JBTF9HTFNMXFxuI2RlZmluZSB0aHJlYWRMb2NhdGlvbigpIGl2ZWMyKHRleENvb3JkICogdGV4U2l6ZSlcXG4jZGVmaW5lIG91dHB1dFNpemUoKSBpdmVjMih0ZXhTaXplKVxcbiNkZWZpbmUgdGhyZWFkUGl4ZWwoaW1nKSB0ZXh0dXJlTG9kKChpbWcpLCB0ZXhDb29yZCwgMC4wZilcXG4jZGVmaW5lIHBpeGVsQXQoaW1nLCBwb3MpIHRleGVsRmV0Y2goKGltZyksIChwb3MpLCAwKVxcbiNkZWZpbmUgcGl4ZWxBdFNob3J0T2Zmc2V0KGltZywgb2Zmc2V0KSB0ZXh0dXJlTG9kT2Zmc2V0KChpbWcpLCB0ZXhDb29yZCwgMC4wZiwgKG9mZnNldCkpXFxuI2RlZmluZSBwaXhlbEF0TG9uZ09mZnNldChpbWcsIG9mZnNldCkgdGV4dHVyZUxvZCgoaW1nKSwgdGV4Q29vcmQgKyB2ZWMyKG9mZnNldCkgLyB0ZXhTaXplLCAwLjBmKVxcbiNlbmRpZlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNpZm5kZWYgX0lOVDMyX0dMU0xcXG4jZGVmaW5lIF9JTlQzMl9HTFNMXFxudWludCBkZWNvZGVVaW50MzIodmVjNCByZ2JhKVxcbntcXG51dmVjNCB2ID0gdXZlYzQocmdiYSAqIDI1NS4wZikgJiAyNTV1O1xcbnJldHVybiB2LnggfCAodi55IDw8IDh1KSB8ICh2LnogPDwgMTZ1KSB8ICh2LncgPDwgMjR1KTtcXG59XFxudmVjNCBlbmNvZGVVaW50MzIodWludCB2YWx1ZSlcXG57XFxudXZlYzQgdiA9IHV2ZWM0KHZhbHVlLCB2YWx1ZSA+PiA4dSwgdmFsdWUgPj4gMTZ1LCB2YWx1ZSA+PiAyNHUpICYgMjU1dTtcXG5yZXR1cm4gdmVjNCh2KSAvIDI1NS4wZjtcXG59XFxuI2VuZGlmXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2lmbmRlZiBfS0VZUE9JTlRfREVTQ1JJUFRPUlNfR0xTTFxcbiNkZWZpbmUgX0tFWVBPSU5UX0RFU0NSSVBUT1JTX0dMU0xcXG4jaWYgIWRlZmluZWQoREVTQ1JJUFRPUl9TSVpFKVxcbiNlcnJvciBNdXN0IGRlZmluZSBERVNDUklQVE9SX1NJWkVcXG4jZWxpZiAhZGVmaW5lZChfS0VZUE9JTlRTX0dMU0wpXFxuI2Vycm9yIE11c3QgaW5jbHVkZSBrZXlwb2ludHMuZ2xzbFxcbiNlbmRpZlxcbnVpbnRbREVTQ1JJUFRPUl9TSVpFXSByZWFkS2V5cG9pbnREZXNjcmlwdG9yKHNhbXBsZXIyRCBlbmNvZGVkS2V5cG9pbnRzLCBpbnQgZGVzY3JpcHRvclNpemUsIGludCBleHRyYVNpemUsIGludCBlbmNvZGVyTGVuZ3RoLCBLZXlwb2ludEFkZHJlc3MgYWRkcmVzcylcXG57XFxuaW50IGRlc2NyaXB0b3JPZmZzZXQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoMCwgZXh0cmFTaXplKSAvIDQ7XFxuS2V5cG9pbnRBZGRyZXNzIGRlc2NyaXB0b3JBZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKGFkZHJlc3MuYmFzZSwgZGVzY3JpcHRvck9mZnNldCk7XFxudWludFtERVNDUklQVE9SX1NJWkVdIGRlc2NyaXB0b3I7XFxudmVjNCBwaXhlbDsgdXZlYzQgYnl0ZXM7XFxuQHVucm9sbFxcbmZvcihpbnQgaSA9IDA7IGkgPCBERVNDUklQVE9SX1NJWkU7IGkgKz0gNCkge1xcbnBpeGVsID0gcmVhZEtleXBvaW50RGF0YShlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBkZXNjcmlwdG9yQWRkcmVzcyk7XFxuYnl0ZXMgPSB1dmVjNChwaXhlbCAqIDI1NS4wZik7XFxuZGVzY3JpcHRvcltpXSAgID0gYnl0ZXMucjtcXG5kZXNjcmlwdG9yW2krMV0gPSBieXRlcy5nO1xcbmRlc2NyaXB0b3JbaSsyXSA9IGJ5dGVzLmI7XFxuZGVzY3JpcHRvcltpKzNdID0gYnl0ZXMuYTtcXG5kZXNjcmlwdG9yQWRkcmVzcy5vZmZzZXQrKztcXG59XFxucmV0dXJuIGRlc2NyaXB0b3I7XFxufVxcbnVpbnRbREVTQ1JJUFRPUl9TSVpFXSByZWFkS2V5cG9pbnREZXNjcmlwdG9yRnJvbURCKHNhbXBsZXIyRCBkZXNjcmlwdG9yREIsIGludCBkZXNjcmlwdG9yREJTdHJpZGUsIGludCBpbmRleClcXG57XFxudWludFtERVNDUklQVE9SX1NJWkVdIGRlc2NyaXB0b3I7XFxuaW50IHJhc3RlckluZGV4ID0gaW5kZXggKiAoREVTQ1JJUFRPUl9TSVpFIC8gNCkgKiBpbnQoaW5kZXggPj0gMCk7XFxudmVjNCBwaXhlbDsgdXZlYzQgYnl0ZXM7IGl2ZWMyIHBvcztcXG5AdW5yb2xsXFxuZm9yKGludCBpID0gMDsgaSA8IERFU0NSSVBUT1JfU0laRTsgaSArPSA0KSB7XFxucG9zID0gaXZlYzIocmFzdGVySW5kZXggJSBkZXNjcmlwdG9yREJTdHJpZGUsIHJhc3RlckluZGV4IC8gZGVzY3JpcHRvckRCU3RyaWRlKTtcXG5waXhlbCA9IChpbmRleCA+PSAwKSA/IHRleGVsRmV0Y2goZGVzY3JpcHRvckRCLCBwb3MsIDApIDogdmVjNCgwLjBmKTtcXG5ieXRlcyA9IHV2ZWM0KHBpeGVsICogMjU1LjBmKTtcXG5kZXNjcmlwdG9yW2ldICAgPSBieXRlcy5yO1xcbmRlc2NyaXB0b3JbaSsxXSA9IGJ5dGVzLmc7XFxuZGVzY3JpcHRvcltpKzJdID0gYnl0ZXMuYjtcXG5kZXNjcmlwdG9yW2krM10gPSBieXRlcy5hO1xcbnJhc3RlckluZGV4Kys7XFxufVxcbnJldHVybiBkZXNjcmlwdG9yO1xcbn1cXG5pbnQgZGlzdGFuY2VCZXR3ZWVuS2V5cG9pbnREZXNjcmlwdG9ycyh1aW50W0RFU0NSSVBUT1JfU0laRV0gYSwgdWludFtERVNDUklQVE9SX1NJWkVdIGIpXFxue1xcbmNvbnN0IGludFsyNTZdIFBPUENOVCA9IGludFsyNTZdKDAsMSwxLDIsMSwyLDIsMywxLDIsMiwzLDIsMywzLDQsMSwyLDIsMywyLDMsMyw0LDIsMywzLDQsMyw0LDQsNSwxLDIsMiwzLDIsMywzLDQsMiwzLDMsNCwzLDQsNCw1LDIsMywzLDQsMyw0LDQsNSwzLDQsNCw1LDQsNSw1LDYsMSwyLDIsMywyLDMsMyw0LDIsMywzLDQsMyw0LDQsNSwyLDMsMyw0LDMsNCw0LDUsMyw0LDQsNSw0LDUsNSw2LDIsMywzLDQsMyw0LDQsNSwzLDQsNCw1LDQsNSw1LDYsMyw0LDQsNSw0LDUsNSw2LDQsNSw1LDYsNSw2LDYsNywxLDIsMiwzLDIsMywzLDQsMiwzLDMsNCwzLDQsNCw1LDIsMywzLDQsMyw0LDQsNSwzLDQsNCw1LDQsNSw1LDYsMiwzLDMsNCwzLDQsNCw1LDMsNCw0LDUsNCw1LDUsNiwzLDQsNCw1LDQsNSw1LDYsNCw1LDUsNiw1LDYsNiw3LDIsMywzLDQsMyw0LDQsNSwzLDQsNCw1LDQsNSw1LDYsMyw0LDQsNSw0LDUsNSw2LDQsNSw1LDYsNSw2LDYsNywzLDQsNCw1LDQsNSw1LDYsNCw1LDUsNiw1LDYsNiw3LDQsNSw1LDYsNSw2LDYsNyw1LDYsNiw3LDYsNyw3LDgpO1xcbnV2ZWM0IHhvciwgdSwgdjtcXG5pbnQgZGlzdCA9IDA7XFxuaXZlYzQgYml0cztcXG5AdW5yb2xsXFxuZm9yKGludCBpID0gMDsgaSA8IERFU0NSSVBUT1JfU0laRTsgaSArPSA0KSB7XFxudSA9IHV2ZWM0KGFbaV0sIGFbaSsxXSwgYVtpKzJdLCBhW2krM10pO1xcbnYgPSB1dmVjNChiW2ldLCBiW2krMV0sIGJbaSsyXSwgYltpKzNdKTtcXG54b3IgPSAodSBeIHYpICYgMjU1dTtcXG5iaXRzID0gaXZlYzQoUE9QQ05UW3hvci54XSwgUE9QQ05UW3hvci55XSwgUE9QQ05UW3hvci56XSwgUE9QQ05UW3hvci53XSk7XFxuZGlzdCArPSBiaXRzLnggKyBiaXRzLnkgKyBiaXRzLnogKyBiaXRzLnc7XFxufVxcbnJldHVybiBkaXN0O1xcbn1cXG4jZW5kaWZcIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWZuZGVmIF9LRVlQT0lOVF9NQVRDSEVTX0dMU0xcXG4jZGVmaW5lIF9LRVlQT0lOVF9NQVRDSEVTX0dMU0xcXG5AaW5jbHVkZSBcXFwiaW50MzIuZ2xzbFxcXCJcXG5jb25zdCBpbnQgTUFUQ0hfSU5ERVhfQklUUyA9IGludChATUFUQ0hfSU5ERVhfQklUU0ApO1xcbmNvbnN0IGludCBNQVRDSF9JTkRFWF9NQVNLID0gaW50KEBNQVRDSF9JTkRFWF9NQVNLQCk7XFxuY29uc3QgaW50IE1BVENIX01BWF9JTkRFWCA9IGludChATUFUQ0hfTUFYX0lOREVYQCk7XFxuY29uc3QgaW50IE1BVENIX01BWF9ESVNUQU5DRSA9IGludChATUFUQ0hfTUFYX0RJU1RBTkNFQCk7XFxuc3RydWN0IEtleXBvaW50TWF0Y2hcXG57XFxuaW50IGluZGV4O1xcbmludCBkaXN0O1xcbn07XFxudmVjNCBlbmNvZGVLZXlwb2ludE1hdGNoKEtleXBvaW50TWF0Y2ggY2FuZGlkYXRlKVxcbntcXG51aW50IGluZGV4ID0gdWludChjYW5kaWRhdGUuaW5kZXggJiBNQVRDSF9JTkRFWF9NQVNLKTtcXG51aW50IGRpc3QgPSB1aW50KGNsYW1wKGNhbmRpZGF0ZS5kaXN0LCAwLCBNQVRDSF9NQVhfRElTVEFOQ0UpKTtcXG51aW50IHUzMiA9IGluZGV4IHwgKGRpc3QgPDwgTUFUQ0hfSU5ERVhfQklUUyk7XFxucmV0dXJuIGVuY29kZVVpbnQzMih1MzIpO1xcbn1cXG5LZXlwb2ludE1hdGNoIGRlY29kZUtleXBvaW50TWF0Y2godmVjNCByZ2JhKVxcbntcXG51aW50IHUzMiA9IGRlY29kZVVpbnQzMihyZ2JhKTtcXG5pbnQgZGlzdCA9IGludCh1MzIgPj4gTUFUQ0hfSU5ERVhfQklUUyk7XFxuaW50IGluZGV4ID0gaW50KHUzMiAmIHVpbnQoTUFUQ0hfSU5ERVhfTUFTSykpO1xcbnJldHVybiBLZXlwb2ludE1hdGNoKGluZGV4LCBkaXN0KTtcXG59XFxuY29uc3QgS2V5cG9pbnRNYXRjaCBNQVRDSF9OT1RfRk9VTkQgPSBLZXlwb2ludE1hdGNoKE1BVENIX01BWF9JTkRFWCwgTUFUQ0hfTUFYX0RJU1RBTkNFKTtcXG4jZW5kaWZcIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWZuZGVmIF9LRVlQT0lOVFNfR0xTTFxcbiNkZWZpbmUgX0tFWVBPSU5UU19HTFNMXFxuQGluY2x1ZGUgXFxcIm1hdGguZ2xzbFxcXCJcXG5AaW5jbHVkZSBcXFwiZml4ZWQtcG9pbnQuZ2xzbFxcXCJcXG5AaW5jbHVkZSBcXFwiZmxvYXQxNi5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJweXJhbWlkcy5nbHNsXFxcIlxcbnN0cnVjdCBLZXlwb2ludFxcbntcXG52ZWMyIHBvc2l0aW9uO1xcbmZsb2F0IGxvZDtcXG5mbG9hdCBvcmllbnRhdGlvbjtcXG5mbG9hdCBzY29yZTtcXG51aW50IGZsYWdzO1xcbn07XFxuc3RydWN0IEtleXBvaW50QWRkcmVzc1xcbntcXG5pbnQgYmFzZTtcXG5pbnQgb2Zmc2V0O1xcbn07XFxuY29uc3QgaW50IE1JTl9LRVlQT0lOVF9TSVpFID0gaW50KEBNSU5fS0VZUE9JTlRfU0laRUApO1xcbmNvbnN0IGludCBNQVhfREVTQ1JJUFRPUl9TSVpFID0gaW50KEBNQVhfREVTQ1JJUFRPUl9TSVpFQCk7XFxuY29uc3QgdWludCBLUEZfTk9ORSA9IDB1O1xcbmNvbnN0IHVpbnQgS1BGX05VTEwgPSAxdTtcXG5jb25zdCB1aW50IEtQRl9ESVNDQVJERUQgPSAydTtcXG4jZGVmaW5lIGVuY29kZUtleXBvaW50U2NvcmUoc2NvcmUpIGVuY29kZUZsb2F0MTYoc2NvcmUpXFxuI2RlZmluZSBkZWNvZGVLZXlwb2ludFNjb3JlKGVuY29kZWRTY29yZSkgZGVjb2RlRmxvYXQxNihlbmNvZGVkU2NvcmUpXFxuI2RlZmluZSBlbmNvZGVLZXlwb2ludE9yaWVudGF0aW9uKGFuZ2xlKSAoKGFuZ2xlKSAqIElOVl9QSV9PVkVSXzIgKyAwLjVmKVxcbiNkZWZpbmUgZGVjb2RlS2V5cG9pbnRPcmllbnRhdGlvbih2YWx1ZSkgKCh2YWx1ZSkgKiBUV09fUEkgLSBQSSlcXG4jZGVmaW5lIGVuY29kZU51bGxLZXlwb2ludCgpICh2ZWM0KDEuMGYpKVxcbiNkZWZpbmUgZW5jb2RlRGlzY2FyZGVkS2V5cG9pbnQoKSAodmVjNCgwLjBmKSlcXG4jZGVmaW5lIGlzTnVsbEtleXBvaW50KGtleXBvaW50KSAoKCgoa2V5cG9pbnQpLmZsYWdzKSAmIEtQRl9OVUxMKSAhPSAwdSlcXG4jZGVmaW5lIGlzRGlzY2FyZGVkS2V5cG9pbnQoa2V5cG9pbnQpICgoKChrZXlwb2ludCkuZmxhZ3MpICYgS1BGX0RJU0NBUkRFRCkgIT0gMHUpXFxuI2RlZmluZSBpc0JhZEtleXBvaW50KGtleXBvaW50KSAoKGtleXBvaW50KS5zY29yZSA8IDAuMGYpXFxuI2RlZmluZSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgKE1JTl9LRVlQT0lOVF9TSVpFICsgKGRlc2NyaXB0b3JTaXplKSArIChleHRyYVNpemUpKVxcbiNkZWZpbmUgc2l6ZW9mRW5jb2RlZEtleXBvaW50SGVhZGVyKCkgc2l6ZW9mRW5jb2RlZEtleXBvaW50KDAsMClcXG4jZGVmaW5lIGZpbmRLZXlwb2ludEluZGV4KGFkZHJlc3MsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpICgoYWRkcmVzcykuYmFzZSAvICgoc2l6ZW9mRW5jb2RlZEtleXBvaW50KChkZXNjcmlwdG9yU2l6ZSksIChleHRyYVNpemUpKSkgLyA0KSlcXG52ZWM0IHJlYWRLZXlwb2ludERhdGEoc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHMsIGludCBlbmNvZGVyTGVuZ3RoLCBLZXlwb2ludEFkZHJlc3MgYWRkcmVzcylcXG57XFxuaW50IHJhc3RlckluZGV4ID0gYWRkcmVzcy5iYXNlICsgYWRkcmVzcy5vZmZzZXQ7XFxudmVjNCBkYXRhID0gcGl4ZWxBdChlbmNvZGVkS2V5cG9pbnRzLCBpdmVjMihyYXN0ZXJJbmRleCAlIGVuY29kZXJMZW5ndGgsIHJhc3RlckluZGV4IC8gZW5jb2Rlckxlbmd0aCkpO1xcbnJldHVybiByYXN0ZXJJbmRleCA8IGVuY29kZXJMZW5ndGggKiBlbmNvZGVyTGVuZ3RoID8gZGF0YSA6IGVuY29kZU51bGxLZXlwb2ludCgpO1xcbn1cXG5LZXlwb2ludEFkZHJlc3MgZmluZEtleXBvaW50QWRkcmVzcyhpdmVjMiB0aHJlYWQsIGludCBlbmNvZGVyTGVuZ3RoLCBpbnQgZGVzY3JpcHRvclNpemUsIGludCBleHRyYVNpemUpXFxue1xcbmludCB0aHJlYWRSYXN0ZXIgPSB0aHJlYWQueSAqIGVuY29kZXJMZW5ndGggKyB0aHJlYWQueDtcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgLyA0O1xcbmludCBrZXlwb2ludEluZGV4ID0gaW50KHRocmVhZFJhc3RlciAvIHBpeGVsc1BlcktleXBvaW50KTtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IEtleXBvaW50QWRkcmVzcyhcXG5rZXlwb2ludEluZGV4ICogcGl4ZWxzUGVyS2V5cG9pbnQsXFxudGhyZWFkUmFzdGVyICUgcGl4ZWxzUGVyS2V5cG9pbnRcXG4pO1xcbnJldHVybiBhZGRyZXNzO1xcbn1cXG5LZXlwb2ludCBkZWNvZGVLZXlwb2ludChzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cywgaW50IGVuY29kZXJMZW5ndGgsIEtleXBvaW50QWRkcmVzcyBhZGRyZXNzKVxcbntcXG5LZXlwb2ludCBrZXlwb2ludDtcXG5LZXlwb2ludEFkZHJlc3MgcG9zaXRpb25BZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKGFkZHJlc3MuYmFzZSwgMCk7XFxuS2V5cG9pbnRBZGRyZXNzIHByb3BlcnRpZXNBZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKGFkZHJlc3MuYmFzZSwgMSk7XFxudmVjNCByYXdFbmNvZGVkUG9zaXRpb24gPSByZWFkS2V5cG9pbnREYXRhKGVuY29kZWRLZXlwb2ludHMsIGVuY29kZXJMZW5ndGgsIHBvc2l0aW9uQWRkcmVzcyk7XFxuaXZlYzQgZW5jb2RlZFBvc2l0aW9uID0gaXZlYzQocmF3RW5jb2RlZFBvc2l0aW9uICogMjU1LjBmKTtcXG5rZXlwb2ludC5wb3NpdGlvbiA9IGZpeHRvdmVjMihmaXhlZDJfdChcXG5lbmNvZGVkUG9zaXRpb24uciB8IChlbmNvZGVkUG9zaXRpb24uZyA8PCA4KSxcXG5lbmNvZGVkUG9zaXRpb24uYiB8IChlbmNvZGVkUG9zaXRpb24uYSA8PCA4KVxcbikpO1xcbnZlYzQgcmF3RW5jb2RlZFByb3BlcnRpZXMgPSByZWFkS2V5cG9pbnREYXRhKGVuY29kZWRLZXlwb2ludHMsIGVuY29kZXJMZW5ndGgsIHByb3BlcnRpZXNBZGRyZXNzKTtcXG5rZXlwb2ludC5sb2QgPSBkZWNvZGVMb2QocmF3RW5jb2RlZFByb3BlcnRpZXMucik7XFxua2V5cG9pbnQub3JpZW50YXRpb24gPSBkZWNvZGVLZXlwb2ludE9yaWVudGF0aW9uKHJhd0VuY29kZWRQcm9wZXJ0aWVzLmcpO1xcbmtleXBvaW50LnNjb3JlID0gZGVjb2RlS2V5cG9pbnRTY29yZShyYXdFbmNvZGVkUHJvcGVydGllcy5iYSk7XFxuYm9vbCBpc051bGwgPSBhbGwoZXF1YWwocmF3RW5jb2RlZFBvc2l0aW9uLCB2ZWM0KDEpKSk7XFxuYm9vbCBpc0Rpc2NhcmRlZCA9IGFsbChlcXVhbChyYXdFbmNvZGVkUG9zaXRpb24gKyByYXdFbmNvZGVkUHJvcGVydGllcywgdmVjNCgwKSkpO1xcbmtleXBvaW50LnNjb3JlID0gKGlzTnVsbCB8fCBpc0Rpc2NhcmRlZCkgPyAtMS4wZiA6IGtleXBvaW50LnNjb3JlO1xcbmtleXBvaW50LmZsYWdzID0gS1BGX05PTkU7XFxua2V5cG9pbnQuZmxhZ3MgfD0gS1BGX05VTEwgKiB1aW50KGlzTnVsbCk7XFxua2V5cG9pbnQuZmxhZ3MgfD0gS1BGX0RJU0NBUkRFRCAqIHVpbnQoaXNEaXNjYXJkZWQpO1xcbnJldHVybiBrZXlwb2ludDtcXG59XFxudmVjNCBlbmNvZGVLZXlwb2ludFBvc2l0aW9uKHZlYzIgcG9zaXRpb24pXFxue1xcbmNvbnN0IHZlYzIgemVyb3MgPSB2ZWMyKDAuMGYpO1xcbmZpeGVkMl90IHBvcyA9IHZlYzJ0b2ZpeChtYXgocG9zaXRpb24sIHplcm9zKSk7XFxuZml4ZWQyX3QgbG8gPSBwb3MgJiAyNTU7XFxuZml4ZWQyX3QgaGkgPSAocG9zID4+IDgpICYgMjU1O1xcbnJldHVybiB2ZWM0KGxvLngsIGhpLngsIGxvLnksIGhpLnkpIC8gMjU1LjBmO1xcbn1cXG4jZW5kaWZcIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWZuZGVmIF9NQVRIX0dMU0xcXG4jZGVmaW5lIF9NQVRIX0dMU0xcXG4jZGVmaW5lIFRXT19QSSAgICAgICAgICA2LjI4MzE4NTMwNzE4ZlxcbiNkZWZpbmUgUEkgICAgICAgICAgICAgIDMuMTQxNTkyNjUzNTlmXFxuI2RlZmluZSBQSV9PVkVSXzIgICAgICAgMS41NzA3OTYzMjY3OWZcXG4jZGVmaW5lIFBJX09WRVJfNCAgICAgICAwLjc4NTM5ODE2MzM5ZlxcbiNkZWZpbmUgSU5WX1BJICAgICAgICAgIDAuMzE4MzA5ODg2MTgzNzkwN2ZcXG4jZGVmaW5lIElOVl9QSV9PVkVSXzIgICAwLjE1OTE1NDk0MzA5MTg5NTM1ZlxcbmNvbnN0IGhpZ2hwIGZsb2F0IElORklOSVRZID0gMS4wZiAvIDAuMGY7XFxuZmxvYXQgZmFzdEF0YW4oZmxvYXQgeClcXG57XFxuZmxvYXQgdyA9IDEuMGYgLSBhYnMoeCk7XFxucmV0dXJuICh3ID49IDAuMGYpID8gKChQSV9PVkVSXzQgKyAwLjI3M2YgKiB3KSAqIHgpIDpcXG4oc2lnbih4KSAqIFBJX09WRVJfMiAtIChQSV9PVkVSXzQgKyAwLjI3M2YgKiAoMS4wZiAtIGFicygxLjBmIC8geCkpKSAvIHgpO1xcbn1cXG5mbG9hdCBmYXN0QXRhbjIoZmxvYXQgeSwgZmxvYXQgeClcXG57XFxucmV0dXJuICh4ID09IDAuMGYpID8gUElfT1ZFUl8yICogc2lnbih5KSA6IGZhc3RBdGFuKHkgLyB4KSArIGZsb2F0KHggPCAwLjBmKSAqIFBJICogc2lnbih5KTtcXG59XFxuI2VuZGlmXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2lmbmRlZiBfUFlSQU1JRFNfR0xTTFxcbiNkZWZpbmUgX1BZUkFNSURTX0dMU0xcXG4jZGVmaW5lIHB5clBpeGVsKHB5ciwgbG9kKSB0ZXh0dXJlTG9kKChweXIpLCB0ZXhDb29yZCwgKGxvZCkpXFxuI2RlZmluZSBweXJQaXhlbEF0T2Zmc2V0KHB5ciwgbG9kLCBwb3QsIG9mZnNldCkgdGV4dHVyZUxvZCgocHlyKSwgdGV4Q29vcmQgKyAoKHBvdCkgKiB2ZWMyKG9mZnNldCkpIC8gdGV4U2l6ZSwgKGxvZCkpXFxuI2RlZmluZSBweXJQaXhlbEF0KHB5ciwgcG9zLCBsb2QpIHRleHR1cmVMb2QoKHB5ciksICh2ZWMyKHBvcykgKyB2ZWMyKDAuNWYpKSAvIHRleFNpemUsIChsb2QpKVxcbiNkZWZpbmUgcHlyUGl4ZWxBdEV4KHB5ciwgcG9zLCBsb2QsIHB5ckJhc2VTaXplKSB0ZXh0dXJlTG9kKChweXIpLCAodmVjMihwb3MpICsgdmVjMigwLjVmKSkgLyB2ZWMyKHB5ckJhc2VTaXplKSwgKGxvZCkpXFxuI2RlZmluZSBweXJTdWJwaXhlbEF0RXgocHlyLCBwb3MsIGxvZCwgcHlyQmFzZVNpemUpIHRleHR1cmVMb2QoKHB5ciksICgocG9zKSArIHZlYzIoMC41ZikpIC8gdmVjMihweXJCYXNlU2l6ZSksIChsb2QpKVxcbiNkZWZpbmUgcHlyU3VicGl4ZWxBdEV4T2Zmc2V0KHB5ciwgcG9zLCBsb2QsIHBvdCwgb2Zmc2V0LCBweXJCYXNlU2l6ZSkgdGV4dHVyZUxvZCgocHlyKSwgKCgocG9zKSArIHZlYzIoMC41ZikpICsgKChwb3QpICogdmVjMihvZmZzZXQpKSkgLyB2ZWMyKHB5ckJhc2VTaXplKSwgKGxvZCkpXFxuY29uc3QgaW50IFBZUkFNSURfTUFYX0xFVkVMUyA9IGludChAUFlSQU1JRF9NQVhfTEVWRUxTQCk7XFxuY29uc3QgZmxvYXQgRl9QWVJBTUlEX01BWF9MRVZFTFMgPSBmbG9hdChAUFlSQU1JRF9NQVhfTEVWRUxTQCk7XFxuY29uc3QgZmxvYXQgTE9HMl9QWVJBTUlEX01BWF9TQ0FMRSA9IGZsb2F0KEBMT0cyX1BZUkFNSURfTUFYX1NDQUxFQCk7XFxuI2RlZmluZSBlbmNvZGVMb2QobG9kKSAoKExPRzJfUFlSQU1JRF9NQVhfU0NBTEUgKyAobG9kKSkgLyAoTE9HMl9QWVJBTUlEX01BWF9TQ0FMRSArIEZfUFlSQU1JRF9NQVhfTEVWRUxTKSlcXG5mbG9hdCBkZWNvZGVMb2QoZmxvYXQgZW5jb2RlZExvZClcXG57XFxuZmxvYXQgbG9kID0gZW5jb2RlZExvZCAqIChMT0cyX1BZUkFNSURfTUFYX1NDQUxFICsgRl9QWVJBTUlEX01BWF9MRVZFTFMpIC0gTE9HMl9QWVJBTUlEX01BWF9TQ0FMRTtcXG5yZXR1cm4gbG9kIC0gbG9kICogc3RlcCgxLjBmLCBlbmNvZGVkTG9kKTtcXG59XFxuI2RlZmluZSBMT0RfRVBTIDAuMDYyNWZcXG5jb25zdCBmbG9hdCBFTkNPREVEX0xPRF9FUFMgPSAoTE9EX0VQUyAvIChMT0cyX1BZUkFNSURfTUFYX1NDQUxFICsgRl9QWVJBTUlEX01BWF9MRVZFTFMpKTtcXG4jZGVmaW5lIGlzU2FtZUxvZChsb2QxLCBsb2QyKSAoYWJzKChsb2QxKSAtIChsb2QyKSkgPCBMT0RfRVBTKVxcbiNkZWZpbmUgaXNTYW1lRW5jb2RlZExvZChhbHBoYTEsIGFscGhhMikgKGFicygoYWxwaGExKSAtIChhbHBoYTIpKSA8IEVOQ09ERURfTE9EX0VQUylcXG4jZW5kaWZcIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWZuZGVmIF9RVUlDS1NFTEVDVF9HTFNMXFxuI2RlZmluZSBfUVVJQ0tTRUxFQ1RfR0xTTFxcbiNpZiBkZWZpbmVkKFFVSUNLU0VMRUNUX1VOU0lHTkVEKSAmJiAhZGVmaW5lZChRVUlDS1NFTEVDVF9TSUdORUQpXFxuI2RlZmluZSBRU19UWVBFIHVpbnRcXG4jZGVmaW5lIFFTX1RZUEU0IHV2ZWM0XFxuI2VsaWYgIWRlZmluZWQoUVVJQ0tTRUxFQ1RfVU5TSUdORUQpICYmIGRlZmluZWQoUVVJQ0tTRUxFQ1RfU0lHTkVEKVxcbiNkZWZpbmUgUVNfVFlQRSBpbnRcXG4jZGVmaW5lIFFTX1RZUEU0IGl2ZWM0XFxuI2Vsc2VcXG4jZXJyb3IgTXVzdCBkZWZpbmUgZWl0aGVyIFFVSUNLU0VMRUNUX1NJR05FRCBvciBRVUlDS1NFTEVDVF9VTlNJR05FRCBiZWZvcmUgaW5jbHVkaW5nIHF1aWNrc2VsZWN0XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoUVVJQ0tTRUxFQ1RfQVNDRU5ESU5HKSAmJiAhZGVmaW5lZChRVUlDS1NFTEVDVF9ERVNDRU5ESU5HKVxcbiNkZWZpbmUgUVNfT1JEKGVsZW1lbnQscGl2b3QpICgoZWxlbWVudCkgPCAocGl2b3QpKVxcbiNlbGlmIGRlZmluZWQoUVVJQ0tTRUxFQ1RfREVTQ0VORElORykgJiYgIWRlZmluZWQoUVVJQ0tTRUxFQ1RfQVNDRU5ESU5HKVxcbiNkZWZpbmUgUVNfT1JEKGVsZW1lbnQscGl2b3QpICgoZWxlbWVudCkgPiAocGl2b3QpKVxcbiNlbHNlXFxuI2Vycm9yIE11c3QgZGVmaW5lIGVpdGhlciBRVUlDS1NFTEVDVF9BU0NFTkRJTkcgb3IgUVVJQ0tTRUxFQ1RfREVTQ0VORElORyBiZWZvcmUgaW5jbHVkaW5nIHF1aWNrc2VsZWN0XFxuI2VuZGlmXFxuI2lmZGVmIFFVSUNLU0VMRUNUX0FSUkFZXFxuI2RlZmluZSBRU19BUlJBWSBRVUlDS1NFTEVDVF9BUlJBWVxcbiNlbHNlXFxuI2Vycm9yIE11c3QgZGVmaW5lIFFVSUNLU0VMRUNUX0FSUkFZIGJlZm9yZSBpbmNsdWRpbmcgcXVpY2tzZWxlY3RcXG4jZW5kaWZcXG5pbnQgcXNwYXJ0KGludCBsLCBpbnQgciwgaW50IHApXFxue1xcbiNkZWZpbmUgUVNfU1dBUChhLGIpIHQgPSBRU19BUlJBWVsoYSldOyBRU19BUlJBWVsoYSldID0gUVNfQVJSQVlbKGIpXTsgUVNfQVJSQVlbKGIpXSA9IHRcXG5oaWdocCBRU19UWVBFIGUsIHQsIG1hc2ssIHBpdm90ID0gUVNfQVJSQVlbcF07XFxuaGlnaHAgUVNfVFlQRTQgdG1wO1xcbmludCBxLCBjb25kO1xcblFTX1NXQVAocCwgcik7XFxucSA9IGw7XFxuZm9yKGludCBpID0gbDsgaSA8IHI7IGkrKykge1xcbmUgPSBRU19BUlJBWVtpXTtcXG50ID0gUVNfQVJSQVlbcV07XFxuY29uZCA9IGludChRU19PUkQoZSwgcGl2b3QpKTtcXG5tYXNrID0gUVNfVFlQRSgtY29uZCk7XFxudG1wID0gUVNfVFlQRTQobWFzayAmIHQsICh+bWFzaykgJiBlLCBtYXNrICYgZSwgKH5tYXNrKSAmIHQpO1xcblFTX0FSUkFZW2ldID0gdG1wLnggfCB0bXAueTtcXG5RU19BUlJBWVtxXSA9IHRtcC56IHwgdG1wLnc7XFxucSArPSBjb25kO1xcbn1cXG5RU19TV0FQKHEsIHIpO1xcbnJldHVybiBxO1xcbn1cXG5oaWdocCBRU19UWVBFIHF1aWNrc2VsZWN0KGludCBsLCBpbnQgciwgaW50IGspXFxue1xcbmludCBwID0gLTEzMzc7XFxuaXZlYzIgaWR4ID0gaXZlYzIobCwgcik7XFxud2hpbGUoaWR4LnMgPCBpZHgudCAmJiBwICE9IGspIHtcXG5wID0gcXNwYXJ0KGlkeC5zLCBpZHgudCwgKGlkeC5zICsgaWR4LnQpIC8gMik7XFxuaWR4ID0gaW50KGsgPCBwKSAqIGl2ZWMyKGlkeC5zLCBwLTEpICsgaW50KGsgPj0gcCkgKiBpdmVjMihwKzEsIGlkeC50KTtcXG59XFxucmV0dXJuIChwID09IGspID8gUVNfQVJSQVlba10gOiBRU19BUlJBWVtpZHguc107XFxufVxcbiNlbmRpZlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNpZm5kZWYgX1NVQlBJWEVMX0dMU0xcXG4jZGVmaW5lIF9TVUJQSVhFTF9HTFNMXFxuI2RlZmluZSBzdWJwaXhlbEF0KGltYWdlLCBwb3MpIHRleHR1cmVMb2QoKGltYWdlKSwgKChwb3MpICsgdmVjMigwLjVmKSkgLyB0ZXhTaXplLCAwLjBmKVxcbnZlYzQgc3VicGl4ZWxBdEJJKHNhbXBsZXIyRCBpbWFnZSwgdmVjMiBwb3MpXFxue1xcbnZlYzIgZnJjID0gZnJhY3QocG9zKTtcXG52ZWMyIGlmcmMgPSB2ZWMyKDEuMGYpIC0gZnJjO1xcbnZlYzIgcCA9IChmbG9vcihwb3MpICsgdmVjMigwLjVmKSkgLyB2ZWMyKHRleHR1cmVTaXplKGltYWdlLCAwKSk7XFxudmVjNCBwaXgwMCA9IHRleHR1cmVMb2QoaW1hZ2UsIHAsIDAuMGYpO1xcbnZlYzQgcGl4MTAgPSB0ZXh0dXJlTG9kT2Zmc2V0KGltYWdlLCBwLCAwLjBmLCBpdmVjMigxLDApKTtcXG52ZWM0IHBpeDAxID0gdGV4dHVyZUxvZE9mZnNldChpbWFnZSwgcCwgMC4wZiwgaXZlYzIoMCwxKSk7XFxudmVjNCBwaXgxMSA9IHRleHR1cmVMb2RPZmZzZXQoaW1hZ2UsIHAsIDAuMGYsIGl2ZWMyKDEsMSkpO1xcbm1hdDQgcGl4ID0gbWF0NChwaXgwMCwgcGl4MTAsIHBpeDAxLCBwaXgxMSk7XFxudmVjNCBtdWwgPSB2ZWM0KGlmcmMueCAqIGlmcmMueSwgZnJjLnggKiBpZnJjLnksIGlmcmMueCAqIGZyYy55LCBmcmMueCAqIGZyYy55KTtcXG5yZXR1cm4gcGl4ICogbXVsO1xcbn1cXG4jZW5kaWZcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgaW5wdXRFbmNvZGVkS2V5cG9pbnRzO1xcbnVuaWZvcm0gaW50IGlucHV0RGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgaW5wdXRFeHRyYVNpemU7XFxudW5pZm9ybSBpbnQgaW5wdXRFbmNvZGVyTGVuZ3RoO1xcbnVuaWZvcm0gaW50IG91dHB1dERlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IG91dHB1dEV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBvdXRwdXRFbmNvZGVyTGVuZ3RoO1xcbmNvbnN0IHZlYzQgRU1QVFlfREVTQ1JJUFRPUiA9IHZlYzQoMC4wZik7XFxudm9pZCBtYWluKClcXG57XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5LZXlwb2ludEFkZHJlc3MgbXlBZGRyZXNzID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIG91dHB1dEVuY29kZXJMZW5ndGgsIG91dHB1dERlc2NyaXB0b3JTaXplLCBvdXRwdXRFeHRyYVNpemUpO1xcbmludCBteUluZGV4ID0gZmluZEtleXBvaW50SW5kZXgobXlBZGRyZXNzLCBvdXRwdXREZXNjcmlwdG9yU2l6ZSwgb3V0cHV0RXh0cmFTaXplKTtcXG5pbnQgaGVhZGVyU2l6ZSA9IHNpemVvZkVuY29kZWRLZXlwb2ludEhlYWRlcigpO1xcbmJvb2wgaXNEZXNjcmlwdG9yID0gKG15QWRkcmVzcy5vZmZzZXQgPj0gKGhlYWRlclNpemUgKyBvdXRwdXRFeHRyYVNpemUpIC8gNCk7XFxuaW50IGFkZHJlc3NPZmZzZXQgPSBteUFkZHJlc3Mub2Zmc2V0O1xcbmludCBwaXhlbHNQZXJLZXlwb2ludCA9IHNpemVvZkVuY29kZWRLZXlwb2ludChpbnB1dERlc2NyaXB0b3JTaXplLCBpbnB1dEV4dHJhU2l6ZSkgLyA0O1xcbktleXBvaW50QWRkcmVzcyBvdGhlckFkZHJlc3MgPSBLZXlwb2ludEFkZHJlc3MobXlJbmRleCAqIHBpeGVsc1BlcktleXBvaW50LCBhZGRyZXNzT2Zmc2V0KTtcXG5jb2xvciA9IGlzRGVzY3JpcHRvciA/IEVNUFRZX0RFU0NSSVBUT1IgOiByZWFkS2V5cG9pbnREYXRhKGlucHV0RW5jb2RlZEtleXBvaW50cywgaW5wdXRFbmNvZGVyTGVuZ3RoLCBvdGhlckFkZHJlc3MpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgaW5wdXRFbmNvZGVkS2V5cG9pbnRzO1xcbnVuaWZvcm0gaW50IGlucHV0RGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgaW5wdXRFeHRyYVNpemU7XFxudW5pZm9ybSBpbnQgaW5wdXRFbmNvZGVyTGVuZ3RoO1xcbnVuaWZvcm0gaW50IG91dHB1dERlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IG91dHB1dEV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBvdXRwdXRFbmNvZGVyTGVuZ3RoO1xcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuS2V5cG9pbnRBZGRyZXNzIG15QWRkcmVzcyA9IGZpbmRLZXlwb2ludEFkZHJlc3ModGhyZWFkLCBvdXRwdXRFbmNvZGVyTGVuZ3RoLCBvdXRwdXREZXNjcmlwdG9yU2l6ZSwgb3V0cHV0RXh0cmFTaXplKTtcXG5pbnQgbXlJbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KG15QWRkcmVzcywgb3V0cHV0RGVzY3JpcHRvclNpemUsIG91dHB1dEV4dHJhU2l6ZSk7XFxuaW50IGhlYWRlclNpemUgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnRIZWFkZXIoKTtcXG5ib29sIGlzSGVhZCA9IChteUFkZHJlc3Mub2Zmc2V0IDwgaGVhZGVyU2l6ZSAvIDQpO1xcbmJvb2wgaXNEZXNjcmlwdG9yID0gKG15QWRkcmVzcy5vZmZzZXQgPj0gKGhlYWRlclNpemUgKyBvdXRwdXRFeHRyYVNpemUpIC8gNCk7XFxuYm9vbCBpc0V4dHJhID0gKCFpc0hlYWQgJiYgIWlzRGVzY3JpcHRvcik7XFxuaW50IG51bWJlck9mRXh0cmFQaXhlbHMgPSBvdXRwdXRFeHRyYVNpemUgLyA0O1xcbmludCBhZGRyZXNzT2Zmc2V0ID0gbXlBZGRyZXNzLm9mZnNldCAtIGludChpc0Rlc2NyaXB0b3IpICogbnVtYmVyT2ZFeHRyYVBpeGVscztcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoaW5wdXREZXNjcmlwdG9yU2l6ZSwgaW5wdXRFeHRyYVNpemUpIC8gNDtcXG5LZXlwb2ludEFkZHJlc3Mgb3RoZXJBZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKG15SW5kZXggKiBwaXhlbHNQZXJLZXlwb2ludCwgYWRkcmVzc09mZnNldCk7XFxuY29sb3IgPSBpc0V4dHJhID8gdmVjNCgwLjBmKSA6IHJlYWRLZXlwb2ludERhdGEoaW5wdXRFbmNvZGVkS2V5cG9pbnRzLCBpbnB1dEVuY29kZXJMZW5ndGgsIG90aGVyQWRkcmVzcyk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJrZXlwb2ludHMuZ2xzbFxcXCJcXG51bmlmb3JtIG1hdDMgaG9tb2dyYXBoeTtcXG51bmlmb3JtIHNhbXBsZXIyRCBlbmNvZGVkS2V5cG9pbnRzO1xcbnVuaWZvcm0gaW50IGRlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoO1xcbnZvaWQgbWFpbigpXFxue1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChlbmNvZGVkS2V5cG9pbnRzKTtcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIGVuY29kZXJMZW5ndGgsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmNvbG9yID0gcGl4ZWw7XFxuaWYoYWRkcmVzcy5vZmZzZXQgIT0gMClcXG5yZXR1cm47XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBhZGRyZXNzKTtcXG5pZihpc0JhZEtleXBvaW50KGtleXBvaW50KSlcXG5yZXR1cm47XFxudmVjMyBwb3MzID0gaG9tb2dyYXBoeSAqIHZlYzMoa2V5cG9pbnQucG9zaXRpb24sIDEuMGYpO1xcbmNvbG9yID0gZW5jb2RlS2V5cG9pbnRQb3NpdGlvbihwb3MzLnh5IC8gcG9zMy56KTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJrZXlwb2ludC1kZXNjcmlwdG9ycy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJrZXlwb2ludC1tYXRjaGVzLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZE1hdGNoZXM7XFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEZpbHRlcnM7XFxudW5pZm9ybSBpbnQgbWF0Y2hlckxlbmd0aDtcXG51bmlmb3JtIHNhbXBsZXIyRCBkYkVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGJEZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBkYkV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBkYkVuY29kZXJMZW5ndGg7XFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG51bmlmb3JtIGludCBwYXNzSWQ7XFxuI2lmbmRlZiBOVU1CRVJfT0ZfS0VZUE9JTlRTX1BFUl9QQVNTXFxuI2Vycm9yIFVuZGVmaW5lZCBOVU1CRVJfT0ZfS0VZUE9JTlRTX1BFUl9QQVNTXFxuI2VuZGlmXFxuY29uc3QgaW50IElORklOSVRFX0RJU1RBTkNFID0gTUFUQ0hfTUFYX0RJU1RBTkNFICsgMTtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbmludCBrZXlwb2ludEluZGV4ID0gdGhyZWFkLnggKyB0aHJlYWQueSAqIG1hdGNoZXJMZW5ndGg7XFxuaW50IHBpeGVsc1BlcktleXBvaW50ID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50KGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpIC8gNDtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IEtleXBvaW50QWRkcmVzcyhrZXlwb2ludEluZGV4ICogcGl4ZWxzUGVyS2V5cG9pbnQsIDApO1xcbktleXBvaW50IGtleXBvaW50ID0gZGVjb2RlS2V5cG9pbnQoZW5jb2RlZEtleXBvaW50cywgZW5jb2Rlckxlbmd0aCwgYWRkcmVzcyk7XFxuY29sb3IgPSBlbmNvZGVLZXlwb2ludE1hdGNoKE1BVENIX05PVF9GT1VORCk7XFxuaWYoaXNCYWRLZXlwb2ludChrZXlwb2ludCkpXFxucmV0dXJuO1xcbktleXBvaW50TWF0Y2ggYmVzdE1hdGNoID0gZGVjb2RlS2V5cG9pbnRNYXRjaCh0aHJlYWRQaXhlbChlbmNvZGVkTWF0Y2hlcykpO1xcbktleXBvaW50TWF0Y2ggZmlsdGVyTWF0Y2ggPSBkZWNvZGVLZXlwb2ludE1hdGNoKHRocmVhZFBpeGVsKGVuY29kZWRGaWx0ZXJzKSk7XFxudWludFtERVNDUklQVE9SX1NJWkVdIGRlc2NyaXB0b3IgPSByZWFkS2V5cG9pbnREZXNjcmlwdG9yKGVuY29kZWRLZXlwb2ludHMsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUsIGVuY29kZXJMZW5ndGgsIGFkZHJlc3MpO1xcbnVpbnRbREVTQ1JJUFRPUl9TSVpFXSBkYkRlc2NyaXB0b3I7XFxuaW50IGRiUGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGJEZXNjcmlwdG9yU2l6ZSwgZGJFeHRyYVNpemUpIC8gNDtcXG5mb3IoaW50IGkgPSAwOyBpIDwgTlVNQkVSX09GX0tFWVBPSU5UU19QRVJfUEFTUzsgaSsrKSB7XFxuaW50IGRiS2V5cG9pbnRJbmRleCA9IHBhc3NJZCAqIE5VTUJFUl9PRl9LRVlQT0lOVFNfUEVSX1BBU1MgKyBpO1xcbktleXBvaW50QWRkcmVzcyBkYkFkZHJlc3MgPSBLZXlwb2ludEFkZHJlc3MoZGJLZXlwb2ludEluZGV4ICogZGJQaXhlbHNQZXJLZXlwb2ludCwgMCk7XFxuS2V5cG9pbnQgZGJLZXlwb2ludCA9IGRlY29kZUtleXBvaW50KGRiRW5jb2RlZEtleXBvaW50cywgZGJFbmNvZGVyTGVuZ3RoLCBkYkFkZHJlc3MpO1xcbmRiRGVzY3JpcHRvciA9IHJlYWRLZXlwb2ludERlc2NyaXB0b3IoZGJFbmNvZGVkS2V5cG9pbnRzLCBkYkRlc2NyaXB0b3JTaXplLCBkYkV4dHJhU2l6ZSwgZGJFbmNvZGVyTGVuZ3RoLCBkYkFkZHJlc3MpO1xcbmludCBkaXN0ID0gIWlzQmFkS2V5cG9pbnQoZGJLZXlwb2ludCkgPyBkaXN0YW5jZUJldHdlZW5LZXlwb2ludERlc2NyaXB0b3JzKGRlc2NyaXB0b3IsIGRiRGVzY3JpcHRvcikgOiBJTkZJTklURV9ESVNUQU5DRTtcXG5iZXN0TWF0Y2guaW5kZXggPSBhbGwoYnZlYzIoXFxuZGlzdCA8IGJlc3RNYXRjaC5kaXN0IHx8IChkaXN0ID09IGJlc3RNYXRjaC5kaXN0ICYmIGRiS2V5cG9pbnRJbmRleCA+IGJlc3RNYXRjaC5pbmRleCksXFxuZGlzdCA+IGZpbHRlck1hdGNoLmRpc3QgfHwgKGRpc3QgPT0gZmlsdGVyTWF0Y2guZGlzdCAmJiBkYktleXBvaW50SW5kZXggPCBmaWx0ZXJNYXRjaC5pbmRleClcXG4pKSA/IGRiS2V5cG9pbnRJbmRleCA6IGJlc3RNYXRjaC5pbmRleDtcXG5iZXN0TWF0Y2guZGlzdCA9IGRiS2V5cG9pbnRJbmRleCA9PSBiZXN0TWF0Y2guaW5kZXggPyBkaXN0IDogYmVzdE1hdGNoLmRpc3Q7XFxufVxcbmNvbG9yID0gZW5jb2RlS2V5cG9pbnRNYXRjaChiZXN0TWF0Y2gpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZSwgbGF5ZXJBLCBsYXllckI7XFxudW5pZm9ybSBmbG9hdCBzY2FsZUEsIHNjYWxlQiwgbGdNLCBoO1xcbnZvaWQgbWFpbigpXFxue1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChpbWFnZSk7XFxuZmxvYXQgc2NvcmUgPSBwaXhlbC5yO1xcbml2ZWMyIHplcm8gPSBpdmVjMigwLCAwKTtcXG5pdmVjMiBzaXplQSA9IHRleHR1cmVTaXplKGxheWVyQSwgMCk7XFxuaXZlYzIgc2l6ZUIgPSB0ZXh0dXJlU2l6ZShsYXllckIsIDApO1xcbnZlYzIgbWlkID0gKHRleENvb3JkICogdGV4U2l6ZSkgKyB2ZWMyKDAuNWYsIDAuNWYpO1xcbml2ZWMyIHBhID0gY2xhbXAoaXZlYzIoY2VpbChtaWQgKiBzY2FsZUEgLSAxLjBmKSksIHplcm8sIHNpemVBIC0gMik7XFxuaXZlYzIgcGIgPSBjbGFtcChpdmVjMihjZWlsKG1pZCAqIHNjYWxlQiAtIDEuMGYpKSwgemVybywgc2l6ZUIgLSAyKTtcXG52ZWM0IGEwMCA9IHBpeGVsQXQobGF5ZXJBLCBwYSk7XFxudmVjNCBhMTAgPSBwaXhlbEF0KGxheWVyQSwgcGEgKyBpdmVjMigxLCAwKSk7XFxudmVjNCBhMDEgPSBwaXhlbEF0KGxheWVyQSwgcGEgKyBpdmVjMigwLCAxKSk7XFxudmVjNCBhMTEgPSBwaXhlbEF0KGxheWVyQSwgcGEgKyBpdmVjMigxLCAxKSk7XFxudmVjNCBiMDAgPSBwaXhlbEF0KGxheWVyQiwgcGIpO1xcbnZlYzQgYjEwID0gcGl4ZWxBdChsYXllckIsIHBiICsgaXZlYzIoMSwgMCkpO1xcbnZlYzQgYjAxID0gcGl4ZWxBdChsYXllckIsIHBiICsgaXZlYzIoMCwgMSkpO1xcbnZlYzQgYjExID0gcGl4ZWxBdChsYXllckIsIHBiICsgaXZlYzIoMSwgMSkpO1xcbmZsb2F0IG1heFNjb3JlID0gbWF4KFxcbm1heChtYXgoYTAwLnIsIGExMC5yKSwgbWF4KGEwMS5yLCBhMTEucikpLFxcbm1heChtYXgoYjAwLnIsIGIxMC5yKSwgbWF4KGIwMS5yLCBiMTEucikpXFxuKTtcXG5jb2xvciA9IHZlYzQoMC4wZiwgcGl4ZWwuZ2JhKTtcXG5pZihzY29yZSA8IG1heFNjb3JlIHx8IHNjb3JlID09IDAuMGYpXFxucmV0dXJuO1xcbnZlYzIgZWEgPSBmcmFjdChtaWQgKiBzY2FsZUEpO1xcbnZlYzIgZWIgPSBmcmFjdChtaWQgKiBzY2FsZUIpO1xcbmZsb2F0IGlzYSA9IGEwMC5iICogKDEuMGYgLSBlYS54KSAqICgxLjBmIC0gZWEueSkgK1xcbmExMC5iICogZWEueCAqICgxLjBmIC0gZWEueSkgK1xcbmEwMS5iICogKDEuMGYgLSBlYS54KSAqIGVhLnkgK1xcbmExMS5iICogZWEueCAqIGVhLnk7XFxuZmxvYXQgaXNiID0gYjAwLmIgKiAoMS4wZiAtIGViLngpICogKDEuMGYgLSBlYi55KSArXFxuYjEwLmIgKiBlYi54ICogKDEuMGYgLSBlYi55KSArXFxuYjAxLmIgKiAoMS4wZiAtIGViLngpICogZWIueSArXFxuYjExLmIgKiBlYi54ICogZWIueTtcXG5jb2xvciA9IChpc2EgPiBzY29yZSAmJiBpc2EgPiBpc2IpID8gdmVjNChpc2EsIHBpeGVsLmdiLCBhMDAuYSkgOiBwaXhlbDtcXG5jb2xvciA9IChpc2IgPiBzY29yZSAmJiBpc2IgPiBpc2EpID8gdmVjNChpc2IsIHBpeGVsLmdiLCBiMDAuYSkgOiBwaXhlbDtcXG5mbG9hdCB5MSA9IGlzYSwgeTIgPSBpc2IsIHkzID0gc2NvcmU7XFxuZmxvYXQgeDEgPSBsZ00gLSAobGdNICsgaCkgKiBhMDAuYTtcXG5mbG9hdCB4MiA9IGxnTSAtIChsZ00gKyBoKSAqIGIwMC5hO1xcbmZsb2F0IHgzID0gbGdNIC0gKGxnTSArIGgpICogcGl4ZWwuYTtcXG5mbG9hdCBkbiA9ICh4MSAtIHgyKSAqICh4MSAtIHgzKSAqICh4MiAtIHgzKTtcXG5pZihhYnMoZG4pIDwgMC4wMDAwMWYpXFxucmV0dXJuO1xcbmZsb2F0IGEgPSAoeDMgKiAoeTIgLSB5MSkgKyB4MiAqICh5MSAtIHkzKSArIHgxICogKHkzIC0geTIpKSAvIGRuO1xcbmlmKGEgPj0gMC4wZilcXG5yZXR1cm47XFxuZmxvYXQgYiA9ICh4MyAqIHgzICogKHkxIC0geTIpICsgeDIgKiB4MiAqICh5MyAtIHkxKSArIHgxICogeDEgKiAoeTIgLSB5MykpIC8gZG47XFxuZmxvYXQgYyA9ICh4MiAqIHgzICogKHgyIC0geDMpICogeTEgKyB4MyAqIHgxICogKHgzIC0geDEpICogeTIgKyB4MSAqIHgyICogKHgxIC0geDIpICogeTMpIC8gZG47XFxuZmxvYXQgeHYgPSAtYiAvICgyLjBmICogYSk7XFxuZmxvYXQgeXYgPSBjIC0gKGIgKiBiKSAvICg0LjBmICogYSk7XFxuaWYoeHYgPCBtaW4oeDEsIG1pbih4MiwgeDMpKSB8fCB4diA+IG1heCh4MSwgbWF4KHgyLCB4MykpKVxcbnJldHVybjtcXG5mbG9hdCBpbnRlcnBvbGF0ZWRTY2FsZSA9IChsZ00gLSB4dikgLyAobGdNICsgaCk7XFxuZmxvYXQgaW50ZXJwb2xhdGVkU2NvcmUgPSBjbGFtcCh5diwgMC4wZiwgMS4wZik7XFxuY29sb3IgPSB2ZWM0KGludGVycG9sYXRlZFNjb3JlLCBwaXhlbC5nYiwgaW50ZXJwb2xhdGVkU2NhbGUpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxudW5pZm9ybSBpbnQgaW1hZ2VXaWR0aDtcXG51bmlmb3JtIGludCBpbWFnZUhlaWdodDtcXG51bmlmb3JtIGludCBib3JkZXJUb3A7XFxudW5pZm9ybSBpbnQgYm9yZGVyUmlnaHQ7XFxudW5pZm9ybSBpbnQgYm9yZGVyQm90dG9tO1xcbnVuaWZvcm0gaW50IGJvcmRlckxlZnQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBhZGRyID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIGVuY29kZXJMZW5ndGgsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbktleXBvaW50IGtleXBvaW50ID0gZGVjb2RlS2V5cG9pbnQoZW5jb2RlZEtleXBvaW50cywgZW5jb2Rlckxlbmd0aCwgYWRkcik7XFxudmVjMiBwID0ga2V5cG9pbnQucG9zaXRpb247XFxuYm9vbCB3aXRoaW5Cb3JkZXIgPSBhbnkobGVzc1RoYW4oXFxudmVjNChwLngsIHAueSwgLXAueCwgLXAueSksXFxudmVjNChib3JkZXJMZWZ0LCBib3JkZXJUb3AsIGJvcmRlclJpZ2h0IC0gKGltYWdlV2lkdGggLSAxKSwgYm9yZGVyQm90dG9tIC0gKGltYWdlSGVpZ2h0IC0gMSkpXFxuKSk7XFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKGVuY29kZWRLZXlwb2ludHMpO1xcbnZlYzQgbnVsbFBpeGVsID0gZW5jb2RlTnVsbEtleXBvaW50KCk7XFxuY29sb3IgPSB3aXRoaW5Cb3JkZXIgPyBudWxsUGl4ZWwgOiBwaXhlbDtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxudW5pZm9ybSBpbnQgbWF4S2V5cG9pbnRzO1xcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaW50IG5ld0VuY29kZXJMZW5ndGggPSBvdXRwdXRTaXplKCkueDtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IGZpbmRLZXlwb2ludEFkZHJlc3ModGhyZWFkLCBuZXdFbmNvZGVyTGVuZ3RoLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5pbnQgaW5kZXggPSBmaW5kS2V5cG9pbnRJbmRleChhZGRyZXNzLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG52ZWM0IHBpeGVsID0gcmVhZEtleXBvaW50RGF0YShlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBhZGRyZXNzKTtcXG5jb2xvciA9IGluZGV4IDwgbWF4S2V5cG9pbnRzID8gcGl4ZWwgOiBlbmNvZGVOdWxsS2V5cG9pbnQoKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxudW5pZm9ybSBpbnQgbmV3RW5jb2Rlckxlbmd0aDtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBteUFkZHJlc3MgPSBmaW5kS2V5cG9pbnRBZGRyZXNzKHRocmVhZCwgbmV3RW5jb2Rlckxlbmd0aCwgMCwgZXh0cmFTaXplKTtcXG5pbnQgbXlJbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KG15QWRkcmVzcywgMCwgZXh0cmFTaXplKTtcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgLyA0O1xcbktleXBvaW50QWRkcmVzcyBvdGhlckFkZHJlc3MgPSBLZXlwb2ludEFkZHJlc3MobXlJbmRleCAqIHBpeGVsc1BlcktleXBvaW50LCBteUFkZHJlc3Mub2Zmc2V0KTtcXG5jb2xvciA9IHJlYWRLZXlwb2ludERhdGEoZW5jb2RlZEtleXBvaW50cywgZW5jb2Rlckxlbmd0aCwgb3RoZXJBZGRyZXNzKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHNBO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGhBO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHNCO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGhCO1xcbnVuaWZvcm0gaW50IGRlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoO1xcbnVuaWZvcm0gZmxvYXQgdGhyZXNob2xkO1xcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuS2V5cG9pbnRBZGRyZXNzIGFkZHJlc3MgPSBmaW5kS2V5cG9pbnRBZGRyZXNzKHRocmVhZCwgZW5jb2Rlckxlbmd0aCwgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuaW50IGluZGV4ID0gZmluZEtleXBvaW50SW5kZXgoYWRkcmVzcywgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuaW50IHBpeGVsc1BlcktleXBvaW50ID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50KGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpIC8gNDtcXG52ZWM0IGRhdGEgPSByZWFkS2V5cG9pbnREYXRhKGVuY29kZWRLZXlwb2ludHNBLCBlbmNvZGVyTGVuZ3RoQSwgYWRkcmVzcyk7XFxuY29sb3IgPSBkYXRhO1xcbmlmKGFkZHJlc3Mub2Zmc2V0ID49IHNpemVvZkVuY29kZWRLZXlwb2ludEhlYWRlcigpIC8gNClcXG5yZXR1cm47XFxuS2V5cG9pbnQga2V5cG9pbnRBID0gZGVjb2RlS2V5cG9pbnQoZW5jb2RlZEtleXBvaW50c0EsIGVuY29kZXJMZW5ndGhBLCBhZGRyZXNzKTtcXG5LZXlwb2ludCBrZXlwb2ludEIgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzQiwgZW5jb2Rlckxlbmd0aEIsIGFkZHJlc3MpO1xcbmNvbG9yID0gZW5jb2RlTnVsbEtleXBvaW50KCk7XFxuaWYoaXNOdWxsS2V5cG9pbnQoa2V5cG9pbnRBKSAmJiBpc051bGxLZXlwb2ludChrZXlwb2ludEIpKVxcbnJldHVybjtcXG5jb2xvciA9IGVuY29kZURpc2NhcmRlZEtleXBvaW50KCk7XFxuaWYoaXNEaXNjYXJkZWRLZXlwb2ludChrZXlwb2ludEEpIHx8IGlzRGlzY2FyZGVkS2V5cG9pbnQoa2V5cG9pbnRCKSlcXG5yZXR1cm47XFxuY29sb3IgPSBlbmNvZGVEaXNjYXJkZWRLZXlwb2ludCgpO1xcbmlmKGlzTnVsbEtleXBvaW50KGtleXBvaW50QSkgfHwgaXNOdWxsS2V5cG9pbnQoa2V5cG9pbnRCKSlcXG5yZXR1cm47XFxudmVjMiBkZWx0YSA9IGtleXBvaW50QS5wb3NpdGlvbiAtIGtleXBvaW50Qi5wb3NpdGlvbjtcXG5ib29sIHNob3VsZEtlZXAgPSAoZG90KGRlbHRhLCBkZWx0YSkgPD0gdGhyZXNob2xkICogdGhyZXNob2xkKTtcXG5jb2xvciA9IHNob3VsZEtlZXAgPyBkYXRhIDogZW5jb2RlRGlzY2FyZGVkS2V5cG9pbnQoKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBvZmZzZXRzSW1hZ2U7XFxudW5pZm9ybSBpdmVjMiBpbWFnZVNpemU7XFxuI2lmbmRlZiBNQVhfSVRFUkFUSU9OU1xcbiNlcnJvciBVbmRlZmluZWQgTUFYX0lURVJBVElPTlNcXG4jZW5kaWZcXG4jZGVmaW5lIGRlY29kZVNraXBPZmZzZXQocGl4ZWwpIChpbnQoKHBpeGVsKS5nICogMjU1LjBmKSB8IChpbnQoKHBpeGVsKS5hICogMjU1LjBmKSA8PCA4KSlcXG4jZGVmaW5lIGVuY29kZVNraXBPZmZzZXQob2Zmc2V0KSAodmVjMigob2Zmc2V0KSAmIDI1NSwgKG9mZnNldCkgPj4gOCkgLyAyNTUuMGYpXFxudm9pZCBtYWluKClcXG57XFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKG9mZnNldHNJbWFnZSk7XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pbnQgcmFzdGVySW5kZXggPSB0aHJlYWQueSAqIGltYWdlU2l6ZS54ICsgdGhyZWFkLng7XFxuaW50IG9mZnNldCA9IGRlY29kZVNraXBPZmZzZXQocGl4ZWwpO1xcbmludCB0b3RhbE9mZnNldCA9IG9mZnNldDtcXG52ZWMyIGVuY29kZWRTY29yZSA9IHBpeGVsLnJiO1xcbml2ZWMyIHBvcyA9IHRocmVhZDsgaW50IGFsbG93ID0gMTtcXG5AdW5yb2xsXFxuZm9yKGludCBpID0gMDsgaSA8IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcXG5hbGxvdyAqPSBpbnQocG9zLnkgPCBpbWFnZVNpemUueSkgKiBpbnQoaXNFbmNvZGVkRmxvYXQxNlplcm8ocGl4ZWwucmIpKTtcXG5yYXN0ZXJJbmRleCArPSBhbGxvdyAqIG9mZnNldDtcXG5wb3MgPSBpdmVjMihyYXN0ZXJJbmRleCAlIGltYWdlU2l6ZS54LCByYXN0ZXJJbmRleCAvIGltYWdlU2l6ZS54KTtcXG5waXhlbCA9IHBpeGVsQXQob2Zmc2V0c0ltYWdlLCBwb3MpO1xcbm9mZnNldCA9IGRlY29kZVNraXBPZmZzZXQocGl4ZWwpO1xcbnRvdGFsT2Zmc2V0ICs9IGFsbG93ICogb2Zmc2V0O1xcbn1cXG50b3RhbE9mZnNldCA9IG1pbih0b3RhbE9mZnNldCwgNjU1MzUpO1xcbmNvbG9yLnJiID0gZW5jb2RlZFNjb3JlO1xcbmNvbG9yLmdhID0gZW5jb2RlU2tpcE9mZnNldCh0b3RhbE9mZnNldCk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJmbG9hdDE2Lmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgY29ybmVycztcXG51bmlmb3JtIGl2ZWMyIGltYWdlU2l6ZTtcXG52b2lkIG1haW4oKVxcbntcXG52ZWM0IHBpeGVsID0gdGhyZWFkUGl4ZWwoY29ybmVycyk7XFxuaXZlYzIgcG9zID0gdGhyZWFkTG9jYXRpb24oKTtcXG52ZWMyIGVuY29kZWRTY29yZSA9IHBpeGVsLnJiO1xcbmludCBvZmZzZXQgPSAwLCBhbGxvdyA9IDEsIGp1bXBlZCA9IDA7XFxuI2RlZmluZSBSRUFEKGopIDsgXFxcXFxcbmFsbG93ICo9IGludChwb3MueSA8IGltYWdlU2l6ZS55KSAqIGludChpc0VuY29kZWRGbG9hdDE2WmVybyhwaXhlbC5yYikpOyBcXFxcXFxub2Zmc2V0ICs9IGFsbG93OyBcXFxcXFxucG9zLnggPSAocG9zLnggKyAxKSAlIGltYWdlU2l6ZS54OyBcXFxcXFxucG9zLnkgKz0gaW50KHBvcy54ID09IDApOyBcXFxcXFxucGl4ZWwgPSAoMCAhPSAoanVtcGVkIHw9IGludChwb3MueCA9PSAwKSkpID8gcGl4ZWxBdFNob3J0T2Zmc2V0KGNvcm5lcnMsIGl2ZWMyKChqKSwxKSkgOiBwaXhlbEF0U2hvcnRPZmZzZXQoY29ybmVycywgaXZlYzIoKGopLDApKVxcblJFQUQoMSk7IFJFQUQoMik7IFJFQUQoMyk7IFJFQUQoNCk7IFJFQUQoNSk7IFJFQUQoNik7IFJFQUQoNyk7XFxuY29sb3IucmIgPSBlbmNvZGVkU2NvcmU7XFxuY29sb3IuZ2EgPSB2ZWMyKG9mZnNldCwgMCkgLyAyNTUuMGY7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJrZXlwb2ludHMuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBvZmZzZXRzSW1hZ2U7XFxudW5pZm9ybSBpdmVjMiBpbWFnZVNpemU7XFxudW5pZm9ybSBpbnQgcGFzc0lkO1xcbnVuaWZvcm0gaW50IG51bVBhc3NlcztcXG51bmlmb3JtIGludCBrZXlwb2ludExpbWl0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxuI2RlZmluZSBkZWNvZGVTa2lwT2Zmc2V0KHBpeGVsKSAoaW50KChwaXhlbCkuZyAqIDI1NS4wZikgfCAoaW50KChwaXhlbCkuYSAqIDI1NS4wZikgPDwgOCkpXFxuYm9vbCBmaW5kUXRoS2V5cG9pbnQoaW50IHEsIGludCBwLCBpbm91dCBpdmVjMiBwb3NpdGlvbiwgb3V0IHZlYzQgcGl4ZWwpXFxue1xcbmludCBub3RGaXJzdFBhc3MgPSBpbnQocGFzc0lkID4gMCk7XFxucG9zaXRpb24gKj0gbm90Rmlyc3RQYXNzO1xcbnAgfD0gLSgxIC0gbm90Rmlyc3RQYXNzKTtcXG5wIC09IG5vdEZpcnN0UGFzcztcXG5pbnQgcmFzdGVySW5kZXggPSBwb3NpdGlvbi55ICogaW1hZ2VTaXplLnggKyBwb3NpdGlvbi54O1xcbndoaWxlKHBvc2l0aW9uLnkgPCBpbWFnZVNpemUueSAmJiBwICE9IHEpIHtcXG5wb3NpdGlvbiA9IGl2ZWMyKHJhc3RlckluZGV4ICUgaW1hZ2VTaXplLngsIHJhc3RlckluZGV4IC8gaW1hZ2VTaXplLngpO1xcbnBpeGVsID0gdGV4ZWxGZXRjaChvZmZzZXRzSW1hZ2UsIHBvc2l0aW9uLCAwKTtcXG5wICs9IGludCghaXNFbmNvZGVkRmxvYXQxNlplcm8ocGl4ZWwucmIpKTtcXG5yYXN0ZXJJbmRleCArPSBtYXgoMSwgZGVjb2RlU2tpcE9mZnNldChwaXhlbCkpO1xcbn1cXG5yZXR1cm4gKHAgPT0gcSk7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaW50IHBpeGVsc1BlcktleXBvaW50ID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50KGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpIC8gNDtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IGZpbmRLZXlwb2ludEFkZHJlc3ModGhyZWFkLCBlbmNvZGVyTGVuZ3RoLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5pbnQgcSA9IGZpbmRLZXlwb2ludEluZGV4KGFkZHJlc3MsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmNvbG9yID0gdmVjNCgwLjBmKTtcXG5pZihhZGRyZXNzLm9mZnNldCAhPSAwKVxcbnJldHVybjtcXG5jb2xvciA9IHRocmVhZFBpeGVsKGVuY29kZWRLZXlwb2ludHMpO1xcbmludCBudW1QaXhlbHMgPSBlbmNvZGVyTGVuZ3RoICogZW5jb2Rlckxlbmd0aDtcXG5pbnQgbWF4S2V5cG9pbnRzID0gbnVtUGl4ZWxzIC8gcGl4ZWxzUGVyS2V5cG9pbnQ7XFxuaW50IG1heEtleXBvaW50c1BlclBhc3MgPSBtYXhLZXlwb2ludHMgLyBudW1QYXNzZXMgKyBpbnQobWF4S2V5cG9pbnRzICUgbnVtUGFzc2VzICE9IDApO1xcbmludCB0YXJnZXRQYXNzSWQgPSBxIC8gbWF4S2V5cG9pbnRzUGVyUGFzcztcXG5pZihwYXNzSWQgIT0gdGFyZ2V0UGFzc0lkKVxcbnJldHVybjtcXG5pbnQgbGFzdEluZGV4RnJvbVByZXZQYXNzID0gcGFzc0lkICogbWF4S2V5cG9pbnRzUGVyUGFzcyAtIDE7XFxuS2V5cG9pbnRBZGRyZXNzIGxhc3RBZGRyZXNzRnJvbVByZXZQYXNzID0gS2V5cG9pbnRBZGRyZXNzKG1heCgwLCBsYXN0SW5kZXhGcm9tUHJldlBhc3MpICogcGl4ZWxzUGVyS2V5cG9pbnQsIDApO1xcbktleXBvaW50IGxhc3RLZXlwb2ludEZyb21QcmV2UGFzcyA9IGRlY29kZUtleXBvaW50KGVuY29kZWRLZXlwb2ludHMsIGVuY29kZXJMZW5ndGgsIGxhc3RBZGRyZXNzRnJvbVByZXZQYXNzKTtcXG5pdmVjMiBwb3NpdGlvbiA9IHBhc3NJZCA+IDAgPyBpdmVjMihsYXN0S2V5cG9pbnRGcm9tUHJldlBhc3MucG9zaXRpb24pIDogaXZlYzIoMCk7XFxudmVjNCBwaXhlbDtcXG5jb2xvciA9IGVuY29kZU51bGxLZXlwb2ludCgpO1xcbmlmKHEgPj0gbWluKG1heEtleXBvaW50cywga2V5cG9pbnRMaW1pdCkgfHwgIWZpbmRRdGhLZXlwb2ludChxLCBsYXN0SW5kZXhGcm9tUHJldlBhc3MsIHBvc2l0aW9uLCBwaXhlbCkpXFxucmV0dXJuO1xcbmNvbG9yID0gZW5jb2RlS2V5cG9pbnRQb3NpdGlvbih2ZWMyKHBvc2l0aW9uKSk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJrZXlwb2ludHMuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBjb3JuZXJzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxudm9pZCBtYWluKClcXG57XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG52ZWM0IHBpeGVsID0gdGhyZWFkUGl4ZWwoZW5jb2RlZEtleXBvaW50cyk7XFxuaW50IHBpeGVsc1BlcktleXBvaW50ID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50KGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpIC8gNDtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IGZpbmRLZXlwb2ludEFkZHJlc3ModGhyZWFkLCBlbmNvZGVyTGVuZ3RoLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5pbnQgcSA9IGZpbmRLZXlwb2ludEluZGV4KGFkZHJlc3MsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmNvbG9yID0gcGl4ZWw7XFxuaWYoYWRkcmVzcy5vZmZzZXQgIT0gMSlcXG5yZXR1cm47XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBhZGRyZXNzKTtcXG52ZWM0IGtwaXggPSBwaXhlbEF0KGNvcm5lcnMsIGl2ZWMyKGtleXBvaW50LnBvc2l0aW9uKSk7XFxua2V5cG9pbnQuc2NvcmUgPSBkZWNvZGVGbG9hdDE2KGtwaXgucmIpO1xcbmNvbG9yLnIgPSBrcGl4LmE7XFxuY29sb3IuZyA9IGVuY29kZUtleXBvaW50T3JpZW50YXRpb24oMC4wZik7XFxuY29sb3IuYmEgPSBlbmNvZGVLZXlwb2ludFNjb3JlKGtleXBvaW50LnNjb3JlKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGNvcm5lcnM7XFxudW5pZm9ybSBtZWRpdW1wIHVzYW1wbGVyMkQgbG9va3VwVGFibGU7XFxudW5pZm9ybSBpbnQgc3RyaWRlO1xcbnVuaWZvcm0gaW50IGRlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoO1xcbnVuaWZvcm0gaW50IGVuY29kZXJDYXBhY2l0eTtcXG5jb25zdCB1dmVjMiBOVUxMX0VMRU1FTlQgPSB1dmVjMigweEZGRkZ1KTtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIGVuY29kZXJMZW5ndGgsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmludCBpbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KGFkZHJlc3MsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbml2ZWMyIHBvcyA9IGl2ZWMyKGluZGV4ICUgc3RyaWRlLCBpbmRleCAvIHN0cmlkZSk7XFxudXZlYzQgZW50cnkgPSB0ZXhlbEZldGNoKGxvb2t1cFRhYmxlLCBwb3MsIDApO1xcbmludCBwaXhlbHNQZXJLZXlwb2ludCA9IHNpemVvZkVuY29kZWRLZXlwb2ludChkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKSAvIDQ7XFxuaW50IHJhc3RlckluZGV4ID0gYWRkcmVzcy5iYXNlICsgYWRkcmVzcy5vZmZzZXQ7XFxuaW50IG51bWJlck9mUGl4ZWxzID0gZW5jb2Rlckxlbmd0aCAqIGVuY29kZXJMZW5ndGg7XFxuaW50IG51bWJlck9mVmFsaWRQaXhlbHMgPSBudW1iZXJPZlBpeGVscyAtIChudW1iZXJPZlBpeGVscyAlIHBpeGVsc1BlcktleXBvaW50KTtcXG5pbnQgbWF4RW5jb2RlckNhcGFjaXR5ID0gbnVtYmVyT2ZWYWxpZFBpeGVscyAvIHBpeGVsc1BlcktleXBvaW50O1xcbmNvbG9yID0gZW5jb2RlTnVsbEtleXBvaW50KCk7XFxuaWYoYWxsKGVxdWFsKGVudHJ5Lnh5LCBOVUxMX0VMRU1FTlQpKSB8fCBpbmRleCA+PSBtaW4oZW5jb2RlckNhcGFjaXR5LCBtYXhFbmNvZGVyQ2FwYWNpdHkpKVxcbnJldHVybjtcXG5jb2xvciA9IGVuY29kZUtleXBvaW50UG9zaXRpb24odmVjMihlbnRyeS54eSkpO1xcbmlmKGFkZHJlc3Mub2Zmc2V0ID09IDApXFxucmV0dXJuO1xcbmNvbG9yID0gdmVjNCgwLjBmKTtcXG5pZihhZGRyZXNzLm9mZnNldCA+PSBzaXplb2ZFbmNvZGVkS2V5cG9pbnRIZWFkZXIoKSAvIDQpXFxucmV0dXJuO1xcbnZlYzQgcGl4ZWwgPSB0ZXhlbEZldGNoKGNvcm5lcnMsIGl2ZWMyKGVudHJ5Lnh5KSwgMCk7XFxudmVjMiBlbmNvZGVkU2NvcmUgPSBlbmNvZGVLZXlwb2ludFNjb3JlKGRlY29kZUZsb2F0MTYocGl4ZWwucmIpKTtcXG5mbG9hdCBlbmNvZGVkT3JpZW50YXRpb24gPSBlbmNvZGVLZXlwb2ludE9yaWVudGF0aW9uKDAuMGYpO1xcbmZsb2F0IGVuY29kZWRMb2QgPSBwaXhlbC5hO1xcbmNvbG9yID0gdmVjNChlbmNvZGVkTG9kLCBlbmNvZGVkT3JpZW50YXRpb24sIGVuY29kZWRTY29yZSk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJrZXlwb2ludHMuZ2xzbFxcXCJcXG52b2lkIG1haW4oKVxcbntcXG5jb2xvciA9IGVuY29kZU51bGxLZXlwb2ludCgpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwicHlyYW1pZHMuZ2xzbFxcXCJcXG5AaW5jbHVkZSBcXFwiZmxvYXQxNi5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGNvcm5lcnM7XFxudW5pZm9ybSBzYW1wbGVyMkQgcHlyYW1pZDtcXG51bmlmb3JtIGZsb2F0IGxvZDtcXG51bmlmb3JtIGludCB0aHJlc2hvbGQ7XFxuI2RlZmluZSBVU0VfVkFSWUlOR1MgMVxcbiNpZiAhZGVmaW5lZChGQVNUX1RZUEUpXFxuI2Vycm9yIFVuZGVmaW5lZCBGQVNUX1RZUEVcXG4jZWxpZiBGQVNUX1RZUEUgPT0gOTE2XFxuaW4gdmVjMiB2X3BpeDAsIHZfcGl4MSwgdl9waXgyLCB2X3BpeDMsIHZfcGl4NCwgdl9waXg1LCB2X3BpeDYsIHZfcGl4NyxcXG52X3BpeDgsIHZfcGl4OSwgdl9waXgxMCx2X3BpeDExLHZfcGl4MTIsdl9waXgxMyx2X3BpeDE0LHZfcGl4MTU7XFxuI2Vsc2VcXG4jZXJyb3IgSW52YWxpZCBGQVNUX1RZUEVcXG4jZW5kaWZcXG4jZGVmaW5lIFBJWCh4LHkpIHB5clBpeGVsQXRPZmZzZXQocHlyYW1pZCwgbG9kLCBwb3QsIGl2ZWMyKCh4KSwoeSkpKS5nXFxuI2RlZmluZSBYSVAodikgdGV4dHVyZUxvZChweXJhbWlkLCAodiksIGxvZCkuZ1xcbnZvaWQgbWFpbigpXFxue1xcbmZsb2F0IHBpeGVsID0gdGhyZWFkUGl4ZWwocHlyYW1pZCkuZztcXG52ZWM0IHByZXYgPSB0aHJlYWRQaXhlbChjb3JuZXJzKTtcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbml2ZWMyIHNpemUgPSBvdXRwdXRTaXplKCk7XFxuZmxvYXQgcG90ID0gZXhwMihsb2QpO1xcbmZsb2F0IHQgPSBmbG9hdChjbGFtcCh0aHJlc2hvbGQsIDAsIDI1NSkpIC8gMjU1LjBmO1xcbmZsb2F0IGN0ID0gcGl4ZWwgKyB0LCBjX3QgPSBwaXhlbCAtIHQ7XFxuY29sb3IgPSB2ZWM0KHByZXYuciwgcGl4ZWwsIHByZXYuYmEpO1xcbiNpZiBGQVNUX1RZUEUgPT0gOTE2XFxuY29uc3QgaXZlYzQgbWFyZ2luID0gaXZlYzQoMywgMywgNCwgNCk7XFxuaWYoYW55KGxlc3NUaGFuKGl2ZWM0KHRocmVhZCwgc2l6ZSAtIHRocmVhZCksIG1hcmdpbikpKVxcbnJldHVybjtcXG4jaWYgVVNFX1ZBUllJTkdTXFxuZmxvYXQgcDAgPSBYSVAodl9waXgwKSwgcDQgPSBYSVAodl9waXg0KSwgcDggPSBYSVAodl9waXg4KSwgcDEyID0gWElQKHZfcGl4MTIpO1xcbiNlbHNlXFxuZmxvYXQgcDAgPSBQSVgoMCwzKSwgcDQgPSBQSVgoMywwKSwgcDggPSBQSVgoMCwtMyksIHAxMiA9IFBJWCgtMywwKTtcXG4jZW5kaWZcXG5idmVjNCBicmlnaHRlciA9IGJ2ZWM0KHAwID4gY3QsIHA0ID4gY3QsIHA4ID4gY3QsIHAxMiA+IGN0KTtcXG5idmVjNCBkYXJrZXIgPSBidmVjNChwMCA8IGNfdCwgcDQgPCBjX3QsIHA4IDwgY190LCBwMTIgPCBjX3QpO1xcbmJ2ZWM0IGJwYWlycyA9IGJ2ZWM0KGFsbChicmlnaHRlci54eSksIGFsbChicmlnaHRlci55eiksIGFsbChicmlnaHRlci56dyksIGFsbChicmlnaHRlci53eCkpO1xcbmJ2ZWM0IGRwYWlycyA9IGJ2ZWM0KGFsbChkYXJrZXIueHkpLCBhbGwoZGFya2VyLnl6KSwgYWxsKGRhcmtlci56dyksIGFsbChkYXJrZXIud3gpKTtcXG5pZighKGFueShicGFpcnMpIHx8IGFueShkcGFpcnMpKSlcXG5yZXR1cm47XFxuI2lmIFVTRV9WQVJZSU5HU1xcbmZsb2F0IHAxID0gWElQKHZfcGl4MSksIHAyID0gWElQKHZfcGl4MiksIHAzID0gWElQKHZfcGl4MyksXFxucDUgPSBYSVAodl9waXg1KSwgcDYgPSBYSVAodl9waXg2KSwgcDcgPSBYSVAodl9waXg3KSxcXG5wOSA9IFhJUCh2X3BpeDkpLCBwMTAgPSBYSVAodl9waXgxMCksIHAxMSA9IFhJUCh2X3BpeDExKSxcXG5wMTMgPSBYSVAodl9waXgxMyksIHAxNCA9IFhJUCh2X3BpeDE0KSwgcDE1ID0gWElQKHZfcGl4MTUpO1xcbiNlbHNlXFxuZmxvYXQgcDEgPSBQSVgoMSwzKSwgcDIgPSBQSVgoMiwyKSwgcDMgPSBQSVgoMywxKSxcXG5wNSA9IFBJWCgzLC0xKSwgcDYgPSBQSVgoMiwtMiksIHA3ID0gUElYKDEsLTMpLFxcbnA5ID0gUElYKC0xLC0zKSwgcDEwID0gUElYKC0yLC0yKSwgcDExID0gUElYKC0zLC0xKSxcXG5wMTMgPSBQSVgoLTMsMSksIHAxNCA9IFBJWCgtMiwyKSwgcDE1ID0gUElYKC0xLDMpO1xcbiNlbmRpZlxcbmJvb2wgQT0ocDA+Y3QpLEI9KHAxPmN0KSxDPShwMj5jdCksRD0ocDM+Y3QpLEU9KHA0PmN0KSxGPShwNT5jdCksRz0ocDY+Y3QpLEg9KHA3PmN0KSxJPShwOD5jdCksSj0ocDk+Y3QpLEs9KHAxMD5jdCksTD0ocDExPmN0KSxNPShwMTI+Y3QpLE49KHAxMz5jdCksTz0ocDE0PmN0KSxQPShwMTU+Y3QpLGE9KHAwPGNfdCksYj0ocDE8Y190KSxjPShwMjxjX3QpLGQ9KHAzPGNfdCksZT0ocDQ8Y190KSxmPShwNTxjX3QpLGc9KHA2PGNfdCksaD0ocDc8Y190KSxpPShwODxjX3QpLGo9KHA5PGNfdCksaz0ocDEwPGNfdCksbD0ocDExPGNfdCksbT0ocDEyPGNfdCksbj0ocDEzPGNfdCksbz0ocDE0PGNfdCkscD0ocDE1PGNfdCk7XFxuYm9vbCBpc0Nvcm5lcj1BJiYoQiYmKEsmJkwmJkomJihNJiZOJiZPJiZQfHxHJiZIJiZJJiYoTSYmTiYmT3x8RiYmKE0mJk58fEUmJihNfHxEKSkpKXx8QyYmKEsmJkwmJk0mJihOJiZPJiZQfHxHJiZIJiZJJiZKJiYoTiYmT3x8RiYmKE58fEUpKSl8fEQmJihOJiYoTCYmTSYmKEsmJkcmJkgmJkkmJkomJihPfHxGKXx8TyYmUCl8fGsmJmwmJm0mJmUmJmYmJmcmJmgmJmkmJmopfHxFJiYoTyYmKE0mJk4mJihLJiZMJiZHJiZIJiZJJiZKfHxQKXx8ayYmbCYmbSYmbiYmZiYmZyYmaCYmaSYmail8fEYmJihQJiYoTiYmT3x8ayYmbCYmbSYmbiYmbyYmZyYmaCYmaSYmail8fEcmJihPJiZQfHxIJiYoUHx8SSl8fGsmJmwmJm0mJm4mJm8mJnAmJmgmJmkmJmopfHxrJiZsJiZtJiZuJiZvJiZoJiZpJiZqJiYocHx8ZykpfHxrJiZsJiZtJiZuJiZoJiZpJiZqJiYobyYmKHB8fGcpfHxmJiYobyYmcHx8ZykpKXx8ayYmbCYmbSYmaCYmaSYmaiYmKG4mJihvJiZwfHxnJiYob3x8ZikpfHxlJiYobiYmbyYmcHx8ZyYmKG4mJm98fGYpKSkpfHxrJiZsJiZoJiZpJiZqJiYobSYmKG4mJm8mJnB8fGcmJihuJiZvfHxmJiYobnx8ZSkpKXx8ZCYmKG0mJm4mJm8mJnB8fGcmJihtJiZuJiZvfHxmJiYobSYmbnx8ZSkpKSkpfHxrJiZoJiZpJiZqJiYobCYmKG0mJm4mJm8mJnB8fGcmJihtJiZuJiZvfHxmJiYobSYmbnx8ZSYmKG18fGQpKSkpfHxjJiYobCYmbSYmbiYmbyYmcHx8ZyYmKGwmJm0mJm4mJm98fGYmJihsJiZtJiZufHxlJiYobCYmbXx8ZCkpKSkpKXx8SyYmSSYmSiYmKEwmJk0mJk4mJk8mJlB8fEcmJkgmJihMJiZNJiZOJiZPfHxGJiYoTCYmTSYmTnx8RSYmKEwmJk18fEQmJihMfHxDKSkpKSl8fGgmJmkmJmomJihiJiYoayYmbCYmbSYmbiYmbyYmcHx8ZyYmKGsmJmwmJm0mJm4mJm98fGYmJihrJiZsJiZtJiZufHxlJiYoayYmbCYmbXx8ZCYmKGsmJmx8fGMpKSkpKXx8ayYmKGwmJm0mJm4mJm8mJnB8fGcmJihsJiZtJiZuJiZvfHxmJiYobCYmbSYmbnx8ZSYmKGwmJm18fGQmJihsfHxjKSkpKSkpKXx8QiYmKEgmJkkmJkomJihLJiZMJiZNJiZOJiZPJiZQJiZhfHxHJiYoSyYmTCYmTSYmTiYmTyYmYXx8RiYmKEsmJkwmJk0mJk4mJmF8fEUmJihLJiZMJiZNJiZhfHxEJiYoSyYmTCYmYXx8QykpKSkpfHxhJiZrJiZpJiZqJiYobCYmbSYmbiYmbyYmcHx8ZyYmaCYmKGwmJm0mJm4mJm98fGYmJihsJiZtJiZufHxlJiYobCYmbXx8ZCYmKGx8fGMpKSkpKSl8fEMmJihLJiZIJiZJJiZKJiYoTCYmTSYmTiYmTyYmUCYmYSYmYnx8RyYmKEwmJk0mJk4mJk8mJmEmJmJ8fEYmJihMJiZNJiZOJiZhJiZifHxFJiYoTCYmTSYmYSYmYnx8RCkpKSl8fGEmJmImJmsmJmwmJmomJihtJiZuJiZvJiZwfHxnJiZoJiZpJiYobSYmbiYmb3x8ZiYmKG0mJm58fGUmJihtfHxkKSkpKSl8fEQmJihLJiZMJiZIJiZJJiZKJiYoTSYmTiYmTyYmUCYmYSYmYiYmY3x8RyYmKE0mJk4mJk8mJmEmJmImJmN8fEYmJihNJiZOJiZhJiZiJiZjfHxFKSkpfHxhJiZiJiZrJiZsJiZtJiZjJiYobiYmbyYmcHx8ZyYmaCYmaSYmaiYmKG4mJm98fGYmJihufHxlKSkpKXx8RSYmKEsmJkwmJk0mJkgmJkkmJkomJihOJiZPJiZQJiZhJiZiJiZjJiZkfHxHJiYoTiYmTyYmYSYmYiYmYyYmZHx8RikpfHxhJiZiJiZsJiZtJiZuJiZjJiZkJiYoayYmZyYmaCYmaSYmaiYmKG98fGYpfHxvJiZwKSl8fEYmJihLJiZMJiZNJiZOJiZIJiZJJiZKJiYoTyYmUCYmYSYmYiYmYyYmZCYmZXx8Ryl8fGEmJmImJm0mJm4mJm8mJmMmJmQmJmUmJihrJiZsJiZnJiZoJiZpJiZqfHxwKSl8fEcmJihLJiZMJiZNJiZOJiZPJiZIJiZJJiZKfHxhJiZiJiZuJiZvJiZwJiZjJiZkJiZlJiZmKXx8SCYmKEsmJkwmJk0mJk4mJk8mJlAmJkkmJkp8fGEmJmImJm8mJnAmJmMmJmQmJmUmJmYmJmcpfHxhJiYoYiYmKGsmJmwmJmomJihtJiZuJiZvJiZwfHxnJiZoJiZpJiYobSYmbiYmb3x8ZiYmKG0mJm58fGUmJihtfHxkKSkpKXx8YyYmKGsmJmwmJm0mJihuJiZvJiZwfHxnJiZoJiZpJiZqJiYobiYmb3x8ZiYmKG58fGUpKSl8fGQmJihsJiZtJiZuJiYoayYmZyYmaCYmaSYmaiYmKG98fGYpfHxvJiZwKXx8ZSYmKG0mJm4mJm8mJihrJiZsJiZnJiZoJiZpJiZqfHxwKXx8ZiYmKG4mJm8mJnB8fGcmJihvJiZwfHxoJiYocHx8aSkpKSkpKSl8fGsmJmkmJmomJihsJiZtJiZuJiZvJiZwfHxnJiZoJiYobCYmbSYmbiYmb3x8ZiYmKGwmJm0mJm58fGUmJihsJiZtfHxkJiYobHx8YykpKSkpKXx8aCYmaSYmaiYmKGsmJmwmJm0mJm4mJm8mJnB8fGcmJihrJiZsJiZtJiZuJiZvfHxmJiYoayYmbCYmbSYmbnx8ZSYmKGsmJmwmJm18fGQmJihrJiZsfHxjJiYoYnx8aykpKSkpKTtcXG5pZighaXNDb3JuZXIpXFxucmV0dXJuO1xcbm1hdDQgbXAgPSBtYXQ0KHAwLHAxLHAyLHAzLHA0LHA1LHA2LHA3LHA4LHA5LHAxMCxwMTEscDEyLHAxMyxwMTQscDE1KTtcXG5tYXQ0IG1jdCA9IG1wIC0gbWF0NChjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCk7XFxubWF0NCBtY190ID0gbWF0NChjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QpIC0gbXA7XFxuY29uc3QgdmVjNCB6ZXJvcyA9IHZlYzQoMC4wZiksIG9uZXMgPSB2ZWM0KDEuMGYpO1xcbnZlYzQgYnMgPSBtYXgobWN0WzBdLCB6ZXJvcyksIGRzID0gbWF4KG1jX3RbMF0sIHplcm9zKTtcXG5icyArPSBtYXgobWN0WzFdLCB6ZXJvcyk7ICAgICBkcyArPSBtYXgobWNfdFsxXSwgemVyb3MpO1xcbmJzICs9IG1heChtY3RbMl0sIHplcm9zKTsgICAgIGRzICs9IG1heChtY190WzJdLCB6ZXJvcyk7XFxuYnMgKz0gbWF4KG1jdFszXSwgemVyb3MpOyAgICAgZHMgKz0gbWF4KG1jX3RbM10sIHplcm9zKTtcXG5mbG9hdCB0aGlzU2NvcmUgPSBtYXgoZG90KGJzLCBvbmVzKSwgZG90KGRzLCBvbmVzKSkgLyAxNi4wZjtcXG5mbG9hdCBwcmV2U2NvcmUgPSBkZWNvZGVGbG9hdDE2KHByZXYucmIpO1xcbnZlYzMgdGhpc1Jlc3VsdCA9IHZlYzMoZW5jb2RlRmxvYXQxNih0aGlzU2NvcmUpLCBlbmNvZGVMb2QobG9kKSk7XFxuY29sb3IucmJhID0gdGhpc1Njb3JlID4gcHJldlNjb3JlID8gdGhpc1Jlc3VsdCA6IGNvbG9yLnJiYTtcXG4jZW5kaWZcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwidW5pZm9ybSBtZWRpdW1wIGZsb2F0IGxvZDtcXG4jaWYgIWRlZmluZWQoRkFTVF9UWVBFKVxcbiNlcnJvciBVbmRlZmluZWQgRkFTVF9UWVBFXFxuI2VsaWYgRkFTVF9UWVBFID09IDkxNlxcbm91dCB2ZWMyIHZfcGl4MCwgdl9waXgxLCB2X3BpeDIsIHZfcGl4Mywgdl9waXg0LCB2X3BpeDUsIHZfcGl4Niwgdl9waXg3LFxcbnZfcGl4OCwgdl9waXg5LCB2X3BpeDEwLHZfcGl4MTEsdl9waXgxMix2X3BpeDEzLHZfcGl4MTQsdl9waXgxNTtcXG4jZWxzZVxcbiNlcnJvciBJbnZhbGlkIEZBU1RfVFlQRVxcbiNlbmRpZlxcbiNkZWZpbmUgUElYKHgseSkgKHRleENvb3JkICsgKChwb3QpICogdmVjMigoeCksKHkpKSkgLyB0ZXhTaXplKVxcbnZvaWQgdnNtYWluKClcXG57XFxuZmxvYXQgcG90ID0gZXhwMihsb2QpO1xcbiNpZiBGQVNUX1RZUEUgPT0gOTE2XFxudl9waXgwID0gUElYKDAsMyk7IHZfcGl4MSA9IFBJWCgxLDMpLCB2X3BpeDIgPSBQSVgoMiwyKSwgdl9waXgzID0gUElYKDMsMSk7XFxudl9waXg0ID0gUElYKDMsMCk7IHZfcGl4NSA9IFBJWCgzLC0xKSwgdl9waXg2ID0gUElYKDIsLTIpLCB2X3BpeDcgPSBQSVgoMSwtMyk7XFxudl9waXg4ID0gUElYKDAsLTMpOyB2X3BpeDkgPSBQSVgoLTEsLTMpLCB2X3BpeDEwID0gUElYKC0yLC0yKSwgdl9waXgxMSA9IFBJWCgtMywtMSk7XFxudl9waXgxMiA9IFBJWCgtMywwKTsgdl9waXgxMyA9IFBJWCgtMywxKSwgdl9waXgxNCA9IFBJWCgtMiwyKSwgdl9waXgxNSA9IFBJWCgtMSwzKTtcXG4jZW5kaWZcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJrZXlwb2ludC1kZXNjcmlwdG9ycy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHNBO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGhBO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHNCO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGhCO1xcbnVuaWZvcm0gaW50IGRlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoO1xcbnVuaWZvcm0gaW50IHRocmVzaG9sZDtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIGVuY29kZXJMZW5ndGgsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmludCBpbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KGFkZHJlc3MsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmludCBwaXhlbHNQZXJLZXlwb2ludCA9IHNpemVvZkVuY29kZWRLZXlwb2ludChkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKSAvIDQ7XFxudmVjNCBkYXRhID0gcmVhZEtleXBvaW50RGF0YShlbmNvZGVkS2V5cG9pbnRzQSwgZW5jb2Rlckxlbmd0aEEsIGFkZHJlc3MpO1xcbmNvbG9yID0gZGF0YTtcXG5pZihhZGRyZXNzLm9mZnNldCA+PSBzaXplb2ZFbmNvZGVkS2V5cG9pbnRIZWFkZXIoKSAvIDQpXFxucmV0dXJuO1xcbktleXBvaW50IGtleXBvaW50QSA9IGRlY29kZUtleXBvaW50KGVuY29kZWRLZXlwb2ludHNBLCBlbmNvZGVyTGVuZ3RoQSwgYWRkcmVzcyk7XFxuS2V5cG9pbnQga2V5cG9pbnRCID0gZGVjb2RlS2V5cG9pbnQoZW5jb2RlZEtleXBvaW50c0IsIGVuY29kZXJMZW5ndGhCLCBhZGRyZXNzKTtcXG5jb2xvciA9IGVuY29kZU51bGxLZXlwb2ludCgpO1xcbmlmKGlzTnVsbEtleXBvaW50KGtleXBvaW50QSkgJiYgaXNOdWxsS2V5cG9pbnQoa2V5cG9pbnRCKSlcXG5yZXR1cm47XFxuY29sb3IgPSBlbmNvZGVEaXNjYXJkZWRLZXlwb2ludCgpO1xcbmlmKGlzRGlzY2FyZGVkS2V5cG9pbnQoa2V5cG9pbnRBKSB8fCBpc0Rpc2NhcmRlZEtleXBvaW50KGtleXBvaW50QikpXFxucmV0dXJuO1xcbmNvbG9yID0gZW5jb2RlRGlzY2FyZGVkS2V5cG9pbnQoKTtcXG5pZihpc051bGxLZXlwb2ludChrZXlwb2ludEEpIHx8IGlzTnVsbEtleXBvaW50KGtleXBvaW50QikpXFxucmV0dXJuO1xcbnVpbnRbREVTQ1JJUFRPUl9TSVpFXSBkZXNjcmlwdG9yQSwgZGVzY3JpcHRvckI7XFxuZGVzY3JpcHRvckEgPSByZWFkS2V5cG9pbnREZXNjcmlwdG9yKGVuY29kZWRLZXlwb2ludHNBLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplLCBlbmNvZGVyTGVuZ3RoQSwgYWRkcmVzcyk7XFxuZGVzY3JpcHRvckIgPSByZWFkS2V5cG9pbnREZXNjcmlwdG9yKGVuY29kZWRLZXlwb2ludHNCLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplLCBlbmNvZGVyTGVuZ3RoQiwgYWRkcmVzcyk7XFxuaW50IGRpc3QgPSBkaXN0YW5jZUJldHdlZW5LZXlwb2ludERlc2NyaXB0b3JzKGRlc2NyaXB0b3JBLCBkZXNjcmlwdG9yQik7XFxuYm9vbCBzaG91bGRLZWVwID0gKGRpc3QgPD0gdGhyZXNob2xkKTtcXG5jb2xvciA9IHNob3VsZEtlZXAgPyBkYXRhIDogZW5jb2RlRGlzY2FyZGVkS2V5cG9pbnQoKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBjb3JuZXJzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1heFNjb3JlO1xcbnVuaWZvcm0gZmxvYXQgcXVhbGl0eTtcXG52b2lkIG1haW4oKVxcbntcXG52ZWM0IHBpeGVsID0gdGhyZWFkUGl4ZWwoY29ybmVycyk7XFxuZmxvYXQgc2NvcmUgPSBkZWNvZGVGbG9hdDE2KHBpeGVsLnJiKTtcXG5mbG9hdCBtYXh2YWwgPSBkZWNvZGVGbG9hdDE2KHRocmVhZFBpeGVsKG1heFNjb3JlKS5yYik7XFxuZmxvYXQgdGhyZXNob2xkID0gbWF4dmFsICogY2xhbXAocXVhbGl0eSwgMC4wZiwgMS4wZik7XFxuY29sb3IgPSBwaXhlbDtcXG5jb2xvci5yYiA9IHNjb3JlID49IHRocmVzaG9sZCA/IGNvbG9yLnJiIDogZW5jb2RlRmxvYXQxNigwLjBmKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcInB5cmFtaWRzLmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG5AaW5jbHVkZSBcXFwiZmlsdGVycy5nbHNsXFxcIlxcbiNpZiAhZGVmaW5lZChXSU5ET1dfU0laRSlcXG4jZXJyb3IgVW5kZWZpbmVkIFdJTkRPV19TSVpFXFxuI2VuZGlmXFxuI2RlZmluZSBXSU5ET1dfUkFESVVTICgoV0lORE9XX1NJWkUgLSAxKSAvIDIpXFxudW5pZm9ybSBzYW1wbGVyMkQgY29ybmVycztcXG51bmlmb3JtIHNhbXBsZXIyRCBweXJhbWlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGRlcml2YXRpdmVzO1xcbnVuaWZvcm0gZmxvYXQgbG9kO1xcbnVuaWZvcm0gZmxvYXQgbG9kU3RlcDtcXG51bmlmb3JtIGZsb2F0IGdhdXNzaWFuW0BXSU5ET1dfU0laRUBdO1xcbiNkZWZpbmUgRyh4KSBnYXVzc2lhblsoeCkgKyBXSU5ET1dfUkFESVVTXVxcbiNkZWZpbmUgVyh4LHkpIChHKHgpICogRyh5KSlcXG4jZGVmaW5lIEgob3gsb3kpIGRwaXggPSBwaXhlbEF0U2hvcnRPZmZzZXQoZGVyaXZhdGl2ZXMsIGl2ZWMyKChveCksKG95KSkpOyBcXFxcXFxuZGYgPSAoMS4wZiArIGxvZCkgKiBkZWNvZGVQYWlyT2ZGbG9hdDE2KGRwaXgpOyBcXFxcXFxuaCArPSB2ZWMzKGRmLnggKiBkZi54LCBkZi54ICogZGYueSwgZGYueSAqIGRmLnkpICogVygob3gpLChveSkpXFxudm9pZCBtYWluKClcXG57XFxuZmxvYXQgaW50ZW5zaXR5ID0gMC4wZjtcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChjb3JuZXJzKTtcXG52ZWM0IGRwaXggPSB2ZWM0KDAuMGYpO1xcbnZlYzIgZGYgPSB2ZWMyKDAuMGYpO1xcbnZlYzMgaCA9IHZlYzMoMC4wZik7XFxuY29sb3IgPSBwaXhlbDtcXG4jaWYgV0lORE9XX1NJWkUgPT0gMVxcbkgoMCwwKTtcXG4jZWxpZiBXSU5ET1dfU0laRSA9PSAzXFxuSCgtMSwtMSk7IEgoMCwtMSk7IEgoMSwtMSk7XFxuSCgtMSwwKTsgSCgwLDApOyBIKDEsMCk7XFxuSCgtMSwxKTsgSCgwLDEpOyBIKDEsMSk7XFxuI2VsaWYgV0lORE9XX1NJWkUgPT0gNVxcbkgoLTIsLTIpOyBIKC0xLC0yKTsgSCgwLC0yKTsgSCgxLC0yKTsgSCgyLC0yKTtcXG5IKC0yLC0xKTsgSCgtMSwtMSk7IEgoMCwtMSk7IEgoMSwtMSk7IEgoMiwtMSk7XFxuSCgtMiwwKTsgSCgtMSwwKTsgSCgwLDApOyBIKDEsMCk7IEgoMiwwKTtcXG5IKC0yLDEpOyBIKC0xLDEpOyBIKDAsMSk7IEgoMSwxKTsgSCgyLDEpO1xcbkgoLTIsMik7IEgoLTEsMik7IEgoMCwyKTsgSCgxLDIpOyBIKDIsMik7XFxuI2VsaWYgV0lORE9XX1NJWkUgPT0gN1xcbkgoLTMsLTMpOyBIKC0yLC0zKTsgSCgtMSwtMyk7IEgoMCwtMyk7IEgoMSwtMyk7IEgoMiwtMyk7IEgoMywtMyk7XFxuSCgtMywtMik7IEgoLTIsLTIpOyBIKC0xLC0yKTsgSCgwLC0yKTsgSCgxLC0yKTsgSCgyLC0yKTsgSCgzLC0yKTtcXG5IKC0zLC0xKTsgSCgtMiwtMSk7IEgoLTEsLTEpOyBIKDAsLTEpOyBIKDEsLTEpOyBIKDIsLTEpOyBIKDMsLTEpO1xcbkgoLTMsMCk7IEgoLTIsMCk7IEgoLTEsMCk7IEgoMCwwKTsgSCgxLDApOyBIKDIsMCk7IEgoMywwKTtcXG5IKC0zLDEpOyBIKC0yLDEpOyBIKC0xLDEpOyBIKDAsMSk7IEgoMSwxKTsgSCgyLDEpOyBIKDMsMSk7XFxuSCgtMywyKTsgSCgtMiwyKTsgSCgtMSwyKTsgSCgwLDIpOyBIKDEsMik7IEgoMiwyKTsgSCgzLDIpO1xcbkgoLTMsMyk7IEgoLTIsMyk7IEgoLTEsMyk7IEgoMCwzKTsgSCgxLDMpOyBIKDIsMyk7IEgoMywzKTtcXG4jZWxzZVxcbiNlcnJvciBJbnZhbGlkIFdJTkRPV19TSVpFXFxuI2VuZGlmXFxuZmxvYXQgcmVzcG9uc2UgPSAwLjVmICogKGgueCArIGgueiAtIHNxcnQoKGgueCAtIGgueikgKiAoaC54IC0gaC56KSArIDQuMGYgKiBoLnkgKiBoLnkpKTtcXG5yZXNwb25zZSAvPSBmbG9hdChXSU5ET1dfU0laRSAqIFdJTkRPV19TSVpFKTtcXG5mbG9hdCBsb2RQbHVzID0gbWluKGZsb2F0KFBZUkFNSURfTUFYX0xFVkVMUyAtIDEpLCBsb2QgKyBsb2RTdGVwKTtcXG5mbG9hdCBjdXJyZW50U2NhbGVTdHJlbmd0aCA9IGFicyhsYXBsYWNpYW4ocHlyYW1pZCwgdmVjMih0aHJlYWQpLCBsb2QpKTtcXG5mbG9hdCBwcmV2aW91c1NjYWxlU3RyZW5ndGggPSBhYnMobGFwbGFjaWFuKHB5cmFtaWQsIHZlYzIodGhyZWFkKSwgbG9kUGx1cykpO1xcbmZsb2F0IHByZXZpb3VzUmVzcG9uc2UgPSBkZWNvZGVGbG9hdDE2KHBpeGVsLnJiKTtcXG52ZWM0IHJlc3VsdCA9IHZlYzQoZW5jb2RlRmxvYXQxNihyZXNwb25zZSksIGVuY29kZUxvZChsb2QpLCBpbnRlbnNpdHkpO1xcbmNvbG9yLnJiYWcgPSAoY3VycmVudFNjYWxlU3RyZW5ndGggPj0gcHJldmlvdXNTY2FsZVN0cmVuZ3RoIHx8IHByZXZpb3VzUmVzcG9uc2UgPT0gMC4wZikgPyByZXN1bHQgOiBwaXhlbC5yYmFnO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnQtbWF0Y2hlcy5nbHNsXFxcIlxcbnZvaWQgbWFpbigpXFxue1xcbiNpZiBFTkNPREVfRklMVEVSUyAhPSAwXFxuS2V5cG9pbnRNYXRjaCBpbml0aWFsID0gS2V5cG9pbnRNYXRjaChNQVRDSF9NQVhfSU5ERVgsIDApO1xcbiNlbHNlXFxuS2V5cG9pbnRNYXRjaCBpbml0aWFsID0gS2V5cG9pbnRNYXRjaChNQVRDSF9NQVhfSU5ERVgsIE1BVENIX01BWF9ESVNUQU5DRSk7XFxuI2VuZGlmXFxuY29sb3IgPSBlbmNvZGVLZXlwb2ludE1hdGNoKGluaXRpYWwpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnQtbWF0Y2hlcy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRNYXRjaGVzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLdGhNYXRjaGVzO1xcbnVuaWZvcm0gaW50IG51bWJlck9mTWF0Y2hlc1BlcktleXBvaW50O1xcbnVuaWZvcm0gaW50IGt0aE1hdGNoO1xcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaXZlYzIgbWF0Y2hlclNpemUgPSB0ZXh0dXJlU2l6ZShlbmNvZGVkTWF0Y2hlcywgMCk7XFxuaXZlYzIga3RoTWF0Y2hlclNpemUgPSB0ZXh0dXJlU2l6ZShlbmNvZGVkS3RoTWF0Y2hlcywgMCk7XFxuaW50IHJhc3RlckluZGV4ID0gdGhyZWFkLnkgKiBtYXRjaGVyU2l6ZS54ICsgdGhyZWFkLng7XFxuaW50IG1hdGNoSW5kZXggPSByYXN0ZXJJbmRleCAvIG51bWJlck9mTWF0Y2hlc1BlcktleXBvaW50O1xcbmludCBtYXRjaENlbGwgPSByYXN0ZXJJbmRleCAlIG51bWJlck9mTWF0Y2hlc1BlcktleXBvaW50O1xcbmNvbG9yID0gdGhyZWFkUGl4ZWwoZW5jb2RlZE1hdGNoZXMpO1xcbmlmKG1hdGNoQ2VsbCAhPSBrdGhNYXRjaClcXG5yZXR1cm47XFxuY29sb3IgPSBlbmNvZGVLZXlwb2ludE1hdGNoKE1BVENIX05PVF9GT1VORCk7XFxuaWYobWF0Y2hJbmRleCA+PSBrdGhNYXRjaGVyU2l6ZS54ICoga3RoTWF0Y2hlclNpemUueSlcXG5yZXR1cm47XFxuaXZlYzIgcG9zID0gaXZlYzIobWF0Y2hJbmRleCAlIGt0aE1hdGNoZXJTaXplLngsIG1hdGNoSW5kZXggLyBrdGhNYXRjaGVyU2l6ZS54KTtcXG5jb2xvciA9IHRleGVsRmV0Y2goZW5jb2RlZEt0aE1hdGNoZXMsIHBvcywgMCk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJweXJhbWlkcy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJmbG9hdDE2Lmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImZpbHRlcnMuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBjb3JuZXJzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHB5cmFtaWQ7XFxudW5pZm9ybSBmbG9hdCBsb2RTdGVwO1xcbnVuaWZvcm0gZmxvYXQgbG9kT2Zmc2V0O1xcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKGNvcm5lcnMpO1xcbmZsb2F0IGxvZCA9IGRlY29kZUxvZChwaXhlbC5hKTtcXG5mbG9hdCBsb2RNaW51cyA9IG1heCgwLjBmLCBsb2QgLSBsb2RTdGVwICsgbG9kT2Zmc2V0KTtcXG5mbG9hdCBsb2RQbHVzID0gbWluKGZsb2F0KFBZUkFNSURfTUFYX0xFVkVMUyAtIDEpLCBsb2QgKyBsb2RTdGVwICsgbG9kT2Zmc2V0KTtcXG5mbG9hdCBsYXBNaW51cyA9IGxhcGxhY2lhbihweXJhbWlkLCB2ZWMyKHRocmVhZCksIGxvZE1pbnVzKTtcXG5mbG9hdCBsYXBQbHVzID0gYWJzKGxvZFBsdXMgLSBsb2RNaW51cykgPCAxZS01ID8gbGFwTWludXMgOiBsYXBsYWNpYW4ocHlyYW1pZCwgdmVjMih0aHJlYWQpLCBsb2RQbHVzKTtcXG5jb2xvciA9IGVuY29kZVBhaXJPZkZsb2F0MTYodmVjMihsYXBNaW51cywgbGFwUGx1cykpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBuZXh0UHlyYW1pZDtcXG51bmlmb3JtIHNhbXBsZXIyRCBwcmV2UHlyYW1pZDtcXG51bmlmb3JtIHNhbXBsZXIyRCBlbmNvZGVkRmxvdztcXG51bmlmb3JtIHNhbXBsZXIyRCBwcmV2S2V5cG9pbnRzO1xcbnVuaWZvcm0gaW50IGxldmVsO1xcbnVuaWZvcm0gaW50IGRlcHRoO1xcbnVuaWZvcm0gaW50IG51bWJlck9mSXRlcmF0aW9ucztcXG51bmlmb3JtIGZsb2F0IGRpc2NhcmRUaHJlc2hvbGQ7XFxudW5pZm9ybSBmbG9hdCBlcHNpbG9uO1xcbnVuaWZvcm0gaW50IGRlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoO1xcbiNpZm5kZWYgV0lORE9XX1NJWkVcXG4jZXJyb3IgVW5kZWZpbmVkIFdJTkRPV19TSVpFXFxuI2VuZGlmXFxuI2RlZmluZSBORVhUX0lNQUdFIDFcXG4jZGVmaW5lIFBSRVZfSU1BR0UgMFxcbmNvbnN0IGludCBXSU5ET1dfUkFESVVTID0gKFdJTkRPV19TSVpFIC0gMSkgLyAyO1xcbmNvbnN0IGludCBXSU5ET1dfU0laRV9TUVVBUkVEID0gKFdJTkRPV19TSVpFKSAqIChXSU5ET1dfU0laRSk7XFxuY29uc3QgaW50IFdJTkRPV19TSVpFX1BMVVMgPSAoV0lORE9XX1NJWkUpICsgMjtcXG5jb25zdCBpbnQgV0lORE9XX1NJWkVfUExVU19TUVVBUkVEID0gV0lORE9XX1NJWkVfUExVUyAqIFdJTkRPV19TSVpFX1BMVVM7XFxuY29uc3QgaW50IERCTF9XSU5ET1dfU0laRV9QTFVTX1NRVUFSRUQgPSAyICogV0lORE9XX1NJWkVfUExVU19TUVVBUkVEO1xcbmNvbnN0IGludCBXSU5ET1dfUkFESVVTX1BMVVMgPSAoV0lORE9XX1NJWkVfUExVUyAtIDEpIC8gMjtcXG5jb25zdCBoaWdocCBmbG9hdCBGTFRfU0NBTEUgPSA5LjUzNjc0MzE2NDA2MjVlLTc7XFxuY29uc3QgaGlnaHAgZmxvYXQgRkxUX0VQU0lMT04gPSAwLjAwMDAwMDExOTIwOTI5ZjtcXG5pbnQgcGl4ZWxCdWZmZXJbREJMX1dJTkRPV19TSVpFX1BMVVNfU1FVQVJFRF07XFxuI2RlZmluZSBwcmV2UGl4ZWwoaW5kZXgpIHBpeGVsQnVmZmVyWyhpbmRleCldXFxuI2RlZmluZSBuZXh0UGl4ZWwoaW5kZXgpIHBpeGVsQnVmZmVyW1dJTkRPV19TSVpFX1BMVVNfU1FVQVJFRCArIChpbmRleCldXFxuI2RlZmluZSBwaXhlbEluZGV4KGksIGopICgoKGopICsgV0lORE9XX1JBRElVU19QTFVTKSAqIFdJTkRPV19TSVpFX1BMVVMgKyAoKGkpICsgV0lORE9XX1JBRElVU19QTFVTKSlcXG5pdmVjMiBkZXJpdkJ1ZmZlcltXSU5ET1dfU0laRV9TUVVBUkVEXTtcXG4jZGVmaW5lIGRlcml2YXRpdmVzQXQoeCwgeSkgZGVyaXZCdWZmZXJbKCh5KSArIFdJTkRPV19SQURJVVMpICogV0lORE9XX1NJWkUgKyAoKHgpICsgV0lORE9XX1JBRElVUyldXFxudm9pZCByZWFkV2luZG93KHZlYzIgY2VudGVyLCBmbG9hdCBsb2QpXFxue1xcbmNvbnN0IGludCByID0gV0lORE9XX1JBRElVUztcXG5pdmVjMiBweXJCYXNlU2l6ZSA9IHRleHR1cmVTaXplKHByZXZQeXJhbWlkLCAwKTtcXG5mbG9hdCBwb3QgPSBleHAyKGxvZCk7XFxuaXZlYzIgb2Zmc2V0OyBpbnQgaWR4O1xcbiNkZWZpbmUgcmVhZFBpeGVsc0F0KG94LCBveSkgb2Zmc2V0ID0gaXZlYzIoKG94KSwgKG95KSk7IFxcXFxcXG5pZHggPSBwaXhlbEluZGV4KG9mZnNldC54LCBvZmZzZXQueSk7IFxcXFxcXG5uZXh0UGl4ZWwoaWR4KSA9IGludCgyNTUuMGYgKiBweXJTdWJwaXhlbEF0RXhPZmZzZXQobmV4dFB5cmFtaWQsIGNlbnRlciwgbG9kLCBwb3QsIG9mZnNldCwgcHlyQmFzZVNpemUpLmcpOyBcXFxcXFxucHJldlBpeGVsKGlkeCkgPSBpbnQoMjU1LjBmICogcHlyU3VicGl4ZWxBdEV4T2Zmc2V0KHByZXZQeXJhbWlkLCBjZW50ZXIsIGxvZCwgcG90LCBvZmZzZXQsIHB5ckJhc2VTaXplKS5nKVxcbmZvcihpbnQgaiA9IDA7IGogPCBXSU5ET1dfU0laRTsgaisrKSB7XFxuZm9yKGludCBpID0gMDsgaSA8IFdJTkRPV19TSVpFOyBpKyspIHtcXG5yZWFkUGl4ZWxzQXQoaS1yLCBqLXIpO1xcbn1cXG59XFxuaW50IHIxID0gcisxO1xcbmZvcihpbnQgayA9IDA7IGsgPCBXSU5ET1dfU0laRTsgaysrKSB7XFxucmVhZFBpeGVsc0F0KC1yMSwgay1yKTtcXG5yZWFkUGl4ZWxzQXQoIHIxLCBrLXIpO1xcbnJlYWRQaXhlbHNBdChrLXIsLXIxKTtcXG5yZWFkUGl4ZWxzQXQoay1yLCByMSk7XFxufVxcbnJlYWRQaXhlbHNBdCgtcjEsLXIxKTtcXG5yZWFkUGl4ZWxzQXQoIHIxLC1yMSk7XFxucmVhZFBpeGVsc0F0KC1yMSwgcjEpO1xcbnJlYWRQaXhlbHNBdCggcjEsIHIxKTtcXG59XFxuaXZlYzIgY29tcHV0ZURlcml2YXRpdmVzKGludCBpbWFnZUNvZGUsIGl2ZWMyIG9mZnNldClcXG57XFxuY29uc3QgbWF0MyBkeCA9IG1hdDMoXFxuMywgMCwgLTMsXFxuMTAsIDAsIC0xMCxcXG4zLCAwLCAtM1xcbik7XFxuY29uc3QgbWF0MyBkeSA9IG1hdDMoXFxuMywgMTAsIDMsXFxuMCwgMCwgMCxcXG4tMywgLTEwLCAtM1xcbik7XFxuaW50IGluZGV4T2Zmc2V0ID0gaW1hZ2VDb2RlICogV0lORE9XX1NJWkVfUExVU19TUVVBUkVEO1xcbm1hdDMgd2luZG93ID0gbWF0MyhcXG5waXhlbEJ1ZmZlcltpbmRleE9mZnNldCArIHBpeGVsSW5kZXgob2Zmc2V0LngtMSwgb2Zmc2V0LnktMSldLFxcbnBpeGVsQnVmZmVyW2luZGV4T2Zmc2V0ICsgcGl4ZWxJbmRleChvZmZzZXQueCswLCBvZmZzZXQueS0xKV0sXFxucGl4ZWxCdWZmZXJbaW5kZXhPZmZzZXQgKyBwaXhlbEluZGV4KG9mZnNldC54KzEsIG9mZnNldC55LTEpXSxcXG5waXhlbEJ1ZmZlcltpbmRleE9mZnNldCArIHBpeGVsSW5kZXgob2Zmc2V0LngtMSwgb2Zmc2V0LnkrMCldLFxcbjAuMGYsXFxucGl4ZWxCdWZmZXJbaW5kZXhPZmZzZXQgKyBwaXhlbEluZGV4KG9mZnNldC54KzEsIG9mZnNldC55KzApXSxcXG5waXhlbEJ1ZmZlcltpbmRleE9mZnNldCArIHBpeGVsSW5kZXgob2Zmc2V0LngtMSwgb2Zmc2V0LnkrMSldLFxcbnBpeGVsQnVmZmVyW2luZGV4T2Zmc2V0ICsgcGl4ZWxJbmRleChvZmZzZXQueCswLCBvZmZzZXQueSsxKV0sXFxucGl4ZWxCdWZmZXJbaW5kZXhPZmZzZXQgKyBwaXhlbEluZGV4KG9mZnNldC54KzEsIG9mZnNldC55KzEpXVxcbik7XFxubWF0MyBmeCA9IG1hdHJpeENvbXBNdWx0KGR4LCB3aW5kb3cpO1xcbm1hdDMgZnkgPSBtYXRyaXhDb21wTXVsdChkeSwgd2luZG93KTtcXG5jb25zdCB2ZWMzIG9uZXMgPSB2ZWMzKDEuMGYpO1xcbnJldHVybiBpdmVjMihcXG5kb3QoZnhbMF0sIG9uZXMpICsgZG90KGZ4WzFdLCBvbmVzKSArIGRvdChmeFsyXSwgb25lcyksXFxuZG90KGZ5WzBdLCBvbmVzKSArIGRvdChmeVsxXSwgb25lcykgKyBkb3QoZnlbMl0sIG9uZXMpXFxuKTtcXG59XFxuaW50IHJlYWRCdWZmZXJlZFBpeGVsKGludCBpbWFnZUNvZGUsIGl2ZWMyIG9mZnNldClcXG57XFxuY29uc3QgaW50IHIgPSBXSU5ET1dfUkFESVVTO1xcbm9mZnNldCA9IGNsYW1wKG9mZnNldCwgLXIsIHIpO1xcbmludCBpbmRleE9mZnNldCA9IGltYWdlQ29kZSAqIFdJTkRPV19TSVpFX1BMVVNfU1FVQVJFRDtcXG5yZXR1cm4gcGl4ZWxCdWZmZXJbaW5kZXhPZmZzZXQgKyBwaXhlbEluZGV4KG9mZnNldC54LCBvZmZzZXQueSldO1xcbn1cXG5pbnQgcmVhZEJ1ZmZlcmVkU3VicGl4ZWwoaW50IGltYWdlQ29kZSwgdmVjMiBvZmZzZXQpXFxue1xcbml2ZWMyIHAgPSBpdmVjMihmbG9vcihvZmZzZXQpKTtcXG52ZWMyIGZyYyA9IGZyYWN0KG9mZnNldCk7XFxudmVjMiBpZnJjID0gdmVjMigxLjBmKSAtIGZyYztcXG52ZWM0IHBpeCA9IHZlYzQoXFxucmVhZEJ1ZmZlcmVkUGl4ZWwoaW1hZ2VDb2RlLCBwKSxcXG5yZWFkQnVmZmVyZWRQaXhlbChpbWFnZUNvZGUsIHAgKyBpdmVjMigxLDApKSxcXG5yZWFkQnVmZmVyZWRQaXhlbChpbWFnZUNvZGUsIHAgKyBpdmVjMigwLDEpKSxcXG5yZWFkQnVmZmVyZWRQaXhlbChpbWFnZUNvZGUsIHAgKyBpdmVjMigxLDEpKVxcbik7XFxudmVjNCBzdWIgPSB2ZWM0KFxcbmlmcmMueCAqIGlmcmMueSxcXG5mcmMueCAqIGlmcmMueSxcXG5pZnJjLnggKiBmcmMueSxcXG5mcmMueCAqIGZyYy55XFxuKTtcXG5yZXR1cm4gaW50KDAuNWYgKyBkb3Qoc3ViKnBpeCwgdmVjNCgxLjBmKSkpO1xcbn1cXG52ZWMyIGNvbXB1dGVNaXNtYXRjaCh2ZWMyIHB5ckd1ZXNzLCB2ZWMyIGxvY2FsR3Vlc3MpXFxue1xcbmNvbnN0IGludCByID0gV0lORE9XX1JBRElVUztcXG5pbnQgdGltZURlcml2YXRpdmU7XFxuaXZlYzIgbWlzbWF0Y2ggPSBpdmVjMigwKTtcXG5pbnQgeCwgeSwgX3gsIF95O1xcbnZlYzIgZCA9IHB5ckd1ZXNzICsgbG9jYWxHdWVzcztcXG4jZGVmaW5lIGlubmVyTG9vcCgpIFxcXFxcXG5mb3IoX3ggPSAwOyBfeCA8IFdJTkRPV19TSVpFOyBfeCsrKSB7IFxcXFxcXG54ID0gX3ggLSByOyB5ID0gX3kgLSByOyBcXFxcXFxudGltZURlcml2YXRpdmUgPSAoIFxcXFxcXG5yZWFkQnVmZmVyZWRTdWJwaXhlbChORVhUX0lNQUdFLCB2ZWMyKHgsIHkpICsgZCkgLSBcXFxcXFxucmVhZEJ1ZmZlcmVkUGl4ZWwoUFJFVl9JTUFHRSwgaXZlYzIoeCwgeSkpIFxcXFxcXG4pOyBcXFxcXFxubWlzbWF0Y2ggKz0gZGVyaXZhdGl2ZXNBdCh4LCB5KSAqIHRpbWVEZXJpdmF0aXZlOyBcXFxcXFxufVxcbkB1bnJvbGxcXG5mb3IoX3kgPSAwOyBfeSA8IFdJTkRPV19TSVpFOyBfeSsrKSB7XFxuaW5uZXJMb29wKCk7XFxufVxcbnJldHVybiB2ZWMyKG1pc21hdGNoKSAqIEZMVF9TQ0FMRTtcXG59XFxuYm9vbCBpc0luc2lkZUltYWdlKHZlYzIgcG9zaXRpb24pXFxue1xcbnZlYzIgaW1hZ2VTaXplID0gdmVjMih0ZXh0dXJlU2l6ZShuZXh0UHlyYW1pZCwgMCkpO1xcbnZlYzIgYm9yZGVyID0gdmVjMihXSU5ET1dfU0laRSk7XFxucmV0dXJuIGFsbChidmVjNChcXG5ncmVhdGVyVGhhbkVxdWFsKHBvc2l0aW9uLCBib3JkZXIpLFxcbmxlc3NUaGFuKHBvc2l0aW9uLCBpbWFnZVNpemUgLSBib3JkZXIpXFxuKSk7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChlbmNvZGVkRmxvdyk7XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5mbG9hdCB3aW5kb3dBcmVhID0gZmxvYXQoV0lORE9XX1NJWkUgKiBXSU5ET1dfU0laRSk7XFxuY29uc3QgaW50IHIgPSBXSU5ET1dfUkFESVVTO1xcbmludCBrZXlwb2ludEluZGV4ID0gdGhyZWFkLnggKyB0aHJlYWQueSAqIG91dHB1dFNpemUoKS54O1xcbmludCBwaXhlbHNQZXJLZXlwb2ludCA9IHNpemVvZkVuY29kZWRLZXlwb2ludChkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKSAvIDQ7XFxuS2V5cG9pbnRBZGRyZXNzIGFkZHJlc3MgPSBLZXlwb2ludEFkZHJlc3Moa2V5cG9pbnRJbmRleCAqIHBpeGVsc1BlcktleXBvaW50LCAwKTtcXG5LZXlwb2ludCBrZXlwb2ludCA9IGRlY29kZUtleXBvaW50KHByZXZLZXlwb2ludHMsIGVuY29kZXJMZW5ndGgsIGFkZHJlc3MpO1xcbmNvbG9yID0gZW5jb2RlTnVsbFBhaXJPZkZsb2F0MTYoKTtcXG5pZihpc051bGxLZXlwb2ludChrZXlwb2ludCkpXFxucmV0dXJuO1xcbmNvbG9yID0gZW5jb2RlRGlzY2FyZGVkUGFpck9mRmxvYXQxNigpO1xcbmlmKGlzQmFkS2V5cG9pbnQoa2V5cG9pbnQpKVxcbnJldHVybjtcXG52ZWMyIHB5ckd1ZXNzID0gKGxldmVsIDwgZGVwdGggLSAxKSA/IGRlY29kZVBhaXJPZkZsb2F0MTYocGl4ZWwpIDogdmVjMigwLjBmKTtcXG5weXJHdWVzcyAqPSAyLjBmO1xcbnJlYWRXaW5kb3coa2V5cG9pbnQucG9zaXRpb24sIGZsb2F0KGxldmVsKSk7XFxuaXZlYzIgZGVyaXZhdGl2ZXM7XFxuaXZlYzMgaGFycmlzM2kgPSBpdmVjMygwKTtcXG5mb3IoaW50IGogPSAwOyBqIDwgV0lORE9XX1NJWkU7IGorKykge1xcbmZvcihpbnQgaSA9IDA7IGkgPCBXSU5ET1dfU0laRTsgaSsrKSB7XFxuZGVyaXZhdGl2ZXMgPSBjb21wdXRlRGVyaXZhdGl2ZXMoUFJFVl9JTUFHRSwgaXZlYzIoaS1yLCBqLXIpKTtcXG5oYXJyaXMzaSArPSBpdmVjMyhcXG5kZXJpdmF0aXZlcy54ICogZGVyaXZhdGl2ZXMueCxcXG5kZXJpdmF0aXZlcy54ICogZGVyaXZhdGl2ZXMueSxcXG5kZXJpdmF0aXZlcy55ICogZGVyaXZhdGl2ZXMueVxcbik7XFxuZGVyaXZhdGl2ZXNBdChpLXIsIGotcikgPSBkZXJpdmF0aXZlcztcXG59XFxufVxcbmhpZ2hwIHZlYzMgaGFycmlzID0gdmVjMyhoYXJyaXMzaSkgKiBGTFRfU0NBTEU7XFxuaGlnaHAgbWF0MiBpbnZIYXJyaXMgPSBtYXQyKGhhcnJpcy56LCAtaGFycmlzLnksIC1oYXJyaXMueSwgaGFycmlzLngpO1xcbmhpZ2hwIGZsb2F0IGRldCA9IGhhcnJpcy54ICogaGFycmlzLnogLSBoYXJyaXMueSAqIGhhcnJpcy55O1xcbmhpZ2hwIGZsb2F0IGludkRldCA9IGFicyhkZXQpID49IEZMVF9FUFNJTE9OID8gMS4wZiAvIGRldCA6IDAuMGY7XFxuaGlnaHAgZmxvYXQgbWluRWlnZW52YWx1ZSA9IDAuNWYgKiAoKGhhcnJpcy54ICsgaGFycmlzLnopIC0gc3FydChcXG4oaGFycmlzLnggLSBoYXJyaXMueikgKiAoaGFycmlzLnggLSBoYXJyaXMueikgKyA0LjBmICogKGhhcnJpcy55ICogaGFycmlzLnkpXFxuKSk7XFxuaW50IG5pY2VOdW1iZXJzID0gaW50KGFicyhkZXQpID49IEZMVF9FUFNJTE9OICYmIG1pbkVpZ2VudmFsdWUgPj0gZGlzY2FyZFRocmVzaG9sZCAqIHdpbmRvd0FyZWEpO1xcbmJvb2wgZ29vZEtleXBvaW50ID0gKGxldmVsID4gMCkgfHwgKG5pY2VOdW1iZXJzICE9IDApO1xcbmhpZ2hwIGZsb2F0IGVwczIgPSBlcHNpbG9uICogZXBzaWxvbjtcXG5oaWdocCB2ZWMyIG1pc21hdGNoLCBkZWx0YSwgbG9jYWxHdWVzcyA9IHZlYzIoMC4wZik7XFxuZm9yKGludCBrID0gMDsgayA8IG51bWJlck9mSXRlcmF0aW9uczsgaysrKSB7XFxubWlzbWF0Y2ggPSBuaWNlTnVtYmVycyAhPSAwID8gY29tcHV0ZU1pc21hdGNoKHB5ckd1ZXNzLCBsb2NhbEd1ZXNzKSA6IHZlYzIoMC4wZik7XFxuZGVsdGEgPSBtaXNtYXRjaCAqIGludkhhcnJpcyAqIGludkRldDtcXG5uaWNlTnVtYmVycyAqPSBpbnQoZXBzMiA8PSBkb3QoZGVsdGEsIGRlbHRhKSk7XFxubG9jYWxHdWVzcyArPSBmbG9hdChuaWNlTnVtYmVycykgKiBkZWx0YTtcXG59XFxudmVjMiBvcHRpY2FsRmxvdyA9IHB5ckd1ZXNzICsgbG9jYWxHdWVzcztcXG5ib29sIG11c3REaXNjYXJkID0gKGxldmVsID09IDApICYmIGFueShidmVjMihcXG4hZ29vZEtleXBvaW50LFxcbiFpc0luc2lkZUltYWdlKGtleXBvaW50LnBvc2l0aW9uICsgb3B0aWNhbEZsb3cpXFxuKSk7XFxuY29sb3IgPSAhbXVzdERpc2NhcmQgPyBlbmNvZGVQYWlyT2ZGbG9hdDE2KG9wdGljYWxGbG93KSA6IGVuY29kZURpc2NhcmRlZFBhaXJPZkZsb2F0MTYoKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2lmIEBGU19VU0VfQ1VTVE9NX1BSRUNJU0lPTkBcXG5wcmVjaXNpb24gbWVkaXVtcCBpbnQ7XFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuI2lmICFkZWZpbmVkKFNUQUdFKVxcbiNlcnJvciBVbmRlZmluZWQgU1RBR0VcXG4jZWxpZiBTVEFHRSA9PSAxXFxuQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBjb3JuZXJzO1xcbiNlbGlmIFNUQUdFIDwgMVxcbnVuaWZvcm0gbWVkaXVtcCB1c2FtcGxlcjJEIGxvb2t1cFRhYmxlO1xcbiNlbHNlXFxuI2RlZmluZSBTS0lQX1RFWFRVUkVfUkVBRFMgMVxcbiNkZWZpbmUgREVOU0lUWV9GQUNUT1IgMC4xMFxcbnVuaWZvcm0gbWVkaXVtcCB1c2FtcGxlcjJEIGxvb2t1cFRhYmxlO1xcbnVuaWZvcm0gaW50IGJsb2NrU2l6ZTtcXG51bmlmb3JtIGludCB3aWR0aDtcXG51bmlmb3JtIGludCBoZWlnaHQ7XFxuaW4gdmVjMiB2X3RvcExlZnQsIHZfdG9wLCB2X3RvcFJpZ2h0LFxcbnZfbGVmdCwgdl9jZW50ZXIsIHZfcmlnaHQsXFxudl9ib3R0b21MZWZ0LCB2X2JvdHRvbSwgdl9ib3R0b21SaWdodDtcXG4jZW5kaWZcXG5jb25zdCB1dmVjMiBOVUxMX0VMRU1FTlQgPSB1dmVjMigweEZGRkZ1KTtcXG52b2lkIG1haW4oKVxcbntcXG4jaWYgU1RBR0UgPT0gMVxcbnV2ZWMyIG91dFNpemUgPSB1dmVjMihvdXRwdXRTaXplKCkpO1xcbnV2ZWMyIHRocmVhZCA9IHV2ZWMyKHRocmVhZExvY2F0aW9uKCkpO1xcbnV2ZWMyIHNpemUgPSB1dmVjMih0ZXh0dXJlU2l6ZShjb3JuZXJzLCAwKSk7XFxudWludCBsb2NhdGlvbiA9IHRocmVhZC55ICogb3V0U2l6ZS54ICsgdGhyZWFkLng7XFxuaXZlYzIgcG9zID0gaXZlYzIobG9jYXRpb24gJSBzaXplLngsIGxvY2F0aW9uIC8gc2l6ZS54KTtcXG52ZWM0IHBpeGVsID0gbG9jYXRpb24gPCBzaXplLnggKiBzaXplLnkgPyB0ZXhlbEZldGNoKGNvcm5lcnMsIHBvcywgMCkgOiB2ZWM0KDAuMGYpO1xcbmJvb2wgaXNDb3JuZXIgPSAhaXNFbmNvZGVkRmxvYXQxNlplcm8ocGl4ZWwucmIpO1xcbmNvbG9yID0gaXNDb3JuZXIgPyB1dmVjNCh1dmVjMihwb3MpLCAxdSwgMHUpIDogdXZlYzQoTlVMTF9FTEVNRU5ULCAwdSwgMHUpO1xcbiNlbGlmIFNUQUdFID4gMVxcbmludCBkYmxCbG9ja1NpemUgPSAyICogYmxvY2tTaXplO1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaXZlYzIgb2Zmc2V0ID0gdGhyZWFkICUgZGJsQmxvY2tTaXplO1xcbml2ZWMyIGRlbHRhID0gdGhyZWFkIC0gb2Zmc2V0O1xcbiNpZiBTS0lQX1RFWFRVUkVfUkVBRFNcXG5pZihibG9ja1NpemUgPj0gOCkge1xcbnVpbnQgc2IgPSB0ZXh0dXJlKGxvb2t1cFRhYmxlLCB0ZXhDb29yZCkuejtcXG5mbG9hdCBwID0gbWF4KChmbG9hdChzYikgLyBmbG9hdChibG9ja1NpemUpKSAvIGZsb2F0KGJsb2NrU2l6ZSksIERFTlNJVFlfRkFDVE9SKTtcXG5mbG9hdCByb3d0aHIgPSBmbG9hdChkYmxCbG9ja1NpemUpICogcCArIDMuMGYgKiBzcXJ0KHAgKiAoMS4wZiAtIHApKTtcXG5jb2xvciA9IHV2ZWM0KE5VTExfRUxFTUVOVCwgNHUgKiBzYiwgMHUpO1xcbmlmKG9mZnNldC55ID49IG1heCgxLCBpbnQoY2VpbChyb3d0aHIpKSkpXFxucmV0dXJuO1xcbn1cXG4jZW5kaWZcXG4jZGVmaW5lIGRlbHRhQ2VudGVyIGl2ZWMyKDAsMClcXG4jZGVmaW5lIGRlbHRhVG9wIGl2ZWMyKDAsLWJsb2NrU2l6ZSlcXG4jZGVmaW5lIGRlbHRhVG9wUmlnaHQgaXZlYzIoYmxvY2tTaXplLC1ibG9ja1NpemUpXFxuI2RlZmluZSBkZWx0YVJpZ2h0IGl2ZWMyKGJsb2NrU2l6ZSwwKVxcbiNkZWZpbmUgZGVsdGFCb3R0b21SaWdodCBpdmVjMihibG9ja1NpemUsYmxvY2tTaXplKVxcbiNkZWZpbmUgZGVsdGFCb3R0b20gaXZlYzIoMCxibG9ja1NpemUpXFxuI2RlZmluZSBkZWx0YUJvdHRvbUxlZnQgaXZlYzIoLWJsb2NrU2l6ZSxibG9ja1NpemUpXFxuI2RlZmluZSBkZWx0YUxlZnQgaXZlYzIoLWJsb2NrU2l6ZSwwKVxcbiNkZWZpbmUgZGVsdGFUb3BMZWZ0IGl2ZWMyKC1ibG9ja1NpemUsLWJsb2NrU2l6ZSlcXG5pdmVjMiBib3VuZGFyeSA9IGl2ZWMyKHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSkgLyBibG9ja1NpemU7XFxuaXZlYzIgYm90dG9tUmlnaHRQb3MgPSB0aHJlYWQgKyBkZWx0YUJvdHRvbVJpZ2h0O1xcbnV2ZWMyIHZhbGlkID0gdXZlYzIoXFxuYm90dG9tUmlnaHRQb3MueCA8IHdpZHRoICB8fCBib3R0b21SaWdodFBvcy54IC8gYmxvY2tTaXplID09IGJvdW5kYXJ5LngsXFxuYm90dG9tUmlnaHRQb3MueSA8IGhlaWdodCB8fCBib3R0b21SaWdodFBvcy55IC8gYmxvY2tTaXplID09IGJvdW5kYXJ5LnlcXG4pO1xcbnV2ZWM0IG1hc2tbNF0gPSB1dmVjNFs0XShcXG51dmVjNCgxdSwgdmFsaWQueCwgdmFsaWQueSwgdmFsaWQueCAqIHZhbGlkLnkpLFxcbnV2ZWM0KDF1LCAxdSwgdmFsaWQueSwgdmFsaWQueSksXFxudXZlYzQoMXUsIHZhbGlkLngsIDF1LCB2YWxpZC54KSxcXG51dmVjNCgxdSlcXG4pO1xcbiNpZiBTS0lQX1RFWFRVUkVfUkVBRFNcXG4jZGVmaW5lIGNhbGNTYihkZWx0YSkgdGV4ZWxGZXRjaChsb29rdXBUYWJsZSwgYmxvY2tTaXplICogKCh0aHJlYWQgKyAoZGVsdGEpKSAvIGJsb2NrU2l6ZSksIDApLnpcXG51aW50IGNlbnRlciA9IGNhbGNTYihkZWx0YUNlbnRlcik7XFxudWludCB0b3AgPSBjYWxjU2IoZGVsdGFUb3ApO1xcbnVpbnQgdG9wUmlnaHQgPSBjYWxjU2IoZGVsdGFUb3BSaWdodCk7XFxudWludCByaWdodCA9IGNhbGNTYihkZWx0YVJpZ2h0KTtcXG51aW50IGJvdHRvbVJpZ2h0ID0gY2FsY1NiKGRlbHRhQm90dG9tUmlnaHQpO1xcbnVpbnQgYm90dG9tID0gY2FsY1NiKGRlbHRhQm90dG9tKTtcXG51aW50IGJvdHRvbUxlZnQgPSBjYWxjU2IoZGVsdGFCb3R0b21MZWZ0KTtcXG51aW50IGxlZnQgPSBjYWxjU2IoZGVsdGFMZWZ0KTtcXG51aW50IHRvcExlZnQgPSBjYWxjU2IoZGVsdGFUb3BMZWZ0KTtcXG4jZWxzZVxcbiNkZWZpbmUgY2FsY1NiKHBvcykgdGV4dHVyZShsb29rdXBUYWJsZSwgKHBvcykpLnpcXG51aW50IGNlbnRlciA9IGNhbGNTYih2X2NlbnRlcik7XFxudWludCB0b3AgPSBjYWxjU2Iodl90b3ApO1xcbnVpbnQgdG9wUmlnaHQgPSBjYWxjU2Iodl90b3BSaWdodCk7XFxudWludCByaWdodCA9IGNhbGNTYih2X3JpZ2h0KTtcXG51aW50IGJvdHRvbVJpZ2h0ID0gY2FsY1NiKHZfYm90dG9tUmlnaHQpO1xcbnVpbnQgYm90dG9tID0gY2FsY1NiKHZfYm90dG9tKTtcXG51aW50IGJvdHRvbUxlZnQgPSBjYWxjU2Iodl9ib3R0b21MZWZ0KTtcXG51aW50IGxlZnQgPSBjYWxjU2Iodl9sZWZ0KTtcXG51aW50IHRvcExlZnQgPSBjYWxjU2Iodl90b3BMZWZ0KTtcXG4jZW5kaWZcXG51dmVjNCBzdW1zWzRdID0gdXZlYzRbNF0oXFxudXZlYzQoY2VudGVyLCByaWdodCwgYm90dG9tLCBib3R0b21SaWdodCksXFxudXZlYzQobGVmdCwgY2VudGVyLCBib3R0b21MZWZ0LCBib3R0b20pLFxcbnV2ZWM0KHRvcCwgdG9wUmlnaHQsIGNlbnRlciwgcmlnaHQpLFxcbnV2ZWM0KHRvcExlZnQsIHRvcCwgbGVmdCwgY2VudGVyKVxcbik7XFxuaXZlYzIgY21wID0gaXZlYzIoZ3JlYXRlclRoYW5FcXVhbChvZmZzZXQsIGl2ZWMyKGJsb2NrU2l6ZSkpKTtcXG5pbnQgb3B0aW9uID0gMiAqIGNtcC55ICsgY21wLng7XFxudXZlYzQgY2RlZiA9IHN1bXNbb3B0aW9uXSAqIG1hc2tbb3B0aW9uXTtcXG51aW50IGMyYiA9IGNkZWYueCwgZDJiID0gY2RlZi55LCBlMmIgPSBjZGVmLnosIGYyYiA9IGNkZWYudztcXG51aW50IHNiID0gY2VudGVyO1xcbnVpbnQgczJiID0gYzJiICsgZDJiICsgZTJiICsgZjJiO1xcbnMyYiA9IHMyYiA8IHNiID8gMHhGRkZGdSA6IG1pbigweEZGRkZ1LCBzMmIpO1xcbnVpbnQgdzJiID0gdWludChtaW4oZGJsQmxvY2tTaXplLCB3aWR0aCAtIGRlbHRhLngpKTtcXG51dmVjMiB1b2Zmc2V0ID0gdXZlYzIob2Zmc2V0KTtcXG51aW50IGNlaWxpbmcgPSBzMmIgPj0gdW9mZnNldC54ID8gKHMyYiAtIHVvZmZzZXQueCkgLyB3MmIgKyB1aW50KChzMmIgLSB1b2Zmc2V0LngpICUgdzJiID4gMHUpIDogMHU7XFxuY29sb3IgPSB1dmVjNChOVUxMX0VMRU1FTlQsIHMyYiwgMHUpO1xcbmlmKHVvZmZzZXQueSA+PSBjZWlsaW5nKVxcbnJldHVybjtcXG51aW50IGkyYiA9IHVvZmZzZXQueSAqIHcyYiArIHVvZmZzZXQueDtcXG51aW50IGoyYiA9IGkyYiA+PSBjMmIgPyBpMmIgLSBjMmIgOiAwdTtcXG51aW50IGsyYiA9IGoyYiA+PSBkMmIgPyBqMmIgLSBkMmIgOiAwdTtcXG51aW50IGwyYiA9IGsyYiA+PSBlMmIgPyBrMmIgLSBlMmIgOiAwdTtcXG51aW50IHdsID0gdWludChtaW4oYmxvY2tTaXplLCB3aWR0aCAtIGRlbHRhLngpKTtcXG51aW50IHdyID0gdWludChtaW4oYmxvY2tTaXplLCB3aWR0aCAtIGRlbHRhLnggLSBibG9ja1NpemUpKTtcXG5pdmVjMiBtYWdpY09mZnNldCA9IChcXG4oaTJiIDwgYzJiKSA/IGl2ZWMyKGkyYiAlIHdsLCBpMmIgLyB3bCkgOiAoXFxuKGoyYiA8IGQyYikgPyBpdmVjMihqMmIgJSB3ciwgajJiIC8gd3IpICsgaXZlYzIoYmxvY2tTaXplLCAwKSA6IChcXG4oazJiIDwgZTJiKSA/IGl2ZWMyKGsyYiAlIHdsLCBrMmIgLyB3bCkgKyBpdmVjMigwLCBibG9ja1NpemUpIDogKFxcbihsMmIgPCBmMmIpID8gaXZlYzIobDJiICUgd3IsIGwyYiAvIHdyKSArIGl2ZWMyKGJsb2NrU2l6ZSkgOiBpdmVjMigwKVxcbikpKSk7XFxudXZlYzIgYTJiID0gdGV4ZWxGZXRjaChsb29rdXBUYWJsZSwgZGVsdGEgKyBtYWdpY09mZnNldCwgMCkueHk7XFxuY29sb3IgPSB1dmVjNChhMmIsIHMyYiwgMHUpO1xcbiNlbHNlXFxudXZlYzQgcGl4ID0gdGV4dHVyZShsb29rdXBUYWJsZSwgdGV4Q29vcmQpO1xcbmNvbG9yID0gYWxsKGVxdWFsKHBpeC54eSwgTlVMTF9FTEVNRU5UKSkgPyB2ZWM0KDAsMSwxLDEpIDogdmVjNCgxLDAsMCwxKTtcXG4jZW5kaWZcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2lmICFkZWZpbmVkKFNUQUdFKSB8fCBTVEFHRSA8IDFcXG4jZXJyb3IgSW52YWxpZCBTVEFHRVxcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIGludCBibG9ja1NpemU7XFxub3V0IHZlYzIgdl90b3BMZWZ0LCB2X3RvcCwgdl90b3BSaWdodCxcXG52X2xlZnQsIHZfY2VudGVyLCB2X3JpZ2h0LFxcbnZfYm90dG9tTGVmdCwgdl9ib3R0b20sIHZfYm90dG9tUmlnaHQ7XFxudm9pZCB2c21haW4oKVxcbntcXG5mbG9hdCBiID0gZmxvYXQoYmxvY2tTaXplKTtcXG4jZGVmaW5lIFYoeCx5KSAodGV4Q29vcmQgKyAodmVjMigoeCksKHkpKSAqIGIpIC8gdGV4U2l6ZSlcXG52X3RvcExlZnQgPSBWKC0xLC0xKTsgdl90b3AgPSBWKDAsLTEpOyB2X3RvcFJpZ2h0ID0gVigxLC0xKTtcXG52X2xlZnQgPSBWKC0xLDApOyB2X2NlbnRlciA9IFYoMCwwKTsgdl9yaWdodCA9IFYoMSwwKTtcXG52X2JvdHRvbUxlZnQgPSBWKC0xLDEpOyB2X2JvdHRvbSA9IFYoMCwxKTsgdl9ib3R0b21SaWdodCA9IFYoMSwxKTtcXG59XFxuI2VuZGlmXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJrZXlwb2ludC1tYXRjaGVzLmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImtleXBvaW50LWRlc2NyaXB0b3JzLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgY2FuZGlkYXRlcztcXG51bmlmb3JtIHNhbXBsZXIyRCBmaWx0ZXJzO1xcbnVuaWZvcm0gaW50IG1hdGNoZXJMZW5ndGg7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGFibGVzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGRlc2NyaXB0b3JEQjtcXG51bmlmb3JtIGludCB0YWJsZUluZGV4O1xcbnVuaWZvcm0gaW50IGJ1Y2tldENhcGFjaXR5O1xcbnVuaWZvcm0gaW50IGJ1Y2tldHNQZXJUYWJsZTtcXG51bmlmb3JtIGludCB0YWJsZXNTdHJpZGU7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvckRCU3RyaWRlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxuI2lmIEhBU0hfU0laRSA+IFNFUVVFTkNFX01BWExFTlxcbiNlcnJvciBMU0g6IGludmFsaWQgSEFTSF9TSVpFXFxuI2VsaWYgU0VRVUVOQ0VfQ09VTlQgKiBTRVFVRU5DRV9NQVhMRU4gKiA0ID4gMTYzODRcXG4jZXJyb3IgTFNIOiBzZXF1ZW5jZXMgYXJlIHRvbyBsYXJnZSFcXG4jZWxpZiAoU0VRVUVOQ0VfQ09VTlQgKiBTRVFVRU5DRV9NQVhMRU4pICUgNCA+IDBcXG4jZXJyb3IgTFNIOiBzZXF1ZW5jZXMgb2YgaW52YWxpZCBzaXplIVxcbiNlbmRpZlxcbmxheW91dChzdGQxNDApIHVuaWZvcm0gTFNIU2VxdWVuY2VzXFxue1xcbnV2ZWM0IHNlcXVlbmNlc1soU0VRVUVOQ0VfQ09VTlQgKiBTRVFVRU5DRV9NQVhMRU4pIC8gNF07XFxufTtcXG4jaWYgSEFTSF9TSVpFID09IDEwXFxuY29uc3QgaW50IFNXQVBfQ09VTlRbM10gPSBpbnRbM10oMSwgMTEsIDU2KTtcXG5jb25zdCBpbnRbNTZdIFNXQVAgPSBpbnRbNTZdKDAsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjU2LDUxMiwzLDUsNiw5LDEwLDEyLDE3LDE4LDIwLDI0LDMzLDM0LDM2LDQwLDQ4LDY1LDY2LDY4LDcyLDgwLDk2LDEyOSwxMzAsMTMyLDEzNiwxNDQsMTYwLDE5MiwyNTcsMjU4LDI2MCwyNjQsMjcyLDI4OCwzMjAsMzg0LDUxMyw1MTQsNTE2LDUyMCw1MjgsNTQ0LDU3Niw2NDAsNzY4KTtcXG4jZWxpZiBIQVNIX1NJWkUgPT0gMTFcXG5jb25zdCBpbnQgU1dBUF9DT1VOVFszXSA9IGludFszXSgxLCAxMiwgNjcpO1xcbmNvbnN0IGludFs2N10gU1dBUCA9IGludFs2N10oMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMyw1LDYsOSwxMCwxMiwxNywxOCwyMCwyNCwzMywzNCwzNiw0MCw0OCw2NSw2Niw2OCw3Miw4MCw5NiwxMjksMTMwLDEzMiwxMzYsMTQ0LDE2MCwxOTIsMjU3LDI1OCwyNjAsMjY0LDI3MiwyODgsMzIwLDM4NCw1MTMsNTE0LDUxNiw1MjAsNTI4LDU0NCw1NzYsNjQwLDc2OCwxMDI1LDEwMjYsMTAyOCwxMDMyLDEwNDAsMTA1NiwxMDg4LDExNTIsMTI4MCwxNTM2KTtcXG4jZWxpZiBIQVNIX1NJWkUgPT0gMTJcXG5jb25zdCBpbnQgU1dBUF9DT1VOVFszXSA9IGludFszXSgxLCAxMywgNzkpO1xcbmNvbnN0IGludFs3OV0gU1dBUCA9IGludFs3OV0oMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMjA0OCwzLDUsNiw5LDEwLDEyLDE3LDE4LDIwLDI0LDMzLDM0LDM2LDQwLDQ4LDY1LDY2LDY4LDcyLDgwLDk2LDEyOSwxMzAsMTMyLDEzNiwxNDQsMTYwLDE5MiwyNTcsMjU4LDI2MCwyNjQsMjcyLDI4OCwzMjAsMzg0LDUxMyw1MTQsNTE2LDUyMCw1MjgsNTQ0LDU3Niw2NDAsNzY4LDEwMjUsMTAyNiwxMDI4LDEwMzIsMTA0MCwxMDU2LDEwODgsMTE1MiwxMjgwLDE1MzYsMjA0OSwyMDUwLDIwNTIsMjA1NiwyMDY0LDIwODAsMjExMiwyMTc2LDIzMDQsMjU2MCwzMDcyKTtcXG4jZWxpZiBIQVNIX1NJWkUgPT0gMTNcXG5jb25zdCBpbnQgU1dBUF9DT1VOVFszXSA9IGludFszXSgxLCAxNCwgOTIpO1xcbmNvbnN0IGludFs5Ml0gU1dBUCA9IGludFs5Ml0oMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMjA0OCw0MDk2LDMsNSw2LDksMTAsMTIsMTcsMTgsMjAsMjQsMzMsMzQsMzYsNDAsNDgsNjUsNjYsNjgsNzIsODAsOTYsMTI5LDEzMCwxMzIsMTM2LDE0NCwxNjAsMTkyLDI1NywyNTgsMjYwLDI2NCwyNzIsMjg4LDMyMCwzODQsNTEzLDUxNCw1MTYsNTIwLDUyOCw1NDQsNTc2LDY0MCw3NjgsMTAyNSwxMDI2LDEwMjgsMTAzMiwxMDQwLDEwNTYsMTA4OCwxMTUyLDEyODAsMTUzNiwyMDQ5LDIwNTAsMjA1MiwyMDU2LDIwNjQsMjA4MCwyMTEyLDIxNzYsMjMwNCwyNTYwLDMwNzIsNDA5Nyw0MDk4LDQxMDAsNDEwNCw0MTEyLDQxMjgsNDE2MCw0MjI0LDQzNTIsNDYwOCw1MTIwLDYxNDQpO1xcbiNlbGlmIEhBU0hfU0laRSA9PSAxNFxcbmNvbnN0IGludCBTV0FQX0NPVU5UWzNdID0gaW50WzNdKDEsIDE1LCAxMDYpO1xcbmNvbnN0IGludFsxMDZdIFNXQVAgPSBpbnRbMTA2XSgwLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI1Niw1MTIsMTAyNCwyMDQ4LDQwOTYsODE5MiwzLDUsNiw5LDEwLDEyLDE3LDE4LDIwLDI0LDMzLDM0LDM2LDQwLDQ4LDY1LDY2LDY4LDcyLDgwLDk2LDEyOSwxMzAsMTMyLDEzNiwxNDQsMTYwLDE5MiwyNTcsMjU4LDI2MCwyNjQsMjcyLDI4OCwzMjAsMzg0LDUxMyw1MTQsNTE2LDUyMCw1MjgsNTQ0LDU3Niw2NDAsNzY4LDEwMjUsMTAyNiwxMDI4LDEwMzIsMTA0MCwxMDU2LDEwODgsMTE1MiwxMjgwLDE1MzYsMjA0OSwyMDUwLDIwNTIsMjA1NiwyMDY0LDIwODAsMjExMiwyMTc2LDIzMDQsMjU2MCwzMDcyLDQwOTcsNDA5OCw0MTAwLDQxMDQsNDExMiw0MTI4LDQxNjAsNDIyNCw0MzUyLDQ2MDgsNTEyMCw2MTQ0LDgxOTMsODE5NCw4MTk2LDgyMDAsODIwOCw4MjI0LDgyNTYsODMyMCw4NDQ4LDg3MDQsOTIxNiwxMDI0MCwxMjI4OCk7XFxuI2VsaWYgSEFTSF9TSVpFID09IDE1XFxuY29uc3QgaW50IFNXQVBfQ09VTlRbM10gPSBpbnRbM10oMSwgMTYsIDEyMSk7XFxuY29uc3QgaW50WzEyMV0gU1dBUCA9IGludFsxMjFdKDAsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjU2LDUxMiwxMDI0LDIwNDgsNDA5Niw4MTkyLDE2Mzg0LDMsNSw2LDksMTAsMTIsMTcsMTgsMjAsMjQsMzMsMzQsMzYsNDAsNDgsNjUsNjYsNjgsNzIsODAsOTYsMTI5LDEzMCwxMzIsMTM2LDE0NCwxNjAsMTkyLDI1NywyNTgsMjYwLDI2NCwyNzIsMjg4LDMyMCwzODQsNTEzLDUxNCw1MTYsNTIwLDUyOCw1NDQsNTc2LDY0MCw3NjgsMTAyNSwxMDI2LDEwMjgsMTAzMiwxMDQwLDEwNTYsMTA4OCwxMTUyLDEyODAsMTUzNiwyMDQ5LDIwNTAsMjA1MiwyMDU2LDIwNjQsMjA4MCwyMTEyLDIxNzYsMjMwNCwyNTYwLDMwNzIsNDA5Nyw0MDk4LDQxMDAsNDEwNCw0MTEyLDQxMjgsNDE2MCw0MjI0LDQzNTIsNDYwOCw1MTIwLDYxNDQsODE5Myw4MTk0LDgxOTYsODIwMCw4MjA4LDgyMjQsODI1Niw4MzIwLDg0NDgsODcwNCw5MjE2LDEwMjQwLDEyMjg4LDE2Mzg1LDE2Mzg2LDE2Mzg4LDE2MzkyLDE2NDAwLDE2NDE2LDE2NDQ4LDE2NTEyLDE2NjQwLDE2ODk2LDE3NDA4LDE4NDMyLDIwNDgwLDI0NTc2KTtcXG4jZWxpZiBIQVNIX1NJWkUgPT0gMTZcXG5jb25zdCBpbnQgU1dBUF9DT1VOVFszXSA9IGludFszXSgxLCAxNywgMTM3KTtcXG5jb25zdCBpbnRbMTM3XSBTV0FQID0gaW50WzEzN10oMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMjA0OCw0MDk2LDgxOTIsMTYzODQsMzI3NjgsMyw1LDYsOSwxMCwxMiwxNywxOCwyMCwyNCwzMywzNCwzNiw0MCw0OCw2NSw2Niw2OCw3Miw4MCw5NiwxMjksMTMwLDEzMiwxMzYsMTQ0LDE2MCwxOTIsMjU3LDI1OCwyNjAsMjY0LDI3MiwyODgsMzIwLDM4NCw1MTMsNTE0LDUxNiw1MjAsNTI4LDU0NCw1NzYsNjQwLDc2OCwxMDI1LDEwMjYsMTAyOCwxMDMyLDEwNDAsMTA1NiwxMDg4LDExNTIsMTI4MCwxNTM2LDIwNDksMjA1MCwyMDUyLDIwNTYsMjA2NCwyMDgwLDIxMTIsMjE3NiwyMzA0LDI1NjAsMzA3Miw0MDk3LDQwOTgsNDEwMCw0MTA0LDQxMTIsNDEyOCw0MTYwLDQyMjQsNDM1Miw0NjA4LDUxMjAsNjE0NCw4MTkzLDgxOTQsODE5Niw4MjAwLDgyMDgsODIyNCw4MjU2LDgzMjAsODQ0OCw4NzA0LDkyMTYsMTAyNDAsMTIyODgsMTYzODUsMTYzODYsMTYzODgsMTYzOTIsMTY0MDAsMTY0MTYsMTY0NDgsMTY1MTIsMTY2NDAsMTY4OTYsMTc0MDgsMTg0MzIsMjA0ODAsMjQ1NzYsMzI3NjksMzI3NzAsMzI3NzIsMzI3NzYsMzI3ODQsMzI4MDAsMzI4MzIsMzI4OTYsMzMwMjQsMzMyODAsMzM3OTIsMzQ4MTYsMzY4NjQsNDA5NjAsNDkxNTIpO1xcbiNlbGlmIEhBU0hfU0laRSA9PSAxN1xcbmNvbnN0IGludCBTV0FQX0NPVU5UWzNdID0gaW50WzNdKDEsIDE4LCAxNTQpO1xcbmNvbnN0IGludFsxNTRdIFNXQVAgPSBpbnRbMTU0XSgwLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI1Niw1MTIsMTAyNCwyMDQ4LDQwOTYsODE5MiwxNjM4NCwzMjc2OCw2NTUzNiwzLDUsNiw5LDEwLDEyLDE3LDE4LDIwLDI0LDMzLDM0LDM2LDQwLDQ4LDY1LDY2LDY4LDcyLDgwLDk2LDEyOSwxMzAsMTMyLDEzNiwxNDQsMTYwLDE5MiwyNTcsMjU4LDI2MCwyNjQsMjcyLDI4OCwzMjAsMzg0LDUxMyw1MTQsNTE2LDUyMCw1MjgsNTQ0LDU3Niw2NDAsNzY4LDEwMjUsMTAyNiwxMDI4LDEwMzIsMTA0MCwxMDU2LDEwODgsMTE1MiwxMjgwLDE1MzYsMjA0OSwyMDUwLDIwNTIsMjA1NiwyMDY0LDIwODAsMjExMiwyMTc2LDIzMDQsMjU2MCwzMDcyLDQwOTcsNDA5OCw0MTAwLDQxMDQsNDExMiw0MTI4LDQxNjAsNDIyNCw0MzUyLDQ2MDgsNTEyMCw2MTQ0LDgxOTMsODE5NCw4MTk2LDgyMDAsODIwOCw4MjI0LDgyNTYsODMyMCw4NDQ4LDg3MDQsOTIxNiwxMDI0MCwxMjI4OCwxNjM4NSwxNjM4NiwxNjM4OCwxNjM5MiwxNjQwMCwxNjQxNiwxNjQ0OCwxNjUxMiwxNjY0MCwxNjg5NiwxNzQwOCwxODQzMiwyMDQ4MCwyNDU3NiwzMjc2OSwzMjc3MCwzMjc3MiwzMjc3NiwzMjc4NCwzMjgwMCwzMjgzMiwzMjg5NiwzMzAyNCwzMzI4MCwzMzc5MiwzNDgxNiwzNjg2NCw0MDk2MCw0OTE1Miw2NTUzNyw2NTUzOCw2NTU0MCw2NTU0NCw2NTU1Miw2NTU2OCw2NTYwMCw2NTY2NCw2NTc5Miw2NjA0OCw2NjU2MCw2NzU4NCw2OTYzMiw3MzcyOCw4MTkyMCw5ODMwNCk7XFxuI2VsaWYgSEFTSF9TSVpFID09IDE4XFxuY29uc3QgaW50IFNXQVBfQ09VTlRbM10gPSBpbnRbM10oMSwgMTksIDE3Mik7XFxuY29uc3QgaW50WzE3Ml0gU1dBUCA9IGludFsxNzJdKDAsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjU2LDUxMiwxMDI0LDIwNDgsNDA5Niw4MTkyLDE2Mzg0LDMyNzY4LDY1NTM2LDEzMTA3MiwzLDUsNiw5LDEwLDEyLDE3LDE4LDIwLDI0LDMzLDM0LDM2LDQwLDQ4LDY1LDY2LDY4LDcyLDgwLDk2LDEyOSwxMzAsMTMyLDEzNiwxNDQsMTYwLDE5MiwyNTcsMjU4LDI2MCwyNjQsMjcyLDI4OCwzMjAsMzg0LDUxMyw1MTQsNTE2LDUyMCw1MjgsNTQ0LDU3Niw2NDAsNzY4LDEwMjUsMTAyNiwxMDI4LDEwMzIsMTA0MCwxMDU2LDEwODgsMTE1MiwxMjgwLDE1MzYsMjA0OSwyMDUwLDIwNTIsMjA1NiwyMDY0LDIwODAsMjExMiwyMTc2LDIzMDQsMjU2MCwzMDcyLDQwOTcsNDA5OCw0MTAwLDQxMDQsNDExMiw0MTI4LDQxNjAsNDIyNCw0MzUyLDQ2MDgsNTEyMCw2MTQ0LDgxOTMsODE5NCw4MTk2LDgyMDAsODIwOCw4MjI0LDgyNTYsODMyMCw4NDQ4LDg3MDQsOTIxNiwxMDI0MCwxMjI4OCwxNjM4NSwxNjM4NiwxNjM4OCwxNjM5MiwxNjQwMCwxNjQxNiwxNjQ0OCwxNjUxMiwxNjY0MCwxNjg5NiwxNzQwOCwxODQzMiwyMDQ4MCwyNDU3NiwzMjc2OSwzMjc3MCwzMjc3MiwzMjc3NiwzMjc4NCwzMjgwMCwzMjgzMiwzMjg5NiwzMzAyNCwzMzI4MCwzMzc5MiwzNDgxNiwzNjg2NCw0MDk2MCw0OTE1Miw2NTUzNyw2NTUzOCw2NTU0MCw2NTU0NCw2NTU1Miw2NTU2OCw2NTYwMCw2NTY2NCw2NTc5Miw2NjA0OCw2NjU2MCw2NzU4NCw2OTYzMiw3MzcyOCw4MTkyMCw5ODMwNCwxMzEwNzMsMTMxMDc0LDEzMTA3NiwxMzEwODAsMTMxMDg4LDEzMTEwNCwxMzExMzYsMTMxMjAwLDEzMTMyOCwxMzE1ODQsMTMyMDk2LDEzMzEyMCwxMzUxNjgsMTM5MjY0LDE0NzQ1NiwxNjM4NDAsMTk2NjA4KTtcXG4jZWxpZiBIQVNIX1NJWkUgPT0gMTlcXG5jb25zdCBpbnQgU1dBUF9DT1VOVFszXSA9IGludFszXSgxLCAyMCwgMTkxKTtcXG5jb25zdCBpbnRbMTkxXSBTV0FQID0gaW50WzE5MV0oMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMjA0OCw0MDk2LDgxOTIsMTYzODQsMzI3NjgsNjU1MzYsMTMxMDcyLDI2MjE0NCwzLDUsNiw5LDEwLDEyLDE3LDE4LDIwLDI0LDMzLDM0LDM2LDQwLDQ4LDY1LDY2LDY4LDcyLDgwLDk2LDEyOSwxMzAsMTMyLDEzNiwxNDQsMTYwLDE5MiwyNTcsMjU4LDI2MCwyNjQsMjcyLDI4OCwzMjAsMzg0LDUxMyw1MTQsNTE2LDUyMCw1MjgsNTQ0LDU3Niw2NDAsNzY4LDEwMjUsMTAyNiwxMDI4LDEwMzIsMTA0MCwxMDU2LDEwODgsMTE1MiwxMjgwLDE1MzYsMjA0OSwyMDUwLDIwNTIsMjA1NiwyMDY0LDIwODAsMjExMiwyMTc2LDIzMDQsMjU2MCwzMDcyLDQwOTcsNDA5OCw0MTAwLDQxMDQsNDExMiw0MTI4LDQxNjAsNDIyNCw0MzUyLDQ2MDgsNTEyMCw2MTQ0LDgxOTMsODE5NCw4MTk2LDgyMDAsODIwOCw4MjI0LDgyNTYsODMyMCw4NDQ4LDg3MDQsOTIxNiwxMDI0MCwxMjI4OCwxNjM4NSwxNjM4NiwxNjM4OCwxNjM5MiwxNjQwMCwxNjQxNiwxNjQ0OCwxNjUxMiwxNjY0MCwxNjg5NiwxNzQwOCwxODQzMiwyMDQ4MCwyNDU3NiwzMjc2OSwzMjc3MCwzMjc3MiwzMjc3NiwzMjc4NCwzMjgwMCwzMjgzMiwzMjg5NiwzMzAyNCwzMzI4MCwzMzc5MiwzNDgxNiwzNjg2NCw0MDk2MCw0OTE1Miw2NTUzNyw2NTUzOCw2NTU0MCw2NTU0NCw2NTU1Miw2NTU2OCw2NTYwMCw2NTY2NCw2NTc5Miw2NjA0OCw2NjU2MCw2NzU4NCw2OTYzMiw3MzcyOCw4MTkyMCw5ODMwNCwxMzEwNzMsMTMxMDc0LDEzMTA3NiwxMzEwODAsMTMxMDg4LDEzMTEwNCwxMzExMzYsMTMxMjAwLDEzMTMyOCwxMzE1ODQsMTMyMDk2LDEzMzEyMCwxMzUxNjgsMTM5MjY0LDE0NzQ1NiwxNjM4NDAsMTk2NjA4LDI2MjE0NSwyNjIxNDYsMjYyMTQ4LDI2MjE1MiwyNjIxNjAsMjYyMTc2LDI2MjIwOCwyNjIyNzIsMjYyNDAwLDI2MjY1NiwyNjMxNjgsMjY0MTkyLDI2NjI0MCwyNzAzMzYsMjc4NTI4LDI5NDkxMiwzMjc2ODAsMzkzMjE2KTtcXG4jZWxpZiBIQVNIX1NJWkUgPT0gMjBcXG5jb25zdCBpbnQgU1dBUF9DT1VOVFszXSA9IGludFszXSgxLCAyMSwgMjExKTtcXG5jb25zdCBpbnRbMjExXSBTV0FQID0gaW50WzIxMV0oMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMjA0OCw0MDk2LDgxOTIsMTYzODQsMzI3NjgsNjU1MzYsMTMxMDcyLDI2MjE0NCw1MjQyODgsMyw1LDYsOSwxMCwxMiwxNywxOCwyMCwyNCwzMywzNCwzNiw0MCw0OCw2NSw2Niw2OCw3Miw4MCw5NiwxMjksMTMwLDEzMiwxMzYsMTQ0LDE2MCwxOTIsMjU3LDI1OCwyNjAsMjY0LDI3MiwyODgsMzIwLDM4NCw1MTMsNTE0LDUxNiw1MjAsNTI4LDU0NCw1NzYsNjQwLDc2OCwxMDI1LDEwMjYsMTAyOCwxMDMyLDEwNDAsMTA1NiwxMDg4LDExNTIsMTI4MCwxNTM2LDIwNDksMjA1MCwyMDUyLDIwNTYsMjA2NCwyMDgwLDIxMTIsMjE3NiwyMzA0LDI1NjAsMzA3Miw0MDk3LDQwOTgsNDEwMCw0MTA0LDQxMTIsNDEyOCw0MTYwLDQyMjQsNDM1Miw0NjA4LDUxMjAsNjE0NCw4MTkzLDgxOTQsODE5Niw4MjAwLDgyMDgsODIyNCw4MjU2LDgzMjAsODQ0OCw4NzA0LDkyMTYsMTAyNDAsMTIyODgsMTYzODUsMTYzODYsMTYzODgsMTYzOTIsMTY0MDAsMTY0MTYsMTY0NDgsMTY1MTIsMTY2NDAsMTY4OTYsMTc0MDgsMTg0MzIsMjA0ODAsMjQ1NzYsMzI3NjksMzI3NzAsMzI3NzIsMzI3NzYsMzI3ODQsMzI4MDAsMzI4MzIsMzI4OTYsMzMwMjQsMzMyODAsMzM3OTIsMzQ4MTYsMzY4NjQsNDA5NjAsNDkxNTIsNjU1MzcsNjU1MzgsNjU1NDAsNjU1NDQsNjU1NTIsNjU1NjgsNjU2MDAsNjU2NjQsNjU3OTIsNjYwNDgsNjY1NjAsNjc1ODQsNjk2MzIsNzM3MjgsODE5MjAsOTgzMDQsMTMxMDczLDEzMTA3NCwxMzEwNzYsMTMxMDgwLDEzMTA4OCwxMzExMDQsMTMxMTM2LDEzMTIwMCwxMzEzMjgsMTMxNTg0LDEzMjA5NiwxMzMxMjAsMTM1MTY4LDEzOTI2NCwxNDc0NTYsMTYzODQwLDE5NjYwOCwyNjIxNDUsMjYyMTQ2LDI2MjE0OCwyNjIxNTIsMjYyMTYwLDI2MjE3NiwyNjIyMDgsMjYyMjcyLDI2MjQwMCwyNjI2NTYsMjYzMTY4LDI2NDE5MiwyNjYyNDAsMjcwMzM2LDI3ODUyOCwyOTQ5MTIsMzI3NjgwLDM5MzIxNiw1MjQyODksNTI0MjkwLDUyNDI5Miw1MjQyOTYsNTI0MzA0LDUyNDMyMCw1MjQzNTIsNTI0NDE2LDUyNDU0NCw1MjQ4MDAsNTI1MzEyLDUyNjMzNiw1MjgzODQsNTMyNDgwLDU0MDY3Miw1NTcwNTYsNTg5ODI0LDY1NTM2MCw3ODY0MzIpO1xcbiNlbHNlXFxuI2Vycm9yIEludmFsaWQgSEFTSF9TSVpFXFxuI2VuZGlmXFxuI2lmIExFVkVMIDwgMCB8fCBMRVZFTCA+IDJcXG4jZXJyb3IgSW52YWxpZCBMRVZFTFxcbiNlbmRpZlxcbmNvbnN0IHVpbnQgRU5EX09GX0xJU1QgPSAweEZGRkZGRkZGdTtcXG5jb25zdCBpbnQgTlVNQkVSX09GX0hBU0hFUyA9IFNXQVBfQ09VTlRbTEVWRUxdO1xcbnVpbnQgc2VxdWVuY2VFbGVtZW50KGludCBzZXF1ZW5jZUluZGV4LCBpbnQgZWxlbWVudEluZGV4KVxcbntcXG5pbnQgb2Zmc2V0ID0gKFNFUVVFTkNFX01BWExFTikgKiBzZXF1ZW5jZUluZGV4ICsgZWxlbWVudEluZGV4O1xcbnV2ZWM0IHR1cGxlID0gc2VxdWVuY2VzW29mZnNldCAvIDRdO1xcbnJldHVybiB0dXBsZVtvZmZzZXQgJiAzXTtcXG59XFxuaW50IGRlc2NyaXB0b3JIYXNoKHVpbnRbREVTQ1JJUFRPUl9TSVpFXSBkZXNjcmlwdG9yLCBpbnQgc2VxdWVuY2VJbmRleClcXG57XFxudWludCBiaXQsIGIsIG07XFxuaW50IGhhc2ggPSAwO1xcbkB1bnJvbGxcXG5mb3IoaW50IGkgPSAwOyBpIDwgSEFTSF9TSVpFOyBpKyspIHtcXG5iaXQgPSBzZXF1ZW5jZUVsZW1lbnQoc2VxdWVuY2VJbmRleCwgaSk7XFxuYiA9IGJpdCA+PiAzdTtcXG5tID0gMXUgPDwgKGJpdCAmIDd1KTtcXG5oYXNoID0gKGhhc2ggPDwgMSkgfCBpbnQoKGRlc2NyaXB0b3JbYl0gJiBtKSAhPSAwdSk7XFxufVxcbnJldHVybiBoYXNoO1xcbn1cXG4jZGVmaW5lIHJlYWRUYWJsZURhdGEodGFibGVzLCB0YWJsZXNTdHJpZGUsIHJhc3RlckluZGV4KSBkZWNvZGVVaW50MzIodGV4ZWxGZXRjaCgodGFibGVzKSwgaXZlYzIoKHJhc3RlckluZGV4KSAlICh0YWJsZXNTdHJpZGUpLCAocmFzdGVySW5kZXgpIC8gKHRhYmxlc1N0cmlkZSkpLCAwKSlcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbmludCBrZXlwb2ludEluZGV4ID0gdGhyZWFkLnggKyB0aHJlYWQueSAqIG1hdGNoZXJMZW5ndGg7XFxuaW50IHBpeGVsc1BlcktleXBvaW50ID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50KGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpIC8gNDtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IEtleXBvaW50QWRkcmVzcyhrZXlwb2ludEluZGV4ICogcGl4ZWxzUGVyS2V5cG9pbnQsIDApO1xcbktleXBvaW50IGtleXBvaW50ID0gZGVjb2RlS2V5cG9pbnQoZW5jb2RlZEtleXBvaW50cywgZW5jb2Rlckxlbmd0aCwgYWRkcmVzcyk7XFxuY29sb3IgPSBlbmNvZGVLZXlwb2ludE1hdGNoKE1BVENIX05PVF9GT1VORCk7XFxuaWYoaXNCYWRLZXlwb2ludChrZXlwb2ludCkpXFxucmV0dXJuO1xcbktleXBvaW50TWF0Y2ggY2FuZGlkYXRlID0gZGVjb2RlS2V5cG9pbnRNYXRjaCh0aHJlYWRQaXhlbChjYW5kaWRhdGVzKSk7XFxuS2V5cG9pbnRNYXRjaCBtZmlsdGVyID0gZGVjb2RlS2V5cG9pbnRNYXRjaCh0aHJlYWRQaXhlbChmaWx0ZXJzKSk7XFxudWludFtERVNDUklQVE9SX1NJWkVdIGNhbmRpZGF0ZURlc2NyaXB0b3I7XFxudWludFtERVNDUklQVE9SX1NJWkVdIGRlc2NyaXB0b3IgPSByZWFkS2V5cG9pbnREZXNjcmlwdG9yKGVuY29kZWRLZXlwb2ludHMsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUsIGVuY29kZXJMZW5ndGgsIGFkZHJlc3MpO1xcbmludCBoYXNoMCA9IGRlc2NyaXB0b3JIYXNoKGRlc2NyaXB0b3IsIHRhYmxlSW5kZXgpO1xcbmZvcihpbnQgaCA9IDA7IGggPCBOVU1CRVJfT0ZfSEFTSEVTOyBoKyspIHtcXG5pbnQgaGFzaCA9IGhhc2gwIF4gU1dBUFtoXTtcXG5pbnQgdGFibGVBZGRyZXNzID0gdGFibGVJbmRleCAqIGJ1Y2tldHNQZXJUYWJsZSAqIGJ1Y2tldENhcGFjaXR5O1xcbmludCBidWNrZXRBZGRyZXNzID0gdGFibGVBZGRyZXNzICsgaGFzaCAqIGJ1Y2tldENhcGFjaXR5O1xcbmJvb2wgdmFsaWRFbnRyeSA9IHRydWU7XFxuZm9yKGludCBiID0gMDsgYiA8IGJ1Y2tldENhcGFjaXR5OyBiKyspIHtcXG5pbnQgZW50cnlBZGRyZXNzID0gYnVja2V0QWRkcmVzcyArIGI7XFxudWludCBlbnRyeSA9IHZhbGlkRW50cnkgPyByZWFkVGFibGVEYXRhKHRhYmxlcywgdGFibGVzU3RyaWRlLCBlbnRyeUFkZHJlc3MpIDogRU5EX09GX0xJU1Q7XFxudmFsaWRFbnRyeSA9ICh2YWxpZEVudHJ5ICYmIGVudHJ5ICE9IEVORF9PRl9MSVNUKTtcXG5pbnQgY2FuZGlkYXRlSW5kZXggPSBpbnQoZW50cnkpO1xcbmNhbmRpZGF0ZURlc2NyaXB0b3IgPSByZWFkS2V5cG9pbnREZXNjcmlwdG9yRnJvbURCKGRlc2NyaXB0b3JEQiwgZGVzY3JpcHRvckRCU3RyaWRlLCB2YWxpZEVudHJ5ID8gY2FuZGlkYXRlSW5kZXggOiAtMSk7XFxuaW50IGRlc2NyaXB0b3JEaXN0YW5jZSA9IGRpc3RhbmNlQmV0d2VlbktleXBvaW50RGVzY3JpcHRvcnMoZGVzY3JpcHRvciwgY2FuZGlkYXRlRGVzY3JpcHRvcik7XFxuS2V5cG9pbnRNYXRjaCBtYXRjaCA9IEtleXBvaW50TWF0Y2goY2FuZGlkYXRlSW5kZXgsIGRlc2NyaXB0b3JEaXN0YW5jZSk7XFxuYm9vbCBiZXR0ZXJUaGFuQ2FuZGlkYXRlID0gKG1hdGNoLmRpc3QgPCBjYW5kaWRhdGUuZGlzdCkgfHwgKG1hdGNoLmRpc3QgPT0gY2FuZGlkYXRlLmRpc3QgJiYgbWF0Y2guaW5kZXggPiBjYW5kaWRhdGUuaW5kZXgpO1xcbmJvb2wgd29yc2VUaGFuRmlsdGVyID0gKG1hdGNoLmRpc3QgPiBtZmlsdGVyLmRpc3QpIHx8IChtYXRjaC5kaXN0ID09IG1maWx0ZXIuZGlzdCAmJiBtYXRjaC5pbmRleCA8IG1maWx0ZXIuaW5kZXgpO1xcbmJvb2wgbmljZXJNYXRjaCA9ICh2YWxpZEVudHJ5ICYmIGJldHRlclRoYW5DYW5kaWRhdGUgJiYgd29yc2VUaGFuRmlsdGVyKTtcXG5pdmVjMiB2ID0gbmljZXJNYXRjaCA/IGl2ZWMyKG1hdGNoLmluZGV4LCBtYXRjaC5kaXN0KSA6IGl2ZWMyKGNhbmRpZGF0ZS5pbmRleCwgY2FuZGlkYXRlLmRpc3QpO1xcbmNhbmRpZGF0ZSA9IEtleXBvaW50TWF0Y2godi54LCB2LnkpO1xcbn1cXG59XFxuY29sb3IgPSBlbmNvZGVLZXlwb2ludE1hdGNoKGNhbmRpZGF0ZSk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJrZXlwb2ludHMuZ2xzbFxcXCJcXG5AaW5jbHVkZSBcXFwiaW50MzIuZ2xzbFxcXCJcXG4jaWYgIWRlZmluZWQoU1RBR0UpXFxuI2Vycm9yIFVuZGVmaW5lZCBTVEFHRVxcbiNlbGlmIFNUQUdFID09IDFcXG51bmlmb3JtIHNhbXBsZXIyRCBlbmNvZGVkS2V5cG9pbnRzQTtcXG51bmlmb3JtIHNhbXBsZXIyRCBlbmNvZGVkS2V5cG9pbnRzQjtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoQTtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoQjtcXG51bmlmb3JtIGludCBlbmNvZGVyQ2FwYWNpdHlBO1xcbnVuaWZvcm0gaW50IGVuY29kZXJDYXBhY2l0eUI7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxuI2VsaWYgU1RBR0UgPT0gMlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxudW5pZm9ybSBpbnQgbWF4S2V5cG9pbnRzO1xcbiNlbGlmIFNUQUdFID09IDNcXG51bmlmb3JtIHNhbXBsZXIyRCBhcnJheTtcXG51bmlmb3JtIGludCBibG9ja1NpemU7XFxuI2VsaWYgU1RBR0UgPT0gNFxcbnVuaWZvcm0gc2FtcGxlcjJEIGFycmF5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxuI2VsaWYgU1RBR0UgPT0gNVxcbnVuaWZvcm0gc2FtcGxlcjJEIGFycmF5O1xcbiNlbHNlXFxuI2Vycm9yIEludmFsaWQgU1RBR0VcXG4jZW5kaWZcXG4jZGVmaW5lIE5VTExfS0VZUE9JTlRfSU5ERVggMHhGRkZGXFxuY29uc3QgaGlnaHAgdWludCBVTklUID0gMHgxMDAwMHU7XFxudm9pZCBtYWluKClcXG57XFxuI2lmIFNUQUdFID09IDFcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBhZGRyID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIGVuY29kZXJMZW5ndGgsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmludCBrZXlwb2ludEluZGV4ID0gZmluZEtleXBvaW50SW5kZXgoYWRkciwgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuaW50IG5ld0tleXBvaW50SW5kZXggPSBrZXlwb2ludEluZGV4IDwgZW5jb2RlckNhcGFjaXR5QSA/IGtleXBvaW50SW5kZXggOiBrZXlwb2ludEluZGV4IC0gZW5jb2RlckNhcGFjaXR5QTtcXG5jb2xvciA9IGVuY29kZU51bGxLZXlwb2ludCgpO1xcbmlmKG5ld0tleXBvaW50SW5kZXggPj0gbWF4KGVuY29kZXJDYXBhY2l0eUEsIGVuY29kZXJDYXBhY2l0eUIpKVxcbnJldHVybjtcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgLyA0O1xcbmFkZHIgPSBLZXlwb2ludEFkZHJlc3MobmV3S2V5cG9pbnRJbmRleCAqIHBpeGVsc1BlcktleXBvaW50LCBhZGRyLm9mZnNldCk7XFxudmVjNCBkYXRhQSA9IHJlYWRLZXlwb2ludERhdGEoZW5jb2RlZEtleXBvaW50c0EsIGVuY29kZXJMZW5ndGhBLCBhZGRyKTtcXG52ZWM0IGRhdGFCID0gcmVhZEtleXBvaW50RGF0YShlbmNvZGVkS2V5cG9pbnRzQiwgZW5jb2Rlckxlbmd0aEIsIGFkZHIpO1xcbmNvbG9yID0ga2V5cG9pbnRJbmRleCA8IGVuY29kZXJDYXBhY2l0eUEgPyBkYXRhQSA6IGRhdGFCO1xcbiNlbGlmIFNUQUdFID09IDJcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbmludCBrZXlwb2ludEluZGV4ID0gdGhyZWFkLnkgKiBvdXRwdXRTaXplKCkueCArIHRocmVhZC54O1xcbmludCBwaXhlbHNQZXJLZXlwb2ludCA9IHNpemVvZkVuY29kZWRLZXlwb2ludChkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKSAvIDQ7XFxuS2V5cG9pbnRBZGRyZXNzIGFkZHIgPSBLZXlwb2ludEFkZHJlc3Moa2V5cG9pbnRJbmRleCAqIHBpeGVsc1BlcktleXBvaW50LCAwKTtcXG5LZXlwb2ludCBrZXlwb2ludCA9IGRlY29kZUtleXBvaW50KGVuY29kZWRLZXlwb2ludHMsIGVuY29kZXJMZW5ndGgsIGFkZHIpO1xcbmJvb2wgaXNWYWxpZCA9ICFpc051bGxLZXlwb2ludChrZXlwb2ludCkgJiYga2V5cG9pbnRJbmRleCA8IG1heEtleXBvaW50cztcXG5rZXlwb2ludEluZGV4ID0gaXNWYWxpZCA/IGtleXBvaW50SW5kZXggOiBOVUxMX0tFWVBPSU5UX0lOREVYO1xcbmNvbG9yID0gZW5jb2RlVWludDMyKHVpbnQoa2V5cG9pbnRJbmRleCAmIDB4RkZGRikgfCAoaXNWYWxpZCA/IFVOSVQgOiAwdSkpO1xcbiNlbGlmIFNUQUdFID09IDNcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbml2ZWMyIHNpemUgPSBvdXRwdXRTaXplKCk7XFxuaW50IGFycmF5TGVuZ3RoID0gc2l6ZS54ICogc2l6ZS55O1xcbmludCBhcnJheUluZGV4ID0gdGhyZWFkLnkgKiBzaXplLnggKyB0aHJlYWQueDtcXG5pbnQgYXJyYXlJbmRleExlZnQgPSBhcnJheUluZGV4IC0gYmxvY2tTaXplO1xcbmludCBhcnJheUluZGV4UmlnaHQgPSBhcnJheUluZGV4ICsgYmxvY2tTaXplO1xcbmludCBtYXNrID0gaW50KGFycmF5SW5kZXhSaWdodCA8IGFycmF5TGVuZ3RoIHx8IGFycmF5SW5kZXhSaWdodCAvIGJsb2NrU2l6ZSA9PSAoYXJyYXlMZW5ndGggLSAxKSAvIGJsb2NrU2l6ZSk7XFxuYXJyYXlJbmRleExlZnQgPSBtYXgoMCwgYXJyYXlJbmRleExlZnQpO1xcbmFycmF5SW5kZXhSaWdodCA9IG1pbihhcnJheUxlbmd0aCAtIDEsIGFycmF5SW5kZXhSaWdodCk7XFxuI2RlZmluZSByYXN0ZXIycG9zKGspIGl2ZWMyKChrKSAlIHNpemUueCwgKGspIC8gc2l6ZS54KVxcbnV2ZWMzIGVudHJpZXMzMiA9IHV2ZWMzKFxcbmRlY29kZVVpbnQzMih0aHJlYWRQaXhlbChhcnJheSkpLFxcbmRlY29kZVVpbnQzMih0ZXhlbEZldGNoKGFycmF5LCByYXN0ZXIycG9zKGFycmF5SW5kZXhMZWZ0KSwgMCkpLFxcbmRlY29kZVVpbnQzMih0ZXhlbEZldGNoKGFycmF5LCByYXN0ZXIycG9zKGFycmF5SW5kZXhSaWdodCksIDApKVxcbik7XFxuaXZlYzMgc2IgPSBpdmVjMygoZW50cmllczMyID4+IDE2dSkgJiAweEZGRkZ1KTtcXG5zYi56ICo9IG1hc2s7XFxuaW50IGRibEJsb2NrU2l6ZSA9IDIgKiBibG9ja1NpemU7XFxuaW50IG9mZnNldCA9IGFycmF5SW5kZXggJSBkYmxCbG9ja1NpemU7XFxuaW50IHMyYiA9IHNiLnggKyAob2Zmc2V0IDwgYmxvY2tTaXplID8gc2IueiA6IHNiLnkpO1xcbmludCBsMmIgPSBvZmZzZXQgPCBibG9ja1NpemUgPyBzYi54IDogc2IueTtcXG51aW50IGtleXBvaW50SW5kZXggPSBlbnRyaWVzMzIueCAmIDB4RkZGRnU7XFxudWludCBzaGlmdGVkUzJiID0gdWludChzMmIpIDw8IDE2dTtcXG5jb2xvciA9IGVuY29kZVVpbnQzMih1aW50KE5VTExfS0VZUE9JTlRfSU5ERVgpIHwgc2hpZnRlZFMyYik7XFxuaWYob2Zmc2V0ID49IHMyYilcXG5yZXR1cm47XFxuY29sb3IgPSBlbmNvZGVVaW50MzIoa2V5cG9pbnRJbmRleCB8IHNoaWZ0ZWRTMmIpO1xcbmlmKG9mZnNldCA8IGwyYilcXG5yZXR1cm47XFxudmVjNCBlbnRyeSA9IHRleGVsRmV0Y2goYXJyYXksIHJhc3RlcjJwb3MoYXJyYXlJbmRleCArIGJsb2NrU2l6ZSAtIGwyYiksIDApO1xcbmtleXBvaW50SW5kZXggPSBkZWNvZGVVaW50MzIoZW50cnkpICYgMHhGRkZGdTtcXG5jb2xvciA9IGVuY29kZVVpbnQzMihrZXlwb2ludEluZGV4IHwgc2hpZnRlZFMyYik7XFxuI2VsaWYgU1RBR0UgPT0gNFxcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaW50IHBpeGVsc1BlcktleXBvaW50ID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50KGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpIC8gNDtcXG5LZXlwb2ludEFkZHJlc3MgYWRkciA9IGZpbmRLZXlwb2ludEFkZHJlc3ModGhyZWFkLCBlbmNvZGVyTGVuZ3RoLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5pbnQga2V5cG9pbnRJbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KGFkZHIsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbiNkZWZpbmUgcmFzdGVyMnBvcyhrKSBpdmVjMigoaykgJSBzaXplLngsIChrKSAvIHNpemUueClcXG5pdmVjMiBzaXplID0gdGV4dHVyZVNpemUoYXJyYXksIDApO1xcbnVpbnQgc29ydGVkUGFpciA9IGRlY29kZVVpbnQzMih0ZXhlbEZldGNoKGFycmF5LCByYXN0ZXIycG9zKGtleXBvaW50SW5kZXgpLCAwKSk7XFxuaW50IG5ld0tleXBvaW50SW5kZXggPSBpbnQoc29ydGVkUGFpciAmIDB4RkZGRnUpO1xcbmNvbG9yID0gZW5jb2RlTnVsbEtleXBvaW50KCk7XFxuaWYobmV3S2V5cG9pbnRJbmRleCA9PSBOVUxMX0tFWVBPSU5UX0lOREVYIHx8IGtleXBvaW50SW5kZXggPj0gc2l6ZS54ICogc2l6ZS55KVxcbnJldHVybjtcXG5LZXlwb2ludEFkZHJlc3MgbmV3QWRkciA9IEtleXBvaW50QWRkcmVzcyhuZXdLZXlwb2ludEluZGV4ICogcGl4ZWxzUGVyS2V5cG9pbnQsIGFkZHIub2Zmc2V0KTtcXG5jb2xvciA9IHJlYWRLZXlwb2ludERhdGEoZW5jb2RlZEtleXBvaW50cywgZW5jb2Rlckxlbmd0aCwgbmV3QWRkcik7XFxuI2VsaWYgU1RBR0UgPT0gNVxcbnVpbnQgdmFsID0gZGVjb2RlVWludDMyKHRocmVhZFBpeGVsKGFycmF5KSk7XFxuY29sb3IgPSAodmFsICYgMHhGRkZGdSkgPT0gdWludChOVUxMX0tFWVBPSU5UX0lOREVYKSA/IHZlYzQoMCwxLDEsMSkgOiB2ZWM0KDEsMCwwLDEpO1xcbiNlbmRpZlxcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBlbmNvZGVkRmxvdztcXG51bmlmb3JtIHNhbXBsZXIyRCBwcmV2S2V5cG9pbnRzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHByZXZQeXJhbWlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG5leHRQeXJhbWlkO1xcbnVuaWZvcm0gaW50IHdpbmRvd1NpemU7XFxudW5pZm9ybSBpbnQgcGF0Y2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgZGlzY2FyZFRocmVzaG9sZDtcXG51bmlmb3JtIGludCBsZXZlbDtcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG4jaWYgIWRlZmluZWQoTUFYX1dJTkRPV19TSVpFX0xPRDEpXFxuI2Vycm9yIE11c3QgZGVmaW5lIE1BWF9XSU5ET1dfU0laRV9MT0QxXFxuI2VsaWYgIWRlZmluZWQoTUFYX1BBVENIX1NJWkUpXFxuI2RlZmluZSBNdXN0IGRlZmluZSBNQVhfUEFUQ0hfU0laRVxcbiNlbmRpZlxcbmNvbnN0IGludCBNQVhfV0lORE9XX1JBRElVUyA9IChNQVhfV0lORE9XX1NJWkVfTE9EMSAtIDEpIC8gMjtcXG5jb25zdCBpbnQgV0lORE9XX0JVRkZFUl9TVFJJREUgPSBNQVhfV0lORE9XX1NJWkVfTE9EMSArIChNQVhfUEFUQ0hfU0laRSAtIDEpO1xcbmNvbnN0IGludCBXSU5ET1dfQlVGRkVSX1NJWkUgPSBXSU5ET1dfQlVGRkVSX1NUUklERSAqIFdJTkRPV19CVUZGRVJfU1RSSURFO1xcbmZsb2F0IHdpbmRvd0J1ZmZlcltXSU5ET1dfQlVGRkVSX1NJWkVdO1xcbmZsb2F0IHdpbmRvd01lYW47XFxuY29uc3QgaW50IFBBVENIX0JVRkZFUl9TSVpFID0gTUFYX1BBVENIX1NJWkUgKiBNQVhfUEFUQ0hfU0laRTtcXG5mbG9hdCBwYXRjaEJ1ZmZlcltQQVRDSF9CVUZGRVJfU0laRV07XFxuZmxvYXQgcGF0Y2hNZWFuO1xcbiNkZWZpbmUgd2luZG93SW5kZXgoaSwgaikgKCgoaikgKyBNQVhfV0lORE9XX1JBRElVUykgKiBXSU5ET1dfQlVGRkVSX1NUUklERSArICgoaSkgKyBNQVhfV0lORE9XX1JBRElVUykpXFxuI2RlZmluZSBwYXRjaEluZGV4KGksIGopICgoKGopICogTUFYX1BBVENIX1NJWkUpICsgKGkpKVxcbiNkZWZpbmUgd2luZG93UmFkaXVzKCkgKCh3aW5kb3dTaXplIC0gMSkgLyAyKVxcbiNkZWZpbmUgd2luZG93UGl4ZWwoaSwgaikgd2luZG93QnVmZmVyW3dpbmRvd0luZGV4KChpKSwgKGopKV1cXG4jZGVmaW5lIHBhdGNoUGl4ZWwoaSwgaikgcGF0Y2hCdWZmZXJbcGF0Y2hJbmRleCgoaSksIChqKSldXFxudm9pZCByZWFkV2luZG93KHZlYzIgY2VudGVyLCBmbG9hdCBsb2QpXFxue1xcbml2ZWMyIHB5ckJhc2VTaXplID0gdGV4dHVyZVNpemUobmV4dFB5cmFtaWQsIDApO1xcbmZsb2F0IHBvdCA9IGV4cDIobG9kKTtcXG5pbnQgciA9IHdpbmRvd1JhZGl1cygpO1xcbmludCBpLCBqO1xcbml2ZWMyIG9mZnNldDtcXG5mbG9hdCBzdW0gPSAwLjBmO1xcbmZvcihqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKykge1xcbmZvcihpID0gMDsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xcbm9mZnNldCA9IGl2ZWMyKGktciwgai1yKTtcXG5zdW0gKz0gKHdpbmRvd1BpeGVsKGktciwgai1yKSA9IHB5clN1YnBpeGVsQXRFeE9mZnNldChuZXh0UHlyYW1pZCwgY2VudGVyLCBsb2QsIHBvdCwgb2Zmc2V0LCBweXJCYXNlU2l6ZSkuZyk7XFxufVxcbn1cXG5mb3IoaiA9IDE7IGogPCBwYXRjaFNpemU7IGorKykge1xcbmZvcihpID0gMDsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xcbm9mZnNldCA9IGl2ZWMyKGktciwgcitqKTtcXG5zdW0gKz0gKHdpbmRvd1BpeGVsKGktciwgcitqKSA9IHB5clN1YnBpeGVsQXRFeE9mZnNldChuZXh0UHlyYW1pZCwgY2VudGVyLCBsb2QsIHBvdCwgb2Zmc2V0LCBweXJCYXNlU2l6ZSkuZyk7XFxuc3VtICs9ICh3aW5kb3dQaXhlbChyK2osIGktcikgPSBweXJTdWJwaXhlbEF0RXhPZmZzZXQobmV4dFB5cmFtaWQsIGNlbnRlciwgbG9kLCBwb3QsIG9mZnNldC55eCwgcHlyQmFzZVNpemUpLmcpO1xcbn1cXG59XFxuZm9yKGogPSAxOyBqIDwgcGF0Y2hTaXplOyBqKyspIHtcXG5mb3IoaSA9IDE7IGkgPCBwYXRjaFNpemU7IGkrKykge1xcbm9mZnNldCA9IGl2ZWMyKHIraSwgcitqKTtcXG5zdW0gKz0gKHdpbmRvd1BpeGVsKHIraSwgcitqKSA9IHB5clN1YnBpeGVsQXRFeE9mZnNldChuZXh0UHlyYW1pZCwgY2VudGVyLCBsb2QsIHBvdCwgb2Zmc2V0LCBweXJCYXNlU2l6ZSkuZyk7XFxufVxcbn1cXG5pbnQgcCA9IHBhdGNoU2l6ZSwgdyA9IHdpbmRvd1NpemU7XFxuaW50IHdpbmRvd0FyZWEgPSB3ICogdyArIDIgKiB3ICogKHAtMSkgKyAocC0xKSAqIChwLTEpO1xcbndpbmRvd01lYW4gPSBzdW0gLyBmbG9hdCh3aW5kb3dBcmVhKTtcXG59XFxudm9pZCByZWFkUGF0Y2godmVjMiBjZW50ZXIsIGZsb2F0IGxvZClcXG57XFxuaXZlYzIgcHlyQmFzZVNpemUgPSB0ZXh0dXJlU2l6ZShwcmV2UHlyYW1pZCwgMCk7XFxuZmxvYXQgcG90ID0gZXhwMihsb2QpO1xcbmZsb2F0IHN1bSA9IDAuMGY7XFxuaW50IHIgPSBwYXRjaFNpemUgLyAyO1xcbml2ZWMyIG9mZnNldDtcXG5mb3IoaW50IGogPSAwOyBqIDwgcGF0Y2hTaXplOyBqKyspIHtcXG5mb3IoaW50IGkgPSAwOyBpIDwgcGF0Y2hTaXplOyBpKyspIHtcXG5vZmZzZXQgPSBpdmVjMihpLXIsIGotcik7XFxuc3VtICs9IChwYXRjaFBpeGVsKGksIGopID0gcHlyU3VicGl4ZWxBdEV4T2Zmc2V0KHByZXZQeXJhbWlkLCBjZW50ZXIsIGxvZCwgcG90LCBvZmZzZXQsIHB5ckJhc2VTaXplKS5nKTtcXG59XFxufVxcbmludCBwYXRjaEFyZWEgPSBwYXRjaFNpemUgKiBwYXRjaFNpemU7XFxucGF0Y2hNZWFuID0gc3VtIC8gZmxvYXQocGF0Y2hBcmVhKTtcXG59XFxuI2RlZmluZSBlbmNvZGVJbnZhbGlkRmxvdygpIHZlYzQoZW5jb2RlRmxvYXQxNk5hTigpLCBlbmNvZGVGbG9hdDE2TmFOKCkpXFxuZmxvYXQgY29tcHV0ZU5DQyhpdmVjMiBvZmZzZXQpXFxue1xcbmludCByID0gd2luZG93UmFkaXVzKCk7XFxuaW50IHggPSBjbGFtcChvZmZzZXQueCwgLXIsIHIpLCB5ID0gY2xhbXAob2Zmc2V0LnksIC1yLCByKTtcXG4jaWYgMVxcbmZsb2F0IHdpbiA9IDAuMGYsIHRwbCA9IDAuMGY7XFxuZmxvYXQgY292YXIgPSAwLjBmLCB3aW52YXIgPSAwLjBmLCB0cGx2YXIgPSAwLjBmO1xcbmZvcihpbnQgaSA9IDA7IGkgPCBwYXRjaFNpemU7IGkrKykge1xcbmZvcihpbnQgaiA9IDA7IGogPCBwYXRjaFNpemU7IGorKykge1xcbndpbiA9IHdpbmRvd1BpeGVsKHgraSwgeStqKSAtIHdpbmRvd01lYW47XFxudHBsID0gcGF0Y2hQaXhlbChpLCBqKSAtIHBhdGNoTWVhbjtcXG5jb3ZhciArPSB3aW4gKiB0cGw7XFxud2ludmFyICs9IHdpbiAqIHdpbjtcXG50cGx2YXIgKz0gdHBsICogdHBsO1xcbn1cXG59XFxucmV0dXJuIGNvdmFyIC8gc3FydCh3aW52YXIgKiB0cGx2YXIpO1xcbiNlbHNlXFxuaW50IGNvdmFyID0gMCwgd2ludmFyID0gMCwgdHBsdmFyID0gMDtcXG5pbnQgd21lYW4gPSBpbnQocm91bmQoMjU1LjBmICogd2luZG93TWVhbikpLCBwbWVhbiA9IGludChyb3VuZCgyNTUuMGYgKiBwYXRjaE1lYW4pKTtcXG5mb3IoaW50IGkgPSAwOyBpIDwgcGF0Y2hTaXplOyBpKyspIHtcXG5mb3IoaW50IGogPSAwOyBqIDwgcGF0Y2hTaXplOyBqKyspIHtcXG5pbnQgd2luID0gaW50KDI1NS4wZiAqIHdpbmRvd1BpeGVsKHgraSwgeStqKSkgLSB3bWVhbjtcXG5pbnQgdHBsID0gaW50KDI1NS4wZiAqIHBhdGNoUGl4ZWwoaSwgaikpIC0gcG1lYW47XFxuY292YXIgKz0gd2luICogdHBsO1xcbndpbnZhciArPSB3aW4gKiB3aW47XFxudHBsdmFyICs9IHRwbCAqIHRwbDtcXG59XFxufVxcbnJldHVybiAoZmxvYXQoY292YXIpIC8gNjUwMjUuMGYpIC8gc3FydCgoZmxvYXQod2ludmFyKSAvIDY1MDI1LjBmKSAqIChmbG9hdCh0cGx2YXIpIC8gNjUwMjUuMGYpKTtcXG4jZW5kaWZcXG59XFxudmVjMiByZWZpbmVTdWJwaXhlbChpdmVjMiBmbG93KVxcbntcXG5mbG9hdCBxMSA9IGNvbXB1dGVOQ0MoZmxvdyArIGl2ZWMyKC0xLC0xKSk7XFxuZmxvYXQgcTIgPSBjb21wdXRlTkNDKGZsb3cgKyBpdmVjMiggMCwtMSkpO1xcbmZsb2F0IHEzID0gY29tcHV0ZU5DQyhmbG93ICsgaXZlYzIoIDEsLTEpKTtcXG5mbG9hdCBxNCA9IGNvbXB1dGVOQ0MoZmxvdyArIGl2ZWMyKC0xLCAwKSk7XFxuZmxvYXQgcTUgPSBjb21wdXRlTkNDKGZsb3cgKyBpdmVjMiggMCwgMCkpO1xcbmZsb2F0IHE2ID0gY29tcHV0ZU5DQyhmbG93ICsgaXZlYzIoIDEsIDApKTtcXG5mbG9hdCBxNyA9IGNvbXB1dGVOQ0MoZmxvdyArIGl2ZWMyKC0xLCAxKSk7XFxuZmxvYXQgcTggPSBjb21wdXRlTkNDKGZsb3cgKyBpdmVjMiggMCwgMSkpO1xcbmZsb2F0IHE5ID0gY29tcHV0ZU5DQyhmbG93ICsgaXZlYzIoIDEsIDEpKTtcXG5mbG9hdCBhID0gKHExIC0gMi4wZiAqIHEyICsgcTMgKyBxNCAtIDIuMGYgKiBxNSArIHE2ICsgcTcgLSAyLjBmICogcTggKyBxOSkgLyA2LjBmO1xcbmZsb2F0IGIgPSAocTEgLSBxMyAtIHE3ICsgcTkpIC8gNC4wZjtcXG5mbG9hdCBjID0gKHExICsgcTIgKyBxMyAtIDIuMGYgKiBxNCAtIDIuMGYgKiBxNSAtIDIuMGYgKiBxNiArIHE3ICsgcTggKyBxOSkgLyA2LjBmO1xcbmZsb2F0IGQgPSAoLXExICsgcTMgLSBxNCArIHE2IC0gcTcgKyBxOSkgLyA2LjBmO1xcbmZsb2F0IGUgPSAoLXExIC0gcTIgLSBxMyArIHE3ICsgcTggKyBxOSkgLyA2LjBmO1xcbmZsb2F0IGhkZXQgPSA0LjBmICogYSAqIGMgLSBiICogYjtcXG5ib29sIGhhc01heCA9IGhkZXQgPiAwLjBmICYmIGEgPCAwLjBmO1xcbmZsb2F0IGRldCA9IGhkZXQ7XFxudmVjMiBwaXhlbEZsb3cgPSB2ZWMyKGZsb3cpO1xcbnZlYzIgc3VicGl4ZWxGbG93ID0gaGFzTWF4ID8gdmVjMihiICogZSAtIDIuMGYgKiBjICogZCwgYiAqIGQgLSAyLjBmICogYSAqIGUpIC8gZGV0IDogcGl4ZWxGbG93O1xcbnJldHVybiBzdWJwaXhlbEZsb3c7XFxucmV0dXJuIGRpc3RhbmNlKHN1YnBpeGVsRmxvdywgcGl4ZWxGbG93KSA8IDIuMGYgPyBzdWJwaXhlbEZsb3cgOiBwaXhlbEZsb3c7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChlbmNvZGVkRmxvdyk7XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pbnQga2V5cG9pbnRJbmRleCA9IHRocmVhZC54ICsgdGhyZWFkLnkgKiBvdXRwdXRTaXplKCkueDtcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgLyA0O1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKGtleXBvaW50SW5kZXggKiBwaXhlbHNQZXJLZXlwb2ludCwgMCk7XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChwcmV2S2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBhZGRyZXNzKTtcXG5jb2xvciA9IGVuY29kZU51bGxQYWlyT2ZGbG9hdDE2KCk7XFxuaWYoaXNOdWxsS2V5cG9pbnQoa2V5cG9pbnQpKVxcbnJldHVybjtcXG5jb2xvciA9IGVuY29kZVBhaXJPZkZsb2F0MTYodmVjMigwLjBmKSk7XFxuaWYoaXNCYWRLZXlwb2ludChrZXlwb2ludCkpXFxucmV0dXJuO1xcbmNvbnN0IGludCBNQVhfTE9EID0gMDtcXG52ZWMyIGZsb3cgPSBsZXZlbCA8IE1BWF9MT0QgPyBkZWNvZGVQYWlyT2ZGbG9hdDE2KHBpeGVsKSA6IHZlYzIoMC4wZik7XFxuZmxvdyAqPSAyLjBmO1xcbmZsb2F0IGxvZCA9IGZsb2F0KGxldmVsKTtcXG5yZWFkV2luZG93KGtleXBvaW50LnBvc2l0aW9uICsgZmxvdywgbG9kKTtcXG5yZWFkUGF0Y2goa2V5cG9pbnQucG9zaXRpb24gKyBmbG93LCBsb2QpO1xcbml2ZWMyIGJlc3RPZmZzZXQgPSBpdmVjMigwKSwgY3Vyck9mZnNldDtcXG5mbG9hdCBiZXN0TkNDID0gLTIuMGYsIGN1cnJOQ0M7XFxuaW50IHIgPSB3aW5kb3dSYWRpdXMoKTtcXG5mb3IoaW50IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKSB7XFxuZm9yKGludCBpID0gMDsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xcbmN1cnJPZmZzZXQgPSBpdmVjMihpLXIsIGotcik7XFxuY3Vyck5DQyA9IGNvbXB1dGVOQ0MoY3Vyck9mZnNldCk7XFxuYmVzdE9mZnNldCA9IGJlc3ROQ0MgPiBjdXJyTkNDID8gYmVzdE9mZnNldCA6IGN1cnJPZmZzZXQ7XFxuYmVzdE5DQyA9IG1heChjdXJyTkNDLCBiZXN0TkNDKTtcXG59XFxufVxcbmZsb3cgKz0gcmVmaW5lU3VicGl4ZWwoYmVzdE9mZnNldCk7XFxuY29sb3IgPSBiZXN0TkNDID49IGRpc2NhcmRUaHJlc2hvbGQgPyBlbmNvZGVQYWlyT2ZGbG9hdDE2KGZsb3cpIDogZW5jb2RlSW52YWxpZEZsb3coKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcInB5cmFtaWRzLmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG5AaW5jbHVkZSBcXFwiZmlsdGVycy5nbHNsXFxcIlxcbiNpZiAhZGVmaW5lZChVU0VfTEFQTEFDSUFOKVxcbiNlcnJvciBVbmRlZmluZWQgVVNFX0xBUExBQ0lBTlxcbiNlbmRpZlxcbnVuaWZvcm0gc2FtcGxlcjJEIGNvcm5lcnM7XFxudW5pZm9ybSBzYW1wbGVyMkQgcHlyYW1pZDtcXG51bmlmb3JtIGZsb2F0IGxvZFN0ZXA7XFxuI2lmIFVTRV9MQVBMQUNJQU5cXG51bmlmb3JtIHNhbXBsZXIyRCBweXJMYXBsYWNpYW47XFxuI2VuZGlmXFxudm9pZCBtYWluKClcXG57XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG52ZWM0IHBpeGVsID0gdGhyZWFkUGl4ZWwoY29ybmVycyk7XFxuZmxvYXQgc2NvcmUgPSBkZWNvZGVGbG9hdDE2KHBpeGVsLnJiKTtcXG5mbG9hdCBteUVuY29kZWRMb2QgPSBwaXhlbC5hO1xcbmZsb2F0IGxvZCA9IGRlY29kZUxvZChteUVuY29kZWRMb2QpO1xcbmZsb2F0IGxvZFBsdXMgPSBsb2QgKyBsb2RTdGVwO1xcbmZsb2F0IGxvZE1pbnVzID0gbG9kIC0gbG9kU3RlcDtcXG5mbG9hdCBwb3QgPSBleHAyKGxvZCk7XFxuZmxvYXQgcG90UGx1cyA9IGV4cDIobG9kUGx1cyk7XFxuZmxvYXQgcG90TWludXMgPSBleHAyKGxvZE1pbnVzKTtcXG5jb2xvciA9IHBpeGVsO1xcbmlmKHNjb3JlID09IDAuMGYpXFxucmV0dXJuO1xcbiNkZWZpbmUgUChwLHUsdikgdGV4dHVyZUxvZChjb3JuZXJzLCB0ZXhDb29yZCArIChwKSAqIHZlYzIoKHUpLCh2KSkgLyB0ZXhTaXplLCAwLjBmKVxcbnZlYzQgcGl4WzE4XSA9IHZlYzRbMThdKFxcbiNkZWZpbmUgRCh1LHYpIFAocG90TWludXMsKHUpLCh2KSlcXG5EKC0xLC0xKSwgRCgwLC0xKSwgRCgxLC0xKSxcXG5EKC0xLDApLCBEKDAsMCksIEQoMSwwKSxcXG5EKC0xLDEpLCBEKDAsMSksIEQoMSwxKVxcbixcXG4jZGVmaW5lIFUodSx2KSBQKHBvdFBsdXMsKHUpLCh2KSlcXG5VKC0xLC0xKSwgVSgwLC0xKSwgVSgxLC0xKSxcXG5VKC0xLDApLCBVKDAsMCksIFUoMSwwKSxcXG5VKC0xLDEpLCBVKDAsMSksIFUoMSwxKVxcbik7XFxuZmxvYXQgc2NvcmVzWzE4XSA9IGZsb2F0WzE4XShcXG4jZGVmaW5lIEMoaikgZGVjb2RlRmxvYXQxNihwaXhbal0ucmIpXFxuQygwKSwgQygxKSwgQygyKSxcXG5DKDMpLCBDKDQpLCBDKDUpLFxcbkMoNiksIEMoNyksIEMoOClcXG4sXFxuQyg5KSwgQygxMCksIEMoMTEpLFxcbkMoMTIpLCBDKDEzKSwgQygxNCksXFxuQygxNSksIEMoMTYpLCBDKDE3KVxcbik7XFxuZmxvYXQgbG9kc1sxOF0gPSBmbG9hdFsxOF0oXFxuI2RlZmluZSBFKGopIGRlY29kZUxvZChwaXhbal0uYSlcXG5FKDApLCBFKDEpLCBFKDIpLFxcbkUoMyksIEUoNCksIEUoNSksXFxuRSg2KSwgRSg3KSwgRSg4KVxcbixcXG5FKDkpLCBFKDEwKSwgRSgxMSksXFxuRSgxMiksIEUoMTMpLCBFKDE0KSxcXG5FKDE1KSwgRSgxNiksIEUoMTcpXFxuKTtcXG4jaWYgVVNFX0xBUExBQ0lBTlxcbiNkZWZpbmUgTChwLHUsdikgdGV4dHVyZUxvZChweXJMYXBsYWNpYW4sIHRleENvb3JkICsgKHApICogdmVjMigodSksKHYpKSAvIHRleFNpemUsIDAuMGYpXFxubWF0MyBzdHJlbmd0aHNbMl0gPSBtYXQzWzJdKG1hdDMoXFxuI2RlZmluZSBMbSh1LHYpIGFicyhkZWNvZGVGbG9hdDE2KEwocG90TWludXMsKHUpLCh2KSkueHkpKVxcbkxtKC0xLC0xKSwgTG0oMCwtMSksIExtKDEsLTEpLFxcbkxtKC0xLDApLCBMbSgwLDApLCBMbSgxLDApLFxcbkxtKC0xLDEpLCBMbSgwLDEpLCBMbSgxLDEpXFxuKSwgbWF0MyhcXG4jZGVmaW5lIExwKHUsdikgYWJzKGRlY29kZUZsb2F0MTYoTChwb3RQbHVzLCh1KSwodikpLnp3KSlcXG5McCgtMSwtMSksIExwKDAsLTEpLCBMcCgxLC0xKSxcXG5McCgtMSwwKSwgTHAoMCwwKSwgTHAoMSwwKSxcXG5McCgtMSwxKSwgTHAoMCwxKSwgTHAoMSwxKVxcbikpO1xcbmZsb2F0IG15U3RyZW5ndGggPSBhYnMobGFwbGFjaWFuKHB5cmFtaWQsIHZlYzIodGhyZWFkKSwgbG9kKSk7XFxuI2Vsc2VcXG4jZGVmaW5lIEwodSx2KSAoKCh2KSsxKSozICsgKCh1KSsxKSlcXG5tYXQzIHN0cmVuZ3Roc1syXSA9IG1hdDNbMl0obWF0MyhcXG4jZGVmaW5lIExtKHUsdikgc2NvcmVzW0woKHUpLCh2KSldXFxuTG0oLTEsLTEpLCBMbSgwLC0xKSwgTG0oMSwtMSksXFxuTG0oLTEsMCksIExtKDAsMCksIExtKDEsMCksXFxuTG0oLTEsMSksIExtKDAsMSksIExtKDEsMSlcXG4pLCBtYXQzKFxcbiNkZWZpbmUgTHAodSx2KSBzY29yZXNbOSArIEwoKHUpLCh2KSldXFxuTHAoLTEsLTEpLCBMcCgwLC0xKSwgTHAoMSwtMSksXFxuTHAoLTEsMCksIExwKDAsMCksIExwKDEsMCksXFxuTHAoLTEsMSksIExwKDAsMSksIExwKDEsMSlcXG4pKTtcXG5mbG9hdCBteVN0cmVuZ3RoID0gc2NvcmU7XFxuI2VuZGlmXFxuI2RlZmluZSBCKGosbG9kKSBmbG9hdChpc1NhbWVMb2QobG9kc1tqXSwgKGxvZCkpKSAqIGZsb2F0KHNjb3Jlc1tqXSA+IDAuMGYpXFxubWF0MyBuZWFyTG9kWzJdID0gbWF0M1syXShtYXQzKFxcbiNkZWZpbmUgQm0oaikgQigoaiksIGxvZE1pbnVzKVxcbkJtKDApLCBCbSgxKSwgQm0oMiksXFxuQm0oMyksIEJtKDQpLCBCbSg1KSxcXG5CbSg2KSwgQm0oNyksIEJtKDgpXFxuKSwgbWF0MyhcXG4jZGVmaW5lIEJwKGopIEIoKGopLCBsb2RQbHVzKVxcbkJwKDkpLCBCcCgxMCksIEJwKDExKSxcXG5CcCgxMiksIEJwKDEzKSwgQnAoMTQpLFxcbkJwKDE1KSwgQnAoMTYpLCBCcCgxNylcXG4pKTtcXG5tYXQzIHVwU3RyZW5ndGhzID0gbWF0cml4Q29tcE11bHQoc3RyZW5ndGhzWzFdLCBuZWFyTG9kWzFdKTtcXG5tYXQzIGRvd25TdHJlbmd0aHMgPSBtYXRyaXhDb21wTXVsdChzdHJlbmd0aHNbMF0sIG5lYXJMb2RbMF0pO1xcbnZlYzMgbWF4VXBTdHJlbmd0aDMgPSBtYXgodXBTdHJlbmd0aHNbMF0sIG1heCh1cFN0cmVuZ3Roc1sxXSwgdXBTdHJlbmd0aHNbMl0pKTtcXG52ZWMzIG1heERvd25TdHJlbmd0aDMgPSBtYXgoZG93blN0cmVuZ3Roc1swXSwgbWF4KGRvd25TdHJlbmd0aHNbMV0sIGRvd25TdHJlbmd0aHNbMl0pKTtcXG52ZWMzIG1heFN0cmVuZ3RoMyA9IG1heChtYXhVcFN0cmVuZ3RoMywgbWF4RG93blN0cmVuZ3RoMyk7XFxuZmxvYXQgbWF4U3RyZW5ndGggPSBtYXgobWF4U3RyZW5ndGgzLngsIG1heChtYXhTdHJlbmd0aDMueSwgbWF4U3RyZW5ndGgzLnopKTtcXG5jb2xvci5yYiA9IGVuY29kZUZsb2F0MTYoc2NvcmUgKiBzdGVwKG1heFN0cmVuZ3RoLCBteVN0cmVuZ3RoKSk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJweXJhbWlkcy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJmbG9hdDE2Lmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgY29ybmVycztcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChjb3JuZXJzKTtcXG5mbG9hdCBlbmNvZGVkTG9kID0gcGl4ZWwuYTtcXG5mbG9hdCBzY29yZSA9IGRlY29kZUZsb2F0MTYocGl4ZWwucmIpO1xcbmZsb2F0IGxvZCA9IGRlY29kZUxvZChlbmNvZGVkTG9kKTtcXG5mbG9hdCBwb3QgPSBleHAyKGxvZCk7XFxuY29sb3IgPSBwaXhlbDtcXG5pZihzY29yZSA9PSAwLjBmKVxcbnJldHVybjtcXG4jaWYgMVxcbnZlYzIgZ3JpZFNpemUgPSB2ZWMyKHBvdCk7XFxudmVjMiBncmlkTG9jYXRpb24gPSBmbG9vcihtb2QodGV4Q29vcmQgKiB0ZXhTaXplLCBncmlkU2l6ZSkpO1xcbnZlYzIgZ3JpZERlbHRhID0gZ3JpZExvY2F0aW9uIC8gZ3JpZFNpemUgLSB2ZWMyKDAuNWYpO1xcbmZsb2F0IGdyaWRTdGVwID0gMS4wZiAvIHBvdDtcXG5jb25zdCBmbG9hdCBhZGp1c3RtZW50ID0gMS4yNWY7XFxuY29sb3IucmIgPSBlbmNvZGVGbG9hdDE2KDAuMGYpO1xcbmlmKG1heChhYnMoZ3JpZERlbHRhLngpLCBhYnMoZ3JpZERlbHRhLnkpKSA+IGFkanVzdG1lbnQgKiBncmlkU3RlcClcXG5yZXR1cm47XFxuI2VuZGlmXFxuI2RlZmluZSBQKHgseSkgdGV4dHVyZUxvZChjb3JuZXJzLCB0ZXhDb29yZCArIHBvdCAqIHZlYzIoKHgpLCAoeSkpIC8gdGV4U2l6ZSwgMC4wZilcXG52ZWM0IHBpeFs5XSA9IHZlYzRbOV0oXFxuUCgtMSwtMSksIFAoMCwtMSksIFAoMSwtMSksXFxuUCgtMSwwKSwgcGl4ZWwsIFAoMSwwKSxcXG5QKC0xLDEpLCBQKDAsMSksIFAoMSwxKVxcbik7XFxuI2RlZmluZSBTKGopIGRlY29kZUZsb2F0MTYocGl4W2pdLnJiKVxcbm1hdDMgc2NvcmVzID0gbWF0MyhcXG5TKDApLCBTKDEpLCBTKDIpLFxcblMoMyksIFMoNCksIFMoNSksXFxuUyg2KSwgUyg3KSwgUyg4KVxcbik7XFxuI2RlZmluZSBCKGopIGZsb2F0KGlzU2FtZUxvZChkZWNvZGVMb2QocGl4W2pdLmEpLCBsb2QpKVxcbm1hdDMgc2FtZUxvZCA9IG1hdDMoXFxuQigwKSwgQigxKSwgQigyKSxcXG5CKDMpLCBCKDQpLCBCKDUpLFxcbkIoNiksIEIoNyksIEIoOClcXG4pO1xcbm1hdDMgc2FtZUxvZFNjb3JlcyA9IG1hdHJpeENvbXBNdWx0KHNjb3Jlcywgc2FtZUxvZCk7XFxudmVjMyBtYXhTY29yZTMgPSBtYXgoc2FtZUxvZFNjb3Jlc1swXSwgbWF4KHNhbWVMb2RTY29yZXNbMV0sIHNhbWVMb2RTY29yZXNbMl0pKTtcXG5mbG9hdCBtYXhTY29yZSA9IG1heChtYXhTY29yZTMueCwgbWF4KG1heFNjb3JlMy55LCBtYXhTY29yZTMueikpO1xcbmNvbG9yLnJiID0gZW5jb2RlRmxvYXQxNihzY29yZSAqIHN0ZXAobWF4U2NvcmUsIHNjb3JlKSk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJweXJhbWlkcy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJmbG9hdDE2Lmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCBsb2RTdGVwO1xcbiNpZiAhZGVmaW5lZChNVUxUSVNDQUxFKVxcbiNlcnJvciBNdXN0IGRlZmluZSBNVUxUSVNDQUxFXFxuI2VsaWYgTVVMVElTQ0FMRSAhPSAwXFxuI2RlZmluZSBMT0RfU1RFUCAobG9kU3RlcClcXG4jZGVmaW5lIFVTRV9NSURETEVfUklOR1xcbiNlbHNlXFxuI2RlZmluZSBMT0RfU1RFUCAoMC4wZilcXG4jZW5kaWZcXG4jZGVmaW5lIFBJWCh4LHkpIHBpeGVsQXRTaG9ydE9mZnNldChpbWFnZSwgaXZlYzIoKHgpLCh5KSkpXFxuI2RlZmluZSBMMih2LGkpIGJ2ZWMyKGlzU2FtZUVuY29kZWRMb2QodltpXS5hLCBhbHBoYU1pbnVzKSwgaXNTYW1lRW5jb2RlZExvZCh2W2ldLmEsIGFscGhhUGx1cykpXFxuI2RlZmluZSBMMyh2LGkpIGJ2ZWMzKGlzU2FtZUVuY29kZWRMb2QodltpXS5hLCBhbHBoYSksIGlzU2FtZUVuY29kZWRMb2QodltpXS5hLCBhbHBoYU1pbnVzKSwgaXNTYW1lRW5jb2RlZExvZCh2W2ldLmEsIGFscGhhUGx1cykpXFxuI2RlZmluZSBTMyh2LGkpIGRlY29kZUZsb2F0MTYodltpXS5yYikgKiBmbG9hdChhbnkoTDModixpKSkpXFxuI2RlZmluZSBTMih2LGkpIGRlY29kZUZsb2F0MTYodltpXS5yYikgKiBmbG9hdChhbnkoTDIodixpKSkpXFxuI2RlZmluZSBQKGkpIFMzKHAsaSlcXG4jZGVmaW5lIFEoaSkgUzIocSxpKVxcbiNkZWZpbmUgUihpKSBTMihyLGkpXFxuY29uc3QgdmVjNCBPID0gdmVjNCgwLjBmKTtcXG52b2lkIG1haW4oKVxcbntcXG52ZWM0IHBpeGVsID0gdGhyZWFkUGl4ZWwoaW1hZ2UpO1xcbmZsb2F0IGxvZCA9IGRlY29kZUxvZChwaXhlbC5hKTtcXG5mbG9hdCBzY29yZSA9IGRlY29kZUZsb2F0MTYocGl4ZWwucmIpO1xcbmNvbG9yID0gcGl4ZWw7XFxuaWYoc2NvcmUgPT0gMC4wZilcXG5yZXR1cm47XFxudmVjNCBwWzhdID0gdmVjNFs4XShcXG5QSVgoMCwxKSwgUElYKDEsMSksIFBJWCgxLDApLCBQSVgoMSwtMSksXFxuUElYKDAsLTEpLCBQSVgoLTEsLTEpLCBQSVgoLTEsMCksIFBJWCgtMSwxKVxcbik7XFxuI2lmZGVmIFVTRV9NSURETEVfUklOR1xcbnZlYzQgcVsxNl0gPSB2ZWM0WzE2XShcXG5QSVgoMCwyKSwgUElYKDEsMiksIFBJWCgyLDIpLCBQSVgoMiwxKSxcXG5QSVgoMiwwKSwgUElYKDIsLTEpLCBQSVgoMiwtMiksIFBJWCgxLC0yKSxcXG5QSVgoMCwtMiksIFBJWCgtMSwtMiksIFBJWCgtMiwtMiksIFBJWCgtMiwtMSksXFxuUElYKC0yLDApLCBQSVgoLTIsMSksIFBJWCgtMiwyKSwgUElYKC0xLDIpXFxuKTtcXG4jZWxzZVxcbnZlYzQgcVsxNl0gPSB2ZWM0WzE2XShPLE8sTyxPLE8sTyxPLE8sTyxPLE8sTyxPLE8sTyxPKTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX09VVEVSX1JJTkdcXG52ZWM0IHJbMTZdID0gdmVjNFsxNl0oXFxuUElYKDAsMyksIFBJWCgxLDMpLCBQSVgoMywxKSwgUElYKDMsMCksXFxuUElYKDMsLTEpLCBQSVgoMSwtMyksIFBJWCgwLC0zKSwgUElYKC0xLC0zKSxcXG5QSVgoLTMsLTEpLCBQSVgoLTMsMCksIFBJWCgtMywxKSwgUElYKC0xLDMpLFxcblBJWCgwLDQpLCBQSVgoNCwwKSwgUElYKDAsLTQpLCBQSVgoLTQsMClcXG4pO1xcbiNlbHNlXFxudmVjNCByWzE2XSA9IHZlYzRbMTZdKE8sTyxPLE8sTyxPLE8sTyxPLE8sTyxPLE8sTyxPLE8pO1xcbiNlbmRpZlxcbmZsb2F0IGFscGhhUGx1cyA9IGVuY29kZUxvZChsb2QgKyBMT0RfU1RFUCk7XFxuZmxvYXQgYWxwaGFNaW51cyA9IGVuY29kZUxvZChsb2QgLSBMT0RfU1RFUCk7XFxuZmxvYXQgYWxwaGEgPSBlbmNvZGVMb2QobG9kKTtcXG5tYXQzIGlubmVyU2NvcmUgPSBtYXQzKFxcblAoMCksIFAoMSksIFAoMiksIFAoMyksXFxuUCg0KSwgUCg1KSwgUCg2KSwgUCg3KSxcXG4wLjBmKTtcXG5tYXQ0IG1pZGRsZVNjb3JlID0gbWF0NChcXG5RKDApLCBRKDEpLCBRKDIpLCBRKDMpLFxcblEoNCksIFEoNSksIFEoNiksIFEoNyksXFxuUSg4KSwgUSg5KSwgUSgxMCksIFEoMTEpLFxcblEoMTIpLCBRKDEzKSwgUSgxNCksIFEoMTUpXFxuKTtcXG5tYXQ0IG91dGVyU2NvcmUgPSBtYXQ0KFxcblIoMCksIFIoMSksIFIoMiksIFIoMyksXFxuUig0KSwgUig1KSwgUig2KSwgUig3KSxcXG5SKDgpLCBSKDkpLCBSKDEwKSwgUigxMSksXFxuUigxMiksIFIoMTMpLCBSKDE0KSwgUigxNSlcXG4pO1xcbnZlYzMgbWF4SW5uZXJTY29yZTMgPSBtYXgoaW5uZXJTY29yZVswXSwgbWF4KGlubmVyU2NvcmVbMV0sIGlubmVyU2NvcmVbMl0pKTtcXG52ZWM0IG1heE1pZGRsZVNjb3JlNCA9IG1heChtYXgobWlkZGxlU2NvcmVbMF0sIG1pZGRsZVNjb3JlWzFdKSwgbWF4KG1pZGRsZVNjb3JlWzJdLCBtaWRkbGVTY29yZVszXSkpO1xcbnZlYzQgbWF4T3V0ZXJTY29yZTQgPSBtYXgobWF4KG91dGVyU2NvcmVbMF0sIG91dGVyU2NvcmVbMV0pLCBtYXgob3V0ZXJTY29yZVsyXSwgb3V0ZXJTY29yZVszXSkpO1xcbmZsb2F0IG1heElubmVyU2NvcmUgPSBtYXgobWF4SW5uZXJTY29yZTMueCwgbWF4KG1heElubmVyU2NvcmUzLnksIG1heElubmVyU2NvcmUzLnopKTtcXG5mbG9hdCBtYXhNaWRkbGVTY29yZSA9IG1heChtYXgobWF4TWlkZGxlU2NvcmU0LngsIG1heE1pZGRsZVNjb3JlNC55KSwgbWF4KG1heE1pZGRsZVNjb3JlNC56LCBtYXhNaWRkbGVTY29yZTQudykpO1xcbmZsb2F0IG1heE91dGVyU2NvcmUgPSBtYXgobWF4KG1heE91dGVyU2NvcmU0LngsIG1heE91dGVyU2NvcmU0LnkpLCBtYXgobWF4T3V0ZXJTY29yZTQueiwgbWF4T3V0ZXJTY29yZTQudykpO1xcbmZsb2F0IG1heFNjb3JlID0gbWF4KG1heElubmVyU2NvcmUsIG1heChtYXhNaWRkbGVTY29yZSwgbWF4T3V0ZXJTY29yZSkpO1xcbmZsb2F0IGZpbmFsU2NvcmUgPSBzdGVwKG1heFNjb3JlLCBzY29yZSkgKiBzY29yZTtcXG5jb2xvci5yYiA9IGVuY29kZUZsb2F0MTYoZmluYWxTY29yZSk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJrZXlwb2ludHMuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBlbmNvZGVkQ29ybmVycztcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGltYWdlO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG5jb25zdCBpbnQgZGVzY3JpcHRvclNpemUgPSAzMjtcXG4jZGVmaW5lIFAoYSxiLGMsZCkgaXZlYzQoKGEpLChiKSwoYyksKGQpKVxcbmNvbnN0IGl2ZWM0IHBhdDMxWzI1Nl0gPSBpdmVjNFsyNTZdKFxcblAoOCwtMyw5LDUpLFxcblAoNCwyLDcsLTEyKSxcXG5QKC0xMSw5LC04LDIpLFxcblAoNywtMTIsMTIsLTEzKSxcXG5QKDIsLTEzLDIsMTIpLFxcblAoMSwtNywxLDYpLFxcblAoLTIsLTEwLC0yLC00KSxcXG5QKC0xMywtMTMsLTExLC04KSxcXG5QKC0xMywtMywtMTIsLTkpLFxcblAoMTAsNCwxMSw5KSxcXG5QKC0xMywtOCwtOCwtOSksXFxuUCgtMTEsNywtOSwxMiksXFxuUCg3LDcsMTIsNiksXFxuUCgtNCwtNSwtMywwKSxcXG5QKC0xMywyLC0xMiwtMyksXFxuUCgtOSwwLC03LDUpLFxcblAoMTIsLTYsMTIsLTEpLFxcblAoLTMsNiwtMiwxMiksXFxuUCgtNiwtMTMsLTQsLTgpLFxcblAoMTEsLTEzLDEyLC04KSxcXG5QKDQsNyw1LDEpLFxcblAoNSwtMywxMCwtMyksXFxuUCgzLC03LDYsMTIpLFxcblAoLTgsLTcsLTYsLTIpLFxcblAoLTIsMTEsLTEsLTEwKSxcXG5QKC0xMywxMiwtOCwxMCksXFxuUCgtNywzLC01LC0zKSxcXG5QKC00LDIsLTMsNyksXFxuUCgtMTAsLTEyLC02LDExKSxcXG5QKDUsLTEyLDYsLTcpLFxcblAoNSwtNiw3LC0xKSxcXG5QKDEsMCw0LC01KSxcXG5QKDksMTEsMTEsLTEzKSxcXG5QKDQsNyw0LDEyKSxcXG5QKDIsLTEsNCw0KSxcXG5QKC00LC0xMiwtMiw3KSxcXG5QKC04LC01LC03LC0xMCksXFxuUCg0LDExLDksMTIpLFxcblAoMCwtOCwxLC0xMyksXFxuUCgtMTMsLTIsLTgsMiksXFxuUCgtMywtMiwtMiwzKSxcXG5QKC02LDksLTQsLTkpLFxcblAoOCwxMiwxMCw3KSxcXG5QKDAsOSwxLDMpLFxcblAoNywtNSwxMSwtMTApLFxcblAoLTEzLC02LC0xMSwwKSxcXG5QKDEwLDcsMTIsMSksXFxuUCgtNiwtMywtNiwxMiksXFxuUCgxMCwtOSwxMiwtNCksXFxuUCgtMTMsOCwtOCwtMTIpLFxcblAoLTEzLDAsLTgsLTQpLFxcblAoMywzLDcsOCksXFxuUCg1LDcsMTAsLTcpLFxcblAoLTEsNywxLC0xMiksXFxuUCgzLC0xMCw1LDYpLFxcblAoMiwtNCwzLC0xMCksXFxuUCgtMTMsMCwtMTMsNSksXFxuUCgtMTMsLTcsLTEyLDEyKSxcXG5QKC0xMywzLC0xMSw4KSxcXG5QKC03LDEyLC00LDcpLFxcblAoNiwtMTAsMTIsOCksXFxuUCgtOSwtMSwtNywtNiksXFxuUCgtMiwtNSwwLDEyKSxcXG5QKC0xMiw1LC03LDUpLFxcblAoMywtMTAsOCwtMTMpLFxcblAoLTcsLTcsLTQsNSksXFxuUCgtMywtMiwtMSwtNyksXFxuUCgyLDksNSwtMTEpLFxcblAoLTExLC0xMywtNSwtMTMpLFxcblAoLTEsNiwwLC0xKSxcXG5QKDUsLTMsNSwyKSxcXG5QKC00LC0xMywtNCwxMiksXFxuUCgtOSwtNiwtOSw2KSxcXG5QKC0xMiwtMTAsLTgsLTQpLFxcblAoMTAsMiwxMiwtMyksXFxuUCg3LDEyLDEyLDEyKSxcXG5QKC03LC0xMywtNiw1KSxcXG5QKC00LDksLTMsNCksXFxuUCg3LC0xLDEyLDIpLFxcblAoLTcsNiwtNSwxKSxcXG5QKC0xMywxMSwtMTIsNSksXFxuUCgtMyw3LC0yLC02KSxcXG5QKDcsLTgsMTIsLTcpLFxcblAoLTEzLC03LC0xMSwtMTIpLFxcblAoMSwtMywxMiwxMiksXFxuUCgyLC02LDMsMCksXFxuUCgtNCwzLC0yLC0xMyksXFxuUCgtMSwtMTMsMSw5KSxcXG5QKDcsMSw4LC02KSxcXG5QKDEsLTEsMywxMiksXFxuUCg5LDEsMTIsNiksXFxuUCgtMSwtOSwtMSwzKSxcXG5QKC0xMywtMTMsLTEwLDUpLFxcblAoNyw3LDEwLDEyKSxcXG5QKDEyLC01LDEyLDkpLFxcblAoNiwzLDcsMTEpLFxcblAoNSwtMTMsNiwxMCksXFxuUCgyLC0xMiwyLDMpLFxcblAoMyw4LDQsLTYpLFxcblAoMiw2LDEyLC0xMyksXFxuUCg5LC0xMiwxMCwzKSxcXG5QKC04LDQsLTcsOSksXFxuUCgtMTEsMTIsLTQsLTYpLFxcblAoMSwxMiwyLC04KSxcXG5QKDYsLTksNywtNCksXFxuUCgyLDMsMywtMiksXFxuUCg2LDMsMTEsMCksXFxuUCgzLC0zLDgsLTgpLFxcblAoNyw4LDksMyksXFxuUCgtMTEsLTUsLTYsLTQpLFxcblAoLTEwLDExLC01LDEwKSxcXG5QKC01LC04LC0zLDEyKSxcXG5QKC0xMCw1LC05LDApLFxcblAoOCwtMSwxMiwtNiksXFxuUCg0LC02LDYsLTExKSxcXG5QKC0xMCwxMiwtOCw3KSxcXG5QKDQsLTIsNiw3KSxcXG5QKC0yLDAsLTIsMTIpLFxcblAoLTUsLTgsLTUsMiksXFxuUCg3LC02LDEwLDEyKSxcXG5QKC05LC0xMywtOCwtOCksXFxuUCgtNSwtMTMsLTUsLTIpLFxcblAoOCwtOCw5LC0xMyksXFxuUCgtOSwtMTEsLTksMCksXFxuUCgxLC04LDEsLTIpLFxcblAoNywtNCw5LDEpLFxcblAoLTIsMSwtMSwtNCksXFxuUCgxMSwtNiwxMiwtMTEpLFxcblAoLTEyLC05LC02LDQpLFxcblAoMyw3LDcsMTIpLFxcblAoNSw1LDEwLDgpLFxcblAoMCwtNCwyLDgpLFxcblAoLTksMTIsLTUsLTEzKSxcXG5QKDAsNywyLDEyKSxcXG5QKC0xLDIsMSw3KSxcXG5QKDUsMTEsNywtOSksXFxuUCgzLDUsNiwtOCksXFxuUCgtMTMsLTQsLTgsOSksXFxuUCgtNSw5LC0zLC0zKSxcXG5QKC00LC03LC0zLC0xMiksXFxuUCg2LDUsOCwwKSxcXG5QKC03LDYsLTYsMTIpLFxcblAoLTEzLDYsLTUsLTIpLFxcblAoMSwtMTAsMywxMCksXFxuUCg0LDEsOCwtNCksXFxuUCgtMiwtMiwyLC0xMyksXFxuUCgyLC0xMiwxMiwxMiksXFxuUCgtMiwtMTMsMCwtNiksXFxuUCg0LDEsOSwzKSxcXG5QKC02LC0xMCwtMywtNSksXFxuUCgtMywtMTMsLTEsMSksXFxuUCg3LDUsMTIsLTExKSxcXG5QKDQsLTIsNSwtNyksXFxuUCgtMTMsOSwtOSwtNSksXFxuUCg3LDEsOCw2KSxcXG5QKDcsLTgsNyw2KSxcXG5QKC03LC00LC03LDEpLFxcblAoLTgsMTEsLTcsLTgpLFxcblAoLTEzLDYsLTEyLC04KSxcXG5QKDIsNCwzLDkpLFxcblAoMTAsLTUsMTIsMyksXFxuUCgtNiwtNSwtNiw3KSxcXG5QKDgsLTMsOSwtOCksXFxuUCgyLC0xMiwyLDgpLFxcblAoLTExLC0yLC0xMCwzKSxcXG5QKC0xMiwtMTMsLTcsLTkpLFxcblAoLTExLDAsLTEwLC01KSxcXG5QKDUsLTMsMTEsOCksXFxuUCgtMiwtMTMsLTEsMTIpLFxcblAoLTEsLTgsMCw5KSxcXG5QKC0xMywtMTEsLTEyLC01KSxcXG5QKC0xMCwtMiwtMTAsMTEpLFxcblAoLTMsOSwtMiwtMTMpLFxcblAoMiwtMywzLDIpLFxcblAoLTksLTEzLC00LDApLFxcblAoLTQsNiwtMywtMTApLFxcblAoLTQsMTIsLTIsLTcpLFxcblAoLTYsLTExLC00LDkpLFxcblAoNiwtMyw2LDExKSxcXG5QKC0xMywxMSwtNSw1KSxcXG5QKDExLDExLDEyLDYpLFxcblAoNywtNSwxMiwtMiksXFxuUCgtMSwxMiwwLDcpLFxcblAoLTQsLTgsLTMsLTIpLFxcblAoLTcsMSwtNiw3KSxcXG5QKC0xMywtMTIsLTgsLTEzKSxcXG5QKC03LC0yLC02LC04KSxcXG5QKC04LDUsLTYsLTkpLFxcblAoLTUsLTEsLTQsNSksXFxuUCgtMTMsNywtOCwxMCksXFxuUCgxLDUsNSwtMTMpLFxcblAoMSwwLDEwLC0xMyksXFxuUCg5LDEyLDEwLC0xKSxcXG5QKDUsLTgsMTAsLTkpLFxcblAoLTEsMTEsMSwtMTMpLFxcblAoLTksLTMsLTYsMiksXFxuUCgtMSwtMTAsMSwxMiksXFxuUCgtMTMsMSwtOCwtMTApLFxcblAoOCwtMTEsMTAsLTYpLFxcblAoMiwtMTMsMywtNiksXFxuUCg3LC0xMywxMiwtOSksXFxuUCgtMTAsLTEwLC01LC03KSxcXG5QKC0xMCwtOCwtOCwtMTMpLFxcblAoNCwtNiw4LDUpLFxcblAoMywxMiw4LC0xMyksXFxuUCgtNCwyLC0zLC0zKSxcXG5QKDUsLTEzLDEwLC0xMiksXFxuUCg0LC0xMyw1LC0xKSxcXG5QKC05LDksLTQsMyksXFxuUCgwLDMsMywtOSksXFxuUCgtMTIsMSwtNiwxKSxcXG5QKDMsMiw0LC04KSxcXG5QKC0xMCwtMTAsLTEwLDkpLFxcblAoOCwtMTMsMTIsMTIpLFxcblAoLTgsLTEyLC02LC01KSxcXG5QKDIsMiwzLDcpLFxcblAoMTAsNiwxMSwtOCksXFxuUCg2LDgsOCwtMTIpLFxcblAoLTcsMTAsLTYsNSksXFxuUCgtMywtOSwtMyw5KSxcXG5QKC0xLC0xMywtMSw1KSxcXG5QKC0zLC03LC0zLDQpLFxcblAoLTgsLTIsLTgsMyksXFxuUCg0LDIsMTIsMTIpLFxcblAoMiwtNSwzLDExKSxcXG5QKDYsLTksMTEsLTEzKSxcXG5QKDMsLTEsNywxMiksXFxuUCgxMSwtMSwxMiw0KSxcXG5QKC0zLDAsLTMsNiksXFxuUCg0LC0xMSw0LDEyKSxcXG5QKDIsLTQsMiwxKSxcXG5QKC0xMCwtNiwtOCwxKSxcXG5QKC0xMyw3LC0xMSwxKSxcXG5QKC0xMywxMiwtMTEsLTEzKSxcXG5QKDYsMCwxMSwtMTMpLFxcblAoMCwtMSwxLDQpLFxcblAoLTEzLDMsLTksLTIpLFxcblAoLTksOCwtNiwtMyksXFxuUCgtMTMsLTYsLTgsLTIpLFxcblAoNSwtOSw4LDEwKSxcXG5QKDIsNywzLC05KSxcXG5QKC0xLC02LC0xLC0xKSxcXG5QKDksNSwxMSwtMiksXFxuUCgxMSwtMywxMiwtOCksXFxuUCgzLDAsMyw1KSxcXG5QKC0xLDQsMCwxMCksXFxuUCgzLC02LDQsNSksXFxuUCgtMTMsMCwtMTAsNSksXFxuUCg1LDgsMTIsMTEpLFxcblAoOCw5LDksLTYpLFxcblAoNywtNCw4LC0xMiksXFxuUCgtMTAsNCwtMTAsOSksXFxuUCg3LDMsMTIsNCksXFxuUCg5LC03LDEwLC0yKSxcXG5QKDcsMCwxMiwtMiksXFxuUCgtMSwtNiwwLC0xMSlcXG4pO1xcbnZvaWQgZ2V0UGFpcihpbnQgaW5kZXgsIG1hdDIgcm90LCBvdXQgdmVjMiBwLCBvdXQgdmVjMiBxKVxcbntcXG5pdmVjNCBkYXRhID0gcGF0MzFbaW5kZXhdO1xcbnZlYzIgb3AgPSB2ZWMyKGRhdGEueHkpO1xcbnZlYzIgb3EgPSB2ZWMyKGRhdGEuencpO1xcbnAgPSByb3QgKiBvcDtcXG5xID0gcm90ICogb3E7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChlbmNvZGVkQ29ybmVycyk7XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IGZpbmRLZXlwb2ludEFkZHJlc3ModGhyZWFkLCBlbmNvZGVyTGVuZ3RoLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5pbnQgZGVzY3JpcHRvckNlbGwgPSBhZGRyZXNzLm9mZnNldCAtIHNpemVvZkVuY29kZWRLZXlwb2ludCgwLCBleHRyYVNpemUpIC8gNDtcXG5jb2xvciA9IHBpeGVsO1xcbmlmKGRlc2NyaXB0b3JDZWxsIDwgMClcXG5yZXR1cm47XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkQ29ybmVycywgZW5jb2Rlckxlbmd0aCwgYWRkcmVzcyk7XFxuaWYoaXNCYWRLZXlwb2ludChrZXlwb2ludCkpXFxucmV0dXJuO1xcbmZsb2F0IGRlZ3JlZXNPcmllbnRhdGlvbiA9IHJvdW5kKDM2MC4wZiArIGRlZ3JlZXMoa2V5cG9pbnQub3JpZW50YXRpb24pKTtcXG5mbG9hdCBvcmllbnRhdGlvbiA9IHJhZGlhbnMoZGVncmVlc09yaWVudGF0aW9uIC0gbW9kKGRlZ3JlZXNPcmllbnRhdGlvbiwgMTIuMGYpKTtcXG5mbG9hdCBrY29zID0gY29zKG9yaWVudGF0aW9uKTtcXG5mbG9hdCBrc2luID0gc2luKG9yaWVudGF0aW9uKTtcXG5tYXQyIHJvdCA9IG1hdDIoa2Nvcywga3NpbiwgLWtzaW4sIGtjb3MpO1xcbmZsb2F0IHBvdCA9IGV4cDIoa2V5cG9pbnQubG9kKTtcXG5pbnQgcGF0dGVyblN0YXJ0ID0gMzIgKiBkZXNjcmlwdG9yQ2VsbDtcXG51aW50IHRlc3RbNF0gPSB1aW50WzRdKDB1LCAwdSwgMHUsIDB1KTtcXG5mb3IoaW50IHQgPSAwOyB0IDwgNDsgdCsrKSB7XFxudWludCBiaXRzID0gMHU7XFxudmVjMiBwLCBxO1xcbnZlYzQgYSwgYjtcXG5pbnQgaSA9IHQgKiA4O1xcbkB1bnJvbGxcXG5mb3IoaW50IGogPSAwOyBqIDwgODsgaisrKSB7XFxuZ2V0UGFpcihwYXR0ZXJuU3RhcnQgKyBpICsgaiwgcm90LCBwLCBxKTtcXG5hID0gdGV4ZWxGZXRjaChpbWFnZSwgaXZlYzIocm91bmQoa2V5cG9pbnQucG9zaXRpb24gKyBwb3QgKiBwKSksIDApO1xcbmIgPSB0ZXhlbEZldGNoKGltYWdlLCBpdmVjMihyb3VuZChrZXlwb2ludC5wb3NpdGlvbiArIHBvdCAqIHEpKSwgMCk7XFxuYml0cyB8PSB1aW50KGEuZyA8IGIuZykgPDwgajtcXG59XFxudGVzdFt0XSA9IGJpdHM7XFxufVxcbmNvbG9yID0gdmVjNCh0ZXN0WzBdLCB0ZXN0WzFdLCB0ZXN0WzJdLCB0ZXN0WzNdKSAvIDI1NS4wZjtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGltYWdlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxuI2RlZmluZSBQKHgseSkgaXZlYzIoKHgpLCh5KSlcXG5jb25zdCBpbnQgZGlza1BvaW50Q291bnRbMTZdID0gaW50WzE2XSgwLCA0LCAxMiwgMjgsIDQ4LCA4MCwgMTEyLCAxNDgsIDE5NiwgMjUyLCAzMTYsIDM3NiwgNDQwLCA1MjgsIDYxMiwgNzA4KTtcXG5jb25zdCBpdmVjMiBkaXNrUG9pbnRbNzA4XSA9IGl2ZWMyWzcwOF0oXFxuUCgwLC0xKSxQKC0xLDApLFAoMSwwKSxQKDAsMSksXFxuUCgtMSwtMSksUCgxLC0xKSxQKC0xLDEpLFAoMSwxKSxQKDAsLTIpLFAoLTIsMCksUCgyLDApLFAoMCwyKSxcXG5QKC0xLC0yKSxQKDEsLTIpLFAoLTIsLTEpLFAoMiwtMSksUCgtMiwxKSxQKDIsMSksUCgtMSwyKSxQKDEsMiksUCgtMiwtMiksUCgyLC0yKSxQKC0yLDIpLFAoMiwyKSxQKDAsLTMpLFAoLTMsMCksUCgzLDApLFAoMCwzKSxcXG5QKC0xLC0zKSxQKDEsLTMpLFAoLTMsLTEpLFAoMywtMSksUCgtMywxKSxQKDMsMSksUCgtMSwzKSxQKDEsMyksUCgtMiwtMyksUCgyLC0zKSxQKC0zLC0yKSxQKDMsLTIpLFAoLTMsMiksUCgzLDIpLFAoLTIsMyksUCgyLDMpLFAoMCwtNCksUCgtNCwwKSxQKDQsMCksUCgwLDQpLFxcblAoLTEsLTQpLFAoMSwtNCksUCgtNCwtMSksUCg0LC0xKSxQKC00LDEpLFAoNCwxKSxQKC0xLDQpLFAoMSw0KSxQKC0zLC0zKSxQKDMsLTMpLFAoLTMsMyksUCgzLDMpLFAoLTIsLTQpLFAoMiwtNCksUCgtNCwtMiksUCg0LC0yKSxQKC00LDIpLFAoNCwyKSxQKC0yLDQpLFAoMiw0KSxQKDAsLTUpLFAoLTMsLTQpLFAoMywtNCksUCgtNCwtMyksUCg0LC0zKSxQKC01LDApLFAoNSwwKSxQKC00LDMpLFAoNCwzKSxQKC0zLDQpLFAoMyw0KSxQKDAsNSksXFxuUCgtMSwtNSksUCgxLC01KSxQKC01LC0xKSxQKDUsLTEpLFAoLTUsMSksUCg1LDEpLFAoLTEsNSksUCgxLDUpLFAoLTIsLTUpLFAoMiwtNSksUCgtNSwtMiksUCg1LC0yKSxQKC01LDIpLFAoNSwyKSxQKC0yLDUpLFAoMiw1KSxQKC00LC00KSxQKDQsLTQpLFAoLTQsNCksUCg0LDQpLFAoLTMsLTUpLFAoMywtNSksUCgtNSwtMyksUCg1LC0zKSxQKC01LDMpLFAoNSwzKSxQKC0zLDUpLFAoMyw1KSxQKDAsLTYpLFAoLTYsMCksUCg2LDApLFAoMCw2KSxcXG5QKC0xLC02KSxQKDEsLTYpLFAoLTYsLTEpLFAoNiwtMSksUCgtNiwxKSxQKDYsMSksUCgtMSw2KSxQKDEsNiksUCgtMiwtNiksUCgyLC02KSxQKC02LC0yKSxQKDYsLTIpLFAoLTYsMiksUCg2LDIpLFAoLTIsNiksUCgyLDYpLFAoLTQsLTUpLFAoNCwtNSksUCgtNSwtNCksUCg1LC00KSxQKC01LDQpLFAoNSw0KSxQKC00LDUpLFAoNCw1KSxQKC0zLC02KSxQKDMsLTYpLFAoLTYsLTMpLFAoNiwtMyksUCgtNiwzKSxQKDYsMyksUCgtMyw2KSxQKDMsNiksUCgwLC03KSxQKC03LDApLFAoNywwKSxQKDAsNyksXFxuUCgtMSwtNyksUCgxLC03KSxQKC01LC01KSxQKDUsLTUpLFAoLTcsLTEpLFAoNywtMSksUCgtNywxKSxQKDcsMSksUCgtNSw1KSxQKDUsNSksUCgtMSw3KSxQKDEsNyksUCgtNCwtNiksUCg0LC02KSxQKC02LC00KSxQKDYsLTQpLFAoLTYsNCksUCg2LDQpLFAoLTQsNiksUCg0LDYpLFAoLTIsLTcpLFAoMiwtNyksUCgtNywtMiksUCg3LC0yKSxQKC03LDIpLFAoNywyKSxQKC0yLDcpLFAoMiw3KSxQKC0zLC03KSxQKDMsLTcpLFAoLTcsLTMpLFAoNywtMyksUCgtNywzKSxQKDcsMyksUCgtMyw3KSxQKDMsNyksUCgtNSwtNiksUCg1LC02KSxQKC02LC01KSxQKDYsLTUpLFAoLTYsNSksUCg2LDUpLFAoLTUsNiksUCg1LDYpLFAoMCwtOCksUCgtOCwwKSxQKDgsMCksUCgwLDgpLFxcblAoLTEsLTgpLFAoMSwtOCksUCgtNCwtNyksUCg0LC03KSxQKC03LC00KSxQKDcsLTQpLFAoLTgsLTEpLFAoOCwtMSksUCgtOCwxKSxQKDgsMSksUCgtNyw0KSxQKDcsNCksUCgtNCw3KSxQKDQsNyksUCgtMSw4KSxQKDEsOCksUCgtMiwtOCksUCgyLC04KSxQKC04LC0yKSxQKDgsLTIpLFAoLTgsMiksUCg4LDIpLFAoLTIsOCksUCgyLDgpLFAoLTYsLTYpLFAoNiwtNiksUCgtNiw2KSxQKDYsNiksUCgtMywtOCksUCgzLC04KSxQKC04LC0zKSxQKDgsLTMpLFAoLTgsMyksUCg4LDMpLFAoLTMsOCksUCgzLDgpLFAoLTUsLTcpLFAoNSwtNyksUCgtNywtNSksUCg3LC01KSxQKC03LDUpLFAoNyw1KSxQKC01LDcpLFAoNSw3KSxQKC00LC04KSxQKDQsLTgpLFAoLTgsLTQpLFAoOCwtNCksUCgtOCw0KSxQKDgsNCksUCgtNCw4KSxQKDQsOCksUCgwLC05KSxQKC05LDApLFAoOSwwKSxQKDAsOSksXFxuUCgtMSwtOSksUCgxLC05KSxQKC05LC0xKSxQKDksLTEpLFAoLTksMSksUCg5LDEpLFAoLTEsOSksUCgxLDkpLFAoLTIsLTkpLFAoMiwtOSksUCgtNiwtNyksUCg2LC03KSxQKC03LC02KSxQKDcsLTYpLFAoLTksLTIpLFAoOSwtMiksUCgtOSwyKSxQKDksMiksUCgtNyw2KSxQKDcsNiksUCgtNiw3KSxQKDYsNyksUCgtMiw5KSxQKDIsOSksUCgtNSwtOCksUCg1LC04KSxQKC04LC01KSxQKDgsLTUpLFAoLTgsNSksUCg4LDUpLFAoLTUsOCksUCg1LDgpLFAoLTMsLTkpLFAoMywtOSksUCgtOSwtMyksUCg5LC0zKSxQKC05LDMpLFAoOSwzKSxQKC0zLDkpLFAoMyw5KSxQKC00LC05KSxQKDQsLTkpLFAoLTksLTQpLFAoOSwtNCksUCgtOSw0KSxQKDksNCksUCgtNCw5KSxQKDQsOSksUCgtNywtNyksUCg3LC03KSxQKC03LDcpLFAoNyw3KSxQKDAsLTEwKSxQKC02LC04KSxQKDYsLTgpLFAoLTgsLTYpLFAoOCwtNiksUCgtMTAsMCksUCgxMCwwKSxQKC04LDYpLFAoOCw2KSxQKC02LDgpLFAoNiw4KSxQKDAsMTApLFxcblAoLTEsLTEwKSxQKDEsLTEwKSxQKC0xMCwtMSksUCgxMCwtMSksUCgtMTAsMSksUCgxMCwxKSxQKC0xLDEwKSxQKDEsMTApLFAoLTIsLTEwKSxQKDIsLTEwKSxQKC0xMCwtMiksUCgxMCwtMiksUCgtMTAsMiksUCgxMCwyKSxQKC0yLDEwKSxQKDIsMTApLFAoLTUsLTkpLFAoNSwtOSksUCgtOSwtNSksUCg5LC01KSxQKC05LDUpLFAoOSw1KSxQKC01LDkpLFAoNSw5KSxQKC0zLC0xMCksUCgzLC0xMCksUCgtMTAsLTMpLFAoMTAsLTMpLFAoLTEwLDMpLFAoMTAsMyksUCgtMywxMCksUCgzLDEwKSxQKC03LC04KSxQKDcsLTgpLFAoLTgsLTcpLFAoOCwtNyksUCgtOCw3KSxQKDgsNyksUCgtNyw4KSxQKDcsOCksUCgtNCwtMTApLFAoNCwtMTApLFAoLTEwLC00KSxQKDEwLC00KSxQKC0xMCw0KSxQKDEwLDQpLFAoLTQsMTApLFAoNCwxMCksUCgtNiwtOSksUCg2LC05KSxQKC05LC02KSxQKDksLTYpLFAoLTksNiksUCg5LDYpLFAoLTYsOSksUCg2LDkpLFAoMCwtMTEpLFAoLTExLDApLFAoMTEsMCksUCgwLDExKSxcXG5QKC0xLC0xMSksUCgxLC0xMSksUCgtMTEsLTEpLFAoMTEsLTEpLFAoLTExLDEpLFAoMTEsMSksUCgtMSwxMSksUCgxLDExKSxQKC0yLC0xMSksUCgyLC0xMSksUCgtNSwtMTApLFAoNSwtMTApLFAoLTEwLC01KSxQKDEwLC01KSxQKC0xMSwtMiksUCgxMSwtMiksUCgtMTEsMiksUCgxMSwyKSxQKC0xMCw1KSxQKDEwLDUpLFAoLTUsMTApLFAoNSwxMCksUCgtMiwxMSksUCgyLDExKSxQKC04LC04KSxQKDgsLTgpLFAoLTgsOCksUCg4LDgpLFAoLTMsLTExKSxQKDMsLTExKSxQKC03LC05KSxQKDcsLTkpLFAoLTksLTcpLFAoOSwtNyksUCgtMTEsLTMpLFAoMTEsLTMpLFAoLTExLDMpLFAoMTEsMyksUCgtOSw3KSxQKDksNyksUCgtNyw5KSxQKDcsOSksUCgtMywxMSksUCgzLDExKSxQKC02LC0xMCksUCg2LC0xMCksUCgtMTAsLTYpLFAoMTAsLTYpLFAoLTEwLDYpLFAoMTAsNiksUCgtNiwxMCksUCg2LDEwKSxQKC00LC0xMSksUCg0LC0xMSksUCgtMTEsLTQpLFAoMTEsLTQpLFAoLTExLDQpLFAoMTEsNCksUCgtNCwxMSksUCg0LDExKSxQKDAsLTEyKSxQKC0xMiwwKSxQKDEyLDApLFAoMCwxMiksXFxuUCgtMSwtMTIpLFAoMSwtMTIpLFAoLTgsLTkpLFAoOCwtOSksUCgtOSwtOCksUCg5LC04KSxQKC0xMiwtMSksUCgxMiwtMSksUCgtMTIsMSksUCgxMiwxKSxQKC05LDgpLFAoOSw4KSxQKC04LDkpLFAoOCw5KSxQKC0xLDEyKSxQKDEsMTIpLFAoLTUsLTExKSxQKDUsLTExKSxQKC0xMSwtNSksUCgxMSwtNSksUCgtMTEsNSksUCgxMSw1KSxQKC01LDExKSxQKDUsMTEpLFAoLTIsLTEyKSxQKDIsLTEyKSxQKC0xMiwtMiksUCgxMiwtMiksUCgtMTIsMiksUCgxMiwyKSxQKC0yLDEyKSxQKDIsMTIpLFAoLTcsLTEwKSxQKDcsLTEwKSxQKC0xMCwtNyksUCgxMCwtNyksUCgtMTAsNyksUCgxMCw3KSxQKC03LDEwKSxQKDcsMTApLFAoLTMsLTEyKSxQKDMsLTEyKSxQKC0xMiwtMyksUCgxMiwtMyksUCgtMTIsMyksUCgxMiwzKSxQKC0zLDEyKSxQKDMsMTIpLFAoLTYsLTExKSxQKDYsLTExKSxQKC0xMSwtNiksUCgxMSwtNiksUCgtMTEsNiksUCgxMSw2KSxQKC02LDExKSxQKDYsMTEpLFAoLTQsLTEyKSxQKDQsLTEyKSxQKC0xMiwtNCksUCgxMiwtNCksUCgtMTIsNCksUCgxMiw0KSxQKC00LDEyKSxQKDQsMTIpLFAoLTksLTkpLFAoOSwtOSksUCgtOSw5KSxQKDksOSksUCgtOCwtMTApLFAoOCwtMTApLFAoLTEwLC04KSxQKDEwLC04KSxQKC0xMCw4KSxQKDEwLDgpLFAoLTgsMTApLFAoOCwxMCksUCgwLC0xMyksUCgtNSwtMTIpLFAoNSwtMTIpLFAoLTEyLC01KSxQKDEyLC01KSxQKC0xMywwKSxQKDEzLDApLFAoLTEyLDUpLFAoMTIsNSksUCgtNSwxMiksUCg1LDEyKSxQKDAsMTMpLFxcblAoLTEsLTEzKSxQKDEsLTEzKSxQKC03LC0xMSksUCg3LC0xMSksUCgtMTEsLTcpLFAoMTEsLTcpLFAoLTEzLC0xKSxQKDEzLC0xKSxQKC0xMywxKSxQKDEzLDEpLFAoLTExLDcpLFAoMTEsNyksUCgtNywxMSksUCg3LDExKSxQKC0xLDEzKSxQKDEsMTMpLFAoLTIsLTEzKSxQKDIsLTEzKSxQKC0xMywtMiksUCgxMywtMiksUCgtMTMsMiksUCgxMywyKSxQKC0yLDEzKSxQKDIsMTMpLFAoLTMsLTEzKSxQKDMsLTEzKSxQKC0xMywtMyksUCgxMywtMyksUCgtMTMsMyksUCgxMywzKSxQKC0zLDEzKSxQKDMsMTMpLFAoLTYsLTEyKSxQKDYsLTEyKSxQKC0xMiwtNiksUCgxMiwtNiksUCgtMTIsNiksUCgxMiw2KSxQKC02LDEyKSxQKDYsMTIpLFAoLTksLTEwKSxQKDksLTEwKSxQKC0xMCwtOSksUCgxMCwtOSksUCgtMTAsOSksUCgxMCw5KSxQKC05LDEwKSxQKDksMTApLFAoLTQsLTEzKSxQKDQsLTEzKSxQKC04LC0xMSksUCg4LC0xMSksUCgtMTEsLTgpLFAoMTEsLTgpLFAoLTEzLC00KSxQKDEzLC00KSxQKC0xMyw0KSxQKDEzLDQpLFAoLTExLDgpLFAoMTEsOCksUCgtOCwxMSksUCg4LDExKSxQKC00LDEzKSxQKDQsMTMpLFAoLTcsLTEyKSxQKDcsLTEyKSxQKC0xMiwtNyksUCgxMiwtNyksUCgtMTIsNyksUCgxMiw3KSxQKC03LDEyKSxQKDcsMTIpLFAoLTUsLTEzKSxQKDUsLTEzKSxQKC0xMywtNSksUCgxMywtNSksUCgtMTMsNSksUCgxMyw1KSxQKC01LDEzKSxQKDUsMTMpLFAoMCwtMTQpLFAoLTE0LDApLFAoMTQsMCksUCgwLDE0KSxcXG5QKC0xLC0xNCksUCgxLC0xNCksUCgtMTQsLTEpLFAoMTQsLTEpLFAoLTE0LDEpLFAoMTQsMSksUCgtMSwxNCksUCgxLDE0KSxQKC0yLC0xNCksUCgyLC0xNCksUCgtMTAsLTEwKSxQKDEwLC0xMCksUCgtMTQsLTIpLFAoMTQsLTIpLFAoLTE0LDIpLFAoMTQsMiksUCgtMTAsMTApLFAoMTAsMTApLFAoLTIsMTQpLFAoMiwxNCksUCgtOSwtMTEpLFAoOSwtMTEpLFAoLTExLC05KSxQKDExLC05KSxQKC0xMSw5KSxQKDExLDkpLFAoLTksMTEpLFAoOSwxMSksUCgtMywtMTQpLFAoMywtMTQpLFAoLTYsLTEzKSxQKDYsLTEzKSxQKC0xMywtNiksUCgxMywtNiksUCgtMTQsLTMpLFAoMTQsLTMpLFAoLTE0LDMpLFAoMTQsMyksUCgtMTMsNiksUCgxMyw2KSxQKC02LDEzKSxQKDYsMTMpLFAoLTMsMTQpLFAoMywxNCksUCgtOCwtMTIpLFAoOCwtMTIpLFAoLTEyLC04KSxQKDEyLC04KSxQKC0xMiw4KSxQKDEyLDgpLFAoLTgsMTIpLFAoOCwxMiksUCgtNCwtMTQpLFAoNCwtMTQpLFAoLTE0LC00KSxQKDE0LC00KSxQKC0xNCw0KSxQKDE0LDQpLFAoLTQsMTQpLFAoNCwxNCksUCgtNywtMTMpLFAoNywtMTMpLFAoLTEzLC03KSxQKDEzLC03KSxQKC0xMyw3KSxQKDEzLDcpLFAoLTcsMTMpLFAoNywxMyksUCgtNSwtMTQpLFAoNSwtMTQpLFAoLTEwLC0xMSksUCgxMCwtMTEpLFAoLTExLC0xMCksUCgxMSwtMTApLFAoLTE0LC01KSxQKDE0LC01KSxQKC0xNCw1KSxQKDE0LDUpLFAoLTExLDEwKSxQKDExLDEwKSxQKC0xMCwxMSksUCgxMCwxMSksUCgtNSwxNCksUCg1LDE0KSxQKDAsLTE1KSxQKC05LC0xMiksUCg5LC0xMiksUCgtMTIsLTkpLFAoMTIsLTkpLFAoLTE1LDApLFAoMTUsMCksUCgtMTIsOSksUCgxMiw5KSxQKC05LDEyKSxQKDksMTIpLFAoMCwxNSlcXG4pO1xcbmNvbnN0IGludCBERUZBVUxUX1BBVENIX1JBRElVUyA9IDE1O1xcbmNvbnN0IGludCBNSU5fUEFUQ0hfUkFESVVTID0gMjtcXG52b2lkIG1haW4oKVxcbntcXG52ZWM0IHBpeGVsID0gdGhyZWFkUGl4ZWwoZW5jb2RlZEtleXBvaW50cyk7XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pbnQga2V5cG9pbnRJbmRleCA9IHRocmVhZC54ICsgdGhyZWFkLnkgKiBvdXRwdXRTaXplKCkueDtcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgLyA0O1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKGtleXBvaW50SW5kZXggKiBwaXhlbHNQZXJLZXlwb2ludCwgMCk7XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBhZGRyZXNzKTtcXG52ZWMyIG0gPSB2ZWMyKDAuMGYpO1xcbmZsb2F0IHBvdCA9IGV4cDIoa2V5cG9pbnQubG9kKTtcXG52ZWMyIGltYWdlU2l6ZSA9IHZlYzIodGV4dHVyZVNpemUoaW1hZ2UsIDApKTtcXG5pbnQgc2NhbGVkUmFkaXVzID0gaW50KGNlaWwoZmxvYXQoREVGQVVMVF9QQVRDSF9SQURJVVMpIC8gcG90KSk7XFxuaW50IHJhZGl1cyA9IG1heChzY2FsZWRSYWRpdXMsIE1JTl9QQVRDSF9SQURJVVMpO1xcbmludCBjb3VudCA9IGRpc2tQb2ludENvdW50W3JhZGl1c107XFxuZm9yKGludCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcXG52ZWMyIG9mZnNldCA9IHZlYzIoZGlza1BvaW50W2pdKTtcXG52ZWMyIHBvc2l0aW9uID0ga2V5cG9pbnQucG9zaXRpb24gKyByb3VuZChwb3QgKiBvZmZzZXQpO1xcbnZlYzQgcGF0Y2hQaXhlbCA9IHRleHR1cmUoaW1hZ2UsIChwb3NpdGlvbiArIHZlYzIoMC41ZikpIC8gaW1hZ2VTaXplKTtcXG5tICs9IG9mZnNldCAqIHBhdGNoUGl4ZWwuZztcXG59XFxuZmxvYXQgYW5nbGUgPSBmYXN0QXRhbjIobS55LCBtLngpO1xcbmZsb2F0IGVuY29kZWRPcmllbnRhdGlvbiA9IGVuY29kZUtleXBvaW50T3JpZW50YXRpb24oYW5nbGUpO1xcbmNvbG9yID0gdmVjNCgwLjBmLCBlbmNvZGVkT3JpZW50YXRpb24sIDAuMGYsIDAuMGYpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImZpbHRlcnMuZ2xzbFxcXCJcXG4jaWYgIWRlZmluZWQoTUVUSE9EKVxcbiNlcnJvciBVbmRlZmluZWQgTUVUSE9EXFxuI2VuZGlmXFxudW5pZm9ybSBzYW1wbGVyMkQgcHlyYW1pZDtcXG51bmlmb3JtIGZsb2F0IGxvZFN0ZXA7XFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG4jaWYgTUVUSE9EID09IDFcXG51bmlmb3JtIGludCB0aHJlc2hvbGQ7XFxuI2VuZGlmXFxuY29uc3QgZmxvYXQgZXBzID0gMWUtNjtcXG5mbG9hdCBjb3JuZXJTdHJlbmd0aCh2ZWMyIHBvc2l0aW9uLCBmbG9hdCBsb2QpXFxue1xcbiNpZiBNRVRIT0QgPT0gMFxcbnJldHVybiBsYXBsYWNpYW4ocHlyYW1pZCwgcG9zaXRpb24sIGxvZCk7XFxuI2VsaWYgTUVUSE9EID09IDFcXG5mbG9hdCBwb3QgPSBleHAyKGxvZCk7XFxuZmxvYXQgdCA9IGZsb2F0KGNsYW1wKHRocmVzaG9sZCwgMCwgMjU1KSkgLyAyNTUuMGY7XFxuI2RlZmluZSBQKHgseSkgcHlyUGl4ZWxBdE9mZnNldChweXJhbWlkLCBsb2QsIHBvdCwgaXZlYzIoKHgpLCh5KSkpLmdcXG5tYXQ0IG1wID0gbWF0NChcXG5QKDAsMyksUCgzLDApLFAoMCwtMyksUCgtMywwKSxcXG5QKDEsMyksUCgyLDIpLFAoMywxKSxQKDMsLTEpLFxcblAoMiwtMiksUCgxLC0zKSxQKC0xLC0zKSxQKC0yLC0yKSxcXG5QKC0zLC0xKSxQKC0zLDEpLFAoLTIsMiksUCgtMSwzKVxcbik7XFxuZmxvYXQgYyA9IFAoMCwwKTtcXG5mbG9hdCBjdCA9IGMgKyB0LCBjX3QgPSBjIC0gdDtcXG5tYXQ0IG1jdCA9IG1wIC0gbWF0NChjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCxjdCk7XFxubWF0NCBtY190ID0gbWF0NChjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QsY190LGNfdCxjX3QpIC0gbXA7XFxuY29uc3QgdmVjNCB6ZXJvcyA9IHZlYzQoMC4wZiksIG9uZXMgPSB2ZWM0KDEuMGYpO1xcbnZlYzQgYnMgPSBtYXgobWN0WzBdLCB6ZXJvcyksIGRzID0gbWF4KG1jX3RbMF0sIHplcm9zKTtcXG5icyArPSBtYXgobWN0WzFdLCB6ZXJvcyk7ICAgICBkcyArPSBtYXgobWNfdFsxXSwgemVyb3MpO1xcbmJzICs9IG1heChtY3RbMl0sIHplcm9zKTsgICAgIGRzICs9IG1heChtY190WzJdLCB6ZXJvcyk7XFxuYnMgKz0gbWF4KG1jdFszXSwgemVyb3MpOyAgICAgZHMgKz0gbWF4KG1jX3RbM10sIHplcm9zKTtcXG5yZXR1cm4gbWF4KGRvdChicywgb25lcyksIGRvdChkcywgb25lcykpIC8gMTYuMGY7XFxuI2Vsc2VcXG4jZXJyb3IgSW52YWxpZCBtZXRob2RcXG4jZW5kaWZcXG59XFxudm9pZCBtYWluKClcXG57XFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKGVuY29kZWRLZXlwb2ludHMpO1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuS2V5cG9pbnRBZGRyZXNzIGFkZHJlc3MgPSBmaW5kS2V5cG9pbnRBZGRyZXNzKHRocmVhZCwgZW5jb2Rlckxlbmd0aCwgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuY29sb3IgPSBwaXhlbDtcXG5pZihhZGRyZXNzLm9mZnNldCAhPSAxKVxcbnJldHVybjtcXG5LZXlwb2ludCBrZXlwb2ludCA9IGRlY29kZUtleXBvaW50KGVuY29kZWRLZXlwb2ludHMsIGVuY29kZXJMZW5ndGgsIGFkZHJlc3MpO1xcbmlmKGlzQmFkS2V5cG9pbnQoa2V5cG9pbnQpKVxcbnJldHVybjtcXG52ZWMzIHN0cmVuZ3RoID0gdmVjMyhcXG5jb3JuZXJTdHJlbmd0aChrZXlwb2ludC5wb3NpdGlvbiwgbWF4KDAuMGYsIGtleXBvaW50LmxvZCAtIGxvZFN0ZXApKSxcXG5jb3JuZXJTdHJlbmd0aChrZXlwb2ludC5wb3NpdGlvbiwga2V5cG9pbnQubG9kKSxcXG5jb3JuZXJTdHJlbmd0aChrZXlwb2ludC5wb3NpdGlvbiwga2V5cG9pbnQubG9kICsgbG9kU3RlcClcXG4pO1xcbnZlYzMgcCA9IG1hdDMoXFxuMiwgLTMsIDEsXFxuLTQsIDQsIDAsXFxuMiwgLTEsIDBcXG4pICogc3RyZW5ndGg7XFxuZmxvYXQgbWF4U3RyZW5ndGggPSBtYXgoc3RyZW5ndGgueCwgbWF4KHN0cmVuZ3RoLnksIHN0cmVuZ3RoLnopKTtcXG52ZWMzIGRpZmZTdHJlbmd0aCA9IGFicyhzdHJlbmd0aCAtIHZlYzMobWF4U3RyZW5ndGgpKTtcXG52ZWMzIHN0cmVuZ3RoSW5kaWNhdG9ycyA9IHZlYzMobGVzc1RoYW4oZGlmZlN0cmVuZ3RoLCB2ZWMzKGVwcykpKTtcXG5mbG9hdCBtYXhQb2ludCA9IG1pbigxLjBmLCBkb3QodmVjMygwLjBmLCAwLjVmLCAxLjBmKSwgc3RyZW5ndGhJbmRpY2F0b3JzKSk7XFxuYm9vbCBoYXNNYXggPSBwLnggPCAtZXBzO1xcbmZsb2F0IHBtYXggPSBoYXNNYXggPyAtMC41ZiAqIHAueSAvIHAueCA6IG1heFBvaW50O1xcbmZsb2F0IGFscGhhID0gYWJzKHBtYXggLSAwLjVmKSA8PSAwLjVmID8gcG1heCA6IG1heFBvaW50O1xcbmZsb2F0IGxvZE9mZnNldCA9IG1peCgtbG9kU3RlcCwgbG9kU3RlcCwgYWxwaGEpO1xcbmZsb2F0IGxvZCA9IGtleXBvaW50LmxvZCArIGxvZE9mZnNldDtcXG5jb2xvci5yID0gZW5jb2RlTG9kKGxvZCk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJmbG9hdDE2Lmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgY29ybmVycztcXG51bmlmb3JtIGludCBpdGVyYXRpb25OdW1iZXI7XFxudm9pZCBtYWluKClcXG57XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pdmVjMiBib3VuZHMgPSBvdXRwdXRTaXplKCk7XFxuaW50IGp1bXAgPSAoMSA8PCBpdGVyYXRpb25OdW1iZXIpO1xcbmludCBjbHVzdGVyTGVuZ3RoID0ganVtcCA8PCAxO1xcbmludCBjbHVzdGVyTWFzayA9IGNsdXN0ZXJMZW5ndGggLSAxO1xcbml2ZWMyIGNsdXN0ZXJQb3MgPSBpdmVjMih0aHJlYWQgPj4gKDEgKyBpdGVyYXRpb25OdW1iZXIpKSA8PCAoMSArIGl0ZXJhdGlvbk51bWJlcik7XFxuaXZlYzIgbmV4dDEgPSBjbHVzdGVyUG9zICsgKCh0aHJlYWQgLSBjbHVzdGVyUG9zICsgaXZlYzIoanVtcCwgMCkpICYgY2x1c3Rlck1hc2spO1xcbml2ZWMyIG5leHQyID0gY2x1c3RlclBvcyArICgodGhyZWFkIC0gY2x1c3RlclBvcyArIGl2ZWMyKDAsIGp1bXApKSAmIGNsdXN0ZXJNYXNrKTtcXG5pdmVjMiBuZXh0MyA9IGNsdXN0ZXJQb3MgKyAoKHRocmVhZCAtIGNsdXN0ZXJQb3MgKyBpdmVjMihqdW1wLCBqdW1wKSkgJiBjbHVzdGVyTWFzayk7XFxudmVjNCBwMCA9IHRocmVhZFBpeGVsKGNvcm5lcnMpO1xcbnZlYzQgcDEgPSB0ZXhlbEZldGNoKGNvcm5lcnMsIG5leHQxICUgYm91bmRzLCAwKTtcXG52ZWM0IHAyID0gdGV4ZWxGZXRjaChjb3JuZXJzLCBuZXh0MiAlIGJvdW5kcywgMCk7XFxudmVjNCBwMyA9IHRleGVsRmV0Y2goY29ybmVycywgbmV4dDMgJSBib3VuZHMsIDApO1xcbmZsb2F0IHMwID0gZGVjb2RlRmxvYXQxNihwMC5yYik7XFxuZmxvYXQgczEgPSBkZWNvZGVGbG9hdDE2KHAxLnJiKTtcXG5mbG9hdCBzMiA9IGRlY29kZUZsb2F0MTYocDIucmIpO1xcbmZsb2F0IHMzID0gZGVjb2RlRmxvYXQxNihwMy5yYik7XFxuYm9vbCBiMCA9IHMwID49IHMxICYmIHMwID49IHMyICYmIHMwID49IHMzO1xcbmJvb2wgYjEgPSBzMSA+PSBzMCAmJiBzMSA+PSBzMiAmJiBzMSA+PSBzMztcXG5ib29sIGIyID0gczIgPj0gczAgJiYgczIgPj0gczEgJiYgczIgPj0gczM7XFxuY29sb3IgPSB2ZWM0KDAuMGYpO1xcbmNvbG9yLnJiID0gYjAgPyBwMC5yYiA6IChcXG5iMSA/IHAxLnJiIDogKFxcbmIyID8gcDIucmIgOiBwMy5yYlxcbilcXG4pO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG4jaWYgUEVSTVVUQVRJT05fTUFYTEVOICUgNCA+IDAgfHwgUEVSTVVUQVRJT05fTUFYTEVOICogNCA+IDE2Mzg0XFxuI2Vycm9yIEludmFsaWQgUEVSTVVUQVRJT05fTUFYTEVOXFxuI2VuZGlmXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBQZXJtdXRhdGlvblxcbntcXG5pdmVjNCBwZXJtdXRhdGlvbltQRVJNVVRBVElPTl9NQVhMRU4gLyA0XTtcXG59O1xcbmludCBwZXJtdXRhdGlvbkVsZW1lbnQoaW50IGluZGV4KVxcbntcXG5pbnQgYmFzZSA9IGluZGV4IC0gKGluZGV4ICUgUEVSTVVUQVRJT05fTUFYTEVOKTtcXG5pbnQgb2Zmc2V0ID0gaW5kZXggLSBiYXNlO1xcbml2ZWM0IHR1cGxlID0gcGVybXV0YXRpb25bb2Zmc2V0IC8gNF07XFxuaW50IG5ld09mZnNldCA9IHR1cGxlW29mZnNldCAmIDNdO1xcbnJldHVybiBiYXNlICsgbmV3T2Zmc2V0O1xcbn1cXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbmludCBwaXhlbHNQZXJLZXlwb2ludCA9IHNpemVvZkVuY29kZWRLZXlwb2ludChkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKSAvIDQ7XFxuS2V5cG9pbnRBZGRyZXNzIG15QWRkcmVzcyA9IGZpbmRLZXlwb2ludEFkZHJlc3ModGhyZWFkLCBlbmNvZGVyTGVuZ3RoLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5pbnQgbXlJbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KG15QWRkcmVzcywgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuaW50IG90aGVySW5kZXggPSBwZXJtdXRhdGlvbkVsZW1lbnQobXlJbmRleCk7XFxuS2V5cG9pbnRBZGRyZXNzIG90aGVyQWRkcmVzcyA9IEtleXBvaW50QWRkcmVzcyhvdGhlckluZGV4ICogcGl4ZWxzUGVyS2V5cG9pbnQsIG15QWRkcmVzcy5vZmZzZXQpO1xcbktleXBvaW50IG15S2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBteUFkZHJlc3MpO1xcbktleXBvaW50IG90aGVyS2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBvdGhlckFkZHJlc3MpO1xcbmNvbG9yID0gcmVhZEtleXBvaW50RGF0YShlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBvdGhlckFkZHJlc3MpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxuI2lmICFkZWZpbmVkKFNUQUdFKVxcbiNlcnJvciBVbmRlZmluZWQgU1RBR0VcXG4jZWxpZiBTVEFHRSA9PSAxXFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG4jZWxpZiBTVEFHRSA9PSAyXFxudW5pZm9ybSBzYW1wbGVyMkQgcGVybXV0YXRpb247XFxudW5pZm9ybSBpbnQgYmxvY2tTaXplO1xcbnVuaWZvcm0gaW50IGRibExvZzJCbG9ja1NpemU7XFxuI2VsaWYgU1RBR0UgPT0gM1xcbnVuaWZvcm0gc2FtcGxlcjJEIHBlcm11dGF0aW9uO1xcbnVuaWZvcm0gaW50IG1heEtleXBvaW50cztcXG51bmlmb3JtIHNhbXBsZXIyRCBlbmNvZGVkS2V5cG9pbnRzO1xcbnVuaWZvcm0gaW50IGRlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG4jZWxzZVxcbiNlcnJvciBJbnZhbGlkIFNUQUdFXFxuI2VuZGlmXFxuc3RydWN0IFBlcm11dGF0aW9uRWxlbWVudFxcbntcXG5pbnQga2V5cG9pbnRJbmRleDtcXG5mbG9hdCBzY29yZTtcXG5ib29sIHZhbGlkO1xcbn07XFxudmVjNCBlbmNvZGVQZXJtdXRhdGlvbkVsZW1lbnQoUGVybXV0YXRpb25FbGVtZW50IGVsZW1lbnQpXFxue1xcbmNvbnN0IHZlYzIgT05FUyA9IHZlYzIoMS4wZik7XFxudmVjMiBlbmNvZGVkU2NvcmUgPSBlbGVtZW50LnZhbGlkID8gZW5jb2RlRmxvYXQxNihlbGVtZW50LnNjb3JlKSA6IE9ORVM7XFxudmVjMiBlbmNvZGVkSW5kZXggPSB2ZWMyKGVsZW1lbnQua2V5cG9pbnRJbmRleCAmIDI1NSwgKGVsZW1lbnQua2V5cG9pbnRJbmRleCA+PiA4KSAmIDI1NSkgLyAyNTUuMGY7XFxucmV0dXJuIHZlYzQoZW5jb2RlZEluZGV4LCBlbmNvZGVkU2NvcmUpO1xcbn1cXG5QZXJtdXRhdGlvbkVsZW1lbnQgZGVjb2RlUGVybXV0YXRpb25FbGVtZW50KHZlYzQgcGl4ZWwpXFxue1xcbmNvbnN0IHZlYzIgT05FUyA9IHZlYzIoMS4wZik7XFxuUGVybXV0YXRpb25FbGVtZW50IGVsZW1lbnQ7XFxuZWxlbWVudC5rZXlwb2ludEluZGV4ID0gaW50KHBpeGVsLnIgKiAyNTUuMGYpIHwgKGludChwaXhlbC5nICogMjU1LjBmKSA8PCA4KTtcXG5lbGVtZW50LnZhbGlkID0gIWFsbChlcXVhbChwaXhlbC5iYSwgT05FUykpO1xcbmVsZW1lbnQuc2NvcmUgPSBlbGVtZW50LnZhbGlkID8gZGVjb2RlRmxvYXQxNihwaXhlbC5iYSkgOiAtMS4wZjtcXG5yZXR1cm4gZWxlbWVudDtcXG59XFxuUGVybXV0YXRpb25FbGVtZW50IHJlYWRQZXJtdXRhdGlvbkVsZW1lbnQoc2FtcGxlcjJEIHBlcm11dGF0aW9uLCBpbnQgZWxlbWVudEluZGV4LCBpbnQgc3RyaWRlLCBpbnQgaGVpZ2h0KVxcbntcXG5jb25zdCB2ZWM0IElOVkFMSURfUElYRUwgPSB2ZWM0KDEuMGYpO1xcbml2ZWMyIHBvcyA9IGl2ZWMyKGVsZW1lbnRJbmRleCAlIHN0cmlkZSwgZWxlbWVudEluZGV4IC8gc3RyaWRlKTtcXG52ZWM0IHBpeGVsID0gcG9zLnkgPCBoZWlnaHQgPyBwaXhlbEF0KHBlcm11dGF0aW9uLCBwb3MpIDogSU5WQUxJRF9QSVhFTDtcXG5yZXR1cm4gZGVjb2RlUGVybXV0YXRpb25FbGVtZW50KHBpeGVsKTtcXG59XFxuI2lmIFNUQUdFID09IDJcXG5QZXJtdXRhdGlvbkVsZW1lbnQgc2VsZWN0S3RoKHNhbXBsZXIyRCBwZXJtdXRhdGlvbiwgaW50IGssIGludCBsYSwgaW50IHJhLCBpbnQgbGIsIGludCByYilcXG57XFxuZmxvYXQgc2NvcmVBLCBzY29yZUI7XFxuaW50IGhhLCBoYiwgbWEsIG1iO1xcbmJvb2wgZGlzY2FyZDFzdEhhbGYsIGFsdGI7XFxuYm9vbCBsb2NrZWQgPSBmYWxzZTtcXG5pbnQgdG1wLCByZXN1bHQgPSAwO1xcbmludCBzdHJpZGUgPSBvdXRwdXRTaXplKCkueDtcXG5pbnQgaGVpZ2h0ID0gb3V0cHV0U2l6ZSgpLnk7XFxuZm9yKGludCBpID0gMDsgaSA8IGRibExvZzJCbG9ja1NpemU7IGkrKykge1xcbnRtcCA9IChsYiA+IHJiICYmICFsb2NrZWQpID8gKGxhK2spIDogcmVzdWx0O1xcbnJlc3VsdCA9IChsYSA+IHJhICYmICFsb2NrZWQpID8gKGxiK2spIDogdG1wO1xcbmxvY2tlZCA9IGxvY2tlZCB8fCAobGEgPiByYSkgfHwgKGxiID4gcmIpO1xcbmhhID0gKHJhIC0gbGEgKyAxKSAvIDI7XFxuaGIgPSAocmIgLSBsYiArIDEpIC8gMjtcXG5tYSA9IGxhICsgaGE7XFxubWIgPSBsYiArIGhiO1xcbnNjb3JlQSA9IHJlYWRQZXJtdXRhdGlvbkVsZW1lbnQocGVybXV0YXRpb24sIG1hLCBzdHJpZGUsIGhlaWdodCkuc2NvcmU7XFxuc2NvcmVCID0gcmVhZFBlcm11dGF0aW9uRWxlbWVudChwZXJtdXRhdGlvbiwgbWIsIHN0cmlkZSwgaGVpZ2h0KS5zY29yZTtcXG5kaXNjYXJkMXN0SGFsZiA9IChrID4gaGEgKyBoYik7XFxuYWx0YiA9ICgtc2NvcmVBIDwgLXNjb3JlQik7XFxuayAtPSBpbnQoZGlzY2FyZDFzdEhhbGYgJiYgYWx0YikgKiAoaGEgKyAxKTtcXG5rIC09IGludChkaXNjYXJkMXN0SGFsZiAmJiAhYWx0YikgKiAoaGIgKyAxKTtcXG5sYSArPSBpbnQoZGlzY2FyZDFzdEhhbGYgJiYgYWx0YikgKiAobWEgKyAxIC0gbGEpO1xcbmxiICs9IGludChkaXNjYXJkMXN0SGFsZiAmJiAhYWx0YikgKiAobWIgKyAxIC0gbGIpO1xcbnJhICs9IGludCghZGlzY2FyZDFzdEhhbGYgJiYgIWFsdGIpICogKG1hIC0gMSAtIHJhKTtcXG5yYiArPSBpbnQoIWRpc2NhcmQxc3RIYWxmICYmIGFsdGIpICogKG1iIC0gMSAtIHJiKTtcXG59XFxucmV0dXJuIHJlYWRQZXJtdXRhdGlvbkVsZW1lbnQocGVybXV0YXRpb24sIHJlc3VsdCwgc3RyaWRlLCBoZWlnaHQpO1xcbn1cXG4jZW5kaWZcXG52b2lkIG1haW4oKVxcbntcXG4jaWYgU1RBR0UgPT0gMVxcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaW50IHN0cmlkZSA9IG91dHB1dFNpemUoKS54O1xcbmludCBrZXlwb2ludEluZGV4ID0gdGhyZWFkLnkgKiBzdHJpZGUgKyB0aHJlYWQueDtcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgLyA0O1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKGtleXBvaW50SW5kZXggKiBwaXhlbHNQZXJLZXlwb2ludCwgMCk7XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBhZGRyZXNzKTtcXG5QZXJtdXRhdGlvbkVsZW1lbnQgZWxlbWVudDtcXG5lbGVtZW50LmtleXBvaW50SW5kZXggPSBrZXlwb2ludEluZGV4O1xcbmVsZW1lbnQuc2NvcmUgPSBrZXlwb2ludC5zY29yZTtcXG5lbGVtZW50LnZhbGlkID0gIWlzQmFkS2V5cG9pbnQoa2V5cG9pbnQpO1xcbmNvbG9yID0gZW5jb2RlUGVybXV0YXRpb25FbGVtZW50KGVsZW1lbnQpO1xcbiNlbGlmIFNUQUdFID09IDJcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbmludCBzdHJpZGUgPSBvdXRwdXRTaXplKCkueDtcXG5pbnQgZWxlbWVudEluZGV4ID0gdGhyZWFkLnkgKiBzdHJpZGUgKyB0aHJlYWQueDtcXG5pbnQgYmxvY2tJbmRleCA9IGVsZW1lbnRJbmRleCAvIGJsb2NrU2l6ZTtcXG5pbnQgYmxvY2tPZmZzZXQgPSBlbGVtZW50SW5kZXggJSBibG9ja1NpemU7XFxuaW50IGxhID0gYmxvY2tJbmRleCAqIGJsb2NrU2l6ZTtcXG5pbnQgbGIgPSBsYSArIGJsb2NrU2l6ZSAvIDI7XFxuaW50IHJhID0gbGIgLSAxO1xcbmludCByYiA9IChibG9ja0luZGV4ICsgMSkgKiBibG9ja1NpemUgLSAxO1xcbmludCBrID0gYmxvY2tPZmZzZXQ7XFxuUGVybXV0YXRpb25FbGVtZW50IGVsZW1lbnQgPSBzZWxlY3RLdGgocGVybXV0YXRpb24sIGssIGxhLCByYSwgbGIsIHJiKTtcXG5jb2xvciA9IGVuY29kZVBlcm11dGF0aW9uRWxlbWVudChlbGVtZW50KTtcXG4jZWxpZiBTVEFHRSA9PSAzXFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pbnQgbmV3RW5jb2Rlckxlbmd0aCA9IG91dHB1dFNpemUoKS54O1xcbktleXBvaW50QWRkcmVzcyBteUFkZHJlc3MgPSBmaW5kS2V5cG9pbnRBZGRyZXNzKHRocmVhZCwgbmV3RW5jb2Rlckxlbmd0aCwgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuaW50IG15S2V5cG9pbnRJbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KG15QWRkcmVzcywgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuaXZlYzIgcHNpemUgPSB0ZXh0dXJlU2l6ZShwZXJtdXRhdGlvbiwgMCk7XFxuUGVybXV0YXRpb25FbGVtZW50IGVsZW1lbnQgPSByZWFkUGVybXV0YXRpb25FbGVtZW50KHBlcm11dGF0aW9uLCBteUtleXBvaW50SW5kZXgsIHBzaXplLngsIHBzaXplLnkpO1xcbmludCBvbGRFbmNvZGVyTGVuZ3RoID0gdGV4dHVyZVNpemUoZW5jb2RlZEtleXBvaW50cywgMCkueDtcXG5pbnQgcGl4ZWxzUGVyS2V5cG9pbnQgPSBzaXplb2ZFbmNvZGVkS2V5cG9pbnQoZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSkgLyA0O1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gS2V5cG9pbnRBZGRyZXNzKGVsZW1lbnQua2V5cG9pbnRJbmRleCAqIHBpeGVsc1BlcktleXBvaW50LCBteUFkZHJlc3Mub2Zmc2V0KTtcXG52ZWM0IGtleXBvaW50RGF0YSA9IHJlYWRLZXlwb2ludERhdGEoZW5jb2RlZEtleXBvaW50cywgb2xkRW5jb2Rlckxlbmd0aCwgYWRkcmVzcyk7XFxuY29sb3IgPSBteUtleXBvaW50SW5kZXggPCBtYXhLZXlwb2ludHMgJiYgZWxlbWVudC52YWxpZCA/IGtleXBvaW50RGF0YSA6IGVuY29kZU51bGxLZXlwb2ludCgpO1xcbiNlbmRpZlxcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxuQGluY2x1ZGUgXFxcImZsb2F0MTYuZ2xzbFxcXCJcXG4jaWYgIWRlZmluZWQoTUVUSE9EKVxcbiNlcnJvciBNdXN0IGRlZmluZSBNRVRIT0RcXG4jZW5kaWZcXG51bmlmb3JtIHNhbXBsZXIyRCBweXJhbWlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxudW5pZm9ybSBpbnQgbWF4SXRlcmF0aW9ucztcXG51bmlmb3JtIGZsb2F0IGVwc2lsb247XFxuY29uc3QgaW50IFBBVENIX1JBRElVUyA9IDE7XFxuY29uc3QgaW50IFBBVENIX1NJWkUgPSAyICogUEFUQ0hfUkFESVVTICsgMTtcXG5jb25zdCBpbnQgUEFUQ0hfU0laRV9TUVVBUkVEID0gUEFUQ0hfU0laRSAqIFBBVENIX1NJWkU7XFxuY29uc3QgaW50IExBUkdFX1BBVENIX1JBRElVUyA9IFBBVENIX1JBRElVUyArIDE7XFxuY29uc3QgaW50IExBUkdFX1BBVENIX1NJWkUgPSAyICogTEFSR0VfUEFUQ0hfUkFESVVTICsgMTtcXG5jb25zdCBpbnQgTEFSR0VfUEFUQ0hfU0laRV9TUVVBUkVEID0gTEFSR0VfUEFUQ0hfU0laRSAqIExBUkdFX1BBVENIX1NJWkU7XFxuY29uc3QgaW50IExBUkdFUl9QQVRDSF9SQURJVVMgPSBMQVJHRV9QQVRDSF9SQURJVVMgKyAxO1xcbmNvbnN0IGludCBMQVJHRVJfUEFUQ0hfU0laRSA9IDIgKiBMQVJHRVJfUEFUQ0hfUkFESVVTICsgMTtcXG5jb25zdCBpbnQgTEFSR0VSX1BBVENIX1NJWkVfU1FVQVJFRCA9IExBUkdFUl9QQVRDSF9TSVpFICogTEFSR0VSX1BBVENIX1NJWkU7XFxuY29uc3QgZmxvYXQgRVBTID0gMWUtNTtcXG5mbG9hdCBzbW9vdGhQaXhlbEJ1ZmZlcltMQVJHRVJfUEFUQ0hfU0laRV9TUVVBUkVEXTtcXG52ZWMyIGRlcml2YXRpdmVzQnVmZmVyW0xBUkdFX1BBVENIX1NJWkVfU1FVQVJFRF07XFxuZmxvYXQgcmVzcG9uc2VCdWZmZXJbUEFUQ0hfU0laRV9TUVVBUkVEXTtcXG4jZGVmaW5lIHBhdGNoUGl4ZWxBdCh1LHYpIHNtb290aFBpeGVsQnVmZmVyWygodikgKyBMQVJHRVJfUEFUQ0hfUkFESVVTKSAqIExBUkdFUl9QQVRDSF9TSVpFICsgKCh1KSArIExBUkdFUl9QQVRDSF9SQURJVVMpXVxcbiNkZWZpbmUgZGVyaXZhdGl2ZXNBdCh1LHYpIGRlcml2YXRpdmVzQnVmZmVyWygodikgKyBMQVJHRV9QQVRDSF9SQURJVVMpICogTEFSR0VfUEFUQ0hfU0laRSArICgodSkgKyBMQVJHRV9QQVRDSF9SQURJVVMpXVxcbiNkZWZpbmUgcmVzcG9uc2VBdCh1LHYpIHJlc3BvbnNlQnVmZmVyWygodikgKyBQQVRDSF9SQURJVVMpICogUEFUQ0hfU0laRSArICgodSkgKyBQQVRDSF9SQURJVVMpXVxcbnZvaWQgcmVhZFBpeGVscyh2ZWMyIGNlbnRlciwgZmxvYXQgbG9kKVxcbntcXG5pdmVjMiBweXJCYXNlU2l6ZSA9IHRleHR1cmVTaXplKHB5cmFtaWQsIDApO1xcbmZsb2F0IHBvdCA9IGV4cDIobG9kKTtcXG5pbnQgdSwgdjtcXG5mb3IoaW50IGogPSAwOyBqIDwgTEFSR0VSX1BBVENIX1NJWkU7IGorKykge1xcbmZvcihpbnQgaSA9IDA7IGkgPCBMQVJHRVJfUEFUQ0hfU0laRTsgaSsrKSB7XFxudSA9IGkgLSBMQVJHRVJfUEFUQ0hfUkFESVVTO1xcbnYgPSBqIC0gTEFSR0VSX1BBVENIX1JBRElVUztcXG5wYXRjaFBpeGVsQXQodSx2KSA9IHB5clN1YnBpeGVsQXRFeE9mZnNldChweXJhbWlkLCBjZW50ZXIsIGxvZCwgcG90LCBpdmVjMih1LHYpLCBweXJCYXNlU2l6ZSkuZztcXG59XFxufVxcbn1cXG52b2lkIGNvbXB1dGVEZXJpdmF0aXZlcygpXFxue1xcbmNvbnN0IG1hdDMgZHggPSBtYXQzKFxcbi0xLCAwLCAxLFxcbi0yLCAwLCAyLFxcbi0xLCAwLCAxXFxuKTtcXG5jb25zdCBtYXQzIGR5ID0gbWF0MyhcXG4xLCAyLCAxLFxcbjAsIDAsIDAsXFxuLTEsLTIsLTFcXG4pO1xcbmludCB1LCB2O1xcbm1hdDMgcGl4LCBjb252WCwgY29udlk7XFxuY29uc3QgdmVjMyBvbmVzID0gdmVjMygxLjBmKTtcXG5mb3IoaW50IGogPSAwOyBqIDwgTEFSR0VfUEFUQ0hfU0laRTsgaisrKSB7XFxuZm9yKGludCBpID0gMDsgaSA8IExBUkdFX1BBVENIX1NJWkU7IGkrKykge1xcbnUgPSBpIC0gTEFSR0VfUEFUQ0hfUkFESVVTO1xcbnYgPSBqIC0gTEFSR0VfUEFUQ0hfUkFESVVTO1xcbnBpeCA9IG1hdDMoXFxucGF0Y2hQaXhlbEF0KHUrMSx2KzEpLCBwYXRjaFBpeGVsQXQodSswLHYrMSksIHBhdGNoUGl4ZWxBdCh1LTEsdisxKSxcXG5wYXRjaFBpeGVsQXQodSsxLHYrMCksIHBhdGNoUGl4ZWxBdCh1KzAsdiswKSwgcGF0Y2hQaXhlbEF0KHUtMSx2KzApLFxcbnBhdGNoUGl4ZWxBdCh1KzEsdi0xKSwgcGF0Y2hQaXhlbEF0KHUrMCx2LTEpLCBwYXRjaFBpeGVsQXQodS0xLHYtMSlcXG4pO1xcbmNvbnZYID0gbWF0cml4Q29tcE11bHQoZHgsIHBpeCk7XFxuY29udlkgPSBtYXRyaXhDb21wTXVsdChkeSwgcGl4KTtcXG5kZXJpdmF0aXZlc0F0KHUsdikgPSB2ZWMyKFxcbmRvdChvbmVzLCB2ZWMzKFxcbmRvdChjb252WFswXSwgb25lcyksXFxuZG90KGNvbnZYWzFdLCBvbmVzKSxcXG5kb3QoY29udlhbMl0sIG9uZXMpXFxuKSksXFxuZG90KG9uZXMsIHZlYzMoXFxuZG90KGNvbnZZWzBdLCBvbmVzKSxcXG5kb3QoY29udllbMV0sIG9uZXMpLFxcbmRvdChjb252WVsyXSwgb25lcylcXG4pKVxcbik7XFxufVxcbn1cXG59XFxudmVjMiBjb21wdXRlUmVzcG9uc2VNYXAoKVxcbntcXG5mbG9hdCBwYXRjaEFyZWEgPSBmbG9hdChQQVRDSF9TSVpFICogUEFUQ0hfU0laRSk7XFxudmVjMyBoOyB2ZWMyIGQsIGMgPSB2ZWMyKDAuMGYpO1xcbmNvbnN0IHZlYzMgb25lcyA9IHZlYzMoMS4wZik7XFxuZmxvYXQgcmVzcG9uc2UsIHN1bSA9IDAuMGY7XFxuaW50IHUsIHY7XFxuI2RlZmluZSBIKHIscykgZCA9IGRlcml2YXRpdmVzQXQoKHIpLChzKSk7IGggKz0gdmVjMyhkLnggKiBkLngsIGQueCAqIGQueSwgZC55ICogZC55KVxcbmZvcihpbnQgaiA9IDA7IGogPCBQQVRDSF9TSVpFOyBqKyspIHtcXG5mb3IoaW50IGkgPSAwOyBpIDwgUEFUQ0hfU0laRTsgaSsrKSB7XFxudSA9IGkgLSBQQVRDSF9SQURJVVM7XFxudiA9IGogLSBQQVRDSF9SQURJVVM7XFxuaCA9IHZlYzMoMC4wZik7XFxuSCh1LTEsdi0xKTsgSCh1KzAsdi0xKTsgSCh1KzEsdi0xKTtcXG5IKHUtMSx2KzApOyBIKHUrMCx2KzApOyBIKHUrMSx2KzApO1xcbkgodS0xLHYrMSk7IEgodSswLHYrMSk7IEgodSsxLHYrMSk7XFxucmVzcG9uc2UgPSAwLjVmICogKGgueCArIGgueiAtIHNxcnQoKGgueCAtIGgueikgKiAoaC54IC0gaC56KSArIDQuMGYgKiBoLnkgKiBoLnkpKTtcXG5yZXNwb25zZSAvPSBwYXRjaEFyZWE7XFxucmVzcG9uc2VBdCh1LHYpID0gcmVzcG9uc2U7XFxuYyArPSB2ZWMyKHUsdikgKiByZXNwb25zZTtcXG5zdW0gKz0gcmVzcG9uc2U7XFxufVxcbn1cXG5yZXR1cm4gYWJzKHN1bSkgPiBFUFMgPyBjIC8gc3VtIDogdmVjMigwLjBmKTtcXG59XFxuI2lmIE1FVEhPRCA9PSAwXFxudmVjMiBxdWFkcmF0aWMxZCgpXFxue1xcbmZsb2F0IGEgPSAwLjVmICogKHJlc3BvbnNlQXQoLTEsMCkgLSAyLjBmICogcmVzcG9uc2VBdCgwLDApICsgcmVzcG9uc2VBdCgxLDApKTtcXG5mbG9hdCBiID0gMC41ZiAqIChyZXNwb25zZUF0KDEsMCkgLSByZXNwb25zZUF0KC0xLDApKTtcXG5mbG9hdCBjID0gcmVzcG9uc2VBdCgwLDApO1xcbmZsb2F0IGQgPSAwLjVmICogKHJlc3BvbnNlQXQoMCwtMSkgLSAyLjBmICogcmVzcG9uc2VBdCgwLDApICsgcmVzcG9uc2VBdCgwLDEpKTtcXG5mbG9hdCBlID0gMC41ZiAqIChyZXNwb25zZUF0KDAsMSkgLSByZXNwb25zZUF0KDAsLTEpKTtcXG5mbG9hdCBmID0gcmVzcG9uc2VBdCgwLDApO1xcbmJvb2wgaGFzTWF4ID0gYSA8IC1FUFMgJiYgZCA8IC1FUFM7XFxucmV0dXJuIGhhc01heCA/IC0wLjVmICogdmVjMihiIC8gYSwgZSAvIGQpIDogdmVjMigwLjBmKTtcXG59XFxuI2VuZGlmXFxuI2lmIE1FVEhPRCA9PSAxXFxudmVjMiB0YXlsb3IyZCgpXFxue1xcbmZsb2F0IGR4ID0gKC1yZXNwb25zZUF0KC0xLDApICsgcmVzcG9uc2VBdCgxLDApKSAqIDAuNWY7XFxuZmxvYXQgZHkgPSAoLXJlc3BvbnNlQXQoMCwtMSkgKyByZXNwb25zZUF0KDAsMSkpICogMC41ZjtcXG5mbG9hdCBkeHggPSByZXNwb25zZUF0KC0xLDApIC0gMi4wZiAqIHJlc3BvbnNlQXQoMCwwKSArIHJlc3BvbnNlQXQoMSwwKTtcXG5mbG9hdCBkeXkgPSByZXNwb25zZUF0KDAsLTEpIC0gMi4wZiAqIHJlc3BvbnNlQXQoMCwwKSArIHJlc3BvbnNlQXQoMCwxKTtcXG5mbG9hdCBkeHkgPSAocmVzcG9uc2VBdCgtMSwtMSkgKyByZXNwb25zZUF0KDEsMSkgLSByZXNwb25zZUF0KDEsLTEpIC0gcmVzcG9uc2VBdCgtMSwxKSkgKiAwLjI1ZjtcXG5mbG9hdCBkZXQgPSBkeHggKiBkeXkgLSBkeHkgKiBkeHk7XFxubWF0MiBpbnYgPSBtYXQyKGR5eSwgLWR4eSwgLWR4eSwgZHh4KTtcXG5ib29sIGhhc01heCA9IGRldCA+IEVQUyAmJiBkeHggPCAwLjBmO1xcbnJldHVybiBoYXNNYXggPyBpbnYgKiB2ZWMyKGR4LCBkeSkgLyAoLWRldCkgOiB2ZWMyKDAuMGYpO1xcbn1cXG4jZW5kaWZcXG4jaWYgTUVUSE9EID09IDJcXG52b2lkIGJpbGluZWFyVXBzYW1wbGUoaXZlYzIgcGF0Y2hPZmZzZXQsIHZlYzQgcGl4ZWxzT2ZQYXRjaClcXG57XFxuaW50IHUsIHYsIGksIGo7XFxudmVjMiBmcmMsIGlmcmM7IHZlYzQgc3ViO1xcbmNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wZik7XFxuZmxvYXQgcyA9IDEuMGYgLyBmbG9hdChQQVRDSF9TSVpFIC0gMSk7XFxuaW50IHhvZmYgPSAyICogcGF0Y2hPZmZzZXQueDtcXG5pbnQgeW9mZiA9IDIgKiBwYXRjaE9mZnNldC55O1xcbmZvcihqID0gMDsgaiA8IFBBVENIX1NJWkU7IGorKykge1xcbmZvcihpID0gMDsgaSA8IFBBVENIX1NJWkU7IGkrKykge1xcbnUgPSBpIC0gUEFUQ0hfUkFESVVTO1xcbnYgPSBqIC0gUEFUQ0hfUkFESVVTO1xcbmZyYyA9IHZlYzIoaSwgaikgKiBzO1xcbmlmcmMgPSB2ZWMyKDEuMGYpIC0gZnJjO1xcbnN1YiA9IHZlYzQoXFxuaWZyYy54ICogaWZyYy55LFxcbmZyYy54ICogaWZyYy55LFxcbmlmcmMueCAqIGZyYy55LFxcbmZyYy54ICogZnJjLnlcXG4pO1xcbnBhdGNoUGl4ZWxBdCh1K3hvZmYsdit5b2ZmKSA9IGRvdChzdWIqcGl4ZWxzT2ZQYXRjaCwgb25lcyk7XFxufVxcbn1cXG59XFxuI2VuZGlmXFxuI2lmIE1FVEhPRCA9PSAzXFxudm9pZCBiaWN1YmljVXBzYW1wbGUoaXZlYzIgcGF0Y2hPZmZzZXQsIHZlYzQgcGl4ZWxzT2ZQYXRjaCwgdmVjNCBkeCwgdmVjNCBkeSwgdmVjNCBkeHkpXFxue1xcbmZsb2F0IHgsIHksIHMgPSAxLjBmIC8gZmxvYXQoUEFUQ0hfU0laRSAtIDEpO1xcbmludCB1LCB2LCBpLCBqO1xcbmZsb2F0IGYwMCA9IHBpeGVsc09mUGF0Y2gueDtcXG5mbG9hdCBmMTAgPSBwaXhlbHNPZlBhdGNoLnk7XFxuZmxvYXQgZjAxID0gcGl4ZWxzT2ZQYXRjaC56O1xcbmZsb2F0IGYxMSA9IHBpeGVsc09mUGF0Y2gudztcXG5mbG9hdCBmeDAwID0gZHgueDtcXG5mbG9hdCBmeDEwID0gZHgueTtcXG5mbG9hdCBmeDAxID0gZHguejtcXG5mbG9hdCBmeDExID0gZHgudztcXG5mbG9hdCBmeTAwID0gZHkueDtcXG5mbG9hdCBmeTEwID0gZHkueTtcXG5mbG9hdCBmeTAxID0gZHkuejtcXG5mbG9hdCBmeTExID0gZHkudztcXG5mbG9hdCBmeHkwMCA9IGR4eS54O1xcbmZsb2F0IGZ4eTEwID0gZHh5Lnk7XFxuZmxvYXQgZnh5MDEgPSBkeHkuejtcXG5mbG9hdCBmeHkxMSA9IGR4eS53O1xcbm1hdDQgYmljdWJpYyA9IG1hdDQoXFxuMSwgMCwgLTMsIDIsXFxuMCwgMCwgMywgLTIsXFxuMCwgMSwgLTIsIDEsXFxuMCwgMCwgLTEsIDFcXG4pICogbWF0NChcXG5mMDAsIGYxMCwgZngwMCwgZngxMCxcXG5mMDEsIGYxMSwgZngwMSwgZngxMSxcXG5meTAwLCBmeTEwLCBmeHkwMCwgZnh5MTAsXFxuZnkwMSwgZnkxMSwgZnh5MDEsIGZ4eTExXFxuKSAqIG1hdDQoXFxuMSwgMCwgMCwgMCxcXG4wLCAwLCAxLCAwLFxcbi0zLCAzLCAtMiwgLTEsXFxuMiwgLTIsIDEsIDFcXG4pO1xcbmludCB4b2ZmID0gMiAqIHBhdGNoT2Zmc2V0Lng7XFxuaW50IHlvZmYgPSAyICogcGF0Y2hPZmZzZXQueTtcXG5mb3IoaiA9IDA7IGogPCBQQVRDSF9TSVpFOyBqKyspIHtcXG5mb3IoaSA9IDA7IGkgPCBQQVRDSF9TSVpFOyBpKyspIHtcXG51ID0gaSAtIFBBVENIX1JBRElVUztcXG52ID0gaiAtIFBBVENIX1JBRElVUztcXG54ID0gZmxvYXQoaSkgKiBzO1xcbnkgPSBmbG9hdChqKSAqIHM7XFxucGF0Y2hQaXhlbEF0KHUreG9mZix2K3lvZmYpID0gZG90KFxcbnZlYzQoMSwgeCwgeCp4LCB4KngqeCksXFxuYmljdWJpYyAqIHZlYzQoMSwgeSwgeSp5LCB5KnkqeSlcXG4pO1xcbn1cXG59XFxufVxcbiNlbmRpZlxcbiNpZiBNRVRIT0QgPT0gMiB8fCBNRVRIT0QgPT0gM1xcbnZvaWQgdXBzYW1wbGVQYXRjaChpbnQgbGVmdCwgaW50IHRvcCwgaW50IHJpZ2h0LCBpbnQgYm90dG9tKVxcbntcXG5pbnQgeCwgeSwgaztcXG52ZWM0IHB0Y2hbOV07XFxudmVjMiBkMDAsIGQxMCwgZDAxLCBkMTE7XFxuZm9yKGsgPSAwOyBrIDwgOTsgaysrKSB7XFxueCA9IC0xICsgKGsgJSAzKTtcXG55ID0gLTEgKyAoayAvIDMpO1xcbnB0Y2hba10gPSB2ZWM0KFxcbnBhdGNoUGl4ZWxBdChsZWZ0K3gsIHRvcCt5KSxcXG5wYXRjaFBpeGVsQXQocmlnaHQreCwgdG9wK3kpLFxcbnBhdGNoUGl4ZWxBdChsZWZ0K3gsIGJvdHRvbSt5KSxcXG5wYXRjaFBpeGVsQXQocmlnaHQreCwgYm90dG9tK3kpXFxuKTtcXG59XFxuZm9yKGsgPSAwOyBrIDwgOTsgaysrKSB7XFxueCA9IC0xICsgKGsgJSAzKTtcXG55ID0gLTEgKyAoayAvIDMpO1xcbiNpZiBNRVRIT0QgPT0gMlxcbmJpbGluZWFyVXBzYW1wbGUoaXZlYzIoeCwgeSksIHB0Y2hba10pO1xcbiNlbGlmIE1FVEhPRCA9PSAzXFxuZDAwID0gZGVyaXZhdGl2ZXNBdChsZWZ0K3gsIHRvcCt5KTtcXG5kMTAgPSBkZXJpdmF0aXZlc0F0KHJpZ2h0K3gsIHRvcCt5KTtcXG5kMDEgPSBkZXJpdmF0aXZlc0F0KGxlZnQreCwgYm90dG9tK3kpO1xcbmQxMSA9IGRlcml2YXRpdmVzQXQocmlnaHQreCwgYm90dG9tK3kpO1xcbmJpY3ViaWNVcHNhbXBsZShpdmVjMih4LCB5KSwgcHRjaFtrXSxcXG52ZWM0KGQwMC54LCBkMTAueCwgZDAxLngsIGQxMS54KSxcXG52ZWM0KGQwMC55LCBkMTAueSwgZDAxLnksIGQxMS55KSxcXG4wLjI1ZiAqIHZlYzQoXFxuKHBhdGNoUGl4ZWxBdChsZWZ0K3ggKyAxLHRvcCt5ICsgMSkgKyBwYXRjaFBpeGVsQXQobGVmdCt4IC0gMSwgdG9wK3kgLSAxKSkgLSAocGF0Y2hQaXhlbEF0KGxlZnQreCArIDEsIHRvcCt5IC0gMSkgKyBwYXRjaFBpeGVsQXQobGVmdCt4IC0gMSwgdG9wK3kgKyAxKSksXFxuKHBhdGNoUGl4ZWxBdChyaWdodCt4ICsgMSx0b3AreSArIDEpICsgcGF0Y2hQaXhlbEF0KHJpZ2h0K3ggLSAxLCB0b3AreSAtIDEpKSAtIChwYXRjaFBpeGVsQXQocmlnaHQreCArIDEsIHRvcCt5IC0gMSkgKyBwYXRjaFBpeGVsQXQocmlnaHQreCAtIDEsIHRvcCt5ICsgMSkpLFxcbihwYXRjaFBpeGVsQXQobGVmdCt4ICsgMSxib3R0b20reSArIDEpICsgcGF0Y2hQaXhlbEF0KGxlZnQreCAtIDEsIGJvdHRvbSt5IC0gMSkpIC0gKHBhdGNoUGl4ZWxBdChsZWZ0K3ggKyAxLCBib3R0b20reSAtIDEpICsgcGF0Y2hQaXhlbEF0KGxlZnQreCAtIDEsIGJvdHRvbSt5ICsgMSkpLFxcbihwYXRjaFBpeGVsQXQocmlnaHQreCArIDEsYm90dG9tK3kgKyAxKSArIHBhdGNoUGl4ZWxBdChyaWdodCt4IC0gMSwgYm90dG9tK3kgLSAxKSkgLSAocGF0Y2hQaXhlbEF0KHJpZ2h0K3ggKyAxLCBib3R0b20reSAtIDEpICsgcGF0Y2hQaXhlbEF0KHJpZ2h0K3ggLSAxLCBib3R0b20reSArIDEpKVxcbilcXG4pO1xcbiNlbmRpZlxcbn1cXG59XFxudmVjMiB1cHNhbXBsZVJlc3BvbnNlTWFwKGludCBsZWZ0LCBpbnQgdG9wLCBpbnQgcmlnaHQsIGludCBib3R0b20pXFxue1xcbnVwc2FtcGxlUGF0Y2gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcXG5jb21wdXRlRGVyaXZhdGl2ZXMoKTtcXG5yZXR1cm4gY29tcHV0ZVJlc3BvbnNlTWFwKCk7XFxufVxcbnZlYzIgaXRlcmF0aXZlVXBzYW1wbGUodmVjMiBpbml0aWFsR3Vlc3MpXFxue1xcbmludCByZWZpbmUgPSAxO1xcbmZsb2F0IHNjYWxlID0gMC41ZjtcXG5mbG9hdCBlcHMyID0gZXBzaWxvbiAqIGVwc2lsb247XFxudmVjMiBndWVzcyA9IGluaXRpYWxHdWVzcywgbG9jYWxHdWVzcyA9IGluaXRpYWxHdWVzcztcXG5mb3IoaW50IGsgPSAwOyBrIDwgbWF4SXRlcmF0aW9uczsgaysrKSB7XFxuaXZlYzQgcXVhZCA9IGl2ZWM0KGZsb29yKGxvY2FsR3Vlc3MueCksIGZsb29yKGxvY2FsR3Vlc3MueSksIGNlaWwobG9jYWxHdWVzcy54KSwgY2VpbChsb2NhbEd1ZXNzLnkpKTtcXG52ZWMyIHJlc3BvbnNlID0gKHJlZmluZSAhPSAwKSA/IHVwc2FtcGxlUmVzcG9uc2VNYXAocXVhZC54LCBxdWFkLnksIHF1YWQueiwgcXVhZC53KSA6IHZlYzIoMC4wZik7XFxubG9jYWxHdWVzcyA9IHJlc3BvbnNlICogc2NhbGU7XFxuZ3Vlc3MgKz0gbG9jYWxHdWVzcztcXG5zY2FsZSAqPSAwLjVmO1xcbnJlZmluZSAqPSBpbnQoZG90KGxvY2FsR3Vlc3MsIGxvY2FsR3Vlc3MpID49IGVwczIpO1xcbn1cXG5yZXR1cm4gZ3Vlc3M7XFxufVxcbiNlbmRpZlxcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaW50IGtleXBvaW50SW5kZXggPSB0aHJlYWQueCArIHRocmVhZC55ICogb3V0cHV0U2l6ZSgpLng7XFxuaW50IHBpeGVsc1BlcktleXBvaW50ID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50KGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpIC8gNDtcXG5LZXlwb2ludEFkZHJlc3MgYWRkcmVzcyA9IEtleXBvaW50QWRkcmVzcyhrZXlwb2ludEluZGV4ICogcGl4ZWxzUGVyS2V5cG9pbnQsIDApO1xcbktleXBvaW50IGtleXBvaW50ID0gZGVjb2RlS2V5cG9pbnQoZW5jb2RlZEtleXBvaW50cywgZW5jb2Rlckxlbmd0aCwgYWRkcmVzcyk7XFxuY29sb3IgPSBlbmNvZGVOdWxsUGFpck9mRmxvYXQxNigpO1xcbmlmKGlzTnVsbEtleXBvaW50KGtleXBvaW50KSlcXG5yZXR1cm47XFxuY29sb3IgPSBlbmNvZGVEaXNjYXJkZWRQYWlyT2ZGbG9hdDE2KCk7XFxuaWYoaXNCYWRLZXlwb2ludChrZXlwb2ludCkpXFxucmV0dXJuO1xcbnJlYWRQaXhlbHMoa2V5cG9pbnQucG9zaXRpb24sIGtleXBvaW50LmxvZCk7XFxuY29tcHV0ZURlcml2YXRpdmVzKCk7XFxudmVjMiBvZmZzZXQgPSBjb21wdXRlUmVzcG9uc2VNYXAoKTtcXG4jaWYgTUVUSE9EID09IDBcXG5vZmZzZXQgPSBxdWFkcmF0aWMxZCgpO1xcbiNlbGlmIE1FVEhPRCA9PSAxXFxub2Zmc2V0ID0gdGF5bG9yMmQoKTtcXG4jZWxpZiBNRVRIT0QgPT0gMiB8fCBNRVRIT0QgPT0gM1xcbm9mZnNldCA9IGl0ZXJhdGl2ZVVwc2FtcGxlKG9mZnNldCk7XFxuI2Vsc2VcXG4jZXJyb3IgVW5rbm93biBNRVRIT0RcXG4jZW5kaWZcXG5mbG9hdCBwb3QgPSBleHAyKGtleXBvaW50LmxvZCk7XFxuY29sb3IgPSBlbmNvZGVQYWlyT2ZGbG9hdDE2KG9mZnNldCAqIHBvdCk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJrZXlwb2ludHMuZ2xzbFxcXCJcXG5AaW5jbHVkZSBcXFwiZmxvYXQxNi5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRGbG93O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRLZXlwb2ludHM7XFxudW5pZm9ybSBpbnQgZGVzY3JpcHRvclNpemU7XFxudW5pZm9ybSBpbnQgZXh0cmFTaXplO1xcbnVuaWZvcm0gaW50IGVuY29kZXJMZW5ndGg7XFxudm9pZCBtYWluKClcXG57XFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKGVuY29kZWRLZXlwb2ludHMpO1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaW50IGxlbiA9IHRleHR1cmVTaXplKGVuY29kZWRGbG93LCAwKS54O1xcbktleXBvaW50QWRkcmVzcyBteUFkZHJlc3MgPSBmaW5kS2V5cG9pbnRBZGRyZXNzKHRocmVhZCwgZW5jb2Rlckxlbmd0aCwgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBteUFkZHJlc3MpO1xcbmludCBteUluZGV4ID0gZmluZEtleXBvaW50SW5kZXgobXlBZGRyZXNzLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5jb2xvciA9IHBpeGVsO1xcbmlmKGlzQmFkS2V5cG9pbnQoa2V5cG9pbnQpKVxcbnJldHVybjtcXG5pdmVjMiBsb2NhdGlvbiA9IGl2ZWMyKG15SW5kZXggJSBsZW4sIG15SW5kZXggLyBsZW4pO1xcbnZlYzQgZW5jb2RlZEZsb3cgPSBteUluZGV4IDwgbGVuICogbGVuID8gcGl4ZWxBdChlbmNvZGVkRmxvdywgbG9jYXRpb24pIDogZW5jb2RlRGlzY2FyZGVkS2V5cG9pbnQoKTtcXG5ib29sIGRpc2NhcmRGbG93ID0gaXNEaXNjYXJkZWRQYWlyT2ZGbG9hdDE2KGVuY29kZWRGbG93KTtcXG52ZWMyIGZsb3cgPSAhZGlzY2FyZEZsb3cgPyBkZWNvZGVQYWlyT2ZGbG9hdDE2KGVuY29kZWRGbG93KSA6IHZlYzIoMC4wZik7XFxudmVjNCBuZXdQb3NpdGlvbiA9IGVuY29kZUtleXBvaW50UG9zaXRpb24oa2V5cG9pbnQucG9zaXRpb24gKyBmbG93KTtcXG52ZWM0IG5ld1BpeGVsID0gbXlBZGRyZXNzLm9mZnNldCA9PSAwID8gbmV3UG9zaXRpb24gOiBwaXhlbDtcXG5jb2xvciA9ICFkaXNjYXJkRmxvdyA/IG5ld1BpeGVsIDogZW5jb2RlRGlzY2FyZGVkS2V5cG9pbnQoKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWRPcmllbnRhdGlvbnM7XFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG52b2lkIG1haW4oKVxcbntcXG52ZWM0IHBpeGVsID0gdGhyZWFkUGl4ZWwoZW5jb2RlZEtleXBvaW50cyk7XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5LZXlwb2ludEFkZHJlc3MgbXlBZGRyZXNzID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIGVuY29kZXJMZW5ndGgsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmludCBteUluZGV4ID0gZmluZEtleXBvaW50SW5kZXgobXlBZGRyZXNzLCBkZXNjcmlwdG9yU2l6ZSwgZXh0cmFTaXplKTtcXG5pbnQgb3JpZW50YXRpb25FbmNvZGVyTGVuZ3RoID0gdGV4dHVyZVNpemUoZW5jb2RlZE9yaWVudGF0aW9ucywgMCkueDtcXG5pdmVjMiBsb2NhdGlvbiA9IGl2ZWMyKG15SW5kZXggJSBvcmllbnRhdGlvbkVuY29kZXJMZW5ndGgsIG15SW5kZXggLyBvcmllbnRhdGlvbkVuY29kZXJMZW5ndGgpO1xcbnZlYzQgdGFyZ2V0UGl4ZWwgPSBwaXhlbEF0KGVuY29kZWRPcmllbnRhdGlvbnMsIGxvY2F0aW9uKTtcXG5LZXlwb2ludCBrZXlwb2ludCA9IGRlY29kZUtleXBvaW50KGVuY29kZWRLZXlwb2ludHMsIGVuY29kZXJMZW5ndGgsIG15QWRkcmVzcyk7XFxuYm9vbCBpc1ZhbGlkID0gIWlzQmFkS2V5cG9pbnQoa2V5cG9pbnQpO1xcbmZsb2F0IGVuY29kZWRPcmllbnRhdGlvbiA9IHRhcmdldFBpeGVsLmc7XFxuY29sb3IgPSBpc1ZhbGlkICYmIG15QWRkcmVzcy5vZmZzZXQgPT0gMSA/IHZlYzQocGl4ZWwuciwgZW5jb2RlZE9yaWVudGF0aW9uLCBwaXhlbC5iYSkgOiBwaXhlbDtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcImtleXBvaW50cy5nbHNsXFxcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIGVuY29kZWREYXRhO1xcbnVuaWZvcm0gaW50IHN0cmlkZU9mRW5jb2RlZERhdGE7XFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBkZXNjcmlwdG9yU2l6ZTtcXG51bmlmb3JtIGludCBleHRyYVNpemU7XFxudW5pZm9ybSBpbnQgZW5jb2Rlckxlbmd0aDtcXG52ZWM0IHJlYWRFbmNvZGVkRGF0YShzYW1wbGVyMkQgZW5jb2RlZERhdGEsIGludCBzdHJpZGVPZkVuY29kZWREYXRhLCBpbnQgZWxlbWVudElkLCBpbnQgcGl4ZWxzUGVyRWxlbWVudCwgaW50IHBpeGVsT2Zmc2V0KVxcbntcXG5pbnQgcmFzdGVySW5kZXggPSBlbGVtZW50SWQgKiBwaXhlbHNQZXJFbGVtZW50ICsgcGl4ZWxPZmZzZXQ7XFxuaXZlYzIgcG9zID0gaXZlYzIocmFzdGVySW5kZXggJSBzdHJpZGVPZkVuY29kZWREYXRhLCByYXN0ZXJJbmRleCAvIHN0cmlkZU9mRW5jb2RlZERhdGEpO1xcbnJldHVybiB0ZXhlbEZldGNoKGVuY29kZWREYXRhLCBwb3MsIDApO1xcbn1cXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBteUFkZHJlc3MgPSBmaW5kS2V5cG9pbnRBZGRyZXNzKHRocmVhZCwgZW5jb2Rlckxlbmd0aCwgZGVzY3JpcHRvclNpemUsIGV4dHJhU2l6ZSk7XFxuaW50IG15SW5kZXggPSBmaW5kS2V5cG9pbnRJbmRleChteUFkZHJlc3MsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmludCBoZWFkZXJTaXplID0gc2l6ZW9mRW5jb2RlZEtleXBvaW50SGVhZGVyKCk7XFxuaW50IGV4dHJhQ2VsbCA9IG15QWRkcmVzcy5vZmZzZXQgLSBoZWFkZXJTaXplIC8gNDtcXG5pbnQgbnVtYmVyT2ZFeHRyYUNlbGxzID0gZXh0cmFTaXplIC8gNDtcXG5jb2xvciA9IHRocmVhZFBpeGVsKGVuY29kZWRLZXlwb2ludHMpO1xcbmlmKGV4dHJhQ2VsbCA8IDAgfHwgZXh0cmFDZWxsID49IG51bWJlck9mRXh0cmFDZWxscylcXG5yZXR1cm47XFxuS2V5cG9pbnQga2V5cG9pbnQgPSBkZWNvZGVLZXlwb2ludChlbmNvZGVkS2V5cG9pbnRzLCBlbmNvZGVyTGVuZ3RoLCBteUFkZHJlc3MpO1xcbmlmKGlzQmFkS2V5cG9pbnQoa2V5cG9pbnQpKVxcbnJldHVybjtcXG5jb2xvciA9IHJlYWRFbmNvZGVkRGF0YShlbmNvZGVkRGF0YSwgc3RyaWRlT2ZFbmNvZGVkRGF0YSwgbXlJbmRleCwgbnVtYmVyT2ZFeHRyYUNlbGxzLCBleHRyYUNlbGwpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgZW5jb2RlZEtleXBvaW50cztcXG51bmlmb3JtIGludCBzdGFydEluZGV4O1xcbnVuaWZvcm0gaW50IGVuZEluZGV4O1xcbnVuaWZvcm0gaW50IGRlc2NyaXB0b3JTaXplO1xcbnVuaWZvcm0gaW50IGV4dHJhU2l6ZTtcXG51bmlmb3JtIGludCBlbmNvZGVyTGVuZ3RoO1xcbiNpZm5kZWYgQlVGRkVSX1NJWkVcXG4jZXJyb3IgVW5kZWZpbmVkIEJVRkZFUl9TSVpFXFxuI2VuZGlmXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBLZXlwb2ludEJ1ZmZlclxcbntcXG52ZWM0IGtleXBvaW50QnVmZmVyW0JVRkZFUl9TSVpFXTtcXG59O1xcbnZvaWQgbWFpbigpXFxue1xcbnZlYzQgcGl4ZWwgPSB0aHJlYWRQaXhlbChlbmNvZGVkS2V5cG9pbnRzKTtcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbktleXBvaW50QWRkcmVzcyBhZGRyZXNzID0gZmluZEtleXBvaW50QWRkcmVzcyh0aHJlYWQsIGVuY29kZXJMZW5ndGgsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmludCBpbmRleCA9IGZpbmRLZXlwb2ludEluZGV4KGFkZHJlc3MsIGRlc2NyaXB0b3JTaXplLCBleHRyYVNpemUpO1xcbmNvbG9yID0gcGl4ZWw7XFxuaWYoaW5kZXggPCBzdGFydEluZGV4KVxcbnJldHVybjtcXG5jb2xvciA9IGVuY29kZU51bGxLZXlwb2ludCgpO1xcbmlmKGluZGV4ID49IGVuZEluZGV4KVxcbnJldHVybjtcXG52ZWM0IGRhdGEgPSBrZXlwb2ludEJ1ZmZlcltpbmRleCAtIHN0YXJ0SW5kZXhdO1xcbnN3aXRjaChhZGRyZXNzLm9mZnNldCkge1xcbmNhc2UgMDoge1xcbmNvbG9yID0gZW5jb2RlS2V5cG9pbnRQb3NpdGlvbihkYXRhLnh5KTtcXG5icmVhaztcXG59XFxuY2FzZSAxOiB7XFxudmVjMiBzY29yZSA9IGVuY29kZUtleXBvaW50U2NvcmUobWF4KGRhdGEudywgMC4wZikpO1xcbmZsb2F0IHNjYWxlID0gZW5jb2RlTG9kKGRhdGEueik7XFxuZmxvYXQgcm90YXRpb24gPSBlbmNvZGVLZXlwb2ludE9yaWVudGF0aW9uKDAuMGYpO1xcbmNvbG9yID0gdmVjNChzY2FsZSwgcm90YXRpb24sIHNjb3JlKTtcXG5icmVhaztcXG59XFxuZGVmYXVsdDoge1xcbmNvbG9yID0gdmVjNCgwLjBmKTtcXG5icmVhaztcXG59XFxufVxcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG52b2lkIG1haW4oKVxcbntcXG4jaWYgMVxcbmNvbG9yID0gdGV4dHVyZShpbWFnZSwgdGV4Q29vcmQpO1xcbiNlbHNlXFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pdmVjMiBwb3MgPSBtaW4odGhyZWFkICogMiwgdGV4dHVyZVNpemUoaW1hZ2UsIDApIC0gaXZlYzIoMSkpO1xcbmNvbG9yID0gcGl4ZWxBdChpbWFnZSwgcG9zKTtcXG4jZW5kaWZcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxudm9pZCBtYWluKClcXG57XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pdmVjMiBwb3MgPSBtaW4odGhyZWFkICogMywgdGV4dHVyZVNpemUoaW1hZ2UsIDApIC0gaXZlYzIoMSkpO1xcbmNvbG9yID0gcGl4ZWxBdChpbWFnZSwgcG9zKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxudm9pZCBtYWluKClcXG57XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG52ZWM0IHBpeGVsID0gcGl4ZWxBdChpbWFnZSwgdGhyZWFkIC8gMik7XFxuY29sb3IgPSAoKCh0aHJlYWQueCArIHRocmVhZC55KSAmIDEpID09IDApID8gcGl4ZWwgOiB2ZWM0KDAuMGYsIDAuMGYsIDAuMGYsIHBpeGVsLmEpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbnZlYzQgcGl4ZWwgPSBwaXhlbEF0KGltYWdlLCB0aHJlYWQgLyAzKTtcXG5jb2xvciA9ICgoKHRocmVhZC54IC0gKHRocmVhZC55ICUgMykgKyAzKSAlIDMpID09IDApID8gcGl4ZWwgOiB2ZWM0KDAuMGYsIDAuMGYsIDAuMGYsIHBpeGVsLmEpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwic3VicGl4ZWwuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTA7XFxudW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2UxO1xcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxudW5pZm9ybSBmbG9hdCBiZXRhO1xcbnVuaWZvcm0gZmxvYXQgZ2FtbWE7XFxuY29uc3QgdmVjNCBCQUNLR1JPVU5EID0gdmVjNCgwLjBmKTtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiBsb2NhdGlvbiA9IHRocmVhZExvY2F0aW9uKCk7XFxuaXZlYzIgc2l6ZTAgPSB0ZXh0dXJlU2l6ZShpbWFnZTAsIDApO1xcbml2ZWMyIHNpemUxID0gdGV4dHVyZVNpemUoaW1hZ2UxLCAwKTtcXG52ZWM0IHBpeDAgPSBhbGwobGVzc1RoYW4obG9jYXRpb24sIHNpemUwKSkgPyBwaXhlbEF0KGltYWdlMCwgbG9jYXRpb24pIDogQkFDS0dST1VORDtcXG52ZWM0IHBpeDEgPSBhbGwobGVzc1RoYW4obG9jYXRpb24sIHNpemUxKSkgPyBwaXhlbEF0KGltYWdlMSwgbG9jYXRpb24pIDogQkFDS0dST1VORDtcXG52ZWM0IHBpeCA9IGNsYW1wKGFscGhhICogcGl4MCArIGJldGEgKiBwaXgxICsgdmVjNChnYW1tYSksIDAuMGYsIDEuMGYpO1xcbmNvbG9yID0gdmVjNChwaXgucmdiLCAxLjBmKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiQGluY2x1ZGUgXFxcInN1YnBpeGVsLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxudm9pZCBtYWluKClcXG57XFxudmVjMiBpbWFnZVNpemUgPSB2ZWMyKHRleHR1cmVTaXplKGltYWdlLCAwKSk7XFxuI2lmICFkZWZpbmVkKElOVEVSUE9MQVRJT05fTUVUSE9EKVxcbiNlcnJvciBNdXN0IGRlZmluZSBJTlRFUlBPTEFUSU9OX01FVEhPRFxcbiNlbGlmIElOVEVSUE9MQVRJT05fTUVUSE9EID09IDBcXG52ZWMyIHBvcyA9IHRleENvb3JkICogaW1hZ2VTaXplO1xcbmNvbG9yID0gdGV4dHVyZUxvZChpbWFnZSwgKHJvdW5kKHBvcykgKyB2ZWMyKDAuNWYpKSAvIGltYWdlU2l6ZSwgMC4wZik7XFxuI2VsaWYgSU5URVJQT0xBVElPTl9NRVRIT0QgPT0gMVxcbmNvbG9yID0gc3VicGl4ZWxBdEJJKGltYWdlLCB0ZXhDb29yZCAqIGltYWdlU2l6ZSk7XFxuI2Vsc2VcXG4jZXJyb3IgSW52YWxpZCBJTlRFUlBPTEFUSU9OX01FVEhPRFxcbiNlbmRpZlxcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwic3VicGl4ZWwuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG51bmlmb3JtIG1hdDMgaW52ZXJzZUhvbW9ncmFwaHk7XFxuY29uc3QgdmVjNCBlbXB0eUNvbG9yID0gdmVjNCgwLjBmLCAwLjBmLCAwLjBmLCAxLjBmKTtcXG52ZWMyIHBlcnNwZWN0aXZlV2FycChtYXQzIGhvbW9ncmFwaHksIHZlYzIgcClcXG57XFxudmVjMyBxID0gaG9tb2dyYXBoeSAqIHZlYzMocCwgMS4wZik7XFxucmV0dXJuIHEueHkgLyBxLno7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIGxvY2F0aW9uID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pdmVjMiBzaXplID0gb3V0cHV0U2l6ZSgpO1xcbmNvbnN0IHZlYzIgemVybyA9IHZlYzIoMC4wZik7XFxudmVjMiB0YXJnZXQgPSBwZXJzcGVjdGl2ZVdhcnAoaW52ZXJzZUhvbW9ncmFwaHksIHZlYzIobG9jYXRpb24pKTtcXG5ib29sIHdpdGhpbkJvdW5kcyA9IGFsbChidmVjNChncmVhdGVyVGhhbkVxdWFsKHRhcmdldCwgemVybyksIGxlc3NUaGFuKHRhcmdldCwgdmVjMihzaXplKSkpKTtcXG5jb2xvciA9IHdpdGhpbkJvdW5kcyA/IHN1YnBpeGVsQXRCSShpbWFnZSwgdGFyZ2V0KSA6IGVtcHR5Q29sb3I7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJjb2xvcnMuZ2xzbFxcXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBkZXN0LCBzcmM7XFxudW5pZm9ybSBpbnQgZGVzdENvbXBvbmVudHM7XFxudW5pZm9ybSBpbnQgc3JjQ29tcG9uZW50SWQ7XFxudm9pZCBtYWluKClcXG57XFxudmVjNCBkZXN0UGl4ZWwgPSB0aHJlYWRQaXhlbChkZXN0KTtcXG52ZWM0IHNyY1BpeGVsID0gdGhyZWFkUGl4ZWwoc3JjKTtcXG5idmVjNCBmbGFncyA9IGJ2ZWM0KFxcbihkZXN0Q29tcG9uZW50cyAmIFBJWEVMQ09NUE9ORU5UX1JFRCkgIT0gMCxcXG4oZGVzdENvbXBvbmVudHMgJiBQSVhFTENPTVBPTkVOVF9HUkVFTikgIT0gMCxcXG4oZGVzdENvbXBvbmVudHMgJiBQSVhFTENPTVBPTkVOVF9CTFVFKSAhPSAwLFxcbihkZXN0Q29tcG9uZW50cyAmIFBJWEVMQ09NUE9ORU5UX0FMUEhBKSAhPSAwXFxuKTtcXG5jb2xvciA9IG1peChkZXN0UGl4ZWwsIHZlYzQoc3JjUGl4ZWxbc3JjQ29tcG9uZW50SWRdKSwgZmxhZ3MpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjaWYgIWRlZmluZWQoVFlQRSlcXG4jZXJyb3IgVW5kZWZpbmVkIFRZUEVcXG4jZWxpZiBUWVBFID09IDFcXG5AaW5jbHVkZSBcXFwia2V5cG9pbnRzLmdsc2xcXFwiXFxuI2RlZmluZSBudWxsUGl4ZWwoKSBlbmNvZGVOdWxsS2V5cG9pbnQoKVxcbiNlbGlmIFRZUEUgPT0gMlxcbkBpbmNsdWRlIFxcXCJmbG9hdDE2Lmdsc2xcXFwiXFxuI2RlZmluZSBudWxsUGl4ZWwoKSBlbmNvZGVOdWxsUGFpck9mRmxvYXQxNigpXFxuI2Vsc2VcXG4jZXJyb3IgSW52YWxpZCBUWVBFXFxuI2VuZGlmXFxudW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxudm9pZCBtYWluKClcXG57XFxuaXZlYzIgdGhyZWFkID0gdGhyZWFkTG9jYXRpb24oKTtcXG5pdmVjMiBpbWFnZVNpemUgPSB0ZXh0dXJlU2l6ZShpbWFnZSwgMCk7XFxuaW50IHJhc3RlckluZGV4ID0gdGhyZWFkLnkgKiBvdXRwdXRTaXplKCkueCArIHRocmVhZC54O1xcbmJvb2wgaXNWYWxpZFBpeGVsID0gcmFzdGVySW5kZXggPCBpbWFnZVNpemUueCAqIGltYWdlU2l6ZS55O1xcbml2ZWMyIHBvcyA9IGl2ZWMyKHJhc3RlckluZGV4ICUgaW1hZ2VTaXplLngsIHJhc3RlckluZGV4IC8gaW1hZ2VTaXplLngpO1xcbnZlYzQgbnVsbHBpeCA9IG51bGxQaXhlbCgpO1xcbmNvbG9yID0gaXNWYWxpZFBpeGVsID8gdGV4ZWxGZXRjaChpbWFnZSwgcG9zLCAwKSA6IG51bGxwaXg7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIGltYWdlO1xcbnZvaWQgbWFpbigpXFxue1xcbmNvbG9yID0gdGhyZWFkUGl4ZWwoaW1hZ2UpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbml2ZWMyIHNpemUgPSBvdXRwdXRTaXplKCk7XFxuaXZlYzIgemVybyA9IGl2ZWMyKDAsIDApO1xcbmNvbG9yID0gcGl4ZWxBdChpbWFnZSwgY2xhbXAodGhyZWFkLCB6ZXJvLCBzaXplIC0gMSkpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJAaW5jbHVkZSBcXFwiY29sb3JzLmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxudW5pZm9ybSBpbnQgcGl4ZWxDb21wb25lbnRzO1xcbnVuaWZvcm0gZmxvYXQgdmFsdWU7XFxudm9pZCBtYWluKClcXG57XFxudmVjNCBwaXhlbCA9IHRocmVhZFBpeGVsKGltYWdlKTtcXG5idmVjNCBmbGFncyA9IGJ2ZWM0KFxcbihwaXhlbENvbXBvbmVudHMgJiBQSVhFTENPTVBPTkVOVF9SRUQpICE9IDAsXFxuKHBpeGVsQ29tcG9uZW50cyAmIFBJWEVMQ09NUE9ORU5UX0dSRUVOKSAhPSAwLFxcbihwaXhlbENvbXBvbmVudHMgJiBQSVhFTENPTVBPTkVOVF9CTFVFKSAhPSAwLFxcbihwaXhlbENvbXBvbmVudHMgJiBQSVhFTENPTVBPTkVOVF9BTFBIQSkgIT0gMFxcbik7XFxuY29sb3IgPSBtaXgocGl4ZWwsIHZlYzQodmFsdWUpLCBmbGFncyk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gZmxvYXQgdmFsdWU7XFxudm9pZCBtYWluKClcXG57XFxuY29sb3IgPSB2ZWM0KHZhbHVlKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwidm9pZCB2c21haW4oKVxcbntcXG5nbF9Qb3NpdGlvbiAqPSB2ZWM0KDEsLTEsMSwxKTtcXG59XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxudW5pZm9ybSBpbnQgaXRlcmF0aW9uTnVtYmVyO1xcbnZvaWQgbWFpbigpXFxue1xcbml2ZWMyIHRocmVhZCA9IHRocmVhZExvY2F0aW9uKCk7XFxuaXZlYzIgbGFzdCA9IG91dHB1dFNpemUoKSAtIGl2ZWMyKDEpO1xcbml2ZWMyIGp1bXAgPSBpdmVjMigxIDw8IGl0ZXJhdGlvbk51bWJlcik7XFxuaXZlYzIgZ3JvdXBTaXplID0ganVtcCA8PCAxO1xcbml2ZWMyIGdyb3VwTWFzayA9IGdyb3VwU2l6ZSAtIGl2ZWMyKDEpO1xcbml2ZWMyIGdyb3VwSWQgPSB0aHJlYWQgPj4gKDEgKyBpdGVyYXRpb25OdW1iZXIpO1xcbml2ZWMyIGdyb3VwU3RhcnQgPSBncm91cElkIDw8ICgxICsgaXRlcmF0aW9uTnVtYmVyKTtcXG5pdmVjMiBuZXh0ID0gZ3JvdXBTdGFydCArICgodGhyZWFkIC0gZ3JvdXBTdGFydCArIGp1bXApICYgZ3JvdXBNYXNrKTtcXG5pdmVjMiBzYWZlTmV4dCA9IG1pbihuZXh0LCBsYXN0KTtcXG5pdmVjMiBuZXh0U2FtZVJvdyA9IGl2ZWMyKHNhZmVOZXh0LngsIHRocmVhZC55KTtcXG5pdmVjMiBuZXh0U2FtZUNvbCA9IGl2ZWMyKHRocmVhZC54LCBzYWZlTmV4dC55KTtcXG52ZWM0IHBpeGVsID0gdGV4ZWxGZXRjaChpbWFnZSwgdGhyZWFkLCAwKTtcXG52ZWM0IG5leHRTYW1lUm93UGl4ZWwgPSB0ZXhlbEZldGNoKGltYWdlLCBuZXh0U2FtZVJvdywgMCk7XFxudmVjNCBuZXh0U2FtZUNvbFBpeGVsID0gdGV4ZWxGZXRjaChpbWFnZSwgbmV4dFNhbWVDb2wsIDApO1xcbmNvbG9yID0gdmVjNChcXG5tYXgocGl4ZWwuciwgbmV4dFNhbWVSb3dQaXhlbC5yKSxcXG5tYXgocGl4ZWwuZywgbmV4dFNhbWVDb2xQaXhlbC5nKSxcXG5taW4ocGl4ZWwuYiwgbmV4dFNhbWVSb3dQaXhlbC5iKSxcXG5taW4ocGl4ZWwuYSwgbmV4dFNhbWVDb2xQaXhlbC5hKVxcbik7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIGltYWdlO1xcbnVuaWZvcm0gaW50IGl0ZXJhdGlvbk51bWJlcjtcXG52b2lkIG1haW4oKVxcbntcXG5pdmVjMiB0aHJlYWQgPSB0aHJlYWRMb2NhdGlvbigpO1xcbml2ZWMyIGxhc3QgPSBvdXRwdXRTaXplKCkgLSBpdmVjMigxKTtcXG5pbnQganVtcCA9ICgxIDw8IGl0ZXJhdGlvbk51bWJlcik7XFxuaW50IGNsdXN0ZXJMZW5ndGggPSBqdW1wIDw8IDE7XFxuaW50IGNsdXN0ZXJNYXNrID0gY2x1c3Rlckxlbmd0aCAtIDE7XFxuaXZlYzIgY2x1c3RlclBvcyA9IGl2ZWMyKHRocmVhZCA+PiAoMSArIGl0ZXJhdGlvbk51bWJlcikpIDw8ICgxICsgaXRlcmF0aW9uTnVtYmVyKTtcXG5pdmVjMiBuZXh0MSA9IGNsdXN0ZXJQb3MgKyAoKHRocmVhZCAtIGNsdXN0ZXJQb3MgKyBpdmVjMihqdW1wLCAwKSkgJiBjbHVzdGVyTWFzayk7XFxuaXZlYzIgbmV4dDIgPSBjbHVzdGVyUG9zICsgKCh0aHJlYWQgLSBjbHVzdGVyUG9zICsgaXZlYzIoMCwganVtcCkpICYgY2x1c3Rlck1hc2spO1xcbml2ZWMyIG5leHQzID0gY2x1c3RlclBvcyArICgodGhyZWFkIC0gY2x1c3RlclBvcyArIGl2ZWMyKGp1bXAsIGp1bXApKSAmIGNsdXN0ZXJNYXNrKTtcXG52ZWM0IHAwID0gdGV4ZWxGZXRjaChpbWFnZSwgdGhyZWFkLCAwKTtcXG52ZWM0IHAxID0gdGV4ZWxGZXRjaChpbWFnZSwgbWluKG5leHQxLCBsYXN0KSwgMCk7XFxudmVjNCBwMiA9IHRleGVsRmV0Y2goaW1hZ2UsIG1pbihuZXh0MiwgbGFzdCksIDApO1xcbnZlYzQgcDMgPSB0ZXhlbEZldGNoKGltYWdlLCBtaW4obmV4dDMsIGxhc3QpLCAwKTtcXG52ZWM0IHBtYXggPSBtYXgobWF4KHAwLCBwMSksIG1heChwMiwgcDMpKTtcXG52ZWM0IHBtaW4gPSBtaW4obWluKHAwLCBwMSksIG1pbihwMiwgcDMpKTtcXG5jb2xvciA9IHZlYzQocG1heC5yLCBwbWluLmcsIHBtYXguciAtIHBtaW4uZywgcDAuYSk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIkBpbmNsdWRlIFxcXCJweXJhbWlkcy5nbHNsXFxcIlxcbkBpbmNsdWRlIFxcXCJmbG9hdDE2Lmdsc2xcXFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgcHlyYW1pZDtcXG51bmlmb3JtIGZsb2F0IGxvZDtcXG4jZGVmaW5lIFVTRV9WQVJZSU5HUyAxXFxuaW4gdmVjMiB2X3BpeDAsIHZfcGl4MSwgdl9waXgyLFxcbnZfcGl4Mywgdl9waXg0LCB2X3BpeDUsXFxudl9waXg2LCB2X3BpeDcsIHZfcGl4ODtcXG5jb25zdCBtYXQzIGhrZXJuID0gbWF0MyhcXG4xLjBmLCAwLjBmLC0xLjBmLFxcbjIuMGYsIDAuMGYsLTIuMGYsXFxuMS4wZiwgMC4wZiwtMS4wZlxcbiksIHZrZXJuID0gbWF0MyhcXG4xLjBmLCAyLjBmLCAxLjBmLFxcbjAuMGYsIDAuMGYsIDAuMGYsXFxuLTEuMGYsLTIuMGYsLTEuMGZcXG4pO1xcbiNkZWZpbmUgUElYKHgseSkgcHlyUGl4ZWxBdE9mZnNldChweXJhbWlkLCBsb2QsIHBvdCwgaXZlYzIoKHgpLCh5KSkpLmdcXG4jZGVmaW5lIFhJUCh2KSB0ZXh0dXJlTG9kKHB5cmFtaWQsICh2KSwgbG9kKS5nXFxudm9pZCBtYWluKClcXG57XFxuY29uc3QgdmVjMyBvbmVzID0gdmVjMygxLjBmKTtcXG5mbG9hdCBwb3QgPSBleHAyKGxvZCk7XFxubWF0MyB3aW4gPSBtYXQzKFxcbiNpZiBVU0VfVkFSWUlOR1NcXG5YSVAodl9waXgwKSwgWElQKHZfcGl4MSksIFhJUCh2X3BpeDIpLFxcblhJUCh2X3BpeDMpLCBYSVAodl9waXg0KSwgWElQKHZfcGl4NSksXFxuWElQKHZfcGl4NiksIFhJUCh2X3BpeDcpLCBYSVAodl9waXg4KVxcbiNlbHNlXFxuUElYKC0xLC0xKSwgUElYKDAsLTEpLCBQSVgoMSwtMSksXFxuUElYKC0xLDApLCBQSVgoMCwwKSwgUElYKDEsMCksXFxuUElYKC0xLDEpLCBQSVgoMCwxKSwgUElYKDEsMSlcXG4jZW5kaWZcXG4pO1xcbm1hdDMgZHggPSBtYXRyaXhDb21wTXVsdChoa2Vybiwgd2luKTtcXG5tYXQzIGR5ID0gbWF0cml4Q29tcE11bHQodmtlcm4sIHdpbik7XFxudmVjMiBkZiA9IHZlYzIoXFxuZG90KGR4WzBdICsgZHhbMV0gKyBkeFsyXSwgb25lcyksXFxuZG90KGR5WzBdICsgZHlbMV0gKyBkeVsyXSwgb25lcylcXG4pO1xcbmNvbG9yID0gZW5jb2RlUGFpck9mRmxvYXQxNihkZik7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gbWVkaXVtcCBmbG9hdCBsb2Q7XFxub3V0IHZlYzIgdl9waXgwLCB2X3BpeDEsIHZfcGl4MixcXG52X3BpeDMsIHZfcGl4NCwgdl9waXg1LFxcbnZfcGl4Niwgdl9waXg3LCB2X3BpeDg7XFxuI2RlZmluZSBQSVgoeCx5KSAodGV4Q29vcmQgKyAoKHBvdCkgKiB2ZWMyKCh4KSwoeSkpKSAvIHRleFNpemUpXFxudm9pZCB2c21haW4oKVxcbntcXG5mbG9hdCBwb3QgPSBleHAyKGxvZCk7XFxudl9waXgwID0gUElYKC0xLC0xKTsgdl9waXgxID0gUElYKDAsLTEpOyB2X3BpeDIgPSBQSVgoMSwtMSk7XFxudl9waXgzID0gUElYKC0xLDApOyB2X3BpeDQgPSBQSVgoMCwwKTsgdl9waXg1ID0gUElYKDEsMCk7XFxudl9waXg2ID0gUElYKC0xLDEpOyB2X3BpeDcgPSBQSVgoMCwxKTsgdl9waXg4ID0gUElYKDEsMSk7XFxufVwiIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn0iLCJpbXBvcnQgdG9Qcm9wZXJ0eUtleSBmcm9tIFwiLi90b1Byb3BlcnR5S2V5LmpzXCI7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB0b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn0iLCJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufSIsImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn0iLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCB0b1ByaW1pdGl2ZSBmcm9tIFwiLi90b1ByaW1pdGl2ZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBTcGVlZHlQaXBlbGluZU5vZGUsIFNwZWVkeVBpcGVsaW5lU2lua05vZGUgfSBmcm9tICdzcGVlZHktdmlzaW9uL3NyYy9jb3JlL3BpcGVsaW5lL3BpcGVsaW5lLW5vZGUnO1xyXG5pbXBvcnQgeyBTcGVlZHlQaXBlbGluZU1lc3NhZ2VUeXBlLCBTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoSW1hZ2UgfSBmcm9tICdzcGVlZHktdmlzaW9uL3NyYy9jb3JlL3BpcGVsaW5lL3BpcGVsaW5lLW1lc3NhZ2UnO1xyXG5pbXBvcnQgeyBJbnB1dFBvcnQsIE91dHB1dFBvcnQgfSBmcm9tICdzcGVlZHktdmlzaW9uL3NyYy9jb3JlL3BpcGVsaW5lL3BpcGVsaW5lLXBvcnRidWlsZGVyJztcclxuaW1wb3J0IHsgU3BlZWR5R1BVIH0gZnJvbSAnc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS1ncHUnO1xyXG5pbXBvcnQgeyBTcGVlZHlUZXh0dXJlIH0gZnJvbSAnc3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS10ZXh0dXJlJztcclxuaW1wb3J0IHsgU3BlZWR5TWVkaWEgfSBmcm9tICdzcGVlZHktdmlzaW9uL3NyYy9jb3JlL3NwZWVkeS1tZWRpYSc7XHJcbmltcG9ydCB7IFNwZWVkeU1lZGlhU291cmNlIH0gZnJvbSAnc3BlZWR5LXZpc2lvbi9zcmMvY29yZS9zcGVlZHktbWVkaWEtc291cmNlJztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICdzcGVlZHktdmlzaW9uL3NyYy91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IEltYWdlRm9ybWF0IH0gZnJvbSAnc3BlZWR5LXZpc2lvbi9zcmMvdXRpbHMvdHlwZXMnO1xyXG5pbXBvcnQgeyBTcGVlZHlQcm9taXNlIH0gZnJvbSAnc3BlZWR5LXZpc2lvbi9zcmMvY29yZS9zcGVlZHktcHJvbWlzZSc7XHJcbmltcG9ydCB7IFNwZWVkeVRleHR1cmVSZWFkZXIgfSBmcm9tIFwic3BlZWR5LXZpc2lvbi9zcmMvZ3B1L3NwZWVkeS10ZXh0dXJlLXJlYWRlclwiO1xyXG5cclxuXHJcbmV4cG9ydCAgY2xhc3MgVGV4dHVyZVJlYWRlciBleHRlbmRzIFNwZWVkeVRleHR1cmVSZWFkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuICAgIHJlYWRQaXhlbHMoZ3B1LCB0ZXh0dXJlKSB7XHJcbiAgICAgICByZXR1cm4gZ3B1LnJlYWRQaXhlbHNBc3luYyh0ZXh0dXJlKVxyXG4gICAgfTtcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlZWR5UGlwZWxpbmVOb2RlSW1hZ2VTaW5rSW1hZ2VEYXRhIGV4dGVuZHMgU3BlZWR5UGlwZWxpbmVTaW5rTm9kZSB7XHJcblxyXG4gICAgLy8jX2ltYWdlRGF0YSA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IobmFtZSA9ICdpbWFnZScpXHJcbiAgICB7XHJcbiAgICAgICAgc3VwZXIobmFtZSwgMCwgW1xyXG4gICAgICAgICAgICBJbnB1dFBvcnQoKS5leHBlY3RzKFNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUuSW1hZ2UpXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7SW1hZ2VCaXRtYXB9IG91dHB1dCBiaXRtYXAgKi9cclxuICAgICAgICB0aGlzLl9iaXRtYXAgPSBudWxsO1xyXG5cclxuICAgICAgICAvL3RoaXMuaW1hZ2VEYXRhID0gbnVsbDtcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtJbWFnZUZvcm1hdH0gb3V0cHV0IGZvcm1hdCAqL1xyXG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IEltYWdlRm9ybWF0LlJHQkE7XHJcbiAgICB9XHJcblxyXG4gICAvKipcclxuICAgICAqIEV4cG9ydCBkYXRhIGZyb20gdGhpcyBub2RlIHRvIHRoZSB1c2VyXHJcbiAgICAgKiBAcmV0dXJucyB7U3BlZWR5UHJvbWlzZTxTcGVlZHlNZWRpYT59XHJcbiAgICAgKi9cclxuICAgZXhwb3J0KClcclxuICAge1xyXG4gICAgICAgY29uc3QgeyBpbWFnZSwgZm9ybWF0IH0gPSAvKiogQHR5cGUge1NwZWVkeVBpcGVsaW5lTWVzc2FnZVdpdGhJbWFnZX0gKi8gKCB0aGlzLmlucHV0KCkucmVhZCgpICk7XHJcbiAgICAgICByZXR1cm4gbmV3IFNwZWVkeVByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZ3B1LnJlbmRlclRvQ2FudmFzKGltYWdlKTtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLnNvdXJjZSwgMCwgMCk7XHJcbiAgICAgICAgY3R4LmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KS5kYXRhLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIC8vdGhpcy5faW1hZ2VEYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5fYml0bWFwID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7fSk7XHJcbiAgICB9KTtcclxuICAgfVxyXG5cclxuICAgLyoqXHJcbiAgICAqIFJ1biB0aGUgc3BlY2lmaWMgdGFzayBvZiB0aGlzIG5vZGVcclxuICAgICogQHBhcmFtIHtTcGVlZHlHUFV9IGdwdVxyXG4gICAgKiBAcmV0dXJucyB7dm9pZHxTcGVlZHlQcm9taXNlPHZvaWQ+fVxyXG4gICAgKi9cclxuICAgX3J1bihncHUpXHJcbiAgIHtcclxuICAgICAgIGNvbnN0IHsgaW1hZ2UsIGZvcm1hdCB9ID0gLyoqIEB0eXBlIHtTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoSW1hZ2V9ICovICggdGhpcy5pbnB1dCgpLnJlYWQoKSApO1xyXG5cclxuICAgICAgIHJldHVybiBuZXcgU3BlZWR5UHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICBjb25zdCBjYW52YXMgPSBncHUucmVuZGVyVG9DYW52YXMoaW1hZ2UpO1xyXG4gICAgICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGNhbnZhcywgMCwgY2FudmFzLmhlaWdodCAtIGltYWdlLmhlaWdodCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkudGhlbihiaXRtYXAgPT4ge1xyXG4gICAgICAgICAgICAgICB0aGlzLl9iaXRtYXAgPSBiaXRtYXA7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgfSk7XHJcbiAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiU3BlZWR5UGlwZWxpbmVOb2RlIiwiU3BlZWR5UGlwZWxpbmVTaW5rTm9kZSIsIlNwZWVkeVBpcGVsaW5lTWVzc2FnZVR5cGUiLCJTcGVlZHlQaXBlbGluZU1lc3NhZ2VXaXRoSW1hZ2UiLCJJbnB1dFBvcnQiLCJPdXRwdXRQb3J0IiwiU3BlZWR5R1BVIiwiU3BlZWR5VGV4dHVyZSIsIlNwZWVkeU1lZGlhIiwiU3BlZWR5TWVkaWFTb3VyY2UiLCJVdGlscyIsIkltYWdlRm9ybWF0IiwiU3BlZWR5UHJvbWlzZSIsIlNwZWVkeVRleHR1cmVSZWFkZXIiLCJUZXh0dXJlUmVhZGVyIiwiX1NwZWVkeVRleHR1cmVSZWFkZXIiLCJfaW5oZXJpdHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2FsbFN1cGVyIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJyZWFkUGl4ZWxzIiwiZ3B1IiwidGV4dHVyZSIsInJlYWRQaXhlbHNBc3luYyIsIlNwZWVkeVBpcGVsaW5lTm9kZUltYWdlU2lua0ltYWdlRGF0YSIsIl9TcGVlZHlQaXBlbGluZVNpbmtObyIsIl90aGlzIiwibmFtZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImV4cGVjdHMiLCJJbWFnZSIsIl9iaXRtYXAiLCJfZm9ybWF0IiwiUkdCQSIsIl9leHBvcnQiLCJfdGhpczIiLCJfdGhpcyRpbnB1dCRyZWFkIiwiaW5wdXQiLCJyZWFkIiwiaW1hZ2UiLCJmb3JtYXQiLCJyZXNvbHZlIiwiY2FudmFzIiwicmVuZGVyVG9DYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwic291cmNlIiwiZ2V0SW1hZ2VEYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJkYXRhIiwidGhlbiIsIl9ydW4iLCJfdGhpczMiLCJfdGhpcyRpbnB1dCRyZWFkMiIsImNyZWF0ZUltYWdlQml0bWFwIiwiYml0bWFwIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=